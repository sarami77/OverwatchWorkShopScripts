import "Test.setting.json";
import "Lib/Debug.del";
import "Lib/Utility.del";
import "Lib/ServerOverLoadMeasures.del";
import "Lib/Bot.del";

// Builtin -----------------------------------------------
globalvar define playerTeam = Team.Team1;
globalvar define enemyTeam =  Team.Team2;
globalvar define initCompleted!;

rule: "BuiltinGlobal"
Event.OngoingGlobal
{
    // DisableInspectorRecording();
    Wait(6);
    slowControlHandler = SlowControlHandler.ServerOverLoadMeasures;
    initCompleted = true;
    dbgHudTxt("initCompleted");
}

globalvar define waitTime = 1;

rule: "TriggerAction"
Event.OngoingGlobal
if(
    initCompleted
){
    startCyclicAction = true;
}

// Test Code -----------------------------------------------
globalvar define startCyclicAction;

rule: "CyclicBotAction"
Event.OngoingGlobal
if(
    startCyclicAction
){
    while(true){
        define pList = [
            RandomHero,
            RandomHero,
            RandomHero,
            RandomHero,
            RandomHero,
            RandomHero
        ];
        define eList = [
            RandomHero,
            RandomHero,
            RandomHero,
            RandomHero,
            RandomHero,
            RandomHero
        ];
        DestroyBots(playerTeam);
        DestroyBots(enemyTeam);
        // CreateBotsByHeroList(pList, playerTeam);
        CreateBotsByHeroList(eList, enemyTeam);

        
        SetDamageDealt(AllPlayers(enemyTeam), 1);
        SetStatus(hp, null, Status.Unkillable, MaxValue());

        Wait(120);
    }
}

rule: "CyclicPlayerAction"
Event.OngoingPlayer
if(
    startCyclicAction &&
    IsAlive()
){
    while(true){
        Wait(1, WaitBehavior.AbortWhenFalse);
    }
}

rule: "RestartTeamFormation"
Event.OngoingPlayer
if(
    startCyclicAction &&
    ep != hp
){
    Wait(1);
    SetRespawnMaxTime(ap, 1);

    while(true){
        WaitUntil(
            (
                NumberOfLivingPlayers(playerTeam) <= 0 ||
                NumberOfLivingPlayers(enemyTeam)  <= 0
            ),
            MaxValue()
        );
        Wait(3);
        Respawn(ap);
        Wait(1);
    }
}

rule: "RestartTeamFormation"
Event.OngoingPlayer
if(
    ep == hp &&
    IsUsingUltimate()    
){
            define strafReqScatterRange! = 5;
            define strafReqAttackDistance! = 30;
            define strafReqAttackTime! = 2;
            define strafReqAttackInterval = 0.05;
            define strafReqDamageRange! = 5;
            define strafReqDamage! = 200;

            // play set sound
            PlayEffect(
                ep, PlayEffect.DebuffImpactSound,
                Color.White, ep, MaxValue());

            // set position and angle
            define targetPosition! = BelowPosition(AimingPosition());
            define approachingAngle! = FacingDirectionOf();
            approachingAngle = VectorWithOutY(approachingAngle);
                                                                            
            // set start point
            define startPosition! = 
                targetPosition + 
                    // add random direction
                    -approachingAngle *
                    // add static distance
                    (strafReqAttackDistance / 2);
            // set end point
            define endPosition! = 
                targetPosition + 
                    // add random direction
                    approachingAngle *
                    // add static distance
                    (strafReqAttackDistance / 2);

            // set landing zone text
            define effectAndText! = [];
            CreateInWorldText(
                AllPlayers(), <"<0> <1> <2>", ep, HeroIconString(HeroOf()), "STRAFING REQUEST">,
                targetPosition + PositionOffset(), basicInWorldTextSize, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
                Color.White, Spectators.DefaultVisibility);
            effectAndText [1] = LastTextID();

            // set effect
            // landing zone blast range
            define landPosition;
            define landPosition2!;
            CreateEffect(AllPlayers(), Effect.Sphere, Color.Yellow,
                landPosition, strafReqScatterRange, EffectRev.VisibleToPositionAndRadius);
            effectAndText [2] = LastCreatedEntity();
            // landing zone position
            CreateEffect(AllPlayers(), Effect.Sphere, Color.Red,
                targetPosition, 0.2, EffectRev.VisibleToPositionAndRadius);
            effectAndText [3] = LastCreatedEntity(); 

            // play landing animation
            landPosition = startPosition;
            UpdateEveryFrame(landPosition);
            ChaseVariableOverTime(
                landPosition, endPosition,
                strafReqAttackTime,
                TimeChaseReevaluation.DestinationAndDuration);
            Wait(strafReqAttackTime, WaitBehavior.IgnoreCondition);
            StopChasingVariable(landPosition);
            DestroyEffect(effectAndText[2]);

            // start attack
            // create Ballistic
            CreateBeamEffect(AllPlayers(), BeamType.BadBeam,
                landPosition2, landPosition2 - (approachingAngle * 200) + (Up() * 200),
                Color.White, EffectRev.VisibleToPositionAndRadius);
            effectAndText [4] = LastCreatedEntity(); 

            // play landed animation
            landPosition = startPosition;
            UpdateEveryFrame(landPosition);
            ChaseVariableOverTime(
                landPosition, endPosition,
                strafReqAttackTime,
                TimeChaseReevaluation.DestinationAndDuration);

            for(define count! = strafReqAttackTime / strafReqAttackInterval; count > 0; count --){
                if(isServerOverLoading()) continue;

                // set landed point
                landPosition2 =
                    landPosition + 
                    RandomPosition(
                        strafReqScatterRange / 1.5,
                        0,
                        strafReqScatterRange / 1.5
                    );

                // damage
                Damage(
                    PlayersWithinRadius(
                        landPosition2, strafReqDamageRange,
                        enemyTeam, RadiusLOS.Off
                    ),
                    ep, strafReqDamage
                );

                // play blast sound
                PlayEffect(
                    AllPlayers(), PlayEffect.RingExplosionSound,
                    Color.White,
                    landPosition2,
                    MaxLength());

                // play blast
                PlayEffect(
                    AllPlayers(), PlayEffect.BadExplosion,
                    Color.White,
                    landPosition2,
                    strafReqDamageRange);
                    
                Wait(0.05, WaitBehavior.IgnoreCondition);
            }

            StopChasingVariable(landPosition);
            DestroyInWorldText(effectAndText [1]);
            DestroyEffect(effectAndText [3]);
            DestroyEffect(effectAndText [4]);
}


// killCount -----------------------------------------------
globalvar define killCountTeam1;
globalvar define killCountTeam2;

rule: "killCount/countUp"
Event.OnFinalBlow
{
    if(TeamOf() == Team.Team1)
        killCountTeam1 ++;
    else if(TeamOf() == Team.Team2)        
        killCountTeam2 ++;
    
}

// Debug/Slow -----------------------------------------------
globalvar define slow = DefaultPercentage();

rule: "Debug/Slow/setSlow"
Event.OngoingPlayer
Team.Team1
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Jump)
){
    // 100 -> 50 -> 25 -> 10
    if(slow == DefaultPercentage())
        slow = 50;
    else if(slow == 50)
        slow = 25;
    else if(slow == 25)
        slow = 10;
    else if(slow == 10)
        slow = DefaultPercentage();
    else
        slow = DefaultPercentage();
    SetSlowMotion(slow);
    dbgMsg(<"setSlow <0>", slow>);
}

// Debug/TuneVal -----------------------------------------------
define changeTimeInterval: 0.1;
define initialTuneUnit : 0.01;
globalvar define tuneVal = 0.1;
globalvar define consecutiveChangeCount = 0;
globalvar define tuneUnit = initialTuneUnit;

// TAG Debug ----------
globalvar define debugHuds!;

define Last():
    CountOf(debugHuds);

define AimingPositonOf(define player):
    RayCastHitPosition(
        EyePosition(player),
        EyePosition(player) +
            (FacingDirectionOf(player) * MaxLength()),
        null,
        null,
        false
    );

rule: "showParam"
Event.OngoingGlobal
{
    debugHuds[Last()] = CreateDebugHud("tune Val", tuneVal, Color.Orange);
    debugHuds[Last()] = CreateDebugHud("count Wait Random For Distribute Server Load", countWaitRandomForDistributeServerLoad, Color.Orange);
    debugHuds[Last()] = CreateDebugHud("Server Load", ServerLoad(), ServerLoad() < 255 ? Color.Orange : Color.Red);
    debugHuds[Last()] = CreateDebugHud("game Logic Speed", gameLogicSpeed, gameLogicSpeed >= 100 ? Color.Orange : Color.Red);
    debugHuds[Last()] = CreateDebugHud("Distance to aim pos", DistanceBetween(HostPlayer(), AimingPositonOf(HostPlayer())), Color.Orange);
    debugHuds[Last()] = CreateDebugHud("player team player num", <"<0> / <1>", NumberOfLivingPlayers(playerTeam), NumberOfPlayers(playerTeam)>, Color.Team1);
    debugHuds[Last()] = CreateDebugHud("enemy team player num", <"<0> / <1>", NumberOfLivingPlayers(enemyTeam), NumberOfPlayers(enemyTeam)>, Color.Team2);
    debugHuds[Last()] = CreateDebugHud("killCountTeam1", killCountTeam1, Color.Team1);
    debugHuds[Last()] = CreateDebugHud("killCountTeam2", killCountTeam2, Color.Team2);
    debugHuds[Last()] = CreateDebugHud("waitTime", waitTime, Color.Orange);
}

rule: "Debug/TuneVal/startIncreaseParam"
Event.OngoingPlayer
if(
    HostPlayer() &&
    (
        IsButtonHeld(ep, Button.Interact) &&
        IsButtonHeld(ep, Button.Ability2)
    )
){
    tuneVal += tuneUnit;
    Wait(changeTimeInterval, WaitBehavior.AbortWhenFalse);
    changeTuneUnit();
    LoopIfConditionIsTrue();
}

rule: "Debug/TuneVal/stopIncreaseParam"
Event.OngoingPlayer
if(
    HostPlayer() &&
    !(
        IsButtonHeld(ep, Button.Interact) &&
        IsButtonHeld(ep, Button.Ability2)
    )
){
    resetTuneUnit();
}

rule: "Debug/TuneVal/startDecreaseParam"
Event.OngoingPlayer
if(
    HostPlayer() &&
    (
        IsButtonHeld(ep, Button.Interact) &&
        IsButtonHeld(ep, Button.Ability1)
    )
){
    tuneVal -= tuneUnit;
    Wait(changeTimeInterval, WaitBehavior.AbortWhenFalse);
    changeTuneUnit();
    LoopIfConditionIsTrue();
}

rule: "Debug/TuneVal/stopDecreaseParam"
Event.OngoingPlayer
if(
    HostPlayer() &&
    !(
        IsButtonHeld(ep, Button.Interact) &&
        IsButtonHeld(ep, Button.Ability1)
    )
){
    resetTuneUnit();
}

void resetTuneUnit(){
    tuneUnit = initialTuneUnit;
    consecutiveChangeCount= 0;
}

void changeTuneUnit(){
    consecutiveChangeCount ++;
    if(consecutiveChangeCount < 10)
        tuneUnit =  initialTuneUnit * 1;
    else if(consecutiveChangeCount < 20 )
        tuneUnit = initialTuneUnit * 10;
    else if(consecutiveChangeCount < 30 )
        tuneUnit = initialTuneUnit * 100;
    else
        tuneUnit = initialTuneUnit * 1000;
}
