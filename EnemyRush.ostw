import "EnemyRush.setting.json";
import "Lib/Debug.del";
import "Lib/Utility.del";
import "Lib/ServerOverLoadMeasures.del";
import "Lib/Bot.del";
import "Lib/Buddy.del";
// import "Lib/Mutation.del";

// TAG Signature and infomation ----------
disabled rule: "ENEMY RUSH -HORDE PVE [ver.3.2] Share code [V7PEF]. You allowed copy or modify code." -1 {}
disabled rule: "This script was generated by ItsDeltin/Overwatch-Script-To-Workshop. Check detail with https://github.com/ItsDeltin/Overwatch-Script-To-Workshop" -1 {}
disabled rule: "Original source code was created by sarami77#1868. Check detail with https://github.com/sarami77/OverwatchWorkShopScripts" -1 {}

// TAG Initialize ----------
define playerTeam: Team.Team2;
define enemyTeam: Team.Team1;

globalvar define initCompleted!;

rule: "Initialize/initialize"
Event.OngoingGlobal
{
    // Stop records to reduce server load
    DisableInspectorRecording();

    // If run it right after loading the server, some scripts fail, so wait 3 seconds
    Wait(5, WaitBehavior.AbortWhenFalse);

    // Start watch over load
    slowControlHandler = SlowControlHandler.ServerOverLoadMeasures;

    // show version and share code
    CreateHudText(AllPlayers(),
        null, "ENEMY RUSH -HORDE PVE ver.3.2 / Share code [V7PEF]", null,
        Location.Left, -999,
        Color.White, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);

    // Notify completion of init game setting and start game main logic
    initCompleted = true;
}

rule: "Initialize/shortenAssemblingHeroes"
Event.OngoingGlobal
if(
    IsAssemblingHeroes()
){
    // SetMatchTime(0);
    SetMatchTime(25);
}

rule: "Initialize/shortenSetup"
Event.OngoingGlobal
if(
    IsInSetup()
){
    // SetMatchTime(15);
    SetMatchTime(25);
}

// TAG Buddy ----------
define buddyAssetList:
    [
        // random hero
        [   // assetNo 0
            // recommend
            [EnemyType.None,    Hero.Mercy,     1],
            [EnemyType.None,    Hero.Genji,     1],
            [EnemyType.None,    Hero.Reinhardt, 1],
            [EnemyType.None,    Hero.Kiriko,    1],
            [EnemyType.None,    Hero.Hanzo,     1],
            [EnemyType.None,    Hero.Zarya,     1],
            [EnemyType.None,    Hero.Zenyatta,  1],
            [EnemyType.None,    Hero.Soldier76, 1]
        ],
        [   // assetNo 1
            // recommend
            [EnemyType.None,    Hero.Ana,       1],
            [EnemyType.None,    Hero.Reaper,    1],
            [EnemyType.None,    Hero.Ramattra,  1],
            [EnemyType.None,    Hero.Baptiste,  1],
            [EnemyType.None,    Hero.Sojourn,   1],
            [EnemyType.None,    Hero.Zarya,     1],
            [EnemyType.None,    Hero.Brigitte,  1],
            [EnemyType.None,    Hero.Soldier76, 1]
        ],
        [
            // assetNo 2
            // random with fix role
            [EnemyType.None,    RandomSupportHero,  1],
            [EnemyType.None,    RandomTankHero,     1],
            [EnemyType.None,    RandomDamageHero,   1],
            [EnemyType.None,    RandomSupportHero,  1],
            [EnemyType.None,    RandomTankHero,     1],
            [EnemyType.None,    RandomDamageHero,   1],
            [EnemyType.None,    RandomSupportHero,  1],
            [EnemyType.None,    RandomDamageHero,   1]
        ],
        [
            // assetNo 3
            // random with non role
            [EnemyType.None,    RandomHero, 1],
            [EnemyType.None,    RandomHero, 1],
            [EnemyType.None,    RandomHero, 1],
            [EnemyType.None,    RandomHero, 1],
            [EnemyType.None,    RandomHero, 1],
            [EnemyType.None,    RandomHero, 1],
            [EnemyType.None,    RandomHero, 1],
            [EnemyType.None,    RandomHero, 1]
        ],
        [
            // assetNo 4
            // many damage role
            [EnemyType.None,    favSupport, 1],
            [EnemyType.None,    favSupport, 1],
            [EnemyType.None,    favDamage,  6]
        ],
        [
            // assetNo 5
            // many tank role
            [EnemyType.None,    favSupport, 1],
            [EnemyType.None,    favSupport, 1],
            [EnemyType.None,    favTank,    6]
        ]
    ];

define buddyAssetLotteryList: [
    0, 0,
    1, 1,
    2, 2, 2, 2, 2, 2,
    3,
    4,
    5
];

globalvar define isLockedCreateBotsByAsset! = false;

void CreateBotsByAssetWithMutexLock(define asset!, define team!, define addLimitNum!){ 
    // can't implement as subroutin for mutex  
    define forceReleaseCount = 0;
    while(isLockedCreateBotsByAsset){
        // dbgHudTxt(<"isLockedCreateBotsByAsset <0>", team>);
        if(forceReleaseCount < 5){
            forceReleaseCount ++;
        }
        else{
            break;
        }
        Wait(1, WaitBehavior.IgnoreCondition);
    }
    isLockedCreateBotsByAsset = true;
    CreateBotsByAsset(asset, team, addLimitNum);
    isLockedCreateBotsByAsset = false;
}

define playerNum:
    CountOf(
        FilteredArray(
            AllPlayers(playerTeam),
            !IsDummyBot(ae)
        )
    );

define buddyNum:
    CountOf(
        FilteredArray(
            AllPlayers(playerTeam),
            IsDummyBot(ae)
        )
    );

define needBuddyNum:
    maxBuddyBotNum - playerNum;

globalvar define maxBuddyBotNum! =
    WorkshopSettingInteger("Follower AI Settings (Join as behalf when absent player)", "Max Fill Count", 8, 0, 8, 1);

globalvar define buddyAssetNo!;

rule: "Buddy/BuddyContorl"
Event.OngoingGlobal
if(
    initCompleted
){
    define prevPlayerNum! = -1;
    define prevAssetNo! = -1;
    // set initial asset no
    buddyAssetNo = RandomValueInArray(buddyAssetLotteryList);

    while(true){
        if(
            (
                // choiced AssetNo changed
                prevAssetNo != buddyAssetNo ||
                // not filed by need buddy number
                buddyNum != needBuddyNum ||
                // playerNum changed
                prevPlayerNum != playerNum ||
                // entity num than over slot num
                playerNum + buddyNum > NumberOfSlots(playerTeam)
            ) &&
            // create bot not locked
            !isLockedCreateBotsByAsset
        ){
            // save prev value
            prevPlayerNum = playerNum;
            prevAssetNo = buddyAssetNo;
            // get avg ult charge of bots
            define ultCharge! = GetAvgUltChgOfDummyBot(playerTeam);
            // reload buddy list
            DestroyBots(playerTeam);
            // create bots by addAsset
            define asset! = buddyAssetList[buddyAssetNo];
            CreateBotsByAssetWithMutexLock(asset, playerTeam, needBuddyNum);
            // set avg ult charge of bots
            SetAvgUltChgOfDummyBot(playerTeam, ultCharge);
        }

        // show human player outline
        define players! = AllPlayers();
        players[CountOf(players)] = HostPlayer();
        StartForcingPlayerOutlines(
            FilteredArray(AllPlayers(playerTeam), !IsDummyBot(ae)),
            players,
            true,
            Color.Green,
            OutlineType.Always
        );

        // set max respawn time
        define respawnTime! = 10 * WorkshopSettingReal("Player Settings", "Max Respawn Time Scale", 1.0, 0, 100, 0);
        SetRespawnMaxTime(AllPlayers(playerTeam), respawnTime);

        // check timer
        Wait(10, WaitBehavior.IgnoreCondition);
    }
}

rule: "Buddy/Teleport/init"
Event.OngoingPlayer
if(
    TeamOf() == playerTeam &&
    IsDummyBot() &&
    IsInSpawnRoom()
){
    if(IsGameInProgress()){
        // teleport to player near object
        Teleport(ep, ClosestPlayerTo(CurrentObjectPosition(), playerTeam));
    }
    else{
        // teleport to spawn point
        Teleport(ep, SpawnPoints(playerTeam)[0]);
    }
}

rule: "Buddy/fastRespawnBySucide"
Event.OnDeath
if(
    TeamOf() == playerTeam &&
    IsDummyBot() &&
    Attacker() == ep
){
    Respawn();
}

// TAG Buddy/BotAssetTimer ----------
define assetChangeInterval: RandomInteger(90, 180);
globalvar define reloadBuddyAssetTimer = -1;

rule: "Buddy/BotAssetTimer/initReloadAssetTimer"
Event.OngoingGlobal
if(
    initCompleted &&
    IsGameInProgress()
){
    reloadBuddyAssetTimer = assetChangeInterval;
}

rule: "Buddy/BotAssetTimer/coutnDownReloadBuddyAssetTimer"
Event.OngoingGlobal
if(
    0 < reloadBuddyAssetTimer
){
    reloadBuddyAssetTimer --;
    Wait(1, WaitBehavior.IgnoreCondition);
    LoopIfConditionIsTrue();
}

rule: "Buddy/BotAssetTimer/reloadReloadBuddyAsset"
Event.OngoingGlobal
if(
    reloadBuddyAssetTimer == 0
){
    buddyAssetNo = RandomValueInArray(buddyAssetLotteryList);
    reloadBuddyAssetTimer = assetChangeInterval;
}

// TAG Payload ----------
globalvar define prevPayloadPosition!;

globalvar define payloadDirection!;

rule: "Payload/updatePayloadDirection"
Event.OngoingGlobal
if(
    PayloadProgressPercentage() > 0
){
    prevPayloadPosition = PayloadPosition();

    while(true){
        define nowPayloadPosition! = PayloadPosition();
        if(
            IsPlayerOnObject &&
            DistanceBetween(nowPayloadPosition, prevPayloadPosition) > 0.01
        ){
            payloadDirection = DirectionTowards(prevPayloadPosition, nowPayloadPosition);
            prevPayloadPosition = nowPayloadPosition;
        }
        Wait(1, WaitBehavior.IgnoreCondition);
    }
}

// TAG Player ----------
// TAG Player/DealtDamage ----------
rule: "Player/DealtDamage/update"
Event.OngoingPlayer
if(
    initCompleted
){
    UpdatePlayerDamageDealt();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

void UpdatePlayerDamageDealt()"UpdatePlayerDamageDealt"{
    define playerDamageDealt! = WorkshopSettingReal("Player Settings", "Damage Dealt Scale", 1.0, 0, 100, 1);
    SetDamageDealt(AllPlayers(playerTeam), playerDamageDealt * 100);
}

// TAG Player/FisrtFast
rule: "Player/FisrtFast/setFastSpeed"
Event.OngoingPlayer
if(
    TeamOf() == playerTeam &&
    IsAlive() &&
    IsInSpawnRoom()
){
    SetMoveSpeed(ep, 150);
    while(!IsInLineOfSight(ep, ClosestPlayerTo(ep, enemyTeam))){
        Wait(1, WaitBehavior.IgnoreCondition);
    }
    SetMoveSpeed(ep, DefaultPercentage());
}

// TAG EnemyBot ----------
globalvar define sameHero!;

define enemyAssetList:
    [
        [   // assetNo 0
            // basic
            [EnemyType.General,     RandomHero,         1],
            [EnemyType.Elite,       RandomHero,         4],
            [EnemyType.Minion,      RandomHero,         8]
        ],
        [   // assetNo 1
            // general and minion
            [EnemyType.General,     RandomHero,         1],
            [EnemyType.Minion,      RandomHero,         12]
        ],
        [   // assetNo 2
            // all elite
            [EnemyType.Elite,       RandomHero,         4],
            [EnemyType.Elite,       RandomHero,         4],
            [EnemyType.Elite,       RandomHero,         5]
        ],
        [   // assetNo 3
            // all elites same hero
            [EnemyType.Elite,       sameHero,           13]
        ],
        [   // assetNo 4
            // all minion
            [EnemyType.Minion,      rva([favDamage, favTank]),   13]
        ],
        [   // assetNo 5
            // double general
            [EnemyType.General,     RandomHero,         1],
            [EnemyType.General,     RandomHero,         1],
            [EnemyType.Minion,      RandomHero,         11]
        ],
        [   // assetNo 6
            // damage boss with minion
            [EnemyType.Boss,        favDamage,          1],
            [EnemyType.Minion,      RandomHero,         12]
        ],

        [   // assetNo 7 [progress asset]
            // damage boss with minion
            [EnemyType.Boss,        favDamage,          1],
            [EnemyType.Minion,      RandomHero,         12]
        ],
        [   // assetNo 8 [progress asset]
            // damage boss with tank elite
            [EnemyType.Boss,        favDamage,          1],
            [EnemyType.Elite,       favTank,            4],
            [EnemyType.Minion,      RandomHero,         8]
        ],
        [   // assetNo 9 [progress asset]
            // tank boss with damage elite
            [EnemyType.Boss,        favTank,            1],
            [EnemyType.Elite,       favDamage,          4],
            [EnemyType.Minion,      RandomHero,         8]
        ],
        [   // assetNo 10 [debug]
            // tank boss with damage elite
            [EnemyType.Elite,       Hero.Ramattra,      13]
        ]
    ];

define enemyAssetLotteryList: [
    // 10   // for debug
    0, 0, 0,
    1, 1, 
    2, 2,
    3,
    4,
    5,
    6
];

// TAG EnemyBot/BotAssetTimer ----------
globalvar define reloadEnemyAssetTimer = -1;

rule: "EnemyBot/BotAssetTimer/initReloadAssetTimer"
Event.OngoingGlobal
if(
    initCompleted &&
    (
        (IsInSetup() && MatchTime() <= 5 ) ||
        (IsGameInProgress())
    )
){
    reloadEnemyAssetTimer = 0;
}

rule: "EnemyBot/BotAssetTimer/coutnDownReloadEnemyAssetTimer"
Event.OngoingGlobal
if(
    0 < reloadEnemyAssetTimer
){
    reloadEnemyAssetTimer --;
    Wait(1, WaitBehavior.IgnoreCondition);
    LoopIfConditionIsTrue();
}

define maxEnemyBotNum: 13;

rule: "EnemyBot/BotAssetTimer/reloadReloadEnemyAsset"
Event.OngoingGlobal
if(
    reloadEnemyAssetTimer == 0
){
    // create all bot
    sameHero = RandomHero;
    PlayEffectsToTeam(enemyTeam);
    DestroyBots(enemyTeam);
    define asset! = enemyAssetList[RandomValueInArray(enemyAssetLotteryList)];
    CreateBotsByAssetWithMutexLock(asset, enemyTeam, maxEnemyBotNum);
    // set next timer
    reloadEnemyAssetTimer = assetChangeInterval;
}

globalvar define progressStage;

rule: "EnemyBot/BotAssetTimer/reloadBotAssetTimerByProgress"
Event.OngoingGlobal
if(
    initCompleted &&
    IsGameInProgress()
){
    define progress! = TotalObjectProgress();
    define enemyAssetNo! = -1;
    define specifiedAssetTimer;

    if(
        progressStage == 0 && progress >= 30
    ){
        progressStage ++;
        enemyAssetNo = 7;
        specifiedAssetTimer = assetChangeInterval;
    }
    else if(
        progressStage == 1 && progress >= 60
    ){
        progressStage ++;
        enemyAssetNo = 8;
        specifiedAssetTimer = assetChangeInterval;
    }
    else if(
        progressStage == 2 && progress >= 90
    ){
        progressStage ++;
        enemyAssetNo = 9;
        specifiedAssetTimer = -1;
    }

    if(enemyAssetNo != -1){
        // create all bot
        sameHero = RandomHero;
        PlayEffectsToTeam(enemyTeam);
        DestroyBots(enemyTeam);
        define asset! = enemyAssetList[enemyAssetNo];
        CreateBotsByAssetWithMutexLock(asset, enemyTeam, maxEnemyBotNum);
        // set next timer
        reloadEnemyAssetTimer = specifiedAssetTimer;
    }
    // check timer
    Wait(5, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

void PlayEffectsToTeam(define team!) "PlayEffectsToTeam"{
    define players! = AllPlayers(team);
    for(define playersIndex! = 0; playersIndex < CountOf(players); playersIndex ++){
        // play blast
        PlayEffect(AllPlayers(), PlayEffect.BadExplosion,
            TeamOf(players[playersIndex]) == enemyTeam ?
                enemyColor :
                Color.Yellow,
            PositionOf(players[playersIndex]),
            TeamOf(players[playersIndex]) == enemyTeam ?
                players[playersIndex].eachTextSize : 
                basicInWorldTextSize + 0.5);
    }
    Wait(0.1, WaitBehavior.IgnoreCondition);
}

// TAG EnemyBot/EnemyType ----------
playervar define eachDealtDamageScale!;
playervar define eachMaxSpawnInterval!;
playervar define eachMinSpawnInterval!;
playervar define eachChargeUltInterval!;

playervar define eachBodyScale!;
playervar define eachTextSize!;
playervar define eachNameText!;
playervar define eachNameColor!;
define basicSpawnTimeMin: 10 * (13/16);
define minionSpawnTimeMin: basicSpawnTimeMin * 1;
define eliteSpawnTimeMin: basicSpawnTimeMin * 2;
define generalBossSpawnTimeMin: basicSpawnTimeMin * 4;
define spawnTimeScaleMinToMax: 1.5;

rule: "EnemyBot/EnemyType/setEnemyType"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    enemyType != EnemyType.None
){
    define maxHealthRate! = IsTankHero(HeroOf(ep)) ? 0.666 : 1;

    // setEnemyType
    if(enemyType == EnemyType.Minion){
        watchUpdateRate = 27;
        eachBodyScale = 0.75;
        StartScalingPlayer(ep, eachBodyScale, false);
        StartModifyingHeroVoiceLines(ep, 1.5, false);

        SetMaxHealth(ep, 25 * maxHealthRate);
        SetHealingDealt(ep, 25);
        SetHealingReceived(ep, 25);
        
        eachDealtDamageScale = 0.5;
        eachChargeUltInterval = 60;
        eachMinSpawnInterval = minionSpawnTimeMin;
        eachMaxSpawnInterval = minionSpawnTimeMin * spawnTimeScaleMinToMax;

        eachNameText = "Minion";
        eachNameColor = Color.White;
        eachTextSize = basicInWorldTextSize;
    }
    else if(enemyType == EnemyType.Elite){
        watchUpdateRate = 9;
        eachBodyScale = 1.0;
        StartScalingPlayer(ep, eachBodyScale, false);
        StartModifyingHeroVoiceLines(ep, 1.0, false);

        SetMaxHealth(ep, 100 * maxHealthRate);
        SetHealingDealt(ep, 100);
        SetHealingReceived(ep, 100);

        eachDealtDamageScale = 1.0;
        eachChargeUltInterval = 30;
        eachMinSpawnInterval = eliteSpawnTimeMin;
        eachMaxSpawnInterval = eliteSpawnTimeMin * spawnTimeScaleMinToMax;

        eachNameText = "Elite";
        eachNameColor = Color.Yellow;
        eachTextSize = basicInWorldTextSize + 0.5;
    }
    else if(enemyType == EnemyType.General){
        watchUpdateRate = 3;
        eachBodyScale = 1.5;
        StartScalingPlayer(ep, eachBodyScale, false);
        StartModifyingHeroVoiceLines(ep, 0.5, false);

        SetMaxHealth(ep, 1000 * maxHealthRate);
        SetHealingDealt(ep, 200);
        SetHealingReceived(ep, 200);

        eachDealtDamageScale = 2.0;
        eachChargeUltInterval = 15;
        eachMinSpawnInterval = generalBossSpawnTimeMin;
        eachMaxSpawnInterval = generalBossSpawnTimeMin * spawnTimeScaleMinToMax;

        eachNameText = "General";
        eachNameColor = Color.Orange;
        eachTextSize = basicInWorldTextSize + 1;
    }
    else if(enemyType == EnemyType.Boss){
        watchUpdateRate = 3;
        eachBodyScale = 2.5;
        StartScalingPlayer(ep, eachBodyScale, false);
        StartModifyingHeroVoiceLines(ep, 0.1, false);

        SetMaxHealth(ep, 1000 * maxHealthRate);
        SetHealingDealt(ep, 200);
        SetHealingReceived(ep, 200);

        eachDealtDamageScale = 2.0;
        eachChargeUltInterval = 15;
        eachMinSpawnInterval = generalBossSpawnTimeMin;
        eachMaxSpawnInterval = generalBossSpawnTimeMin * spawnTimeScaleMinToMax;

        eachNameText = "Boss";
        eachNameColor = Color.Red;
        eachTextSize = basicInWorldTextSize + 1.5;

        // set addtinal health
        Wait(0.1, WaitBehavior.AbortWhenFalse);
        define health! = MaxHealth(ep) * 0.5;
        AddHealthPoolToPlayer(ep, HealthType.Armor, health, true, false);
        AddHealthPoolToPlayer(ep, HealthType.Shields, health, true, false);
    }

    // set no back when Low Health
    enableRetreat = false;

    // update param
    UpdateEachDealtDamage();
    UpdateEachSpawnInterval();
}

rule: "EnemyBot/Effect/setFullHealth"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.None &&
    IsAlive()
){
    // heal to max health
    Wait(0.5, WaitBehavior.IgnoreCondition);
    while(Health() < MaxHealth()){
        Heal(ep, null, MaxValue());
        Wait(0.5, WaitBehavior.IgnoreCondition);
    }
}

// TAG EnemyBot/Effect ----------
define enemyColor: Color.Purple;
playervar define botAppearanceEntitys!;

rule: "EnemyBot/Effect/showBotAppearance"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.None &&
    IsAlive()
){
    botAppearanceEntitys = [];
    // show evil aura
    botAppearanceEntitys[0] = 
        CreateEffect(AllPlayers(), Effect.Cloud, enemyColor,
            ep, eachTextSize, EffectRev.VisibleToPositionAndRadius);
    // show name text
    botAppearanceEntitys[1] = 
        CreateInWorldText(
            AllPlayers(), eachNameText, 
            EyePosition() + (Vector(0, 0.5, 0) * eachTextSize), eachTextSize, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            eachNameColor, Spectators.DefaultVisibility);
}

rule: "EnemyBot/Effect/hideBotAppearanceAndReek"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.None &&
    !IsAlive()
){
    // hide evil aura
    DestroyEffect(botAppearanceEntitys[0]);
    // hide name text
    DestroyInWorldText(botAppearanceEntitys[1]);
    // play dead effect
    PlayContinuousBlast(Color.Red, PositionOf(),
        eachTextSize * 1.5, eachTextSize, 0);
}

// TAG EnemyBot/Teleport ----------
playervar define teleportPosition!;
globalvar define commonTeleportPosition!;
define teleportAreaSize: 10;

Player ClosestPlayerFromObject()"ClosestPlayerFromObject"{
    return FirstOf(
        SortedArray(
            FilteredArray(
                AllPlayers(playerTeam),
                (
                    IsAlive(ae)
                )
            ),
            DistanceBetween(ae, CurrentObjectPosition())
        )
    );
}

Boolean SetTeleportPositionToPlayerFront() playervar "SetTeleportPositionToPlayerFront"{
    // set teleportToTarget at closest player from Object
    define teleportToTarget! = ClosestPlayerFromObject();

    for(pLoopIndex = 0; pLoopIndex < 10; pLoopIndex++){
        WaitRandomForDistributeServerLoad();

        define currentObjectPosition! = CurrentObjectPosition();
    
        // select teleportPosition from middle of Object and teleportToTarget
        teleportPosition =
            NearestWalkablePosition(
                PositionOf(teleportToTarget)
                    + 
                (
                    DirectionTowards(teleportToTarget, currentObjectPosition)
                        *
                    DistanceBetween(teleportToTarget, currentObjectPosition) * 0.40
                )
                    +
                RandomPosition(
                    (teleportAreaSize),
                    (teleportAreaSize),
                    (teleportAreaSize)
                )
            );
        break;
    }
    return true;
}

Boolean SetTeleportPositionToPlayerAround() playervar "SetTeleportPositionToPlayerAround"{
    define teleportToTarget! = ClosestPlayerFromObject();

    for(pLoopIndex = 0; pLoopIndex < 10; pLoopIndex++){
        WaitRandomForDistributeServerLoad();

        // select teleportPosition from current object around
        teleportPosition = 
            NearestWalkablePosition(
                PositionOf(teleportToTarget)
                    +
                RandomPosition(
                    (teleportAreaSize),
                    (teleportAreaSize),
                    (teleportAreaSize)
                )
            );
        
        if(
            // Has line to target
            IsInLineOfSight(
                PositionOffsetY1() + PositionOf(ClosestPlayerTo(teleportPosition, playerTeam)),
                PositionOffsetY1() + teleportPosition,
                BarrierLOS.NoBarriersBlock)  
        ){
            break;
        }
        Wait(0.5, WaitBehavior.AbortWhenFalse);
    }
    return true;
}

globalvar define additinalTeleportAreaSize;
define teleportAreaSizeOffset: Bot_ActionRange_Far;
define OnCurrentObjectPosition(): CurrentObjectPosition() + Vector(0, 5, 0); // not collision in payload object position

Boolean SetTeleportPositionToObjectAhead() playervar "SetTeleportPositionToObjectAhead"{
    define teleportToTarget! = OnCurrentObjectPosition();
    
    if(
        payloadDirection != 0 &&
        IsPlayerOnObject
    ){
        // get bloacked position of payload ahead
        define blockedHead! = BlockedPositon(teleportToTarget, payloadDirection, teleportAreaSizeOffset);
        // increase teleportAreaSize by cut off distance for spam payload block by teleport
        additinalTeleportAreaSize = teleportAreaSizeOffset - DistanceBetween(teleportToTarget, blockedHead);
        additinalTeleportAreaSize /= 2;
        // change teleportTarget to payload ahead
        teleportToTarget = blockedHead;
    }
    else{
        additinalTeleportAreaSize = 0;
    }

    for(pLoopIndex = 0; pLoopIndex < 10; pLoopIndex++){
        WaitRandomForDistributeServerLoad();

        // select teleportPosition from teleportToTarget around
        teleportPosition = 
            NearestWalkablePosition(
                teleportToTarget
                    +
                RandomPosition(
                    (teleportAreaSize + additinalTeleportAreaSize),
                    (teleportAreaSize + additinalTeleportAreaSize),
                    (teleportAreaSize + additinalTeleportAreaSize)
                )
            );

        if(
            // Has line to target
            IsInLineOfSight(
                PositionOffsetY1() + PositionOf(ClosestPlayerTo(teleportPosition, playerTeam)),
                PositionOffsetY1() + teleportPosition,
                BarrierLOS.NoBarriersBlock)            
        ){
            break;
        }
        Wait(0.5, WaitBehavior.AbortWhenFalse);
    }
    teleportPosition -= PositionOffset();
    return true;
}

Boolean SetTeleportPositionToCommonPosition() playervar "SetTeleportPositionToCommonPosition"{
    // set telPosNearTarget at closest player from commonTeleportPosition
    if(
        // update commonTeleportPosition conditions
        // invalid commonTeleportPosition
        commonTeleportPosition ==  0 ||
        // force update Probability
        ProbabilityTrue(3) ||
        // player too close from commonTeleportPosition
        DistanceBetween(commonTeleportPosition, ClosestPlayerTo(commonTeleportPosition, playerTeam)) < 3.0 ||
        // has not line commonTeleportPosition to current object 
        !IsInLineOfSight(
            PositionOffsetY1() + CurrentObjectPosition(),
            PositionOffsetY1() + commonTeleportPosition,
            BarrierLOS.NoBarriersBlock
        )
    ){
        // new select common position
        // set teleport position to player around
        if(SetTeleportPositionToObjectAhead()){
            // save teleport position as common position
            commonTeleportPosition = teleportPosition;
        }
        else{
            // set teleport position from common position
            teleportPosition = commonTeleportPosition;
        }
    }
    else{
        // set teleport position from common position
        teleportPosition = commonTeleportPosition;
    }
    return true;
}

define showTeleportBeamTime: 0.6;
void PlayTeleportEffect(define isBefore!) playervar "PlayTeleportEffect"{
    // if before teleport
    if(isBefore){
        // play teleport shadow of own
        PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, enemyColor, ep, 1);
        // play teleport shadow of dest
        PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, enemyColor, teleportPosition, 1);
        // show teleport beam effect
        DestroyEffect(telBeam);
        define fromSky! = IsInSpawnRoom(ep);
        // define fromSky! = true;
        telBeam = CreateBeamEffect(AllPlayers(),
            BeamType.BadBeam,
            fromSky ? 
                teleportPosition + Vector(0, 30, 0) :
                BodyPosition(ep),
            teleportPosition + PositionOffset(),
            Color.Purple, EffectRev.VisibleToPositionAndRadius);
        // wait for show teleport shadow of before
        Wait(showTeleportBeamTime, WaitBehavior.IgnoreCondition);
    }
    else{
        // play teleport blast
        PlayEffect(AllPlayers(), PlayEffect.BadExplosion, enemyColor, ep, eachTextSize);
        // hide teleport beam effect
        DestroyEffect(telBeam);
        // play teleport sound
        PlayEffect(AllPlayers(), PlayEffect.RingExplosionSound, null, ep, 50);
    }
}

playervar define telBeam!;

void TeleportWithEffect() playervar "TeleportWithEffect"{
    define waitTeleportTimer! = 
        IndexOfArrayValue(
            FilteredArray(
                AllPlayers(enemyTeam), IsInSpawnRoom(ae)
            ),
            ep
        ) *
        0.1;
    Wait(waitTeleportTimer, WaitBehavior.AbortWhenFalse);
    // show pre teleport effect
    PlayTeleportEffect(true);
    // Teleport
    Teleport(ep, teleportPosition);
    // show teleport effect
    PlayTeleportEffect(false);
    // hide teleport beam effect
    DestroyEffect(telBeam);
}

define forceActiveTeleport: 40;
define teleportToCommonPositionProb: 50;

define IsPlayerOnObject: ([] != AllPlayersOnObjective(playerTeam));
define IsEnemyOnObject: ([] != AllPlayersOnObjective(enemyTeam));

void HybridTeleport()"HybridTeleport"{
    if(
        // during Object attacks
        IsPlayerOnObject ||
        // probability
        ProbabilityTrue(forceActiveTeleport)
    ){
        if(
            // probability
            ProbabilityTrue(teleportToCommonPositionProb)
        ){
            if(SetTeleportPositionToCommonPosition()){
                TeleportWithEffect();
            }
        }
        else{
            if(SetTeleportPositionToObjectAhead()){
                TeleportWithEffect();
            }
        }
    }
    else{
        if(IsTeamOnDefense(TeamOf())){
            if(SetTeleportPositionToPlayerFront()){
                TeleportWithEffect();
            }
        }
        else{
            if(SetTeleportPositionToPlayerAround()){
                TeleportWithEffect();
            }
        }
    }
}

rule: "EnemyBot/Teleport/teleportByRespawn"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsGameInProgress() &&
    IsInSpawnRoom()
){
    HybridTeleport();
    // failsafe
    Wait(3, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

define checkTeleportConditionMaxCount: 3;

rule: "EnemyBot/Teleport/teleportForDefenceObject"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsGameInProgress() &&
    IsAlive() &&
    !IsInSpawnRoom()
){
    for(define checkTeleportConditionCount! = 0; checkTeleportConditionCount < checkTeleportConditionMaxCount; checkTeleportConditionCount ++){
        WaitRandomForDistributeServerLoad();

        Wait(1, WaitBehavior.AbortWhenFalse);
        // check not teleport condition
        if(
            actionState != ActionState.Non &&        // in combat
            (
                DistanceBetween(ep, CurrentObjectPosition()) <= Bot_ActionRange_Far ||   // near object
                !IsPlayerOnObject                                       // player not on object
            )
        ){
            // reset count up
            LoopIfConditionIsTrue();
        }
        // count up
    }

    // when over checkTeleportConditionMaxCount 

    // teleport
    HybridTeleport();

    LoopIfConditionIsTrue();
}

rule: "EnemyBot/Teleport/clearCommonTeleportPosition"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    Attacker() == ep
){
    commonTeleportPosition = 0;
}

// TAG EnemyBot/EnemyAbility ----------
globalvar define enemyAbilityStatus;

rule: "EnemyBot/EnemyAbility/shotCall"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    enemyAbilityStatus[1] = 0;

    define interval! = ObjectProgressScaledInterval(30, 50);
    interval *= WorkshopSettingReal("Enemy Bot Settings", "Shot Call Event Interval Scale", 1.0, 0.1, 100, 4);
    Wait(interval, WaitBehavior.AbortWhenFalse);

    define deployedEnemys! = FilteredArray(
        AllLivingPlayers(enemyTeam),
        !IsInSpawnRoom(ae)
    );
    define shotCallDelay! = RandomReal(0.2, 1.0);
    for(define scLoopIndex! = 0; scLoopIndex < CountOf(deployedEnemys); scLoopIndex ++){
        WaitRandomForDistributeServerLoad();
        SetUltimateCharge(deployedEnemys[scLoopIndex], DefaultPercentage());
        PressButton(deployedEnemys[scLoopIndex], Button.Ultimate);
        enemyAbilityStatus[1] = CountOf(deployedEnemys) - scLoopIndex;
        Wait(shotCallDelay, WaitBehavior.AbortWhenFalse);
    }

    LoopIfConditionIsTrue();
}

rule: "EnemyBot/EnemyAbility/rush"
Event.OngoingGlobal
if(
    IsGameInProgress() &&
    !IsOverTime()
){
    enemyAbilityStatus[0] = 0;

    define interval! = ObjectProgressScaledInterval(20, 40);
    interval *= WorkshopSettingReal("Enemy Bot Settings", "Spawn Rush Event Interval Scale", 1.0, 0.1, 100, 3);
    Wait(interval, WaitBehavior.AbortWhenFalse);

    define rushDurling! = RandomInteger(5, 10);
    for(rushCount; rushDurling > 0; rushDurling--){
        WaitRandomForDistributeServerLoad();
        Respawn(AllDeadPlayers(enemyTeam));
        enemyAbilityStatus[0] = rushDurling;
        Wait(1, WaitBehavior.AbortWhenFalse);

    }

    LoopIfConditionIsTrue();
}

rule: "EnemyBot/EnemyAbility/combatTeleport"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    (
        enemyType == EnemyType.Boss ||
        enemyType == EnemyType.General
    ) &&
    IsAlive() &&
    actionState != ActionState.Non &&
    !IsOverTime()
){
    define interval! = ObjectProgressScaledInterval(10, 30);
    interval *= WorkshopSettingReal("Enemy Bot Settings", "(General & Boss) Combat Teleport Interval Scale", 1.0, 0.1, 100, 5);
    Wait(interval, WaitBehavior.AbortWhenFalse);

    // set teleport position to object around
    if(SetTeleportPositionToPlayerAround()){
            TeleportWithEffect();
    }
    LoopIfConditionIsTrue();
}

globalvar define multiUltProb!;

rule: "EnemyBot/EnemyAbility/multiUltimate"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    (
        enemyType == EnemyType.Boss ||
        enemyType == EnemyType.General
    ) &&
    IsAlive() &&
    actionState != ActionState.Non &&
    !IsUsingUltimate()
){
    multiUltProb = 100;
    while(
        IsAlive() &&
        ProbabilityTrue(multiUltProb)
    ){
        SetUltimateCharge(ep, DefaultPercentage());
        Wait(RandomReal(0, 3), WaitBehavior.IgnoreCondition);
        PressButton(ep, Button.Ultimate);
        WaitUntil(!IsUsingUltimate(), 10);
    }
    multiUltProb = 0;
}

globalvar define decreaseProb = WorkshopSettingInteger("Enemy Bot Settings", "(General & Boss) Multi Ultimate Probability Decrease Rate", 10, 0, 100, 6);

rule: "EnemyBot/EnemyAbility/decreasemultiUltimate"
Event.OngoingGlobal
if(
    multiUltProb > 0
){
    multiUltProb -= multiUltProb < decreaseProb ? multiUltProb : decreaseProb;
    Wait(1.0, WaitBehavior.AbortWhenFalse);
    Loop();
}

globalvar define closeToObjectInterval!;

rule: "EnemyBot/EnemyAbility/closeToObject"
Event.OngoingGlobal
if(
    IsGameInProgress() &&
    TotalObjectProgress() >= 90 &&
    IsPlayerOnObject
){
    define enemys! = RandomizedArray(
        FilteredArray(
            AllLivingPlayers(enemyTeam),
            (
                !IsInSpawnRoom(ae) &&
                DistanceBetween(ae, OnCurrentObjectPosition()) >= 5
            )
        )
    );

    for(define enemysIndex! = 0; enemysIndex < CountOf(enemys); enemysIndex ++){
        define player! = enemys[enemysIndex];
        PressButton(player, Button.Jump);
        ApplyImpulse(player, 
            VectorTowards(player, OnCurrentObjectPosition()), 12,
            Relative.ToWorld, ContraryMotion.Cancel);
        Wait(0.1, WaitBehavior.AbortWhenFalse);
    }

    Wait(0.5 + closeToObjectInterval, WaitBehavior.AbortWhenFalse);

    if(IsOverTime()){
        closeToObjectInterval += 0.01;
    }

    LoopIfConditionIsTrue();
}

// TAG EnemyBot/SpawnInterval ----------
define showDeadEffectTime: 1.0;
globalvar define spawnTimeScale;
playervar define confirmSpawnInterval!;

void UpdateEachSpawnInterval()"UpdateEachSpawnInterval"{
    define diff = GameProgressDiff();
    if(70 <= diff){
        spawnTimeScale = 0;
    }
    else if(40 <= diff && diff < 70){
        spawnTimeScale = 0.25;
    }
    else if(10 <= diff && diff < 40){
        spawnTimeScale = 0.5;
    }
    else if(-10 <= diff && diff < 10){
        spawnTimeScale = 1.0;
    }
    else if(-40 <= diff && diff < -10){
        spawnTimeScale = 1.25;
    }
    else if(-70 <= diff && diff < -40){
        spawnTimeScale = 1.75;
    }
    else if(diff < -70){
        spawnTimeScale = 2.5;
    }

    confirmSpawnInterval = 
        ObjectProgressScaledInterval(eachMinSpawnInterval, eachMaxSpawnInterval);
    confirmSpawnInterval *= spawnTimeScale;
    confirmSpawnInterval *= WorkshopSettingReal("Enemy Bot Settings", "Basic Spawn Intarval Scale", 1.0, 0, 100, 2);
    SetRespawnMaxTime(ep, confirmSpawnInterval + showDeadEffectTime);
}

Number GameProgressDiff()"GameProgressDiff"{
    Number prgDiff! = 0;
    Number objPrg! = RoundToInteger(TotalObjectProgress());  // MAX 100
    Number timePrg  = RoundToInteger(MatchTime() / 3.0);  // MAX 300
    timePrg = DefaultPercentage() - timePrg;
    prgDiff = objPrg - timePrg;
    return prgDiff;
}

Number ObjectProgressScaledInterval(define intervalMin, define intervalMax) globalvar "ObjectProgressScaledInterval"{
    define intarval! = (intervalMax - intervalMin);
    intarval *= (1 - (TotalObjectProgress() / DefaultPercentage()));
    intarval += intervalMin;
    return intarval;
}

rule: "EnemyBot/SpawnInterval/update"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.None
){
    UpdateEachSpawnInterval();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

rule: "EnemyBot/SpawnInterval/fastRespawnBySucide"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    Attacker() == ep
){
    Wait(showDeadEffectTime, WaitBehavior.AbortWhenFalse);
    Respawn();
}

// TAG EnemyBot/DealtDamage ----------
globalvar define autoTuneDmgDlt!;
globalvar define autoTuneScale! = WorkshopSettingReal("Enemy Bot Settings", "Dynamic Damage Deal Increase Scale", 1.0, 0, 100, 0);
define upTuneInternalRate: 0.3;

rule: "EnemyBot/DealtDamage/upTune"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    Attacker() != ep
){
    if(enemyType == EnemyType.Minion){
        autoTuneDmgDlt += 0.25 * upTuneInternalRate * autoTuneScale;
    }
    else if(enemyType == EnemyType.Elite){
        autoTuneDmgDlt += 1.0 *  upTuneInternalRate * autoTuneScale;
    }
    else if(enemyType == EnemyType.General){
        autoTuneDmgDlt += 10.0 * upTuneInternalRate * autoTuneScale;
    }
    else if(enemyType == EnemyType.Boss){
        autoTuneDmgDlt += 20.0 * upTuneInternalRate * autoTuneScale;
    }
}

rule: "EnemyBot/DealtDamage/downTune"
Event.OnDeath
if(
    TeamOf() == playerTeam &&
    Attacker() != ep
){
    autoTuneDmgDlt -= NumberOfSlots(playerTeam) / NumberOfPlayers(playerTeam);
    autoTuneDmgDlt = autoTuneDmgDlt < 0 ? 0 : autoTuneDmgDlt;
}

playervar define confirmDealtDamage!;

void UpdateEachDealtDamage()"UpdateEachDealtDamage"{
    // set base damage
    confirmDealtDamage = WorkshopSettingReal("Enemy Bot Settings", "Base Damage Dealt", 40, 0, 100, 0);
    // apply auto tune
    confirmDealtDamage += autoTuneDmgDlt;
    // apply enemy type scale
    confirmDealtDamage *= eachDealtDamageScale;
    // apply team balance
    confirmDealtDamage /= ConvertToBalancedValue(1.5, playerTeam);
    SetDamageDealt(ep, confirmDealtDamage);
}

rule: "EnemyBot/DealtDamage/update"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.None
){
    UpdateEachDealtDamage();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/ReceivedDamage ----------
globalvar define confirmReceiveDamage!;

void UpdateEachReceivedDamage()"UpdateEachReceivedDamage"{
    // set base damage
    confirmReceiveDamage = DefaultPercentage();
    // apply team balance
    confirmReceiveDamage *= ConvertToBalancedValue(1.5, playerTeam);
    SetDamageReceived(AllPlayers(enemyTeam), confirmReceiveDamage);
}

rule: "EnemyBot/ReceivedDamage/update"
Event.OngoingGlobal
if(
    initCompleted
){
    UpdateEachReceivedDamage();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/ChargeUltimate ----------
rule: "EnemyBot/ChargeUltimate/charge"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.None &&
    !IsUsingUltimate()
){
    SetUltimateCharge(ep, UltimateChargePercent() + (DefaultPercentage() / eachChargeUltInterval));
    WaitUpdateASecond();
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/ObstIcon ----------
playervar define obstIcon;
define color: isBlink ? Color.Red : Color.Yellow;

rule: "EnemyBot/ObstIcon/show"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    (
        IsPlayerOnObject &&
        IsOnObjective(ep)
    )
){
    DestroyIcon(obstIcon);
    obstIcon = CreateIcon(AllPlayers(playerTeam), ep, Icon.ExclamationMark,
        IconRev.PositionAndColor, color, true);
}

rule: "EnemyBot/ObstIcon/hide"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    !(
        IsPlayerOnObject &&
        IsOnObjective(ep)
    )
){
    DestroyIcon(obstIcon);
    obstIcon = 0;
}

globalvar define isBlink = false;

rule: "EnemyBot/ObstIcon/blinkColor"
Event.OngoingGlobal
if(
    initCompleted
){
    while(true){
        isBlink = !isBlink;
        Wait(0.1, WaitBehavior.AbortWhenFalse); 
    }
}

// TAG FinalStand ----------
rule: "FinalStand/FinalStand"
Event.OngoingGlobal
if(
    IsGameInProgress() &&
    MatchTime() <= 0
){
    BigMessage(AllPlayers(), "Final Stand !");
    slowControlHandler = SlowControlHandler.GameLogic;
    SetSlowMotion(10);
    Wait(0.25, WaitBehavior.IgnoreCondition);   // show slow

    PlayEffectsToTeam(Team.All);
    Resurrect(AllPlayers());
    Heal(AllPlayers(), null, MaxValue());
    SetUltimateCharge(AllPlayers(), DefaultPercentage());

    Wait(0.25, WaitBehavior.IgnoreCondition);   // show slow
    SetSlowMotion(DefaultPercentage());
    slowControlHandler = SlowControlHandler.ServerOverLoadMeasures;
}

// TAG Debug ----------
rule: "Debug/defaultDebugMode"
Event.OngoingGlobal
Team.All
if(
    initCompleted
){
    debugMode = DebugMode.ShowParam;
    ShowDebugHud(HostPlayer());

    // while(true){
    //     define list = FilteredArray(AllPlayers(enemyTeam), ae.enemyType == EnemyType.Boss);
    //     SetUltimateCharge(list, 100);
    //     Wait(1);
    // }
    // CreateIcon(commonTeleportPosition != 0 ? AllPlayers(): null,
    //     commonTeleportPosition + PositionOffsetY1(), Icon.Spiral,
    //     IconRev.VisibleToAndPosition, enemyColor, true);
    // CreateEffect(commonTeleportPosition != 0 ? AllPlayers(): null, Effect.Cloud, enemyColor,
    //     commonTeleportPosition + PositionOffsetY1(), 3, EffectRev.VisibleToPositionRadiusAndColor);
    // CreateBeamEffect(commonTeleportPosition != 0 ? AllPlayers(): null,
    //     BeamType.BadBeam, HostPlayer(), commonTeleportPosition + PositionOffsetY1(),
    //     enemyColor, EffectRev.VisibleToPositionAndRadius);
}

rule: "Debug/changeDebugMode"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Jump) 
){
    // change debug mode
    WaitLongPressConfirm();
    if(debugMode == DebugMode.Non){
        debugMode = DebugMode.SlowLevelOnly;
    }
    else if(debugMode == DebugMode.SlowLevelOnly){
        debugMode = DebugMode.ShowParam;
    }
    else if(debugMode == DebugMode.ShowParam){
        debugMode = DebugMode.WithRecord;
    }
    else if(debugMode == DebugMode.WithRecord){
        debugMode = DebugMode.Non;
    }

    // reload hud
    HideDebugHud();
    ShowDebugHud(HostPlayer());
}

globalvar define debugHuds!;

define Last():
    CountOf(debugHuds);

// show debug icon and hud
void ShowDebugHud(define player!)"ShowDebugHud"{
    if(
        debugMode == DebugMode.WithRecord
    ){
        EnableInspectorRecording();
        debugHuds[Last()] = CreateDebugHud("●Recording", true, Color.Red);
    }
    else{
        DisableInspectorRecording();
    }
    
    if(
        debugMode == DebugMode.SlowLevelOnly ||
        debugMode == DebugMode.ShowParam ||
        debugMode == DebugMode.WithRecord
    ){
        debugHuds[Last()] = CreateDebugHud("Server Load", ServerLoad(), ServerLoad() < 255 ? Color.Orange : Color.Red);
        debugHuds[Last()] = CreateDebugHud("game Logic Speed", gameLogicSpeed, gameLogicSpeed >= 100 ? Color.Orange : Color.Red);
    }
    if(
        debugMode == DebugMode.ShowParam ||
        debugMode == DebugMode.WithRecord
    ){  
        debugHuds[Last()] = CreateDebugHud("count Wait Random For Distribute Server Load", countWaitRandomForDistributeServerLoad, Color.Orange);
        debugHuds[Last()] = CreateDebugHud("human player num", CountOf(FilteredArray(AllPlayers(playerTeam), !IsDummyBot(ae))), Color.Team2);
        debugHuds[Last()] = CreateDebugHud("team player num", <"<0> / <1>", NumberOfLivingPlayers(playerTeam), NumberOfPlayers(playerTeam)>, Color.Team2);
        debugHuds[Last()] = CreateDebugHud("reload Asset Timer", reloadBuddyAssetTimer, reloadBuddyAssetTimer > 5 ? Color.Team2 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("team player num", <"<0> / <1>", NumberOfLivingPlayers(enemyTeam), NumberOfPlayers(enemyTeam)>, Color.Team1);
        debugHuds[Last()] = CreateDebugHud("reload Asset Timer", reloadEnemyAssetTimer, reloadEnemyAssetTimer > 5 ? Color.Team1 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("spawn interval", <"scale = <0> / M = <1> / E = <2> / G = <3> / B = <4>",
            spawnTimeScale,
            FirstOf(FilteredArray(AllPlayers(enemyTeam), ae.enemyType == EnemyType.Minion)).confirmSpawnInterval,
            FirstOf(FilteredArray(AllPlayers(enemyTeam), ae.enemyType == EnemyType.Elite)).confirmSpawnInterval,
            FirstOf(FilteredArray(AllPlayers(enemyTeam), ae.enemyType == EnemyType.General)).confirmSpawnInterval,
            FirstOf(FilteredArray(AllPlayers(enemyTeam), ae.enemyType == EnemyType.Boss)).confirmSpawnInterval
        >, Color.Team1);
        debugHuds[Last()] = CreateDebugHud("rush status", enemyAbilityStatus[0], enemyAbilityStatus[0] == false ? Color.Team1 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("shot call status", enemyAbilityStatus[1], enemyAbilityStatus[1] == false ? Color.Team1 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("more ult prob", multiUltProb, multiUltProb == 0 ? Color.Team1 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("auto Tune Dmg Dlt", autoTuneDmgDlt, Color.Team1);
        debugHuds[Last()] = CreateDebugHud("close To Object Interval", closeToObjectInterval, Color.Team1);
    }
}

// Hide debug icon and hud
void HideDebugHud()"HideDebugHud"{
    for(gLoopIndex = 0; gLoopIndex < CountOf(debugHuds); gLoopIndex ++){
        DestroyHudText(debugHuds[gLoopIndex]);
    }
}

rule: "Debug/resetBotList"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    !IsButtonHeld(ep, Button.Reload) &&
    IsButtonHeld(ep, Button.Crouch)
){
    // Recalculate portal
    WaitLongPressConfirm();
    // set next timer
    reloadEnemyAssetTimer = 0;
    WaitLongPressConfirm();
    WaitUntil(reloadEnemyAssetTimer > 0, 10);
    reloadBuddyAssetTimer = 0;
}

disabled rule: "Output Completed" 99999 {}
