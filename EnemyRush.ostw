import "EnemyRush.setting.json";
import "Lib/Debug.del";
import "Lib/Utility.del";
import "Lib/ServerOverLoadMeasures.del";
import "Lib/Bot.del";
import "Lib/Buddy.del";
import "Lib/Vote.del";
import "Lib/HeroMod.del";

// TAG Signature and infomation ----------
disabled rule: "[PVE] ENEMY RUSH ver.5.0 / Share code [V7PEF]. You allowed copy or modify code." -1 {}
disabled rule: "This script was generated by ItsDeltin/Overwatch-Script-To-Workshop. Check detail with https://github.com/ItsDeltin/Overwatch-Script-To-Workshop" -1 {}
disabled rule: "Original source code was created by sarami77#1868. Check detail with https://github.com/sarami77/OverwatchWorkShopScripts" -1 {}

// TAG Initialize ----------
define playerTeam: Team.Team2;
define enemyTeam: Team.Team1;
define allTeam: Team.All;

globalvar define initCompleted;

rule: "Initialize/initialize"
Event.OngoingGlobal
{
    // Stop records to reduce server load
    DisableInspectorRecording();

    // If run it right after loading the server, some scripts fail, so wait 3 seconds
    Wait(5, WaitBehavior.AbortWhenFalse);

    // Start watch over load
    slowControlHandler = SlowControlHandler.ServerOverLoadMeasures;

    // show version and share code
    CreateHudText(AllPlayers(),
        null, "[PVE] ENEMY RUSH ver.5.0 / Share code [V7PEF]", null,
        Location.Left, -999,
        Color.White, Color.Gray, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleAlways);

    // Notify completion of init game setting and start game main logic
    initCompleted = true;
}

// TAG Round ----------
rule: "Round/shortenAssemblePhase"
Event.OngoingGlobal
if(
    IsAssemblingHeroes()
){
    SetMatchTime(45);

    // wait player join server
    Wait(10, WaitBehavior.AbortWhenFalse);
    
    if(
        // no human
        HumanPlayerNum(playerTeam) <= 0
            ||
        // host human only
        (
            // 1 human only
            HumanPlayerNum(playerTeam) == 1
                &&
            // human is host player
            hp ==
                FirstOf(
                    FilteredArray(
                        AllPlayers(playerTeam),
                        !IsDummyBot(ae)
                    )
                )
        )
    ){
        // omit assemble phase
        SetMatchTime(0);
    }
}

rule: "Round/shortenSetupPhase"
Event.OngoingGlobal
if(
    IsInSetup()
){
    SetMatchTime(45);

    if(
        // no human
        HumanPlayerNum(playerTeam) <= 0
    ){
        // omit setup phase
        SetMatchTime(0);
    }
}

// define addTimeScale: 0.0;

// rule: "Round/AddMatchTime1"
// Event.OngoingGlobal
// if(
//     IsGameInProgress()
// ){
//     // defualt 300
//     SetMatchTime(MatchTime() + (300 * addTimeScale));
// }

// rule: "Round/AddMatchTime2"
// Event.OngoingGlobal
// if(
//     IsObjectiveComplete(0)
// ){
//     // defualt 180
//     SetMatchTime(MatchTime() + (180 * addTimeScale));
// }

// rule: "Round/AddMatchTime3"
// Event.OngoingGlobal
// if(
//     IsObjectiveComplete(1)
// ){
//     // defualt 120
//     SetMatchTime(MatchTime() + (120 * addTimeScale));
// }

// TAG Player/Config ----------
rule: "Player/SetPlayerConfig"
Event.OngoingGlobal
if(
    initCompleted
){
    while(true){
        // show human player outline
        define players! = AllPlayers();
        players[CountOf(players)] = hp;
        StartForcingPlayerOutlines(
            FilteredArray(
                AllPlayers(playerTeam),
                !IsDummyBot(ae)
            ),
            players,
            true,
            Color.Green,
            OutlineType.Always
        );

        // set max respawn time
        define respawnTime! = 10 * WorkshopSettingReal("Player Settings", "Max Respawn Time Scale", 1.0, 0, 100, 1);
        SetRespawnMaxTime(AllPlayers(playerTeam), respawnTime);

        // check Interval
        WaitUpdateLongCycle();
    }
}

// TAG Buddy/Asset ----------
define buddyAssetList:
    [
        // fix hero asset
        [   // assetNo 0
            // recommend 1
            [EnemyType.Non,    Hero.Mercy,      1],
            [EnemyType.Non,    Hero.Genji,      1],
            [EnemyType.Non,    Hero.Reinhardt,  1],
            [EnemyType.Non,    Hero.Ana,        1],
            [EnemyType.Non,    Hero.Hanzo,      1],
            [EnemyType.Non,    Hero.Zarya,      1],
            [EnemyType.Non,    Hero.Zenyatta,   1],
            [EnemyType.Non,    Hero.Soldier76,  1]
        ],
        [   // assetNo 1
            // recommend 2
            [EnemyType.Non,    Hero.Moira,      1],
            [EnemyType.Non,    Hero.Reaper,     1],
            [EnemyType.Non,    Hero.Ramattra,   1],
            [EnemyType.Non,    Hero.Baptiste,   1],
            [EnemyType.Non,    Hero.Sojourn,    1],
            [EnemyType.Non,    Hero.Zarya,      1],
            [EnemyType.Non,    Hero.Brigitte,   1],
            [EnemyType.Non,    Hero.Genji,      1]
        ],
        [   // assetNo 2
            // recommend 2
            [EnemyType.Non,    Hero.Illari,     1],
            [EnemyType.Non,    Hero.Sojourn,    1],
            [EnemyType.Non,    Hero.Ramattra,   1],
            [EnemyType.Non,    Hero.Lifeweaver, 1],
            [EnemyType.Non,    Hero.Ashe,       1],
            [EnemyType.Non,    Hero.Doomfist,   1],
            [EnemyType.Non,    Hero.Kiriko,     1],
            [EnemyType.Non,    Hero.Cassidy,    1]
        ],
        // 3,4,5,6,7,8,9,
        [],[],[],[],[],[],[],

        // random hero asset
        [
            // assetNo 10
            // random with fix role
            [EnemyType.Non,    RandomSupportHero,  1],
            [EnemyType.Non,    RandomTankHero,     1],
            [EnemyType.Non,    RandomDamageHero,   1],
            [EnemyType.Non,    RandomSupportHero,  1],
            [EnemyType.Non,    RandomTankHero,     1],
            [EnemyType.Non,    RandomDamageHero,   1],
            [EnemyType.Non,    RandomSupportHero,  1],
            [EnemyType.Non,    RandomDamageHero,   1]
        ],
        [
            // assetNo 11
            // random with non role
            [EnemyType.Non,    RandomHero, 1],
            [EnemyType.Non,    RandomHero, 1],
            [EnemyType.Non,    RandomHero, 1],
            [EnemyType.Non,    RandomHero, 1],
            [EnemyType.Non,    RandomHero, 1],
            [EnemyType.Non,    RandomHero, 1],
            [EnemyType.Non,    RandomHero, 1],
            [EnemyType.Non,    RandomHero, 1]
        ],
        [
            // assetNo 12
            // many damage role
            [EnemyType.Non,    favSupport, 1],
            [EnemyType.Non,    favSupport, 1],
            [EnemyType.Non,    favDamage,  6]
        ],
        [
            // assetNo 13
            // many tank role
            [EnemyType.Non,    favSupport, 1],
            [EnemyType.Non,    favSupport, 1],
            [EnemyType.Non,    favTank,    6]
        ],
        // 14,15,16,17,18,19,
        [],[],[],[],[],[],

        // debug asset
        [
            // assetNo 20
            // for debug
            [EnemyType.Non,    Hero.Ana,    3],
            [EnemyType.Non,    Hero.Sombra,  5]
        ]
    ];

define buddyAssetNoLotteryList: [
    // fix hero asset
    0, 0,
    1, 1,
    2, 2,

    // random hero asset
    10, 10, 10,
    11,
    12,
    13

    // for debug
    // 20
];

globalvar define isLockedCreateBotsByAsset = false;

void CreateBotsByAssetWithMutexLock(in define asset!, in define team!, in define addLimitNum!){ 
    // can't implement as subroutin for mutex  
    define forceReleaseCount! = 0;
    while(isLockedCreateBotsByAsset){
        if(forceReleaseCount < 5){
            forceReleaseCount ++;
        }
        else{
            break;
        }
        Wait(1, WaitBehavior.IgnoreCondition);
    }
    isLockedCreateBotsByAsset = true;
    CreateBotsByAsset(asset, team, addLimitNum);
    isLockedCreateBotsByAsset = false;
}

define PlayerNum():
    CountOf(
        FilteredArray(
            AllPlayers(playerTeam),
            !IsDummyBot(ae)
        )
    );

define BuddyNum():
    CountOf(
        FilteredArray(
            AllPlayers(playerTeam),
            IsDummyBot(ae)
        )
    );

define needBuddyNum:
    maxBuddyBotNum - PlayerNum();

globalvar define maxBuddyBotNum =
    WorkshopSettingInteger("Ally Bot Settings (bot join game as proxy of player when slot empty)", "Filling Slot Count", 8, 0, 8, 1);

globalvar define buddyAssetNo;

globalvar define forceReloadBuddyAsset = false;

// TAG Buddy/BotAssetInterval ----------
define AssetChangeInterval(): RandomInteger(120, 180);
globalvar define reloadBuddyAssetInterval = -1;

rule: "Buddy/BotAssetInterval/reloadReloadBuddyAsset"
Event.OngoingGlobal
if(
    initCompleted
){
    define prevAssetNo! = -1;

    while(true){
        // if force reload, skip change assetNo and set interval
        if(!forceReloadBuddyAsset){
            // choice asset by random
            buddyAssetNo = RandomValueInArray(buddyAssetNoLotteryList);
            // set default interval
            reloadBuddyAssetInterval = AssetChangeInterval();
        }

        if(
            // force reload
            forceReloadBuddyAsset ||
            // assetNo changed
            prevAssetNo != buddyAssetNo
        ){
            // save current assetNo
            prevAssetNo = buddyAssetNo;
            // save avg ult charge of bots
            define ultCharge! = GetAvgUltChgOfDummyBot(playerTeam);
            // create bots by asset
            DestroyBots(playerTeam);
            CreateBotsByAssetWithMutexLock(buddyAssetList[buddyAssetNo], playerTeam, needBuddyNum);
            // restore avg ult charge of bots
            SetAvgUltChgOfDummyBot(playerTeam, ultCharge);
        }

        // relealse force reload
        forceReloadBuddyAsset = false;
        // wait start intarval until game start.
        WaitUntil(IsGameInProgress() || forceReloadBuddyAsset, MaxValue());

        for(;reloadBuddyAssetInterval > 0 && !forceReloadBuddyAsset; reloadBuddyAssetInterval--){
            Wait(1, WaitBehavior.AbortWhenFalse);
        }
    }
}

rule: "Buddy/tuneAssetMemberNum"
Event.OngoingGlobal
if(
    initCompleted
){
    define prevPlayerNum! = -1;

    // set initial asset no
    buddyAssetNo = RandomValueInArray(buddyAssetNoLotteryList);

    while(true){
        if(
            // create bot not locked
            !isLockedCreateBotsByAsset &&
            (
                // playerNum changed
                prevPlayerNum != PlayerNum() ||
                // not filed by need buddy number
                BuddyNum() != needBuddyNum ||
                // entity num than over slot num
                PlayerNum() + BuddyNum() > NumberOfSlots(playerTeam)
            )
        ){
            // save current playerNum
            prevPlayerNum = PlayerNum();
            // force reload asset
            //  but skip change assetNo, reset interval
            forceReloadBuddyAsset = true;
        }

        // check Interval
        WaitUpdateLongCycle();
    }
}

rule: "Buddy/fastRespawnBySucide"
Event.OnDeath
if(
    TeamOf() == playerTeam &&
    IsDummyBot() &&
    Attacker() == ep
){
    Respawn();
}

// TAG Payload ----------
globalvar define prevPayloadPosition;

globalvar define payloadDirection;

rule: "Payload/updatePayloadDirection"
Event.OngoingGlobal
if(
    PayloadProgressPercentage() > 0
){
    prevPayloadPosition = PayloadPosition();

    while(true){
        define nowPayloadPosition! = PayloadPosition();
        if(
            IsPlayerOnObject &&
            nowPayloadPosition != prevPayloadPosition
        ){
            payloadDirection = DirectionTowards(prevPayloadPosition, nowPayloadPosition);
            prevPayloadPosition = nowPayloadPosition;
        }
        WaitUpdateMediumCycle();
    }
}

// TAG EnemyBot ----------
globalvar define sameHero;

define enemyAssetList:
    [
        // random hero asset
        [   
            // assetNo 0
            // basic
            [EnemyType.General,     RandomHero,         1],
            [EnemyType.Elite,       RandomHero,         4],
            [EnemyType.Minion,      RandomHero,         7]
        ],
        [   
            // assetNo 1
            // general and minion
            [EnemyType.General,     RandomHero,         1],
            [EnemyType.Minion,      RandomHero,         11]
        ],
        [   
            // assetNo 2
            // all elite
            [EnemyType.Elite,       RandomHero,         4],
            [EnemyType.Elite,       RandomHero,         4],
            [EnemyType.Elite,       RandomHero,         4]
        ],
        [   
            // assetNo 3
            // all elites same hero
            [EnemyType.Elite,       sameHero,           12]
        ],
        [   
            // assetNo 4
            // half elite
            [EnemyType.Elite,       RandomHero,         6],
            [EnemyType.Minion,      RandomHero,         6]
        ],
        [   
            // assetNo 5
            // all minion
            [EnemyType.Minion,      rva([favDamage, favTank]),   12]
        ],
        [   
            // assetNo 6
            // double general
            [EnemyType.General,     RandomHero,         1],
            [EnemyType.General,     RandomHero,         1],
            [EnemyType.Minion,      RandomHero,         10]
        ],
        [   
            // assetNo 7
            // triple general
            [EnemyType.General,     RandomHero,         1],
            [EnemyType.General,     RandomHero,         1],
            [EnemyType.General,     RandomHero,         1]
        ],
        [   
            // assetNo 8
            // damage boss with minion
            [EnemyType.Boss,        favDamage,          1],
            [EnemyType.Minion,      RandomHero,         11]
        ],
        // 9,
        [],

        // fix hero asset
        [   
            // assetNo 10
            // Reinhardt army
            [EnemyType.General,     Hero.Reinhardt,     1],
            [EnemyType.Elite,       Hero.Reinhardt,     4],
            [EnemyType.Minion,      Hero.Reinhardt,     7]
        ],
        [   
            // assetNo 11
            // Soldier76 army
            [EnemyType.General,     Hero.Soldier76,     1],
            [EnemyType.Elite,       Hero.Soldier76,     4],
            [EnemyType.Minion,      Hero.Soldier76,     7]
        ],
        [   
            // assetNo 12
            // Pharah army
            [EnemyType.General,     Hero.Pharah,        1],
            [EnemyType.Elite,       Hero.Pharah,        4],
            [EnemyType.Minion,      Hero.Pharah,        7]
        ],
        [   
            // assetNo 13
            // Roadhog army
            [EnemyType.General,     Hero.Roadhog,       1],
            [EnemyType.Elite,       Hero.Roadhog,       4],
            [EnemyType.Minion,      Hero.Roadhog,       7]
        ],
        [   
            // assetNo 14
            // Bastion army
            [EnemyType.General,     Hero.Bastion,       1],
            [EnemyType.Elite,       Hero.Bastion,       4],
            [EnemyType.Minion,      Hero.Bastion,       7]
        ],
        [   
            // assetNo 15
            // gun and shield
            [EnemyType.Boss,        Hero.Widowmaker,    1],
            [EnemyType.General,     Hero.Widowmaker,    4],
            [EnemyType.Minion,      favTank,            7]   
        ],
        // 16,17,18,19,
        [],[],[],[],

        // progress asset
        [
            // assetNo 20
            // damage boss with minion
            [EnemyType.Boss,        favDamage,          1],
            [EnemyType.Elite,       RandomHero,         4],
            [EnemyType.Minion,      RandomHero,         7]
        ],
        [
            // assetNo 21
            // damage boss with tank elite
            [EnemyType.Boss,        favDamage,          1],
            [EnemyType.Elite,       favTank,            4],
            [EnemyType.Minion,      RandomHero,         7]
        ],
        [
            // assetNo 22
            // tank boss with damage elite
            [EnemyType.Boss,        favTank,            1],
            [EnemyType.Elite,       favDamage,          4],
            [EnemyType.Minion,      RandomHero,         7]
        ],
        // 23,24,25,26,27,28,29,
        [],[],[],[],[],[],[],

        // debug asset
        [
            // assetNo 30
            // tank boss with damage elite
            [EnemyType.Boss,       Hero.Widowmaker,      12]
        ]
    ];

define enemyAssetNoLotteryList: [
    // random hero asset
    0, 0,
    1, 1,
    2, 2, 2, 2,
    3, 3,
    4, 4,
    5,
    6,
    7,
    8,

    // fix hero asset
    10,
    11,
    12,
    13,
    14,
    15, 15, 15

    // for debug
    // 30
];

// TAG EnemyBot/BotAssetInterval ----------
globalvar define reloadEnemyAssetInterval = -1;
globalvar define enemyAssetNo = -1;
globalvar define forceReloadEnemyAsset = false;
define maxEnemyBotNum: 12;

rule: "EnemyBot/BotAssetInterval/reloadReloadEnemyAsset"
Event.OngoingGlobal
if(
    initCompleted &&
    (
        (IsInSetup() && MatchTime() <= 5) ||
        (IsGameInProgress())
    )
){
    while(true){
        // play effect at all enemy
        PlayEffectsToTeam(enemyTeam);

        // if force reload, skip change assetNo
        if(!forceReloadEnemyAsset){
            // choice asset by random
            enemyAssetNo = RandomValueInArray(enemyAssetNoLotteryList);
            // set default interval
            reloadEnemyAssetInterval = AssetChangeInterval();
            // change some hero
            sameHero = RandomHero;
        }

        // create bots by asset
        DestroyBots(enemyTeam);
        CreateBotsByAssetWithMutexLock(enemyAssetList[enemyAssetNo], enemyTeam, maxEnemyBotNum);
        // relealse force reload
        forceReloadEnemyAsset = false;
        // wait start intarval until game start.
        WaitUntil(IsGameInProgress(), MaxValue());

        for(;reloadEnemyAssetInterval > 0 && !forceReloadEnemyAsset; reloadEnemyAssetInterval--){
            Wait(1, WaitBehavior.AbortWhenFalse);
        }
    }
}

globalvar define progressStage;

rule: "EnemyBot/BotAssetInterval/reloadBotAssetIntervalByProgress"
Event.OngoingGlobal
if(
    initCompleted &&
    IsGameInProgress()
){
    while(true){
        define progress! = TotalObjectProgress();

        define progressAssetNo! = -1;
        define progressAssetInterval!;

        if(
            progressStage == 0 && progress >= 30
        ){
            progressAssetNo = 20;
            progressAssetInterval = RandomInteger(90, 120);
            progressStage ++;
        }
        else if(
            progressStage == 1 && progress >= 60
        ){
            progressAssetNo =21;
            progressAssetInterval = RandomInteger(90, 120);
            progressStage ++;
        }
        else if(
            progressStage == 2 && progress >= (finaleProgress - 5)
        ){
            progressAssetNo = 22;
            progressAssetInterval = MaxValue();
            progressStage ++;
        }

        // has progress asset
        if(progressAssetNo != -1){
            // set progress asset and interval
            enemyAssetNo = progressAssetNo;
            reloadEnemyAssetInterval = progressAssetInterval;
            // force reload asset
            //  but skip change assetNo
            forceReloadEnemyAsset = true;
        }

        // check Interval
        WaitUpdateMediumCycle();
    }
}

void PlayEffectsToTeam(define team!) "PlayEffectsToTeam"{
    define players! = AllPlayers(team);
    for(define playersIndex! = 0; playersIndex < CountOf(players); playersIndex ++){
        // play blast
        PlayEffect(
            AllPlayers(), PlayEffect.BadExplosion,
            TeamOf(players[playersIndex]) == enemyTeam ?
                enemyColor :
                Color.Yellow,
            BodyPosition(players[playersIndex]),
            TeamOf(players[playersIndex]) == enemyTeam ?
                players[playersIndex].eachBodyScale * 1.5 : 
                1.5
            );
    }
    Wait(0.1, WaitBehavior.IgnoreCondition);
}

// TAG EnemyBot/EnemyType ----------
playervar define eachDealtDamageScale;
playervar define eachMaxSpawnInterval;
playervar define eachMinSpawnInterval;
playervar define eachChargeUltInterval;
playervar define eachBodyScale;
playervar define eachDeathCost;

define basicSpawnTimeMin: 
    confirmGameDifficulty == GameDifficulty.EASY ?      8.0 :
    confirmGameDifficulty == GameDifficulty.NORMAL ?    7.0 :
    confirmGameDifficulty == GameDifficulty.HARD ?      6.0 :
    confirmGameDifficulty == GameDifficulty.HELL ?      5.0 :
    confirmGameDifficulty == GameDifficulty.INSANE ?    4.0 :
                                                        4.0;

define spawnTimeScaleMinToMax: 1.5;

define heroDealHealScale: IsSupportHero(HeroOf()) ? 2.0 : 1.0;

rule: "EnemyBot/EnemyType/setEnemyType"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    enemyType != EnemyType.Non &&
    confirmGameDifficulty != GameDifficulty.NO_VOTE
){
    // setEnemyType
    if(enemyType == EnemyType.Minion){
        StartForcingDummyBotName(ep, "Minion");
        watchUpdateRate =       18;
        eachBodyScale =         0.7;
        StartScalingPlayer(ep, eachBodyScale, false);
        StartModifyingHeroVoiceLines(ep, 1.5, false);
        
        eachDeathCost =         25;
        SetMaxHealth(ep,        25);
        SetHealingDealt(ep,     25 * heroDealHealScale);
        SetHealingReceived(ep,  25);
        eachDealtDamageScale =  0.5;
        eachChargeUltInterval = 60;
        eachMinSpawnInterval =  basicSpawnTimeMin * 1;
        eachMaxSpawnInterval =  eachMinSpawnInterval * spawnTimeScaleMinToMax;
    }
    else if(enemyType == EnemyType.Elite){
        StartForcingDummyBotName(ep, "Elite");
        watchUpdateRate =       6;
        eachBodyScale =         1.0;
        StartScalingPlayer(ep, eachBodyScale, false);
        StartModifyingHeroVoiceLines(ep, 1.0, false);

        eachDeathCost =         100;
        SetMaxHealth(ep,        100);
        SetHealingDealt(ep,     100 * heroDealHealScale);
        SetHealingReceived(ep,  100);
        eachDealtDamageScale =  1.0;
        eachChargeUltInterval = 30;
        eachMinSpawnInterval =  basicSpawnTimeMin * 2;
        eachMaxSpawnInterval =  eachMinSpawnInterval * spawnTimeScaleMinToMax;
    }
    else if(enemyType == EnemyType.General){
        StartForcingDummyBotName(ep, "General");
        watchUpdateRate =       2;
        eachBodyScale =         1.5;
        StartScalingPlayer(ep, eachBodyScale, false);
        StartModifyingHeroVoiceLines(ep, 0.5, false);

        eachDeathCost =         500;
        SetMaxHealth(ep,        500);
        SetHealingDealt(ep,     200 * heroDealHealScale);
        SetHealingReceived(ep,  200);
        eachDealtDamageScale =  2.0;
        eachChargeUltInterval = 15;
        eachMinSpawnInterval =  basicSpawnTimeMin * 4;
        eachMaxSpawnInterval =  eachMinSpawnInterval * spawnTimeScaleMinToMax;
    }
    else if(enemyType == EnemyType.Boss){
        StartForcingDummyBotName(ep, "Boss");
        watchUpdateRate =       2;
        eachBodyScale =         2.5;
        StartScalingPlayer(ep, eachBodyScale, false);
        StartModifyingHeroVoiceLines(ep, 0.1, false);

        eachDeathCost =         1000;
        SetMaxHealth(ep,        1000);
        SetHealingDealt(ep,     200 * heroDealHealScale);
        SetHealingReceived(ep,  200);
        eachDealtDamageScale =  2.0;
        eachChargeUltInterval = 15;
        eachMinSpawnInterval =  basicSpawnTimeMin * 4;
        eachMaxSpawnInterval =  eachMinSpawnInterval * spawnTimeScaleMinToMax;
        
        // set addtinal health
        Wait(0.1, WaitBehavior.IgnoreCondition);
        AddHealthPoolToPlayer(ep, HealthType.Armor, MaxHealth(ep) * 0.5, true, false);
        AddHealthPoolToPlayer(ep, HealthType.Shields, MaxHealth(ep) * 0.5, true, false);
    }

    if(IsThreatEnemy(ep)){
        StartForcingPlayerOutlines(
            ep,
            AllPlayers(playerTeam),
            true,
            Color.Orange,
            OutlineType.Default
        ); 
    }

    // enemy bot don't retreat
    enableRetreat = false;

    // update params
    UpdateEachDealtDamage();
    UpdateEachSpawnInterval();
}

rule: "EnemyBot/Effect/setFullHealth"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.Non &&
    IsAlive()
){
    // heal to max health
    Wait(0.5, WaitBehavior.IgnoreCondition);
    while(Health() < MaxHealth()){
        Heal(ep, null, MaxValue());
        Wait(0.5, WaitBehavior.IgnoreCondition);
    }
}

// TAG EnemyBot/Effect ----------
define enemyColor: Color.Team1;
playervar define skullIcon;

define IsThreatEnemy(in define player):
    player.enemyType == EnemyType.General ||
    player.enemyType == EnemyType.Boss;

define isInCombat:
    actionState != ActionState.Non &&
    (
        IsAlive() &&
        !IsInSpawnRoom()
    );

// rule: "EnemyBot/Effect/showSkullIconByTakenDamage"
// Event.OnDamageTaken
// if(
//     TeamOf() == enemyTeam &&
//     IsThreatEnemyType(ep) &&
//     Attacker() != ep
// ){
//     // show skull icon
//     ShowSkullIcon();
// }

// rule: "EnemyBot/Effect/hideSkullIcon"
// Event.OnDeath
// if(
//     TeamOf() == enemyTeam &&
//     IsThreatEnemyType(ep)
// ){
//     // hide skull icon
//     HideSkullIcon();
// }

// void ShowSkullIcon()"ShowSkullIcon"{
//     if(skullIcon == null){
//         skullIcon = CreateIcon(AllPlayers(playerTeam), ep, Icon.Skull,
//             IconRev.VisibleToPositionAndColor, warningIconColor, true);
//     }
//     Wait(2.0, WaitBehavior.RestartWhenTrue);
//     HideSkullIcon();
// }

// void HideSkullIcon()"HideSkullIcon"{
//     DestroyIcon(skullIcon);
//     skullIcon = 0;
// }

// TAG EnemyBot/Teleport ----------
define teleportAreaSize: ActionRange.Close;
define teleportAreaOffsetDistFromPayload: ActionRange.CanFind;
define teleportAreaExtendScaleByBlockedAhead: 0.4;
define minDistToEnemyWhenTeleport: teleportAreaSize * 0.5;
define minDistOfRenewCommonTeleportPosition: teleportAreaSize * 0.5;
define probOfRenewCommonTeleportPosition: 3;    //3;
define probOfReuseCommonTeleportPosition: 90;   //90;

define IsPlayerOnObject: (0 < NumberOfPlayersOnObjective(playerTeam));

playervar define teleportPosition;
globalvar define commonTeleportPosition;

define CanEncountPosition(define position)"CanEncountPosition"{
    define canEncount = false;

    define player = ClosestPlayerTo(position, playerTeam);
    if(
        // position valid
        position != null
                &&
        // not close to near enemy
        DistanceBetween(position, player) >= minDistToEnemyWhenTeleport
                &&
        // Has line to near enemy
        IsInLineOfSight(
            PositionOffsetY1() + position,
            PositionOffsetY1() + PositionOf(player),
            BarrierLOS.NoBarriersBlock)
    ){
        canEncount = true;
    }

    return canEncount;
}

define SetTeleportPositionToPlayerFront() playervar "SetTeleportPositionToPlayerFront"{
    define isFoundPosition = false;
    define objPos = CurrentObjectPosition();
    if(objPos == null){
        return false;
    }

    define teleportToTarget = ClosestPlayerTo(objPos, playerTeam);

    for(pLoopIndex = 0; pLoopIndex < 6; pLoopIndex++){
        // select teleportPosition from middle of Object and teleportToTarget
        teleportPosition =
            NearestWalkablePosition(
                PositionOf(teleportToTarget)
                    + 
                (
                    DirectionTowards(teleportToTarget, objPos)
                        *
                    DistanceBetween(teleportToTarget, objPos) * 0.25
                )
                    +
                RandomPosition(
                    (teleportAreaSize),
                    (teleportAreaSize),
                    (teleportAreaSize)
                )
            );

        if(
            // can encount enemy
            CanEncountPosition(teleportPosition)
        ){
            isFoundPosition = true;
            break;
        }

        Wait(0.5, WaitBehavior.AbortWhenFalse);
        WaitRandomAfterServerFree();
    }
    return isFoundPosition;
}

globalvar define teleportAreaExtendSize;
globalvar define blockedPositionPayloadAhead;

define SetTeleportPositionToObjectAhead() playervar "SetTeleportPositionToObjectAhead"{
    define isFoundPosition = false;
    define teleportToTarget = CurrentObjectOnPosition();
    if(teleportToTarget == null){
        return false;
    }

    // If there is a wall in the payload direction and the offset distance of the teleport area is not enough,
    //   increase the teleport area size by cut off distance
    if(
        payloadDirection != null &&
        IsPlayerOnObject
    ){
        // get blocked position of payload ahead
        blockedPositionPayloadAhead = BlockedPositon(teleportToTarget, payloadDirection, teleportAreaOffsetDistFromPayload);
        // get cut off distance by blocked position
        define cutOffDist = teleportAreaOffsetDistFromPayload - DistanceBetween(blockedPositionPayloadAhead, blockedPositionPayloadAhead);
        // get teleportAreaExtendSize by cut off distance with scale
        teleportAreaExtendSize = cutOffDist * teleportAreaExtendScaleByBlockedAhead;
        // change teleportTarget to blocked position
        teleportToTarget = blockedPositionPayloadAhead;
    }
    else{
        // clear extend size by no cut off
        teleportAreaExtendSize = 0;
    }

    for(pLoopIndex = 0; pLoopIndex < 6; pLoopIndex++){
        // select teleportPosition from teleportToTarget around
        teleportPosition = 
            NearestWalkablePosition(
                teleportToTarget
                    +
                RandomPosition(
                    (teleportAreaSize + teleportAreaExtendSize),
                    (teleportAreaSize + teleportAreaExtendSize),
                    (teleportAreaSize + teleportAreaExtendSize)
                )
            );

        if(
            // can encount enemy
            CanEncountPosition(teleportPosition)
        ){
            isFoundPosition = true;
            break;
        }

        Wait(0.5, WaitBehavior.AbortWhenFalse);
        WaitRandomAfterServerFree();
    }
    return isFoundPosition;
}

define SetTeleportPositionFromCommonPosition() playervar "SetTeleportPositionFromCommonPosition"{
    define isFoundPosition = false;
    define teleportToTarget = commonTeleportPosition;
    if(teleportToTarget == null){
        return false;
    }

    for(pLoopIndex = 0; pLoopIndex < 6; pLoopIndex++){
        // select teleportPosition from teleportToTarget around
        teleportPosition = 
            NearestWalkablePosition(
                teleportToTarget
                    +
                RandomPosition(
                    (teleportAreaSize),
                    (teleportAreaSize),
                    (teleportAreaSize)
                )
            );

        if(
            // can encount enemy
            CanEncountPosition(teleportPosition)
        ){
            isFoundPosition = true;
            break;
        }

        Wait(0.5, WaitBehavior.AbortWhenFalse);
        WaitRandomAfterServerFree();
    }
    return isFoundPosition;
}

playervar define telBeam;

void TeleportWithEffect(define isBeamFromBody!) playervar "TeleportWithEffect"{
    if(teleportPosition == null){return;}

    WaitUntil(IsGameInProgress(), MaxValue());

    define waitTeleportInterval! = 
        IndexOfArrayValue(
            FilteredArray(
                AllPlayers(enemyTeam), IsInSpawnRoom(ae)
            ),
            ep
        ) *
        0.1;
    // reduce over load by bot logic overlap
    WaitUntilServerFree();
    Wait(waitTeleportInterval, WaitBehavior.AbortWhenFalse);

    // show pre teleport effect
    PlayTeleportEffect(true, isBeamFromBody);
    // Teleport
    Teleport(ep, teleportPosition);
    // show teleport effect
    PlayTeleportEffect(false, isBeamFromBody);
    // hide teleport beam effect
    DestroyEffect(telBeam);
}


define showTeleportBeamTime: 0.7;

define scaleBodySizeToEffectSize: 1.5;

void PlayTeleportEffect(define isBefore!, define isBeamFromBody!) playervar "PlayTeleportEffect"{
    define effectSize! = eachBodyScale * scaleBodySizeToEffectSize;

    // if before teleport
    if(isBefore){
        // play teleport shadow to own position
        PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, enemyColor, PositionOf(ep), effectSize);
        // play teleport blast to teleport positon
        PlayEffect(AllPlayers(), PlayEffect.BadExplosion, enemyColor, teleportPosition, effectSize);
        // show teleport beam to own position
        DestroyEffect(telBeam);
        // define fromSky! = true;
        telBeam = CreateBeamEffect(AllPlayers(),
            BeamType.BadBeam,
            isBeamFromBody ? 
                BodyPosition(ep) :
                teleportPosition + Vector(0, 30, 0),
            teleportPosition + PositionOffset(),
            enemyColor, EffectRev.VisibleToPositionAndRadius);
        // wait for show teleport shadow of before
        Wait(showTeleportBeamTime, WaitBehavior.IgnoreCondition);
    }
    else{
        // hide teleport beam to teleport positon
        DestroyEffect(telBeam);
        // play teleport shadow to teleport positon
        PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, enemyColor, PositionOf(ep), effectSize);
        // play teleport sound
        PlayEffect(AllPlayers(), PlayEffect.RingExplosionSound, null, PositionOf(ep), 75);
    }
}

void DoTeleport(define isBeamFromBody!)"DoTeleport"{
    define isFoundPosition = false;
    define objectPos = CurrentObjectOnPosition();

    // threat enemy combat teleport
    if(
        // general or boss
        IsThreatEnemy(ep)
            &&
        // player team close win
        IsCloseWin(playerTeam)
    ){
        teleportPosition = objectPos;
    }
    // set teleportPosition with update commonTeleportPosition
    else if(
        // by prob
        ProbabilityTrue(probOfRenewCommonTeleportPosition)
            ||
        // too close to near enemy
        DistanceBetween(
            commonTeleportPosition,
            ClosestPlayerTo(commonTeleportPosition, playerTeam)) < minDistOfRenewCommonTeleportPosition        
            ||
        (
            // player on object
            IsPlayerOnObject
                    &&
            // Has not line to object
            !IsInLineOfSight(
                PositionOffsetY1() + commonTeleportPosition,
                PositionOffsetY1() + objectPos,
                BarrierLOS.NoBarriersBlock)
        )
            ||
        // position invalid
        commonTeleportPosition == null
    ){
        // set teleportPosition by calc new position
        if(
            // player on object
            IsPlayerOnObject
        ){
            isFoundPosition = SetTeleportPositionToObjectAhead();
        }
        else{
            isFoundPosition = SetTeleportPositionToPlayerFront();
        }
        
        if(isFoundPosition){
            // renew common position by teleportPosition
            commonTeleportPosition = teleportPosition;
        }        
    }
    // set teleportPosition only
    else{
        if(
            // by prob
            ProbabilityTrue(probOfReuseCommonTeleportPosition)
        ){
            // set teleportPosition by reuse common position
            isFoundPosition = SetTeleportPositionFromCommonPosition();
        }
        else{
            // set teleportPosition by calc new position
            if(
                // player on object
                IsPlayerOnObject
            ){
                isFoundPosition = SetTeleportPositionToObjectAhead();
            }
            else{
                isFoundPosition = SetTeleportPositionToPlayerFront();
            }
        }
    }

    if(isFoundPosition){
        // teleport to teleportPosition
        TeleportWithEffect(isBeamFromBody);
    }
}

rule: "EnemyBot/Teleport/teleportByRespawn"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsGameInProgress() &&
    IsInSpawnRoom()
){
    DoTeleport(false);
    Wait(1, WaitBehavior.AbortWhenFalse);
    WaitUntilServerFree();
    LoopIfConditionIsTrue();
}

define checkTeleportConditionMaxCount: 3;

rule: "EnemyBot/Teleport/teleportForDefendObjectorIdle"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsGameInProgress() &&
    IsAlive() &&
    !IsInSpawnRoom()
){
    Wait(1, WaitBehavior.AbortWhenFalse);

    for(define checkConditionCount = 0; checkConditionCount < checkTeleportConditionMaxCount; checkConditionCount ++){
        
        // check not teleport condition
        if(
            // not
            !(
                // need defend object
                (
                    // player on object
                    IsPlayerOnObject &&
                    // far from object
                    DistanceBetween(ep, CurrentObjectPosition()) > ActionRange.CanFind
                )
                    ||
                // enemy not found
                (
                    aimTarget != null &&
                    !IsInLineOfSight(ep, aimTarget)
                )
            )
        ){
            // keep position
            // reset count up
            LoopIfConditionIsTrue();
        }
        // count up checkConditionCount
        Wait(1, WaitBehavior.AbortWhenFalse);
        WaitUntilServerFree();
    }

    // when over checkConditionCount 
    // teleport
    DoTeleport(false);

    LoopIfConditionIsTrue();
}

rule: "EnemyBot/Teleport/clearCommonTeleportPosition"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    Attacker() == ep
){
    commonTeleportPosition = null;
}

// TAG EnemyBot/EnemyAbility ----------
globalvar define spawnRushInterval;

rule: "EnemyBot/EnemyAbility/spawnRush"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    // set default interval
    spawnRushInterval = ObjectProgressScaledInterval(30, 60, 5);
    spawnRushInterval *= WorkshopSettingReal("Enemy Bot Settings", "Spawn-Rush Interval Scale", 1.0, 0.1, 100, 2);
    spawnRushInterval = RoundToInteger(spawnRushInterval, Rounding.Up);
    for(;spawnRushInterval > 0; spawnRushInterval--){
        Wait(1, WaitBehavior.AbortWhenFalse);
    }

    // show text
    // DestroyHudText(spawnRushWarningHud);
    // spawnRushWarningHud = CreateHudText(AllPlayers(),
    //     "ENEMY SPAWN RUSH INCOMING!", null, null,
    //     Location.Top, 10,
    //     warningIconColor, Color.White, Color.White,
    //     HudTextRev.Color, Spectators.VisibleAlways);

    // action
    define spawnInteval! = RandomInteger(5, 15);
    define rushSpawnCount! = RandomInteger(3, 5);
    spawnInteval /= rushSpawnCount;
    for(; rushSpawnCount > 0; rushSpawnCount--){
        Respawn(
            FilteredArray(
                AllDeadPlayers(enemyTeam),
                (
                    ae.enemyType != EnemyType.Boss
                )
            )
        );
        Wait(spawnInteval, WaitBehavior.IgnoreCondition);
        WaitUntilServerFree();
    }

    // hide text
    // Wait(1, WaitBehavior.IgnoreCondition);
    // DestroyHudText(spawnRushWarningHud);

    LoopIfConditionIsTrue();
}

globalvar define shotCallInterval;

rule: "EnemyBot/EnemyAbility/shotCall"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    // set default interval
    shotCallInterval = ObjectProgressScaledInterval(30, 60, 5);
    shotCallInterval *= WorkshopSettingReal("Enemy Bot Settings", "All-Out-Ultmate Interval Scale", 1.0, 0.1, 100, 3);
    shotCallInterval = RoundToInteger(shotCallInterval, Rounding.Up);
    for(;shotCallInterval > 0; shotCallInterval--){
        Wait(1, WaitBehavior.AbortWhenFalse);
    }

    // show text
    // DestroyHudText(shotCallWarningHud);
    // shotCallWarningHud = CreateHudText(AllPlayers(),
    //     "ENEMY ALL-OUT ULTIMATE INCOMING!", null, null,
    //     Location.Top, 11,
    //     warningIconColor, Color.White, Color.White,
    //     HudTextRev.Color, Spectators.VisibleAlways);

    // action
    define allEnemys! = AllPlayers(enemyTeam);
    define shotCallDelay! = RandomReal(0.3, 1.0);
    for(define scLoopIndex! = 0; scLoopIndex < CountOf(allEnemys); scLoopIndex ++){
        if(
            IsAlive(allEnemys[scLoopIndex]) &&
            !IsInSpawnRoom(allEnemys[scLoopIndex])
        ){
            SetUltimateCharge(allEnemys[scLoopIndex], DefaultPercentage());
            PressButton(allEnemys[scLoopIndex], Button.Ultimate);
            Wait(shotCallDelay, WaitBehavior.IgnoreCondition);
            WaitUntilServerFree();
        }
    }

    // hide text
    // Wait(1, WaitBehavior.IgnoreCondition);
    // DestroyHudText(shotCallWarningHud);

    LoopIfConditionIsTrue();
}

playervar define combatTeleportInterval;

rule: "EnemyBot/EnemyAbility/combatTeleport"
Event.OngoingPlayer
if(
    IsGameInProgress() &&
    TeamOf() == enemyTeam &&
    IsThreatEnemy(ep)
){
    // set default interval
    combatTeleportInterval = ObjectProgressScaledInterval(5, 15, 5);
    combatTeleportInterval *= WorkshopSettingReal("Enemy Bot Settings", "(General & Boss) Combat-Teleport Interval Scale", 1.0, 0.1, 100, 4);
    if(actionRangeMax == ActionRange.Melee){
        combatTeleportInterval *= 1;
    }
    else if(actionRangeMax == ActionRange.Close){
        combatTeleportInterval *= 2;
    } 
    else if(actionRangeMax == ActionRange.Middle){
        combatTeleportInterval *= 4;
    } 
    else if(actionRangeMax == ActionRange.Far){
        combatTeleportInterval *= 8;
    } 
    combatTeleportInterval = RoundToInteger(combatTeleportInterval, Rounding.Up);
    for(;combatTeleportInterval > 0; combatTeleportInterval--){
        Wait(1, WaitBehavior.AbortWhenFalse);
    }

    if(IsAlive()){
        // show teleport beam from body
        DoTeleport(true);
    }

    LoopIfConditionIsTrue();
}

globalvar define moreUltProb;

rule: "EnemyBot/EnemyAbility/moreUltimate"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsThreatEnemy(ep) &&
    IsAlive() &&
    actionState != ActionState.Non &&
    !IsUsingUltimate()
){
    moreUltProb = DefaultPercentage();
    while(
        IsAlive() &&
        ProbabilityTrue(moreUltProb)
    ){
        SetUltimateCharge(ep, DefaultPercentage());
        Wait(RandomReal(0, 3), WaitBehavior.IgnoreCondition);
        PressButton(ep, Button.Ultimate);
        Wait(0.1, WaitBehavior.IgnoreCondition);
        WaitUntil(!IsUsingUltimate(), MaxValue());
    }
    moreUltProb = 0;
    Wait(1, WaitBehavior.IgnoreCondition);
}

globalvar define decreaseProb =
    WorkshopSettingReal("Enemy Bot Settings", "(General & Boss) Rapid-Fire-Ultimate Termination Scale", 1.0, 0, 10, 5) *
    10;

rule: "EnemyBot/EnemyAbility/decreasemultiUltimate"
Event.OngoingGlobal
if(
    moreUltProb > 0
){
    moreUltProb -= moreUltProb < decreaseProb ? moreUltProb : decreaseProb;
    Wait(1.0, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/SpawnInterval ----------
define showDeadEffectTime: 1.0;
globalvar define spawnTimeScale;
playervar define confirmSpawnInterval;

void UpdateEachSpawnInterval()"UpdateEachSpawnInterval"{
    define diff! = GameProgressDiff();
    if(70 <= diff){
        spawnTimeScale = 0;
    }
    else if(40 <= diff && diff < 70){
        spawnTimeScale = 0.25;
    }
    else if(10 <= diff && diff < 40){
        spawnTimeScale = 0.5;
    }
    else if(-10 <= diff && diff < 10){
        spawnTimeScale = 1.0;
    }
    else if(-40 <= diff && diff < -10){
        spawnTimeScale = 1.25;
    }
    else if(-70 <= diff && diff < -40){
        spawnTimeScale = 1.75;
    }
    else if(diff < -70){
        spawnTimeScale = 2.5;
    }

    confirmSpawnInterval = ObjectProgressScaledInterval(eachMinSpawnInterval, eachMaxSpawnInterval, 0);
    confirmSpawnInterval *= spawnTimeScale;
    confirmSpawnInterval *= WorkshopSettingReal("Enemy Bot Settings", "Basic Spawn Intarval Scale", 1.0, 0, 100, 1);
    SetRespawnMaxTime(ep, confirmSpawnInterval + showDeadEffectTime);
}

rule: "EnemyBot/SpawnInterval/update"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.Non &&
    IsGameInProgress()
){
    UpdateEachSpawnInterval();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

rule: "EnemyBot/SpawnInterval/fastRespawnBySucide"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    Attacker() == ep
){
    Wait(showDeadEffectTime, WaitBehavior.AbortWhenFalse);
    Respawn();
}

// TAG EnemyBot/DealtDamage ----------
define autoTuneDmgDltInitial :
    confirmGameDifficulty == GameDifficulty.EASY ?      25 :
    confirmGameDifficulty == GameDifficulty.NORMAL ?    30 :
    confirmGameDifficulty == GameDifficulty.HARD ?      35 :
    confirmGameDifficulty == GameDifficulty.HELL ?      40 :
    confirmGameDifficulty == GameDifficulty.INSANE ?    50 :
                                                        50 ;

define autoTuneDmgDltLimit:
    confirmGameDifficulty == GameDifficulty.EASY ?      50 :
    confirmGameDifficulty == GameDifficulty.NORMAL ?    60 :
    confirmGameDifficulty == GameDifficulty.HARD ?      70 :
    confirmGameDifficulty == GameDifficulty.HELL ?      80 :
    confirmGameDifficulty == GameDifficulty.INSANE ?    100 :
                                                        100 ;

define upValueBase: 0.75;
define upValueScale:
    confirmGameDifficulty == GameDifficulty.EASY ?      upValueBase * 1.00: 
    confirmGameDifficulty == GameDifficulty.NORMAL ?    upValueBase * 1.25: 
    confirmGameDifficulty == GameDifficulty.HARD ?      upValueBase * 1.50: 
    confirmGameDifficulty == GameDifficulty.HELL ?      upValueBase * 1.75: 
    confirmGameDifficulty == GameDifficulty.INSANE ?    upValueBase * 2.00: 
                                                        2.00;
define downValueBase: 1.0;
define downValueScale:
    confirmGameDifficulty == GameDifficulty.EASY ?      downValueBase * 2.00 :
    confirmGameDifficulty == GameDifficulty.NORMAL ?    downValueBase * 1.75 :
    confirmGameDifficulty == GameDifficulty.HARD ?      downValueBase * 1.50 :
    confirmGameDifficulty == GameDifficulty.HELL ?      downValueBase * 1.25 :
    confirmGameDifficulty == GameDifficulty.INSANE ?    downValueBase * 1.00 :
                                                        1.00;
globalvar define autoTuneDmgDlt;
globalvar define enemyDeathCount = [0,0,0,0];  // for debug
globalvar define playerDeathCount = 0;  // for debug

rule: "EnemyBot/DealtDamage/init"
Event.OngoingGlobal
if(
    confirmGameDifficulty != GameDifficulty.NO_VOTE
){
    autoTuneDmgDlt = autoTuneDmgDltInitial;
}

rule: "EnemyBot/DealtDamage/upTune"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    Attacker() != ep
){
    define upValue! = eachDeathCost * 0.01;
    upValue *= upValueScale;
    autoTuneDmgDlt += upValue;
    autoTuneDmgDlt = autoTuneDmgDlt > autoTuneDmgDltLimit ? autoTuneDmgDltLimit : autoTuneDmgDlt;

    enemyDeathCount[ep.enemyType - 1] ++;
    // dbgLogFile(<"autoTuneDmgDlt = <0>, upValue = <1>, enemyDeathCount[<2>] = <3>", autoTuneDmgDlt, upValue, ep.enemyType - 1, enemyDeathCount[ep.enemyType - 1]>);
}

rule: "EnemyBot/DealtDamage/downTune"
Event.OnDeath
if(
    TeamOf() == playerTeam &&
    Attacker() != ep
){
    define downValue! = NumberOfSlots(playerTeam) / NumberOfPlayers(playerTeam);
    if(!IsDummyBot(ep)){
        downValue *= 3;
    }
    else{
        downValue *= 1;
    }
    
    downValue *= downValueScale;
    autoTuneDmgDlt -= downValue;
    autoTuneDmgDlt = autoTuneDmgDlt < autoTuneDmgDltInitial ? autoTuneDmgDltInitial : autoTuneDmgDlt;

    playerDeathCount ++;
    // dbgLogFile(<"autoTuneDmgDlt = <0>, downValue = <2>, playerDeathCount = <2>", autoTuneDmgDlt, downValue, playerDeathCount>);
}

playervar define confirmDealtDamage;

void UpdateEachDealtDamage()"UpdateEachDealtDamage"{
    // set auto tune damage
    confirmDealtDamage = autoTuneDmgDlt;
    // apply setting scale
    confirmDealtDamage *= WorkshopSettingReal("Enemy Bot Settings", "Enemy Deal Damage Scale", 1.0, 0, 100, 0);
    // apply enemy type scale
    confirmDealtDamage *= eachDealtDamageScale;
    // apply team balance
    confirmDealtDamage /= ConvertToBalancedValue(1.5, playerTeam);
    SetDamageDealt(ep, confirmDealtDamage);
}

rule: "EnemyBot/DealtDamage/update"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.Non &&
    IsGameInProgress()
){
    UpdateEachDealtDamage();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/ReceivedDamage ----------
globalvar define confirmReceiveDamage;

void UpdateEachReceivedDamage()"UpdateEachReceivedDamage"{
    // set base damage
    confirmReceiveDamage = DefaultPercentage();
    // apply team balance
    confirmReceiveDamage *= ConvertToBalancedValue(1.5, playerTeam);
    SetDamageReceived(AllPlayers(enemyTeam), confirmReceiveDamage);
}

rule: "EnemyBot/ReceivedDamage/update"
Event.OngoingGlobal
if(
    initCompleted &&
    IsGameInProgress()
){
    UpdateEachReceivedDamage();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/ChargeUltimate ----------
rule: "EnemyBot/ChargeUltimate/charge"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.Non &&
    IsGameInProgress() &&
    !IsUsingUltimate()
){
    SetUltimateCharge(ep, UltimateChargePercent() + (DefaultPercentage() / eachChargeUltInterval));
    WaitUpdateASecond();
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/ObstIcon ----------
playervar define obstIcon;
define warningIconColor: isBlink ? Color.Red : Color.Yellow;

rule: "EnemyBot/ObstIcon/show"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    (
        IsPlayerOnObject &&
        IsOnObjective(ep)
    )
){
    DestroyIcon(obstIcon);
    obstIcon = CreateIcon(AllPlayers(playerTeam), ep, Icon.ExclamationMark,
        IconRev.PositionAndColor, warningIconColor, true);
}

rule: "EnemyBot/ObstIcon/hide"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    !(
        IsPlayerOnObject &&
        IsOnObjective(ep)
    )
){
    DestroyIcon(obstIcon);
}

globalvar define isBlink = false;

rule: "EnemyBot/ObstIcon/blinkColor"
Event.OngoingGlobal
if(
    initCompleted
){
    while(true){
        isBlink = !isBlink;
        Wait(0.1, WaitBehavior.AbortWhenFalse);
        WaitUntilServerFree();
    }
}

// TAG FinalStand ----------
rule: "FinalStand/FinalStand"
Event.OngoingGlobal
if(
    IsGameInProgress() &&
    MatchTime() <= 0
){
    BigMessage(AllPlayers(), "Final Stand !");
    slowControlHandler = SlowControlHandler.GameLogic;
    SetSlowMotion(10);
    Wait(0.25, WaitBehavior.IgnoreCondition);   // show slow

    // play effect at all
    PlayEffectsToTeam(Team.All);
    Resurrect(AllPlayers());
    Heal(AllPlayers(), null, MaxValue());
    SetUltimateCharge(AllPlayers(), DefaultPercentage());

    Wait(0.25, WaitBehavior.IgnoreCondition);   // show slow
    SetSlowMotion(DefaultPercentage());
    slowControlHandler = SlowControlHandler.ServerOverLoadMeasures;
}

// TAG Debug ----------

// rule: "Debug/GlobalAction"
// Event.OngoingGlobal
// Team.All
// if(
//     initCompleted
// ){
//     // show enemy common teleport positon
//     CreateIcon(commonTeleportPosition != null ? hp : null,
//         commonTeleportPosition + PositionOffsetY1(), Icon.Spiral,
//         IconRev.VisibleToAndPosition, enemyColor, true);
//     CreateEffect(commonTeleportPosition != null ? hp : null, Effect.Ring, enemyColor,
//         commonTeleportPosition + PositionOffsetY1(), minDistOfRenewCommonTeleportPosition, EffectRev.VisibleToPositionAndRadius);
//     CreateEffect(commonTeleportPosition != null ? hp : null, Effect.Ring, enemyColor,
//         commonTeleportPosition + PositionOffsetY1(), teleportAreaSize, EffectRev.VisibleToPositionAndRadius);
//     CreateBeamEffect(commonTeleportPosition != null ? hp : null, BeamType.GoodBeam, 
//         commonTeleportPosition, CurrentObjectOnPosition(), enemyColor, EffectRev.VisibleToPositionAndRadius);

//     // show enemy teleport area size of blocked position payload ahead
//     CreateEffect(blockedPositionPayloadAhead != null ? hp : null,
//         Effect.Sphere, enemyColor, blockedPositionPayloadAhead,
//         teleportAreaSize + teleportAreaExtendSize, EffectRev.VisibleToPositionAndRadius);

//     // while(true){
//     //     SetMaxHealth(ap(allTeam), 1000);
//     //     Resurrect(ap(allTeam));
//     //     Wait(1);
//     // }
// }

// rule: "DebugPlayerAction"
// Event.OngoingPlayer
// Team.All
// if(
//     initCompleted &&
//     HasSpawned()
// ){
//     Wait(3);
//     while(true){
//         // define prob = (60 - (MatchTime() % 60) * 1.8);
//         // ProbabilityTrue(prob);
//         // if(PlayersInSlot(0, playerTeam) == ep) dbgHudTxt(<"prob = <0>", prob>);
//         // DoGunshipSupport();
//         selectHeroMod = HeroModType.GRUDGE_LIGHTNING;
//         grudgePower = 100;
//         Wait(15);
//     }
// }

rule: "Debug/initDebugMode"
Event.OngoingGlobal
Team.All
if(
    initCompleted
){
    if(IsHostPlayerInGame()){
        debugMode = DebugMode.Non;
    }
    else{
        debugMode = DebugMode.ShowParam;
        ShowDebugHud(hp);
    }
}

rule: "Debug/changeDebugMode"
Event.OngoingPlayer
Team.All
if(
    hp == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Jump) 
){
    // change debug mode
    WaitLongPressConfirm();
    if(debugMode == DebugMode.Non){
        debugMode = DebugMode.SlowLevelOnly;
    }
    else if(debugMode == DebugMode.SlowLevelOnly){
        debugMode = DebugMode.ShowParam;
    }
    else if(debugMode == DebugMode.ShowParam){
        debugMode = DebugMode.WithRecord;
    }
    else if(debugMode == DebugMode.WithRecord){
        debugMode = DebugMode.Non;
    }

    // reload hud
    HideDebugHud();
    ShowDebugHud(hp);
}

globalvar define debugHuds;

define Last():
    CountOf(debugHuds);

define FirstEnemyOf(in define enemyType):
    FirstOf(FilteredArray(AllPlayers(enemyTeam), ae.enemyType == enemyType));

define FirstThreatEnemy():
    FirstOf(FilteredArray(AllPlayers(enemyTeam), IsThreatEnemy(ae)));

// show debug icon and hud
void ShowDebugHud(define player!)"ShowDebugHud"{
    if(
        debugMode == DebugMode.WithRecord
    ){
        EnableInspectorRecording();
        debugHuds[Last()] = CreateDebugHud("Recording", true, Color.Red);
    }
    else{
        DisableInspectorRecording();
    }
    
    if(
        debugMode == DebugMode.SlowLevelOnly ||
        debugMode == DebugMode.ShowParam ||
        debugMode == DebugMode.WithRecord
    ){
        debugHuds[Last()] = CreateDebugHud("Server Load", ServerLoad(), ServerLoad() < 255 ? Color.Orange : Color.Yellow);
        // debugHuds[Last()] = CreateDebugHud("Server Load Average", ServerLoadAverage(), ServerLoadAverage() < 255 ? Color.Orange : Color.Yellow);
        // debugHuds[Last()] = CreateDebugHud("Server Load Peak", ServerLoadPeak(), ServerLoadPeak() < 255 ? Color.Orange : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("game Logic Speed", gameLogicSpeed, gameLogicSpeed >= 100 ? Color.Orange : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("count Wait Random After Server Free", countWaitRandomAfterServerFree, Color.Orange);
        debugHuds[Last()] = CreateDebugHud("count Game Logic Speed Decrease", countGameLogicSpeedDecrease, Color.Orange);
        debugHuds[Last()] = CreateDebugHud("human player Num", HumanPlayerNum(playerTeam), HumanPlayerNum(playerTeam) <= 1 ? Color.Team2 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("auto Tune Dmg Dlt", autoTuneDmgDlt, Color.Team1);
    }

    if(
        debugMode == DebugMode.ShowParam ||
        debugMode == DebugMode.WithRecord
    ){  
        // player team
        debugHuds[Last()] = CreateDebugHud("team player Num", <"<0> / <1>", NumberOfLivingPlayers(playerTeam), NumberOfPlayers(playerTeam)>, NumberOfLivingPlayers(playerTeam) >= NumberOfPlayers(playerTeam) ? Color.Team2 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("reload Asset Interval", reloadBuddyAssetInterval, reloadBuddyAssetInterval > 5 ? Color.Team2 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("asset Number", buddyAssetNo, Color.Team2);
        debugHuds[Last()] = CreateDebugHud("death Count", playerDeathCount, Color.Team2);

        // enemy team
        debugHuds[Last()] = CreateDebugHud("team player num", <"<0> / <1>", NumberOfLivingPlayers(enemyTeam), NumberOfPlayers(enemyTeam)>, NumberOfLivingPlayers(enemyTeam) >= NumberOfPlayers(enemyTeam) ? Color.Team1 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("reload Asset Interval", reloadEnemyAssetInterval, reloadEnemyAssetInterval > 5 ? Color.Team1 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("Asset Number", enemyAssetNo, Color.Team1);
        debugHuds[Last()] = CreateDebugHud("death Count", <"<0>, <1>, <2>, <3>", enemyDeathCount[0], enemyDeathCount[1], enemyDeathCount[2], enemyDeathCount[3]>, Color.Team1);

        debugHuds[Last()] = CreateDebugHud("spawn Time scale", spawnTimeScale, Color.Team1);
        debugHuds[Last()] = CreateDebugHud("spawn Interval", <"<0>, <1>, <2>, <3>",
            FirstEnemyOf(EnemyType.Minion).confirmSpawnInterval,
            FirstEnemyOf(EnemyType.Elite).confirmSpawnInterval,
            FirstEnemyOf(EnemyType.General).confirmSpawnInterval,
            FirstEnemyOf(EnemyType.Boss).confirmSpawnInterval>, Color.Team1);
        debugHuds[Last()] = CreateDebugHud("spawn Rush Interval", spawnRushInterval, spawnRushInterval > 5 ? Color.Team1 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("shot Call Interval", shotCallInterval, shotCallInterval > 5 ? Color.Team1 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("combat Teleport Interval",
            FirstThreatEnemy().combatTeleportInterval,
            FirstThreatEnemy().combatTeleportInterval > 5 ? Color.Team1 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("more Ult Prob", moreUltProb, moreUltProb <= 0 ? Color.Team1 : Color.Yellow);
    }
}

// Hide debug icon and hud
void HideDebugHud()"HideDebugHud"{
    for(gLoopIndex = 0; gLoopIndex < CountOf(debugHuds); gLoopIndex ++){
        DestroyHudText(debugHuds[gLoopIndex]);
    }
}

rule: "Debug/resetBotList"
Event.OngoingPlayer
Team.All
if(
    hp == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Crouch)
){
    WaitLongPressConfirm();
    reloadEnemyAssetInterval = 0;
    WaitLongPressConfirm();
    WaitUntil(reloadEnemyAssetInterval > 0, 10);
    reloadBuddyAssetInterval = 0;
}

rule: "Debug/triggerRushAndShotCall"
Event.OngoingPlayer
Team.All
Player.All
if(
    hp == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Reload)
){
    WaitLongPressConfirm();
    AllPlayers(enemyTeam).combatTeleportInterval = 0;
    WaitLongPressConfirm();
    spawnRushInterval = 0;
    WaitLongPressConfirm();
    shotCallInterval = 0;
}
