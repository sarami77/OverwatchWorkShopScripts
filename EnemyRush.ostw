import "EnemyRush.setting.json";
import "Lib/Debug.del";
import "Lib/Utility.del";
import "Lib/ServerOverLoadMeasures.del";
import "Lib/Bot.del";
import "Lib/Buddy.del";

// TAG Signature and infomation ----------
disabled rule: "ENEMY RUSH -HORDE PVE [ver.2.0] Share code [V7PEF]"-1{}
disabled rule: "You allowed copy or modify code."-1{}
disabled rule: "This script was generated by [Overwatch-Script-To-Workshop] tools"-1{}
disabled rule: "Check detail with https://github.com/ItsDeltin/Overwatch-Script-To-Workshop"-1{}
disabled rule: "Original source code was created by [sarami77#1868]"-1{}
disabled rule: "Check detail with https://github.com/sarami77/OverwatchWorkShopScripts"-1{}

// TAG Initialize ----------
define playerTeam: Team.Team2;
define enemyTeam: Team.Team1;

globalvar define initCompleted!;

rule: "Initialize/initialize"
Event.OngoingGlobal
{
    // Stop records to reduce server load
    DisableInspectorRecording();

    // If run it right after loading the server, some scripts fail, so wait 3 seconds
    Wait(3, WaitBehavior.AbortWhenFalse);

    // Start watch over load
    slowControlHandler = SlowControlHandler.ServerOverLoadMeasures;

    // show version and share code
    CreateHudText(AllPlayers(),
        null, "ENEMY RUSH -HORDE PVE [ver.2.0] Share code [V7PEF]", null,
        Location.Left, -999,
        Color.White, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);

    // show HUD of enemy team assembly
    CreateHudText(AllPlayers(),
        null,
        null,
        <"Enemy Team Assembly \"<0>\"", enemyTeamName>,
        Location.Right, -1,
        Color.White, Color.White, Color.Purple,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);

    // Notify completion of init game setting and start game main logic
    initCompleted = true;
}

rule: "Initialize/shortenAssemblingHeroes"
Event.OngoingGlobal
if(
    IsAssemblingHeroes()
){
    SetMatchTime(15);
}

rule: "Initialize/shortenSetup"
Event.OngoingGlobal
if(
    IsInSetup()
){
    SetMatchTime(20);
}

// TAG Buddy ----------
rule: "Buddy/BuddyContorl"
Event.OngoingGlobal
if(
    initCompleted
){
    define buddyList! = 
    WorkshopSettingToggle("Follower AI Settings(Join on behalf of absent player)", "Random Hero", false) ?
        // random list
        [
            RandomSupportHero,
            RandomTankHero,
            RandomDamageHero,
            RandomSupportHero,
            RandomTankHero,
            RandomDamageHero,
            RandomSupportHero,
            RandomDamageHero
        ]
    :
        // fix list
        [
            Hero.Mercy,
            Hero.Reinhardt,
            Hero.Genji,
            Hero.Moira,
            Hero.Sigma,
            Hero.Hanzo,
            Hero.Ana,
            Hero.Doomfist
        ];

    // slice buddy list by setting
    buddyList = ArraySlice(buddyList, 0,
        WorkshopSettingInteger(
            "Follower AI Settings(Join on behalf of absent player)",
            "Follower Max Num", 5, 0, 8, 1)
    );

    define prevPlayerNum! = -1;
    define maxSlotNum! = NumberOfSlots(playerTeam);
    define maxBuddyNum! = CountOf(buddyList);

    while(true){
        define playerNum! =
            CountOf(
                FilteredArray(
                    AllPlayers(playerTeam),
                    !IsDummyBot(ae)));

        define needBuddyNum = 
            Min(
                maxSlotNum - playerNum,
                maxBuddyNum);

        define buddyNum! = 
            CountOf(
                FilteredArray(
                    AllPlayers(playerTeam),
                    IsDummyBot(ae)));

        if(
            // player number changed
            prevPlayerNum != playerNum ||
            // not filed buddy number
            buddyNum != needBuddyNum
        ){
            // save player num
            prevPlayerNum = playerNum;
            // relaod buddy list
            DestroyBots(playerTeam);
            define emptySlotNum! = maxSlotNum - playerNum;
            define addList! = ArraySlice(buddyList, 0, emptySlotNum);
            for(define buddyAddIndex! = 0; buddyAddIndex < CountOf(addList); buddyAddIndex++){
                CreateBotsByHeroInput(addList[buddyAddIndex], 1, playerTeam);
            }
        }
    
        Wait(5, WaitBehavior.IgnoreCondition);
    }
}

rule: "Buddy/Teleport/init"
Event.OngoingPlayer
if(
    TeamOf() == playerTeam &&
    IsDummyBot() &&
    HasSpawned()
){
    CreateInWorldText(
        AllPlayers(), followerText, 
        ep, basicInWorldTextSize, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
        Color.SkyBlue, Spectators.DefaultVisibility);

    if(IsGameInProgress()){
        SetUltimateCharge(ep, 50);
        // teleport to player near object
        Teleport(ep, ClosestPlayerTo(CurrentObjectPosition(), playerTeam));
    }
    else{
        // teleport to spawn point
        Teleport(ep, SpawnPoints(playerTeam)[0]);
    }
}

rule: "Buddy/fastRespawnByKilled"
Event.OnDeath
if(
    TeamOf() == playerTeam &&
    IsDummyBot() &&
    Attacker() != ep
){
    Wait(7.5, WaitBehavior.IgnoreCondition);
    Respawn();
}

rule: "Buddy/fastRespawnBySucide"
Event.OnDeath
if(
    TeamOf() == playerTeam &&
    IsDummyBot() &&
    Attacker() == ep
){
    Wait(5, WaitBehavior.IgnoreCondition);
    Respawn();
}


// TAG Payload ----------
globalvar define prevPayloadPosition!;

globalvar define payloadDirection!;

rule: "Payload/updatePayloadDirection"
Event.OngoingGlobal
if(
    PayloadProgressPercentage() > 0
){
    prevPayloadPosition = PayloadPosition();

    while(true){
        define nowPayloadPosition = PayloadPosition();
        if(
            IsPlayerOnObject &&
            DistanceBetween(nowPayloadPosition, prevPayloadPosition) > 0.01
        ){
            payloadDirection = DirectionTowards(prevPayloadPosition, nowPayloadPosition);
            prevPayloadPosition = nowPayloadPosition;
        }
        Wait(1);
    }
    LoopIfConditionIsTrue();
}

// TAG Player ----------
// TAG Player/FisrtFast
rule: "Player/FisrtFast/setFastSpeed"
Event.OngoingPlayer
if(
    TeamOf() == playerTeam &&
    IsAlive() &&
    IsInSpawnRoom()
){
    SetMoveSpeed(ep, 150);
    while(!IsInLineOfSight(ep, ClosestPlayerTo(ep, enemyTeam))){
        Wait(1, WaitBehavior.IgnoreCondition);
    }
    SetMoveSpeed(ep, 100);
}

// TAG EnemBot ----------
define assetList:
    [
        // random hero
        [
            "basic",
            [EnemyType.Boss,        RandomHero,         1],
            [EnemyType.Elite,       RandomHero,         5],
            [EnemyType.Minion,      RandomHero,         10]
        ],
        [
            "basic",
            [EnemyType.Boss,        RandomHero,         1],
            [EnemyType.Elite,       RandomHero,         5],
            [EnemyType.Minion,      RandomHero,         10]
        ],
        [
            "basic",
            [EnemyType.Boss,        RandomHero,         1],
            [EnemyType.Elite,       RandomHero,         5],
            [EnemyType.Minion,      RandomHero,         10]
        ],
        [
            "basic",
            [EnemyType.Boss,        RandomHero,         1],
            [EnemyType.Elite,       RandomHero,         5],
            [EnemyType.Minion,      RandomHero,         10]
        ],
        [
            "basic",
            [EnemyType.Boss,        RandomHero,         1],
            [EnemyType.Elite,       RandomHero,         5],
            [EnemyType.Minion,      RandomHero,         10]
        ],
        [
            "basic",
            [EnemyType.Boss,        RandomHero,         1],
            [EnemyType.Elite,       RandomHero,         5],
            [EnemyType.Minion,      RandomHero,         10]
        ],
        [
            "boss and minions",
            [EnemyType.Boss,        RandomHero,         1],
            [EnemyType.Minion,      RandomHero,         15]
        ],
        [
            "boss and minions",
            [EnemyType.Boss,        RandomHero,         1],
            [EnemyType.Minion,      RandomHero,         15]
        ],        [
            "boss and minions",
            [EnemyType.Boss,        RandomHero,         1],
            [EnemyType.Minion,      RandomHero,         15]
        ],
        [
            "10 elites",
            [EnemyType.Elite,       RandomHero,         3],
            [EnemyType.Elite,       RandomHero,         3],
            [EnemyType.Elite,       RandomHero,         4]
        ],
        [
            "10 elites",
            [EnemyType.Elite,       RandomHero,         3],
            [EnemyType.Elite,       RandomHero,         3],
            [EnemyType.Elite,       RandomHero,         4]
        ],        [
            "10 elites",
            [EnemyType.Elite,       RandomHero,         3],
            [EnemyType.Elite,       RandomHero,         3],
            [EnemyType.Elite,       RandomHero,         4]
        ],
        [
            "double bosses",
            [EnemyType.Boss,        RandomHero,         1],
            [EnemyType.Boss,        RandomHero,         1],
            [EnemyType.Minion,      RandomHero,         8]
        ],
        [
            "double bosses",
            [EnemyType.Boss,        RandomHero,         1],
            [EnemyType.Boss,        RandomHero,         1],
            [EnemyType.Minion,      RandomHero,         8]
        ],        [
            "double bosses",
            [EnemyType.Boss,        RandomHero,         1],
            [EnemyType.Boss,        RandomHero,         1],
            [EnemyType.Minion,      RandomHero,         8]
        ],

        /*
        [
            "clones",
            [EnemyType.Boss,        someHero, 		    1],
            [EnemyType.Elite,       someHero, 		    5],
            [EnemyType.Minion,      someHero, 		    10]
        ],
        [
            "double boss clones",
            [EnemyType.Boss,        someHero, 		    2],
            [EnemyType.Elite,       someHero, 		    8]
        ],
        [
            "10 elites clones",
            [EnemyType.Elite,       someHero, 		    10]
        ],
        */
        
        [
            "giant boss",
            [EnemyType.GiantBoss,   RandomTankHero,     1],
            [EnemyType.Minion,      RandomSupportHero,  10]
        ],
        [
            "giant boss",
            [EnemyType.GiantBoss,   RandomDamageHero,   1],
            [EnemyType.Minion,      RandomSupportHero,  10]
        ],
        [
            "giant boss",
            [EnemyType.GiantBoss,   RandomSupportHero,  1],
            [EnemyType.Minion,      RandomSupportHero,  10]
        ],

        // specificatied hero
        [
            "giant boss",
            [EnemyType.GiantBoss,   Hero.Reinhardt,     1],
            [EnemyType.Minion,      RandomSupportHero,  10]
        ],
        [
            "giant boss",
            [EnemyType.GiantBoss,   Hero.Sigma,         1],
            [EnemyType.Minion,      RandomSupportHero,  10]
        ],
        [
            "giant boss",
            [EnemyType.GiantBoss,   Hero.Doomfist,      1],
            [EnemyType.Minion,      RandomSupportHero,  10]
        ],
        [
            "giant boss",
            [EnemyType.GiantBoss,   Hero.Pharah,        1],
            [EnemyType.Minion,      RandomSupportHero,  10]
        ],
        [
            "giant boss",
            [EnemyType.GiantBoss,   Hero.Genji,         1],
            [EnemyType.Minion,      RandomSupportHero,  10]
        ],
        [
            "giant boss",
            [EnemyType.GiantBoss,   Hero.Roadhog,         1],
            [EnemyType.Minion,      RandomSupportHero,  10]
        ],
        [
            "close range",
            [EnemyType.Boss,        Hero.Reaper,        1],
            [EnemyType.Elite,       Hero.Mei,           5],
            [EnemyType.Minion,      Hero.Dva,           10]
        ],
        [
            "close range",
            [EnemyType.Boss,        Hero.Mei,           1],
            [EnemyType.Elite,       Hero.Dva,           5],
            [EnemyType.Minion,      Hero.Reaper,        10]
        ],
        [
            "melees",
            [EnemyType.Boss,        Hero.Reinhardt,     1],
            [EnemyType.Elite,       Hero.Doomfist,      5],
            [EnemyType.Minion,      Hero.Brigitte,      10]
        ],
        [
            "melees",
            [EnemyType.Boss,        Hero.Brigitte,      1],
            [EnemyType.Elite,       Hero.Doomfist,      5],
            [EnemyType.Minion,      Hero.Reinhardt,     10]
        ],
        [
            "flankers",
            [EnemyType.Boss,        Hero.Genji,         1],
            [EnemyType.Elite,       Hero.Soldier76,     5],
            [EnemyType.Minion,      Hero.Tracer,        10]
        ],
        [
            "flankers",
            [EnemyType.Boss,        Hero.Tracer,        1],
            [EnemyType.Elite,       Hero.Genji,         5],
            [EnemyType.Minion,      Hero.Soldier76,     10]
        ],
        [
            "long range",
            [EnemyType.Boss,        Hero.Orisa, 		1],
            [EnemyType.Elite,       Hero.Bastion, 		5],
            [EnemyType.Minion,      Hero.Ana, 	        10]
        ],
        [
            "long range",
            [EnemyType.Boss,        Hero.Bastion, 		1],
            [EnemyType.Elite,       Hero.Orisa, 		5],
            [EnemyType.Minion,      Hero.Ana, 	        10]
        ],
        [
            "air forces elite",
            [EnemyType.Elite,       Hero.Echo, 			5],
            [EnemyType.Elite,       Hero.Pharah, 		5]
        ],
        [
            "sky queen",
            [EnemyType.Boss,        Hero.Pharah, 		1],
            [EnemyType.Elite,       Hero.Mercy, 		5],
            [EnemyType.Minion,      Hero.Echo,   		10]
        ],
        [
            "sky queen",
            [EnemyType.Boss,        Hero.Echo, 		    1],
            [EnemyType.Elite,       Hero.Mercy, 		5],
            [EnemyType.Minion,      Hero.Pharah,   		10]
        ],
        [
            "snipers elite",
            [EnemyType.Boss,         Hero.Orisa,        1],
            [EnemyType.Elite,        Hero.Hanzo,		7],
            [EnemyType.Elite,        Hero.Widowmaker,	7]
        ],
        [
            "snipers elite",
            [EnemyType.Boss,         Hero.Orisa,        1],
            [EnemyType.Elite,        Hero.Ashe,		    7],
            [EnemyType.Elite,        Hero.Widowmaker,	7]
        ],
        [
            "snipers elite",
            [EnemyType.Boss,         Hero.Orisa,        1],
            [EnemyType.Elite,        Hero.Hanzo,		7],
            [EnemyType.Elite,        Hero.Ana,	        7]
        ],
        [
            "machines",
            [EnemyType.Boss,        Hero.Orisa, 		1],
            [EnemyType.Elite,       Hero.Bastion, 		5],
            [EnemyType.Minion,      Hero.Zenyatta,      10]
        ],
        [
            "machines",
            [EnemyType.Boss,        Hero.Zenyatta, 		1],
            [EnemyType.Elite,       Hero.Orisa, 		5],
            [EnemyType.Minion,      Hero.Bastion,       10]
        ],
        [
            "Steel waves",
            [EnemyType.Boss,        Hero.Reinhardt, 	1],
            [EnemyType.Minion,      Hero.Reinhardt, 	15]
        ],
        [
            "many turrets",
            [EnemyType.Boss,        Hero.Torbjorn, 		1],
            [EnemyType.Elite,       Hero.Symmetra, 		5],
            [EnemyType.Minion,      Hero.Symmetra, 		10]
        ],
        [
            "many turrets",
            [EnemyType.Boss,        Hero.Symmetra, 		1],
            [EnemyType.Elite,       Hero.Torbjorn, 		5],
            [EnemyType.Minion,      Hero.Torbjorn, 		10]
        ],
        [
            "gunmans",
            [EnemyType.Elite,       Hero.Cassidy, 		14]
        ],
        [
            "Explodes",
            [EnemyType.Boss,        Hero.Tracer, 		1],
            [EnemyType.Elite,       Hero.Pharah, 		5],
            [EnemyType.Minion,      Hero.Junkrat, 		10]
        ],
        [
            "Explodes",
            [EnemyType.Boss,        Hero.Pharah, 		1],
            [EnemyType.Elite,       Hero.Junkrat, 		5],
            [EnemyType.Minion,      Hero.Tracer, 		10]
        ]
    ];

globalvar define someHero!;

// TAG EnemyBot/BotAsset ----------
rule: "EnemyBot/reloadBotAsset"
Event.OngoingGlobal
if(
    initCompleted &&
    (
        (IsInSetup() && MatchTime() <= 10 ) ||
        (IsGameInProgress())
    )
){
    dbgMsg("reloadBotAsset");
    WaitUntil(!(IsEnemyOnObject && IsPlayerOnObject), 60);

    // play effect each enemy
    define list! = AllPlayers(enemyTeam);
    for(gLoopIndex = 0; gLoopIndex < CountOf(list); gLoopIndex ++){
        PlayEffect(AllPlayers(), PlayEffect.BadExplosion, enemyColor,
            list[gLoopIndex], list[gLoopIndex].eachEffectTextSize);
    }
    Wait(showDeadEffectTime * 2, WaitBehavior.IgnoreCondition);

    // create all bot
    someHero = RandomHero;
    CreateBotsByAssetList(assetList, enemyTeam);
    
    Wait(RandomInteger(90, 150), WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/EnemyType ----------
playervar define eachDealtDamageScale!;
playervar define eachMaxSpawnInterval!;
playervar define eachMinSpawnInterval!;
playervar define eachChargeUltInterval!;
playervar define eachEffectTextSize!;
playervar define eachNameText!;
playervar define eachNameColor!;

playervar define eachPerkDropProbability;   // dummy

define baseMaxSpawn: 10;
define baseMinSpawn: 5;

rule: "EnemyBot/EnemyType/setEnemyType"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.None
){
    if(enemyType == EnemyType.Minion){
        StartScalingPlayer(ep, 0.75, false);
        StartModifyingHeroVoiceLines(ep, 1.5, false);

        SetMaxHealth(ep, 25);

        SetHealingDealt(ep, 50);
        SetHealingReceived(ep, 50);
        
        eachDealtDamageScale = 0.5;
        eachChargeUltInterval = 90;
        eachMaxSpawnInterval = 10;
        eachMinSpawnInterval = 5;

        eachNameText = "Minion";
        eachNameColor = Color.White;
        eachEffectTextSize = basicInWorldTextSize;

        eachPerkDropProbability = 3;
    }
    else if(enemyType == EnemyType.Elite){
        StartScalingPlayer(ep, 1.0, false);
        StartModifyingHeroVoiceLines(ep, 1.0, false);

        SetMaxHealth(ep, 100);

        SetHealingDealt(ep, 200);
        SetHealingReceived(ep, 200);

        eachDealtDamageScale = 1.0;
        eachChargeUltInterval = 30;
        eachMaxSpawnInterval = 20;
        eachMinSpawnInterval = 10;

        eachNameText = "Elite";
        eachNameColor = Color.Yellow;
        eachEffectTextSize = basicInWorldTextSize + 1;
    }
    else if(enemyType == EnemyType.Boss){
        StartScalingPlayer(ep, 1.5, false);
        StartModifyingHeroVoiceLines(ep, 0.5, false);

        SetMaxHealth(ep, 1000);

        SetHealingDealt(ep, 200);
        SetHealingReceived(ep, 200);

        eachDealtDamageScale = 2.0;
        eachChargeUltInterval = 10;
        eachMaxSpawnInterval = 40;
        eachMinSpawnInterval = 20;

        eachNameText = "Boss";
        eachNameColor = Color.Red;
        eachEffectTextSize = basicInWorldTextSize + 2;
    }
    else if(enemyType == EnemyType.GiantBoss){
        StartScalingPlayer(ep, 2.5, false);
        StartModifyingHeroVoiceLines(ep, 0.1, false);

        SetMaxHealth(ep, 1000);

        SetHealingDealt(ep, 200);
        SetHealingReceived(ep, 200);

        eachDealtDamageScale = 4.0;
        eachChargeUltInterval = 10;
        eachMaxSpawnInterval = 40;
        eachMinSpawnInterval = 20;

        eachNameText = "Giant Boss";
        eachNameColor = Color.Purple;
        eachEffectTextSize = basicInWorldTextSize + 3;

        // set addtinal health
        Wait(0.1, WaitBehavior.AbortWhenFalse);
        define health! = MaxHealth(ep) * 0.5;
        AddHealthPoolToPlayer(ep, HealthType.Armor, health, true, false);
        AddHealthPoolToPlayer(ep, HealthType.Shields, health, true, false);
    }

    UpdateEachDealtDamage();
    UpdateEachSpawnInterval();

    // heal to max health
    while(Health() < MaxHealth()){
        Heal(ep, null, MaxValue());
        Wait(0.1, WaitBehavior.AbortWhenFalse);
    }
}

// TAG EnemyBot/Effect ----------
define enemyColor: Color.Purple;
playervar define botAppearanceEntitys!;

rule: "EnemyBot/Effect/showBotAppearance"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.None &&
    IsAlive()
){
    botAppearanceEntitys = [];
    // show evil aura
    botAppearanceEntitys[0] = 
        CreateEffect(AllPlayers(), Effect.Cloud, enemyColor,
            ep, eachEffectTextSize, EffectRev.VisibleToPositionAndRadius);
    // show name text
    botAppearanceEntitys[1] = 
        CreateInWorldText(
            AllPlayers(), eachNameText, 
            ep, eachEffectTextSize, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            eachNameColor, Spectators.DefaultVisibility);
}

rule: "EnemyBot/Effect/hideBotAppearanceAndReek"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.None &&
    !IsAlive()
){
    // hide evil aura
    DestroyEffect(botAppearanceEntitys[0]);
    // hide name text
    DestroyInWorldText(botAppearanceEntitys[1]);
    // play dead effect
    PlayContinuousBlast(Color.Red, PositionOf(),
        eachEffectTextSize * 1.5, eachEffectTextSize, 0);
}

// TAG EnemyBot/Teleport ----------
globalvar define prvPayloadPos;
define ClosestPlayerToTelPos: ClosestPlayerTo(teleportPosition, playerTeam);
define ClosestPlayerToComTelPos: ClosestPlayerTo(commonTeleportPosition, playerTeam);
define ClosestPlayerToMe: ClosestPlayerTo(ep, playerTeam);

Player ClosestPlayerFromObject()"ClosestPlayerFromObject"{
    return FirstOf(
        SortedArray(
            FilteredArray(
                AllPlayers(playerTeam),
                (
                    HasSpawned(ae) &&
                    IsAlive(ae) &&
                    !IsInSpawnRoom(ae)
                )
            ),
            DistanceBetween(ae, CurrentObjectPosition())
        )
    );
}

playervar define teleportPosition!;
globalvar define commonTeleportPosition!;
define teleportAreaSize: 10;

Boolean SetTeleportPositionToPlayerFront()"SetTeleportPositionToPlayerFront"{
    // set teleportToTarget at closest player from Object
    define teleportToTarget! = ClosestPlayerFromObject();
    if(teleportToTarget == null){
        return false;
    }

    for(pLoopIndex = 0; pLoopIndex < 30; pLoopIndex++){
        // select teleportPosition from middle of Object and teleportToTarget
        teleportPosition =
            NearestWalkablePosition(
                PositionOf(teleportToTarget)
                    + 
                (
                    DirectionTowards(teleportToTarget, CurrentObjectPosition())
                        *
                    DistanceBetween(teleportToTarget, CurrentObjectPosition()) * 0.3
                )
                    +
                RandomPosition(
                    (teleportAreaSize),
                    (teleportAreaSize),
                    (teleportAreaSize)
                )
            );

        if(
            // not close to object
            DistanceBetween(ep, CurrentObjectPosition()) > 6   
        ){
            break;
        }
        Wait(0.1, WaitBehavior.AbortWhenFalse);
        WaitUntilServerFree();
    }
    return true;
}

Boolean SetTeleportPositionToObjectArround()"SetTeleportPositionToObjectArround"{
    for(pLoopIndex = 0; pLoopIndex < 30; pLoopIndex++){
        // select teleportPosition from current object around
        teleportPosition = 
            NearestWalkablePosition(
                CurrentObjectPosition() +
                RandomPosition(
                    (teleportAreaSize),
                    (teleportAreaSize),
                    (teleportAreaSize)
                )
            );

        if(
            // not close to object
            DistanceBetween(ep, CurrentObjectPosition()) > 8    
        ){
            break;
        }
        Wait(0.1, WaitBehavior.AbortWhenFalse);
        WaitUntilServerFree();
    }
    return true;
}

globalvar define additinalTeleportAreaSize;
define teleportAreaSizeOffset: 30;

Boolean SetTeleportPositionToObjectAhead()"SetTeleportPositionToObjectAhead"{
    // set teleportToTarget at Object
    define teleportToTarget! = CurrentObjectPosition() + Vector(0, 4, 0);

    if(
        payloadDirection != 0 &&
        IsPlayerOnObject
    ){
        // get bloacked position of payload ahead
        define blockedHead! = BlockedPositon(teleportToTarget, payloadDirection, teleportAreaSizeOffset);
        // increase teleportAreaSize by cutoff distance for spam payload brock by teleport
        additinalTeleportAreaSize = teleportAreaSizeOffset - DistanceBetween(teleportToTarget, blockedHead);
        additinalTeleportAreaSize /= 2;
        // change teleportTarget to payload ahead
        teleportToTarget = blockedHead;
    }
    else{
        additinalTeleportAreaSize = 0;
    }

    define telPosNearTarget! = ClosestPlayerToTelPos;

    for(pLoopIndex = 0; pLoopIndex < 30; pLoopIndex++){
        // select teleportPosition from teleportToTarget around
        teleportPosition = 
            NearestWalkablePosition(
                teleportToTarget +
                RandomPosition(
                    (teleportAreaSize + additinalTeleportAreaSize),
                    (teleportAreaSize + additinalTeleportAreaSize),
                    (teleportAreaSize + additinalTeleportAreaSize)
                )
            );
    
        if(
            // not close to object
            DistanceBetween(ep, CurrentObjectPosition()) > 8
                &&
            // Has line to target
            IsInLineOfSight(
                telPosNearTarget + PositionOffsetY1(),
                teleportPosition + PositionOffsetY1(),
                BarrierLOS.NoBarriersBlock)            
        ){
            break;
        }
        Wait(0.1, WaitBehavior.AbortWhenFalse);
        WaitUntilServerFree();
    }
    teleportPosition -= PositionOffset();
    return true;
}

define forceUpdateCommonPositionProb: 5;

Boolean SetTeleportPositionToCommonPosition()"SetTeleportPositionToCommonPosition"{
    // set telPosNearTarget at closest player from commonTeleportPosition
    define telPosNearTarget! = ClosestPlayerToComTelPos;
    if(telPosNearTarget == null){
        return false;
    }
    if(
        // invalid commonTeleportPosition
        commonTeleportPosition ==  0 ||
        // Probability
        ProbabilityTrue(forceUpdateCommonPositionProb) ||
        // has not line closest player from commonTeleportPosition
        !IsInLineOfSight(commonTeleportPosition, telPosNearTarget) ||                      
        // target inside teleport area
        DistanceBetween(commonTeleportPosition, telPosNearTarget) < teleportAreaSize 
    ){
        // new select common position
        // set teleport position to player around
        if(SetTeleportPositionToObjectAhead()){
            // save teleport position as common position
            commonTeleportPosition = teleportPosition;
        }
        else{
            // set teleport position from common position
            teleportPosition = commonTeleportPosition;
        }
    }
    else{
        // set teleport position from common position
        teleportPosition = commonTeleportPosition;
    }
    return true;
}

void TeleportWithEffect()"TeleportWithEffect"{
    // distribute serverload
    Wait(SlotOf(ep) * 0.1, WaitBehavior.AbortWhenFalse);
    // show pre teleport effect
    PlayTeleportEffect(true);
    // Teleport
    Teleport(ep, teleportPosition);
    // show teleport effect
    PlayTeleportEffect(false);
}

void PlayTeleportEffect(define isBefore!)"PlayTeleportEffect"{
    // if before teleport
    if(isBefore){
        // play teleport shadow of own
        PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, enemyColor, ep, 1);
        // play teleport shadow of dest
        PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, enemyColor, teleportPosition, 1);
        // wait for show teleport shadow of before
        Wait(0.4, WaitBehavior.IgnoreCondition);
    }
    else{
        // play teleport blast
        PlayEffect(AllPlayers(), PlayEffect.BadExplosion, enemyColor, ep, eachEffectTextSize);
    }
}

define forceActiveTeleport: 30;
define teleportToCommonPositionProb: 50;

define IsPlayerOnObject: ([] != AllPlayersOnObjective(playerTeam));
define IsEnemyOnObject: ([] != AllPlayersOnObjective(enemyTeam));

void HybridTeleport()"HybridTeleport"{
    if(
        // during Object attacks
        IsPlayerOnObject ||
        // probability
        ProbabilityTrue(forceActiveTeleport)
    ){
        if(
            // probability
            ProbabilityTrue(teleportToCommonPositionProb)
        ){
            if(SetTeleportPositionToCommonPosition()){
                TeleportWithEffect();
            }
        }
        else{
            if(SetTeleportPositionToObjectAhead()){
                TeleportWithEffect();
            }
        }
    }
    else{
        if(IsTeamOnDefense(TeamOf())){
            if(SetTeleportPositionToPlayerFront()){
                TeleportWithEffect();
            }
        }
        else{
            if(SetTeleportPositionToObjectArround()){
                TeleportWithEffect();
            }
        }
    }
}

rule: "EnemyBot/Teleport/teleportByRespawn"
Event.OngoingPlayer
if(
    IsGameInProgress() &&
    TeamOf() == enemyTeam &&
    IsAlive() &&
    IsInSpawnRoom()
){
    HybridTeleport();
    // failsafe
    Wait(3, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

rule: "EnemyBot/Teleport/teleportByEnemyNotFound"
Event.OngoingPlayer
if(
    IsGameInProgress() &&
    TeamOf() == enemyTeam &&
    IsAlive() &&
    !IsInSpawnRoom()
){
    for(define notHasLineSecond! = 0; notHasLineSecond < 3; notHasLineSecond ++){
        Wait(1, WaitBehavior.AbortWhenFalse);
        define hasTarget! = (actionState != ActionState.Non);
        define nearObject! = (DistanceBetween(ep, CurrentObjectPosition()) <= 20);
        if(
            !(      // not
                !hasTarget ||                       // not has target
                (!nearObject && IsPlayerOnObject)   // not near object on player attaking
            )
        ){
            // reset count up
            LoopIfConditionIsTrue();
        }
    }
    HybridTeleport();
    LoopIfConditionIsTrue();
}

rule: "EnemyBot/Teleport/clearCommonTeleportPosition"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    Attacker() == ep
){
    commonTeleportPosition = 0;
}

// TAG EnemyBot/EnemyAbility ----------
rule: "EnemyBot/EnemyAbility/shotCall"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    define interval! = (1 - (TotalObjectProgress() / 100)) * 50;
    Wait(RandomReal(interval, 40 + interval), WaitBehavior.AbortWhenFalse);
    dbgMsg("shotCall");
    
    define scList! = AllLivingPlayers(enemyTeam);
    define scDelay! = RandomReal(0, 1);
    for(define scLoopIndex! = 0; scLoopIndex < CountOf(scList); scLoopIndex ++){
        SetUltimateCharge(scList[scLoopIndex], 100);
        PressButton(scList[scLoopIndex], Button.Ultimate);
        Wait(scDelay, WaitBehavior.AbortWhenFalse);
    }
    LoopIfConditionIsTrue();
}

rule: "EnemyBot/EnemyAbility/rush"
Event.OngoingGlobal
if(
    IsGameInProgress() &&
    !IsOverTime()
){
    define interval! = (1 - (TotalObjectProgress() / 100)) * 50;
    Wait(RandomReal(interval, 40 + interval), WaitBehavior.AbortWhenFalse);
    dbgMsg("rush");
    
    Respawn(AllDeadPlayers(enemyTeam));
    LoopIfConditionIsTrue();
}

rule: "EnemyBot/EnemyAbility/combatTeleport"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsGameInProgress() &&
    IsAlive() &&
    enemyType == EnemyType.GiantBoss &&
    actionState == ActionState.Attack
){
    Wait(RandomReal(10, 20), WaitBehavior.AbortWhenFalse);
    // set teleport position to player around
    if(SetTeleportPositionToObjectAhead()){
        define telBeam!;
        // teleport with beam effect
        DestroyEffect(telBeam);
        telBeam = CreateBeamEffect(AllPlayers(),
            BeamType.BadBeam, Midpoint(EyePosition(), PositionOf()), teleportPosition,
            Color.Purple, EffectRev.VisibleToPositionAndRadius);
        TeleportWithEffect();
        DestroyEffect(telBeam);
    }
    LoopIfConditionIsTrue();
}

define OnPayloadPosition: PayloadPosition() + Vector(0, 4, 0);

rule: "EnemyBot/EnemyAbility/closeHopToPayload"
Event.OngoingPlayer
if(
    initCompleted &&
    TeamOf() == enemyTeam &&
    TotalObjectProgress() >= 95 &&
    IsAlive()
){
    if(
        IsPlayerOnObject &&
        IsOnGround() &&
        CountOf(AllPlayersOnObjective(enemyTeam)) <= NumberOfPlayers(enemyTeam) / 4 &&
        DistanceBetween(ep, OnPayloadPosition) >= 5.0
    ){
        PressButton(ep, Button.Jump);
        ApplyImpulse(ep, 
            VectorTowards(ep, OnPayloadPosition), 10,
            Relative.ToWorld, ContraryMotion.Cancel);
    }
    
    Wait(RandomReal(1.0, 1.5), WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/chargeUltimate ----------
rule: "EnemyBot/chargeUltimate"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    HasSpawned() &&
    enemyType != EnemyType.None &&
    !IsUsingUltimate()
){
    SetUltimateCharge(ep, UltimateChargePercent() + (100 / eachChargeUltInterval));
    WaitUpdateASecond();
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/SpawnInterval ----------
define showDeadEffectTime: 1.5;
playervar define confirmSpawnInterval!;

Number TotalObjectProgress()"TotalObjectProgress"{
    Number progress;

    if(!IsGameInProgress()){
        progress = 100;
    }
    else{
        define mode = CurrentGameMode();
        if(mode == GameMode.Assault){
            if(CurrentObjectNo() == 0){
                progress = (PointCapturePercentage() * 0.5);
            }
            else{
                progress = 50 + (PointCapturePercentage() * 0.5);
            }
        }
        else if(mode == GameMode.Escort){
            progress = PayloadProgressPercentage();
        }
        else if(mode == GameMode.Hybrid){
            if(CurrentObjectNo() == 0){
                progress = (PointCapturePercentage() * 0.3);
            }
            else{
                progress = 30 + (PayloadProgressPercentage() * 0.7);
            }
        }
        else{
            errLog("ERROR ON TotalObjectProgress");
        }
    }
    return progress;
}

globalvar define spawnTimeScale;

void UpdateEachSpawnInterval()"UpdateEachSpawnInterval"{
    confirmSpawnInterval = (eachMaxSpawnInterval - eachMinSpawnInterval);
    confirmSpawnInterval *= (1 - (TotalObjectProgress() / 100));
    confirmSpawnInterval += eachMinSpawnInterval;
    
    define diff = GameProgressDiff();
    if(50 <= diff){
        spawnTimeScale = 0.01;
    }
    else if(30 <= diff && diff < 50){
        spawnTimeScale = 0.25;
    }
    else if(10 <= diff && diff < 30){
        spawnTimeScale = 0.5;
    }
    else if(-10 <= diff && diff < 10){
        spawnTimeScale = 1.0;
    }
    else if(-30 <= diff && diff < -10){
        spawnTimeScale = 1.5;
    }
    else if(-50 <= diff && diff < -30){
        spawnTimeScale = 2.5;
    }
    else if(diff < -50){
        spawnTimeScale = 4.0;
    }
    confirmSpawnInterval *= spawnTimeScale;
    SetRespawnMaxTime(ep, confirmSpawnInterval + showDeadEffectTime);
}

Number GameProgressDiff()"GameProgressDiff"{
    Number prgDiff! = 0;
    Number objPrg! = RoundToInteger(TotalObjectProgress());  // MAX 100
    Number timePrg  = RoundToInteger(MatchTime() / 3.0);  // MAX 300
    timePrg = 100 - timePrg;
    prgDiff = objPrg - timePrg;
    return prgDiff;
}

rule: "EnemyBot/SpawnInterval/update"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.None
){
    UpdateEachSpawnInterval();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

rule: "EnemyBot/SpawnInterval/fastRespawnBySucide"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    Attacker() == ep
){
    Wait(showDeadEffectTime, WaitBehavior.AbortWhenFalse);
    Respawn();
}

// TAG EnemyBot/ReceivedDamage ----------
globalvar define confirmReceiveDamage!;

void UpdateEachReceivedDamage()"UpdateEachReceivedDamage"{
    // set base damage
    confirmReceiveDamage = 100;
    // apply team balance
    confirmReceiveDamage *= ConvertToBalancedValue(1.5, playerTeam);
    SetDamageReceived(AllPlayers(enemyTeam), confirmReceiveDamage);
}

rule: "EnemyBot/ReceivedDamage/update"
Event.OngoingGlobal
if(
    initCompleted
){
    UpdateEachReceivedDamage();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/DealtDamage ----------
playervar define confirmDealtDamage!;
globalvar define threatLevel!;
globalvar define autoTuneDmgDlt!;

define upTuneScale: 4.0;

rule: "EnemyBot/DealtDamage/upTune"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    Attacker() != ep
){
    if(enemyType == EnemyType.Minion){
        autoTuneDmgDlt += 0.01 * upTuneScale;
    }
    else if(enemyType == EnemyType.Elite){
        autoTuneDmgDlt += 0.03 * upTuneScale;
    }
    else if(enemyType == EnemyType.Boss){
        autoTuneDmgDlt += 0.09 * upTuneScale;
    }
    else if(enemyType == EnemyType.GiantBoss){
        autoTuneDmgDlt += 0.09 * upTuneScale;
    }
}

rule: "EnemyBot/DealtDamage/downTune"
Event.OnDeath
if(
    TeamOf() == playerTeam &&
    Attacker() != ep
){
    autoTuneDmgDlt -= 1.0;
}

void UpdateEachDealtDamage()"UpdateEachDealtDamage"{
    // set base damage
    confirmDealtDamage = WorkshopSettingReal("Enemy Bot Settings", "Base Deal Damage", 30, 0, 1000, 1);
    // apply team balance
    confirmDealtDamage /= ConvertToBalancedValue(1.5, playerTeam);
    // apply auto tune
    confirmDealtDamage += autoTuneDmgDlt;
        // set threat Level
        threatLevel = confirmDealtDamage;
    // apply enemy type scale
    confirmDealtDamage *= eachDealtDamageScale;
    SetDamageDealt(ep, confirmDealtDamage);
}

rule: "EnemyBot/DealtDamage/update"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.None
){
    UpdateEachDealtDamage();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/ObstIcon ----------
playervar define obstIcon;
define color: isBlink ? Color.Orange : Color.Yellow;

rule: "EnemyBot/ObstIcon/show"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    (
        IsPlayerOnObject &&
        IsOnObjective(ep)
    )
){
    DestroyIcon(obstIcon);
    obstIcon = CreateIcon(AllPlayers(playerTeam), ep, Icon.ExclamationMark,
        IconRev.PositionAndColor, color, true);
}

rule: "EnemyBot/ObstIcon/hide"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    !(
        IsPlayerOnObject &&
        IsOnObjective(ep)
    )
){
    DestroyIcon(obstIcon);
    obstIcon = 0;
}

globalvar define isBlink = false;

rule: "EnemyBot/ObstIcon/blinkColor"
Event.OngoingGlobal
if(
    initCompleted
){
    while(true){
        isBlink = !isBlink;
        Wait(0.15, WaitBehavior.AbortWhenFalse); 
    }
}

// TAG Debug ----------
rule: "Debug/defaultDebugMode"
Event.OngoingGlobal
if(
    initCompleted
){
    debugMode = DebugMode.SlowLevelOnly;
    DisableInspectorRecording();
    ShowDebugHud(HostPlayer());
}

rule: "Debug/changeDebugMode"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Jump) 
){
    // change debug mode
    WaitLongPressConfirm();
    if(debugMode == DebugMode.Non){
        debugMode = DebugMode.SlowLevelOnly;
    }
    else if(debugMode == DebugMode.SlowLevelOnly){
        debugMode = DebugMode.ShowParam;
    }
    else if(debugMode == DebugMode.ShowParam){
        debugMode = DebugMode.WithRecord;
    }
    else if(debugMode == DebugMode.WithRecord){
        debugMode = DebugMode.Non;
    }

    if(debugMode == DebugMode.Non){
        DisableInspectorRecording();
        HideDebugHud();
    }
    else if(debugMode == DebugMode.SlowLevelOnly){
        DisableInspectorRecording();
        HideDebugHud();
        ShowDebugHud(HostPlayer());
    }
    else if(debugMode == DebugMode.ShowParam){
        DisableInspectorRecording();
        HideDebugHud();
        ShowDebugHud(HostPlayer());
    }
    else if(debugMode == DebugMode.WithRecord){
        EnableInspectorRecording();
        HideDebugHud();
        ShowDebugHud(HostPlayer());
    }
}

define End(): CountOf(debugHudEntitys);
define botOfEnemyType(define enemyType!): FirstOf(FilteredArray(AllPlayers(enemyTeam), ae.enemyType == enemyType));
globalvar define debugHudEntitys!;

define isDebugMode: debugMode != DebugMode.Non;

// show debug icon and hud
void ShowDebugHud(define player!)"ShowDebugHud"{
    if(
        debugMode == DebugMode.ShowParam ||
        debugMode == DebugMode.WithRecord
    ){
        if(
            debugMode == DebugMode.WithRecord
        ){
            CreateHudText(player,
                null,
                null,
                "● is Recording",
                Location.Left, -1,
                Color.White, Color.White, Color.Red,
                HudTextRev.VisibleToAndString, Spectators.VisibleNever);
            debugHudEntitys[End()] = LastTextID();
        }

        /*
        CreateHudText(player,
            null,
            <"<0> <1>", "Regeneration Rate", regenRateTeam1>,
            null,
            Location.Left, -1,
            Color.White, Color.Blue, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(player,
            null,
            <"<0> RcvDmg <1> DltDmg <2> SpwItv <3> ChgUlt <4>", "Giant Boss Status",
                confirmReceiveDamage,
                botOfEnemyType(EnemyType.GiantBoss).confirmDealtDamage,
                botOfEnemyType(EnemyType.GiantBoss).confirmSpawnInterval,
                botOfEnemyType(EnemyType.GiantBoss).eachChargeUltInterval
            >,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(player,
            null,
            <"<0> RcvDmg <1> DltDmg <2> SpwItv <3> ChgUlt <4>", "Boss Status",
                confirmReceiveDamage,
                botOfEnemyType(EnemyType.Boss).confirmDealtDamage,
                botOfEnemyType(EnemyType.Boss).confirmSpawnInterval,
                botOfEnemyType(EnemyType.Boss).eachChargeUltInterval
            >,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(player,
            null,
            <"<0> RcvDmg <1> DltDmg <2> SpwItv <3> ChgUlt <4>", "Elite Status",
                confirmReceiveDamage,
                botOfEnemyType(EnemyType.Elite).confirmDealtDamage,
                botOfEnemyType(EnemyType.Elite).confirmSpawnInterval,
                botOfEnemyType(EnemyType.Elite).eachChargeUltInterval
            >,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(player,
            null,
            <"<0> RcvDmg <1> DltDmg <2> SpwItv <3> ChgUlt <4>", "Minion Status",
                confirmReceiveDamage,
                botOfEnemyType(EnemyType.Minion).confirmDealtDamage,
                botOfEnemyType(EnemyType.Minion).confirmSpawnInterval,
                botOfEnemyType(EnemyType.Minion).eachChargeUltInterval
            >,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(player,
            null,
            <"<0> <1>", "threat Level", threatLevel>,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "spawnTimeScale", spawnTimeScale>,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();
        */

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "autoTune", autoTuneDmgDlt>,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(player,
            null,
            <"<0> <1>", "Server Load", ServerLoad()>,
            null,
            Location.Left, -1,
            Color.White, Color.Orange, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();
    }
    
    if(
        debugMode == DebugMode.ShowParam ||
        debugMode == DebugMode.WithRecord
    ){
        CreateHudText(player,
            null,
            <"<0> <1>", "Server Load Average", ServerLoadAverage()>,
            null,
            Location.Left, -1,
            Color.White, Color.Orange, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(player,
            null,
            <"<0> <1>", "Server Load Peak", ServerLoadPeak()>,
            null,
            Location.Left, -1,
            Color.White, Color.Orange, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();
    }

        CreateHudText(player,
            null,
            <"<0> <1>", "game Logic Speed", gameLogicSpeed>,
            null,
            Location.Left, -1,
            Color.White, Color.Orange, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();
}

// Hide debug icon and hud
void HideDebugHud()"HideDebugHud"{
    for(gLoopIndex = 0; gLoopIndex < CountOf(debugHudEntitys); gLoopIndex ++){
        DestroyHudText(debugHudEntitys[gLoopIndex]);
    }
}

rule: "Debug/resetBotList"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    !IsButtonHeld(ep, Button.Reload) &&
    IsButtonHeld(ep, Button.Crouch)
){
    // Recalculate portal
    WaitLongPressConfirm();

    // play effect each enemy
    define list! = AllPlayers(enemyTeam);
    for(gLoopIndex = 0; gLoopIndex < CountOf(list); gLoopIndex ++){
        PlayEffect(AllPlayers(), PlayEffect.BadExplosion, enemyColor,
            list[gLoopIndex], list[gLoopIndex].eachEffectTextSize);
    }
    Wait(showDeadEffectTime * 2, WaitBehavior.IgnoreCondition);

    // create all bot
    someHero = RandomHero;
    CreateBotsByAssetList(assetList, enemyTeam);
}

rule: "Debug/increaseMatchTime"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Ability2)
){
    WaitLongPressConfirm();
    SetMatchTime(MatchTime() + 30);
    LoopIfConditionIsTrue();
}

rule: "Debug/decreaseMatchTime"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Ability1)
){
    WaitLongPressConfirm();
    SetMatchTime(MatchTime() - 30);
    LoopIfConditionIsTrue();
}
