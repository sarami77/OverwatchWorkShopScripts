import "EnemyRush.setting.json";
import "../Lib/Debug.del";
import "../Lib/Utility.del";
import "../Lib/ServerOverloadMeasures.del";
import "../Lib/Bot.del";
import "../Lib/Buddy.del";
import "../Lib/Vote.del";
import "../Lib/HeroMod.del";

// TAG Signature and infomation ----------
disabled rule: "[PVE] ENEMY RUSH ver.13.5 / Share code [V7PEF]. You allowed copy or modify code." -1 {}
disabled rule: "This script was generated by ItsDeltin/Overwatch-Script-To-Workshop. Check detail with https://github.com/ItsDeltin/Overwatch-Script-To-Workshop" -1 {}
disabled rule: "This original script was created by sarami77#1868. Check detail with https://github.com/sarami77/OverwatchWorkShopScripts" -1 {}

// TAG Initialize ----------
define humanTeam: Team.Team2;
define enemyTeam: Team.Team1;
define allTeam: Team.All;

globalvar define initCompleted!;

rule: "Initialize/initialize"
Event.OngoingGlobal
{
    // Stop records to reduce server load
    DisableInspectorRecording();

    // If run it right after loading the server, some scripts fail, so wait 3 seconds
    Wait(5, WaitBehavior.AbortWhenFalse);

    // show version and share code
    CreateHudText(AllPlayers(),
        null, "[PVE] ENEMY RUSH ver.13.5 / Share code [V7PEF]", null,
        Location.Left, -999,
        Color.White, Color.Gray, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleAlways);

    // Notify completion of init game setting and start game main logic
    initCompleted = true;
}

// TAG Round ----------
rule: "Round/shortenAssemblePhase"
Event.OngoingGlobal
if(
    IsAssemblingHeroes()
){
    SetMatchTime(40);

    // wait player join server
    Wait(10, WaitBehavior.AbortWhenFalse);
    
    if(
        // no human
        HumanPlayerNum(humanTeam) <= 0
            ||
        // host human only
        (
            // 1 human only
            HumanPlayerNum(humanTeam) == 1
                &&
            // human is host player
            hp ==
                FirstOf(
                    FilteredArray(
                        AllPlayers(humanTeam),
                        !IsDummyBot(ae)
                    )
                )
        )
    ){
        // shorten assemble phase
        SetMatchTime(0);
    }
}

rule: "Round/shortenSetupPhase"
Event.OngoingGlobal
if(
    IsInSetup()
){
    SetMatchTime(50);

    if(
        // no human
        HumanPlayerNum(humanTeam) <= 0
    ){
        // shorten setup phase
        SetMatchTime(3);
    }
}

// globalvar define matchTimeScale! = WorkshopSettingReal("Game Settings", "Match Time Scale", 1.0, 0.01, 100, 1);

// rule: "Round/AddMatchTime1"
// Event.OngoingGlobal
// if(
//     IsGameInProgress()
// ){
//     // default 300s
//     SetMatchTime((MatchTime() - 300) + (300 * matchTimeScale));
// }

// rule: "Round/AddMatchTime2"
// Event.OngoingGlobal
// if(
//     IsObjectiveComplete(0)
// ){
//     // default 180s
//     SetMatchTime((MatchTime() - 180) + (180 * matchTimeScale));
// }

// rule: "Round/AddMatchTime3"
// Event.OngoingGlobal
// if(
//     IsObjectiveComplete(1)
// ){
//     // default 120s
//     SetMatchTime((MatchTime() - 120) + (120 * matchTimeScale));
// }

// TAG TIPS ----------
// globalvar define tipsText!;
// rule: "TIPS/showTIPS"
// Event.OngoingGlobal
// if(
//     initCompleted
// ){
//     CreateInWorldText(AllPlayers(),
//         <"[TIPS]\n\r<0>", tipsText>,
//         SpawnPoints(humanTeam)[0] + Vector(0, 3, 0), 1.0,
//         Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString, Color.White, Spectators.VisibleAlways
//     );

//     while(true){
//         tipsText = RandomValueInArray([
//             /// valid until 120 character ___________________________________________________________________________________________|
//             // about spawn
//             "Enemy team often causes spawn rush.\n\rSpawn rate is maximized for a dozen seconds.\n\rBe careful not to get surrounded.",
//             "Enemy can spawn anywhere in player's line of sight.\n\r Watch arround, even if you on high ground or in enclosed areas.",
//             "Don't miss sound of enemies spawning.\n\r Sometimes enemies will surprise you from behind or sides.",
//             "Enemy bots try spawn to positions where can see directly player.\n\rIf player is not seem, will be retry positining.",
//             "Enemy bots spawn in groups from fixed locations,\n\rbut can be forced to change locations by player approaching.",
//             // about enemy
//             "Enemy team use ULTs combo just like human team.\n\rWatch out, combo attacks when hear enemy ULT calls in multiple.",
//             "Enemy team knows player's health.\n\rthey try attack low health player as team.\n\rremenber, this is PVE but not 1vs1.",
//             "Support heroes enemy bots has low fire power, but 2x deal heal.\n\rThe combo with boss-class is a threat.",
//             // about boss
//             "Boss-class enemies try continuously multiple use ULTs after cooldown.\n\rKeep watch even if stoped boss's ULT with stun.",
//             "Boss-class enemies teleport in combat for avoid danger or take map advantage.\n\rWatch trajectory to don't miss.",
//             "Boss-class enemies spawn at checkpoints for short time.\n\rAt final point, boss enemy spawn and must be defeated to win.",
//             // about bots
//             "Friend bots use mods just like human players.\n\r include Attack MODs, support MODs, etc, all mod.",
//             "Friend bots are not as well play as human players,\n\rbut they has buff of reduce damage taken 30%.",
//             "For reduce server load, BOT is bad at finding map abyss.\n\rThey sometime fall to abyss and instantly return.",
//             "Widowmaker Bot's headshot accuracy is already cheat-like,\n\rbut it becomes more perfect when using ULT. I reported!",
//             // about game difficulty
//             "The most popular game difficulty seems to be [EXPERT]...\n\rare you try more higher?",
//             "[HERO MUST DIE] has 3x enemy spawn rate as [NORMAL].\n\rdeal damage is 4x.\n\rcan try this?",
//             "When game difficulty changes, only enemy spawn rate and deal damage will change.\n\rMax health will not change.",
//             "If no one has voted for the game difficulty, [NORMAL] will be confirmed.",
//             "The higher game difficulty, the higher enemy's deal damage will be,\n\rso use tanks cover or wall more important.",
//             // about MOD
//             "The most popular MOD seems to be [TITAN FORM]...\n\rNow, hammer time!",
//             "Combo of extended ULT MODs incluide [SHOT CALL] is powerful,\n\rbut some MODs are not supported for game balance.",
//             "If you use [GUARD DOG] to well,\n\rcan powerfully stop even boss-class enemies.",
//             "[POWERFULL GIFT] is more powerful as more ult charge.\n\rcan fill up the teammate's ULT charge one after another.",
//             "Actually, [GUNSHIP GUNNER]'s NUKE CANON and [GRUDGE FIRE BALL] are the same attack.",
//             "[TITAN FORM] and [GUNSHIP GUNNER] are will get stuck in the map,\n\rif you don't think about where to use it.",
//             // about game system
//             "Equiped [Good Game] system.\n\rMonitor game progress and kill rates of both teams to create close matches as can.",
//             "Equiped [workshop settings].\n\rCan be customized using the GUI, enemy spaw rate, friend bots count, etc.",
//             "Even if no players are present,\n\rCan watch skirmishes of BOTs from the spectator."
//         ]);
//         Wait(20, WaitBehavior.IgnoreCondition);
//     }
// }

// TAG Object ----------
globalvar define prevObjectPosition;
globalvar define objectDirection;

define HasObjectDirection(): objectDirection != null;

rule: "Object/updateObjectDirection"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    Wait(0.1);  // wait object position change to enable
    prevObjectPosition = CurrentObjectPosition();

    while(true){
        define nowObjectPosition! = CurrentObjectPosition();
        if(
            IsTeamOnObject(humanTeam) &&
            nowObjectPosition != prevObjectPosition
        ){
            // update objectDirection
            objectDirection = DirectionTowards(prevObjectPosition, nowObjectPosition);
            // set prev position for next judge
            prevObjectPosition = nowObjectPosition;
        }

        WaitUpdateShortCycle();
    }
}

// TAG FinalStand ----------
globalvar define hasFinalStand! = true;

rule: "FinalStand/FinalStand"
Event.OngoingGlobal
if(
    IsGameInProgress() &&
    IsOverTime() &&
    hasFinalStand
){
    SetSlowMotion(10);
    Wait(0.2, WaitBehavior.IgnoreCondition);   // show slow

    // buff humanTeam player
    PlayEffectsToTeam(humanTeam);
    Heal(AllLivingPlayers(humanTeam), null, MaxValue());
    Resurrect(AllDeadPlayers(humanTeam));
    SetUltimateCharge(AllLivingPlayers(humanTeam), 100);
    BigMessage(AllPlayers(humanTeam), "Final Stand !");
    Wait(0.5, WaitBehavior.IgnoreCondition);   // show slow
    
    SetSlowMotion(DefaultPercentage());
    Wait(1, WaitBehavior.IgnoreCondition);
    
    CreateHudText(
        AllPlayers(humanTeam),
        null, null, "No next \"final stand\"", Location.Left, 999, null, null, cautionColor, HudTextRev.Color, Spectators.VisibleNever);
    hasFinalStand = false;
}

// TAG Player/Config ----------
rule: "Player/Config/init"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    HasSpawned()
){
    // set max respawn time
    define respawnTime! = 10 * WorkshopSettingReal("Player Settings", "Max Respawn Time Scale", 1.0, 0.0, 100, 1);
    define receiveDamage! = 100 * WorkshopSettingReal("Player Settings", "Receive Damage Scale_", 1.0, 0.0, 100, 2);

    if(!IsDummyBot()){
        // human player
        SetRespawnMaxTime(ep, respawnTime);
        SetDamageReceived(ep, receiveDamage);

        // show operation message
        Wait(5, WaitBehavior.IgnoreCondition);
        if(IsInSetup()){
            BigMessage(ep, "You can Choose game difficulty vote and hero mod." + NL + "Check top left of screen!");
            PlayEffect(ep, PlayEffect.BuffImpactSound, ep, null, MaxValue());
            WaitUntil(MatchTime() <= 10, 60);
            
            if(IsInSetup()){
                BigMessage(ep, "Already Choose game difficulty vote and hero mod?" + NL + "Are you ready?");
                PlayEffect(ep, PlayEffect.BuffImpactSound, ep, null, MaxValue());
            }
        }
        else{
            BigMessage(ep, "You can Choose hero mod." + NL + "Check top left of screen!");
            PlayEffect(ep, PlayEffect.BuffImpactSound, ep, null, MaxValue());
        }  
    }
    else{
        // dummy bot
        // respawn time 30% cut
        SetRespawnMaxTime(ep, respawnTime * 0.7);
        // receive damage 30% cut
        SetDamageReceived(ep, receiveDamage * 0.7);
    }
}

// TAG Player/HumanIcon ----------
playervar define humanIcon!;

define isHumanIconActive: 
    IsAlive();

rule: "Player/HumanIcon/show"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    HasSpawned() &&
    !IsDummyBot() &&
    isHumanIconActive
){
    // show human icon to human players for easy to find other human from human player
    DestroyIcon(humanIcon);
    humanIcon = CreateIcon(AllPlayers(), ep, Icon.Asterisk,
        IconRev.Position, Color.Team2, false);
}

rule: "Player/HumanIcon/hide"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    HasSpawned() &&
    !IsDummyBot() &&
    !isHumanIconActive
){
    DestroyIcon(humanIcon);
}

// TAG FriendBot/BotActive ----------
define canFriendBotBotActive:
    IsAlive();

rule: "FriendBot/BotActive/activate"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    canFriendBotBotActive
){
    isBotActive = true;
}

rule: "FriendBot/BotActive/deactive"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    !canFriendBotBotActive
){
    isBotActive = false;
}

// TAG FriendBot/Config ----------
rule: "FriendBot/Config/init"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    IsDummyBot() &&
    HasSpawned()
){
    watchUpdateRate = 1.0;
}

// TAG FriendBot/Asset ----------
globalvar define maxFriendBotBotNum! =
    WorkshopSettingInteger("Friend Bot Settings", "Bot Count (when player slot empty, join instead. will switch to player by join.)", 8, 0, 8, 1);

define pMax: maxFriendBotBotNum;

define friendBotAssetList:
    [
        // fix hero asset
        [   // assetNo 0
            // recommend
            [EnemyType.Non,     Hero.Mercy,      1],
            [EnemyType.Non,     Hero.Genji,      1],
            [EnemyType.Non,     Hero.Reinhardt,  1],
            [EnemyType.Non,     Hero.Ana,        1],
            [EnemyType.Non,     Hero.Hanzo,      1],
            [EnemyType.Non,     Hero.Mauga,      1],
            [EnemyType.Non,     Hero.Zenyatta,   1],
            [EnemyType.Non,     Hero.Soldier76,  1]
        ],
        [   // assetNo 1
            // recommend
            [EnemyType.Non,     Hero.Moira,      1],
            [EnemyType.Non,     Hero.Reaper,     1],
            [EnemyType.Non,     Hero.Ramattra,   1],
            [EnemyType.Non,     Hero.Baptiste,   1],
            [EnemyType.Non,     Hero.Sojourn,    1],
            [EnemyType.Non,     Hero.Mauga,      1],
            [EnemyType.Non,     Hero.Brigitte,   1],
            [EnemyType.Non,     Hero.Genji,      1]
        ],
        [   // assetNo 2
            // recommend
            [EnemyType.Non,     Hero.Illari,     1],
            [EnemyType.Non,     Hero.Sojourn,    1],
            [EnemyType.Non,     Hero.Ramattra,   1],
            [EnemyType.Non,     Hero.Lifeweaver, 1],
            [EnemyType.Non,     Hero.Ashe,       1],
            [EnemyType.Non,     Hero.Mauga,      1],
            [EnemyType.Non,     Hero.Kiriko,     1],
            [EnemyType.Non,     Hero.Cassidy,    1]
        ],
        // 3,4
        [],[],

        // random hero asset
        [
            // assetNo 5
            // random with fix role
            [EnemyType.Non,     RandomSupportHero(),  1],
            [EnemyType.Non,     RandomTankHero(),     1],
            [EnemyType.Non,     RandomDamageHero(),   1],
            [EnemyType.Non,     RandomSupportHero(),  1],
            [EnemyType.Non,     RandomTankHero(),     1],
            [EnemyType.Non,     RandomDamageHero(),   1],
            [EnemyType.Non,     RandomSupportHero(),  1],
            [EnemyType.Non,     RandomDamageHero(),   1]
        ],
        [
            // assetNo 6
            // random with non role
            [EnemyType.Non,     RandomHero(), 1],
            [EnemyType.Non,     RandomHero(), 1],
            [EnemyType.Non,     RandomHero(), 1],
            [EnemyType.Non,     RandomHero(), 1],
            [EnemyType.Non,     RandomHero(), 1],
            [EnemyType.Non,     RandomHero(), 1],
            [EnemyType.Non,     RandomHero(), 1],
            [EnemyType.Non,     RandomHero(), 1]
        ],
        [
            // assetNo 7
            // same hero
            [EnemyType.Non,     RandomSupportHero(), 1],
            [EnemyType.Non,     RandomSupportHero(), 1],
            [EnemyType.Non,     favSameHero,    pMax - 2]
        ]
    ];

define FriendBotAssetNoLotteryList: [
    // fix hero asset
    0,
    1,
    2,

    // random hero asset
    5, 5, 5, 5, 5,
    6, 6,
    7, 7
];

globalvar define isLockedCreateBotsByAsset! = false;

void WaitReleaseLockCreateBotsByAsset(){ 
    // can't implement as subroutin for mutex  
    for(define tryCount! = 0; tryCount < 10; tryCount ++){
        if(!isLockedCreateBotsByAsset){
            break;
        }
        Wait(1, WaitBehavior.IgnoreCondition);
    }
}

// TAG FriendBot/Asset/Interval ----------
define PlayerNum():
    CountOf(
        FilteredArray(
            AllPlayers(humanTeam),
            !IsDummyBot(ae)
        )
    );

define FriendBotNum():
    CountOf(
        FilteredArray(
            AllPlayers(humanTeam),
            IsDummyBot(ae)
        )
    );

define needFriendBotNum:
    maxFriendBotBotNum - PlayerNum();

globalvar define friendBotAssetNo!;

globalvar define forceReloadFriendBotAsset! = false;

define AssetChangeInterval(): RandomInteger(120, 180);
globalvar define reloadFriendBotAssetInterval! = -1;

rule: "FriendBot/BotAssetInterval/reloadReloadFriendBotAsset"
Event.OngoingGlobal
if(
    initCompleted
){
    while(true){
        // if force reload, skip change assetNo and set interval
        if(!forceReloadFriendBotAsset){
            // choice asset by random
            friendBotAssetNo = RandomValueInArray(FriendBotAssetNoLotteryList);
            // set default interval
            reloadFriendBotAssetInterval = AssetChangeInterval();
            // reload random hero
            allSameHero = RandomHero();
            favSameHero = RandomValueInArray([
                RandomDamageHero(),
                RandomTankHero()
            ]);
        }

        // get asset
        define asset! = friendBotAssetList[friendBotAssetNo];

        // valid asset
        if(
            0 < CountOf(asset)
        ){
            // save avg ult charge of bots before reload asset
            define ultCharge! = GetAvgUltChgOfDummyBot(humanTeam);
            // reload bots by asset
            WaitReleaseLockCreateBotsByAsset();
            isLockedCreateBotsByAsset = true;
            DestroyBots(humanTeam);
            CreateBotsByAsset(asset, humanTeam, needFriendBotNum);
            isLockedCreateBotsByAsset = false;
            // restore avg ult charge of bots
            SetAvgUltChgOfDummyBot(humanTeam, ultCharge);
            // wait start intarval until game start.
            WaitUntil(IsGameInProgress() || forceReloadFriendBotAsset, MaxValue());
            // release force reload flag
            forceReloadFriendBotAsset = false;

            for(
                ;
                reloadFriendBotAssetInterval > 0;
                reloadFriendBotAssetInterval--
            ){
                Wait(1, WaitBehavior.IgnoreCondition);
                if(
                    // interrupt force reload
                    forceReloadFriendBotAsset ||
                    // create bot error
                    0 >= NumberOfPlayers(humanTeam)
                ){
                    break;
                }
            }
        }
        else{
            errLog(<"friendBotAssetNo is invalid">);
        }

        // avoid infite loop clash
        Wait(1, WaitBehavior.IgnoreCondition);
    }
}

rule: "FriendBot/tuneAssetMemberNum"
Event.OngoingGlobal
if(
    initCompleted
){
    define prevPlayerNum! = -1;

    // set initial asset no
    friendBotAssetNo = RandomValueInArray(FriendBotAssetNoLotteryList);

    while(true){
        if(
            // create bot not locked
            !isLockedCreateBotsByAsset &&
            (
                // playerNum changed
                prevPlayerNum != PlayerNum() ||
                // not filed by need FriendBot number
                FriendBotNum() != needFriendBotNum ||
                // entity num than over slot num
                PlayerNum() + FriendBotNum() > NumberOfSlots(humanTeam)
            )
        ){
            // save current playerNum
            prevPlayerNum = PlayerNum();
            // force reload asset
            forceReloadFriendBotAsset = true;
        }

        // check Interval
        WaitUpdateLongCycle();
    }
}

// TAG EnemyBot/BotActive ----------
define canEnemyBotActive:
    IsAlive() &&
    !IsInSpawnRoom();

rule: "EnemyBot/BotActive/activate"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    canEnemyBotActive    
){
    define closePlayer! = ClosestPlayerTo(ep, EnemyTeamOf(ep));
    SetFacing(ep, DirectionTowards(EyePosition(), EyePosition(closePlayer)));

    if(
        // has damage
        NormalizedHealth() < 1.0 ||
        // has line of close player
        IsInLineOfSight(
            EyePosition(),
            EyePosition(closePlayer))
    ){
        // start bot
        isBotActive = true;
        Abort();
    }
    Wait(0.5, WaitBehavior.IgnoreCondition);
    LoopIfConditionIsTrue();
}

rule: "EnemyBot/BotActive/deactive"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    !canEnemyBotActive
){
    // stop bot for reduce server load
    isBotActive = false;
}

// TAG EnemyBot/Config ----------
define spawnTimeBase: 10;
define spawnTimeEachLevel:
    confirmGameDifficulty == GameDifficulty.EASY ?      spawnTimeBase * 1.0 :
    confirmGameDifficulty == GameDifficulty.NORMAL ?    spawnTimeBase * 0.9 :  //-0.1
    confirmGameDifficulty == GameDifficulty.HARD ?      spawnTimeBase * 0.8 :  //-0.1
    confirmGameDifficulty == GameDifficulty.EXPERT ?    spawnTimeBase * 0.7 :  //-0.1
    confirmGameDifficulty == GameDifficulty.LEGENDARY ? spawnTimeBase * 0.5 :  //-0.2
    confirmGameDifficulty == GameDifficulty.INSANITY ?  spawnTimeBase * 0.3 :  //-0.2
                                                        spawnTimeBase * 1.0 ;

define damageDealtBase: 50;
define damageDealtEachLevel:
    confirmGameDifficulty == GameDifficulty.EASY ?      damageDealtBase * 1.0  :
    confirmGameDifficulty == GameDifficulty.NORMAL ?    damageDealtBase * 1.2  :    //+0.2
    confirmGameDifficulty == GameDifficulty.HARD ?      damageDealtBase * 1.4  :    //+0.2
    confirmGameDifficulty == GameDifficulty.EXPERT ?    damageDealtBase * 1.6  :    //+0.2
    confirmGameDifficulty == GameDifficulty.LEGENDARY ? damageDealtBase * 2.0  :    //+0.4
    confirmGameDifficulty == GameDifficulty.INSANITY ?  damageDealtBase * 2.4  :    //+0.4
                                                        damageDealtBase ;

define enemyTeamColor: Color.Team1;
define humanTeamColor: Color.Team2;

define IsBossClass(in define player):
    player.enemyType == EnemyType.SubBoss ||
    player.enemyType == EnemyType.Boss;

playervar define damageDealt!;
playervar define spawnTime!;
playervar define chargeUltInterval!;

rule: "EnemyBot/Config/update"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    enemyType != EnemyType.Non &&
    confirmGameDifficulty != GameDifficulty.NO_VOTE &&
    IsGameInProgress()
){
    // disable builtin respawn for avoid auto teamup
    DisableRespawning();
    // disable retreat cuz enemy bot
    enableRetreat = false;

    define name!;
    define scale!;
    define voiceLine!;
    define maxHealth!;
    define healReceived!;
    define healDealt!;
    define moveSpeed!;
    define jumpSpeed!;
    define gravity!;
    define addArmor!;
    define addShield!;

    // init config by enemy type
    // comon config
    moveSpeed =         100;
    jumpSpeed =         100;
    gravity =           100;
    
    // each type config
    if(enemyType == EnemyType.Minion){
        // fixed config
        name =              "Minion";
        watchUpdateRate =   5;
        chargeUltInterval = 60;

        scale =             0.7;
        voiceLine =         1.5;
        maxHealth =         50;
        healReceived =      50;
        healDealt =         50;

        // scalable config by update function
        spawnTime =         1.0;
        damageDealt =       50;
    }
    else if(enemyType == EnemyType.Elite){
        // fixed config
        name =              "Elite";
        watchUpdateRate =   3;
        chargeUltInterval = 30;

        scale =             1.0;
        voiceLine =         1.0;
        maxHealth =         150;
        healReceived =      150;
        healDealt =         150;

        // scalable config by update function
        spawnTime =         2.0;
        damageDealt =       100;
    }
    else if(enemyType == EnemyType.SubBoss){
        // fixed config
        name =              "Sub-Boss";
        watchUpdateRate =   1;
        chargeUltInterval = 15;

        scale =             1.5;
        voiceLine =         0.5;
        maxHealth =         600;
        healReceived =      200;
        healDealt =         200;

        // scalable config by update function
        spawnTime =         4.0;
        damageDealt =       150;
    }
    else if(enemyType == EnemyType.Boss){
        // fixed config
        name =              "Boss";
        watchUpdateRate =   1;
        chargeUltInterval = 15;

        scale =             2.5;
        voiceLine =         0.1;
        maxHealth =         1000;
        healReceived =      200;
        healDealt =         200;
        addArmor =          20;
        addShield =         20;

        // scalable config by update function
        spawnTime =         6.0;
        damageDealt =       150;
    }

    // if support hero, multi deal heal
    healDealt *= IsSupportHero(HeroOf()) ? 2.0 : 1.0;

    // set mod
    enemyModType = RandomValueInArray(enemyModList[enemyModNo]);

    // set float text
    if(enemyModType == EnemyModType.Health){
        name = <"<0> endurer", name>;
        maxHealth   *= 1.5;
        moveSpeed   *= 0.5;
    }
    else if(enemyModType == EnemyModType.Damage){
        name = <"<0> damager", name>;
        damageDealt *= 1.5;
        maxHealth   *= 0.5;
    }
    else if(enemyModType == EnemyModType.Speed){
        name = <"<0> runner", name>;
        moveSpeed   *= 2.0;
        damageDealt *= 0.5;
    }        
    else if(enemyModType == EnemyModType.Jump){
        name = <"<0> jumper", name>;
        jumpSpeed   *= 3.0;
        moveSpeed   *= 0.5;
    }
    else if(enemyModType == EnemyModType.Flying){
        name = <"<0> flyer", name>;
        gravity     *= 0.01;
        moveSpeed   *= 0.5;
    }
    else if(enemyModType == EnemyModType.Explosion){
        name = <"<0> exploder", name>;
        // explode self when dead
        maxHealth   *= 0.5;
    }
    else if(enemyModType == EnemyModType.Freeze){
        name = <"<0> freezer", name>;
        // freeze enemy when encount
        maxHealth   *= 0.5;
        damageDealt *= 0.1;
    }

    // set param
    StartForcingDummyBotName(ep, name);
    StartScalingPlayer(ep, scale, false);
    StartModifyingHeroVoiceLines(ep, voiceLine, false);
    SetMaxHealth(ep, maxHealth);
    SetHealingReceived(ep, healReceived);
    SetHealingDealt(ep, healDealt);
    SetMoveSpeed(ep, moveSpeed);
    SetJumpVerticalSpeed(ep, jumpSpeed);
    SetGravity(ep, gravity);

    // wait max health change finish
    Wait(0.1, WaitBehavior.IgnoreCondition);

    // add health pool
    if(addArmor != null){
        AddHealthPoolToPlayer(ep, HealthType.Armor, MaxHealth() * addArmor / DefaultPercentage(), true, false);
    }
    if(addShield != null){
        AddHealthPoolToPlayer(ep, HealthType.Shields, MaxHealth() * addShield / DefaultPercentage(), true, false);
    }

    // wait max health change finish
    Wait(0.1, WaitBehavior.IgnoreCondition);

    // heal to max
    while(NormalizedHealth() < 1.0){
        Heal(ep, null, MaxValue());
        Wait(0.1, WaitBehavior.IgnoreCondition);
    }

    while(true){
        // update scalable config
        UpdateEachSpawnInterval();
        UpdateEachDealtDamage();
        WaitUpdateLongCycle();
    }
}

// TAG EnemyBot/Config/SpawnInterval ----------
define showDeadEffectTime: 1.0;
playervar define confirmSpawnTime;

rule: "EnemyBot/Config/SpawnInterval/waitingRespawn"
Event.OnDeath
if(
    TeamOf() == enemyTeam
){
    // wait for show dead effect
    Wait(showDeadEffectTime, WaitBehavior.AbortWhenFalse);
    // if sucide, skip wait timer
    if(Attacker() != ep){
        // wait for respawn by each timer
        Wait(confirmSpawnTime, WaitBehavior.AbortWhenFalse);
    }
    // respawn
    if(IsDead()){
        Respawn();
    }
}

globalvar define spawnTimeScale;

void UpdateEachSpawnInterval()"UpdateEachSpawnInterval"{
    // tune enemy spawen interval for make close match
    define diff! = GameProgressDiff(humanTeam);

    // tune interval by game progress diff
    if(70 <= diff){
        spawnTimeScale = 0;
    }
    else if(40 <= diff && diff < 70){
        spawnTimeScale = 0.25;
    }
    else if(10 <= diff && diff < 40){
        spawnTimeScale = 0.5;
    }
    // team even, default enemy respawn
    else if(-10 <= diff && diff < 10){
        spawnTimeScale = 1.0;
    }
    // enemy team advantage, slow enemy respawn
    else if(-40 <= diff && diff < -10){
        spawnTimeScale = 1.5;
    }
    else if(-70 <= diff && diff < -40){
        spawnTimeScale = 2.0;
    }
    else if(diff < -70){
        spawnTimeScale = 3.0;
    }

    // set spawn time
    confirmSpawnTime = spawnTimeEachLevel;
    // apply enemy type scale
    confirmSpawnTime *= spawnTime;
    // apply setting scale
    confirmSpawnTime *= WorkshopSettingReal("Enemy Bot Settings", "Basic Spawn Intarval Scale", 1.0, 0.0, 100, 3);
    // apply tune scale
    confirmSpawnTime *= spawnTimeScale;
}

// TAG EnemyBot/Config/DealtDamage ----------
playervar define confirmDealtDamage;

void UpdateEachDealtDamage()"UpdateEachDealtDamage"{
    // set deal damage
    confirmDealtDamage = damageDealtEachLevel;
    // apply enemy type scale
    confirmDealtDamage *= (damageDealt / DefaultPercentage());
    // apply setting scale
    confirmDealtDamage *= WorkshopSettingReal("Enemy Bot Settings", "Deal Damage Scale", 1.0, 0.0, 100, 1);
    // apply team balance
    confirmDealtDamage /= ConvertToBalancedValue(1.5, humanTeam);
    SetDamageDealt(ep, confirmDealtDamage);
}

// TAG EnemyBot/Config/ReceivedDamage ----------
globalvar define confirmReceiveDamage;

rule: "EnemyBot/Config/ReceivedDamage/update"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    while(true){
        UpdateGlobalReceivedDamage();
        WaitUpdateLongCycle();
    }
}

void UpdateGlobalReceivedDamage()"UpdateGlobalReceivedDamage"{
    // set receive damage
    confirmReceiveDamage = DefaultPercentage();
    // apply team balance
    confirmReceiveDamage *= ConvertToBalancedValue(1.5, humanTeam);
    // apply workshop setting
    confirmReceiveDamage *= WorkshopSettingReal("Enemy Bot Settings", "Receive Damage Scale", 1.0, 0.0, 100, 2);

    SetDamageReceived(AllPlayers(enemyTeam), confirmReceiveDamage);
}

// TAG EnemyBot/Config/ChargeUltimate ----------
rule: "EnemyBot/ChargeUltimate/charge"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.Non &&
    IsGameInProgress() &&
    !IsUsingUltimate()
){
    SetUltimateCharge(ep, UltimateChargePercent() + (DefaultPercentage() / chargeUltInterval));
    WaitUpdateShortCycle();
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/Asset ----------
globalvar define maxCreateEnemyBotNum! = 
    WorkshopSettingInteger("Enemy Bot Settings", "Bot Count (! when too many BOTs, may reduce game performance and stability.)", 8, 0, 16, 0);

define eMax: maxCreateEnemyBotNum;

globalvar define allSameHero!;
globalvar define favSameHero!;

define enemyAssetList:
    [
        // random hero asset
        [   
            // assetNo 0
            // basic
            [EnemyType.SubBoss,     RandomHero(),           1],
            [EnemyType.Elite,       RandomHero(),           eMax / 2 - 1],
            [EnemyType.Minion,      RandomHero(),           eMax / 2]
        ],
        [   
            // assetNo 1
            // sub boss and minion
            [EnemyType.SubBoss,     RandomHero(),           1],
            [EnemyType.Minion,      RandomHero(),           eMax]
        ],
        [   
            // assetNo 2
            // all elite
            [EnemyType.Elite,       RandomHero(),           eMax / 3],
            [EnemyType.Elite,       RandomHero(),           eMax / 3],
            [EnemyType.Elite,       RandomHero(),           eMax / 3]
        ],
        [   
            // assetNo 3
            // all elites same hero
            [EnemyType.Elite,       allSameHero,            eMax]
        ],
        [   
            // assetNo 4
            // half elite
            [EnemyType.Elite,       RandomHero(),           eMax / 2],
            [EnemyType.Minion,      RandomHero(),           eMax / 2]
        ],
        [   
            // assetNo 5
            // all minion
            [EnemyType.Minion,      rva([
                                        RandomDamageHero(),
                                        RandomTankHero()
                                    ]),                     eMax]
        ],
        [   
            // assetNo 6
            // double sub boss
            [EnemyType.SubBoss,     RandomHero(),           1],
            [EnemyType.SubBoss,     RandomHero(),           1],
            [EnemyType.Minion,      RandomHero(),           eMax - 2]
        ],
        [   
            // assetNo 7
            // sub bosses
            [EnemyType.SubBoss,     RandomHero(),           1],
            [EnemyType.SubBoss,     RandomHero(),           1],
            [EnemyType.SubBoss,     RandomHero(),           eMax / 8]
        ],
        [   
            // assetNo 8
            // damage boss with minion
            [EnemyType.Boss,        RandomDamageHero(),     1],
            [EnemyType.Minion,      RandomHero(),           eMax - 1]
        ],
        [
            // assetNo 9
            // fav sameHero
            [EnemyType.SubBoss,     favSameHero,            1],
            [EnemyType.Elite,       favSameHero,            eMax / 2 - 1],
            [EnemyType.Minion,      favSameHero,            eMax / 2]
        ],
        [
            // assetNo 10
            // snipers
            [EnemyType.Boss,        Hero.Widowmaker,        1],
            [EnemyType.SubBoss,     Hero.Widowmaker,        3],
            [EnemyType.Elite,       RandomTankHero(),       eMax - 4]
        ],
        [
            // assetNo 11
            // reins
            [EnemyType.SubBoss,     Hero.Reinhardt,         1],
            [EnemyType.Elite,       Hero.Reinhardt,         eMax / 2 - 1],
            [EnemyType.Minion,      Hero.Reinhardt,         eMax / 2]
        ],
        [
            // assetNo 12
            // bast and reins
            [EnemyType.SubBoss,     Hero.Reinhardt,         1],
            [EnemyType.Elite,       Hero.Bastion,           eMax / 2 - 1],
            [EnemyType.Minion,      Hero.Bastion,           eMax / 2]
        ],
        [
            // assetNo 13
            // hog and sol
            [EnemyType.SubBoss,     Hero.Roadhog,            1],
            [EnemyType.Elite,       Hero.Soldier76,         eMax / 2 - 1],
            [EnemyType.Minion,      Hero.Soldier76,         eMax / 2]
        ],
        //  
        [
            // assetNo 14
            // hog and oris
            [EnemyType.SubBoss,     Hero.Roadhog,         1],
            [EnemyType.Elite,       Hero.Orisa,           eMax / 2 - 1],
            [EnemyType.Minion,      Hero.Orisa,           eMax / 2]
        ],
        // 15,16,17,18,19
        [],[],[],[],[],
        // progress asset
        [
            // assetNo 20
            // damage boss
            [EnemyType.Boss,        RandomDamageHero(),     1],
            [EnemyType.Elite,       RandomHero(),           eMax / 2 - 1],
            [EnemyType.Minion,      RandomHero(),           eMax / 2]
        ],
        [
            // assetNo 21
            // damage boss with tank elite
            [EnemyType.Boss,        RandomDamageHero(),     1],
            [EnemyType.Elite,       RandomTankHero(),       eMax / 2 - 1],
            [EnemyType.Minion,      RandomHero(),           eMax / 2]
        ],
        [
            // assetNo 22
            // tank boss
            [EnemyType.Boss,        FavoriteTankHero(),     1],
            [EnemyType.Elite,       RandomDamageHero(),     eMax / 2 - 1],
            [EnemyType.Minion,      RandomHero(),           eMax / 2]
        ],
        [
            // assetNo 23
            // double damage boss
            [EnemyType.Boss,        RandomDamageHero(),   1],
            [EnemyType.Boss,        RandomDamageHero(),   1],
            [EnemyType.Minion,      RandomHero(),           eMax - 2]
        ],
        //  24,25,26,27,28,29,
            [],[],[],[],[],[],

        [
            // assetNo 30
            // debug
            [EnemyType.Elite,       Hero.Reinhardt,         eMax]
        ]
    ];

define enemyAssetNoLotteryList: [
    // basic
    0, 0,
    // sub boss and minion 
    1, 1,
    // all elite
    2, 2,
    // all elites same hero 
    3, 3,
    // half elite
    4, 4,
    // all minion
    5, 
    // double sub boss
    6, 6,
    // triple sub boss
    7, 
    // damage boss with minion
    8,
    // fav sameHero
    9,
    // snipers
    10,
    // reins
    11,11,
    // bast and reins
    12,12,
    // hog and sol
    13,13,
    // hog and oris
    14,14
];


// TAG EnemyBot/Asset/Interval ----------
globalvar define reloadEnemyAssetInterval! = -1;
globalvar define enemyAssetNo! = -1;
globalvar define forceReloadEnemyAsset! = false;

define IsInPreLoadAssetTime():
    (
        (
            IsInSetup() &&
            MatchTime() <= 5
        ) ||
        IsGameInProgress()
    );

rule: "EnemyBot/Asset/Interval/reloadReloadEnemyAsset"
Event.OngoingGlobal
if(
    IsInPreLoadAssetTime()
){
    while(true){
        // if force reload, skip change assetNo and set interval
        if(!forceReloadEnemyAsset){
            // choice asset by random
            enemyAssetNo = RandomValueInArray(enemyAssetNoLotteryList);
            // set default interval
            reloadEnemyAssetInterval = AssetChangeInterval();
            // reload random hero
            allSameHero = RandomHero();
            favSameHero = RandomValueInArray([
                RandomDamageHero(),
                RandomTankHero()
            ]);
        }

        // choice mod by random 
        enemyModNo = RandomValueInArray(enemyModNoLotteryList);

        // get asset
        define asset! = enemyAssetList[enemyAssetNo];

        // valid asset
        if(
            0 < CountOf(asset)
        ){
            // play effect at all enemy
            PlayEffectsToTeam(enemyTeam);
            // reload bots by asset
            WaitReleaseLockCreateBotsByAsset();
            isLockedCreateBotsByAsset = true;
            DestroyBots(enemyTeam);
            CreateBotsByAsset(asset, enemyTeam, maxCreateEnemyBotNum);
            isLockedCreateBotsByAsset = false;
            // release force reload flag
            forceReloadEnemyAsset = false;

            for(
                ;
                // if hasProgressAssetNo, skip interval count and reload asset instanty
                reloadEnemyAssetInterval > 0;
                reloadEnemyAssetInterval--
            ){
                Wait(1, WaitBehavior.IgnoreCondition);
                if(
                    // interrupt force reload
                    forceReloadEnemyAsset ||
                    // create bot error
                    0 >= NumberOfPlayers(enemyTeam)
                ){
                    break;
                }
            }
        }
        else{
            errLog(<"enemyAssetNo is invalid">);
        }
        
        // avoid infite loop clash
        Wait(1, WaitBehavior.IgnoreCondition);
    }
}

rule: "EnemyBot/Asset/Interval/reloadBotAssetIntervalByProgress"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    define progressStage! = 0;

    while(true){
        define progress! = ObjectProgress(humanTeam);
        define progressAssetNo! = -1;
        define progressAssetInterval!;

        if(
            progressStage == 0 && progress >= 10
        ){
            if(!HasObjectDirection()){
                spawnRushInterval = 0;
            }
            progressStage ++;
        }
        else if(
            progressStage == 1 && progress >= 20
        ){
            if(!HasObjectDirection()){
                spawnRushInterval = 0;
            }
            progressStage ++;
        }
        else if(
            progressStage == 2 && progress >= 30
        ){
            progressAssetNo = 20;
            progressAssetInterval = (AssetChangeInterval() - 60);
            progressStage ++;
        }
        else if(
            progressStage == 3 && progress >= 60
        ){
            progressAssetNo = 21;
            progressAssetInterval = (AssetChangeInterval() - 60);
            progressStage ++;
        }
        else if(
            progressStage == 4 && progress >= (FinalWaveProgress())
        ){
            spawnRushInterval = 0;
            progressAssetNo = RandomValueInArray([22, 23]);
            progressAssetInterval = MaxValue();
            progressStage ++;
        }

        // has progress asset
        if(progressAssetNo != -1){
            // set assetNo from progress asset
            // set interval from progress asset interval
            enemyAssetNo = progressAssetNo;
            reloadEnemyAssetInterval = progressAssetInterval;
            // force reload asset
            forceReloadEnemyAsset = true;
        }

        // check Interval
        WaitUpdateMediumCycle();
    }
}

void PlayEffectsToTeam(define team!) "PlayEffectsToTeam"{
    define players! = AllPlayers(team);
    for(define playersIndex! = 0; playersIndex < CountOf(players); playersIndex ++){
        // play blast
        PlayEffect(
            AllPlayers(), PlayEffect.GoodPickupEffect,
            TeamOf(players[playersIndex]) == enemyTeam ?
                enemyTeamColor :
                Color.Yellow,
            players[playersIndex],
            1
        );
    }
    Wait(0.1, WaitBehavior.IgnoreCondition);
}

// TAG EnemyBot/Mod ----------
playervar define enemyModType!;

enum EnemyModType{
    Non,
    Health,
    Damage,
    Speed,
    Jump,
    Flying,
    Explosion,
    Freeze
}

globalvar define enemyModNo!;

define enemyModList:
    [
        [
            // modNo 0
            EnemyModType.Non,
            EnemyModType.Non,
            EnemyModType.Non,
            EnemyModType.Non,
            EnemyModType.Non,
            EnemyModType.Non,
            EnemyModType.Health,
            EnemyModType.Damage,
            EnemyModType.Speed,
            EnemyModType.Jump,
            EnemyModType.Flying,
            EnemyModType.Explosion,
            EnemyModType.Freeze
        ],
        [
            // modNo 1
            EnemyModType.Non,
            EnemyModType.Health,
            EnemyModType.Damage,
            EnemyModType.Speed,
            EnemyModType.Jump,
            EnemyModType.Flying,
            EnemyModType.Explosion,
            EnemyModType.Freeze
        ],
        [
            // modNo 2
            EnemyModType.Health
        ],
        [
            // modNo 3
            EnemyModType.Speed
        ],
        [
            // modNo 4
            EnemyModType.Jump
        ],
        [
            // modNo 5
            EnemyModType.Flying
        ],
        [
            // modNo 6
            EnemyModType.Explosion
        ],
        [
            // modNo 7
            EnemyModType.Freeze
        ]
    ];

define enemyModNoLotteryList: [
    // basic
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    // all mod
    1, 1, 1, 1, 1,
    // all healthj
    2,
    // all speed
    3,
    // al jump
    4,
    // all flying
    5,
    // all explosion
    6
    // all freezer
    // 7
];

// TAG EnemyBot/Mod/Fly ----------
rule: "EnemyBot/Mod/Fly"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyModType == EnemyModType.Flying &&
    IsAlive()
){
    if(aimTarget != null){
        define distToTarget! = DistanceBetween(ep, aimTarget);
        define flyDir!;
        define force!;

        // front/back
        if(
            // target is close
            distToTarget < actionRangeMin
        ){
            flyDir = DirectionTowards(ep, aimTarget) * -1;
            force = actionRangeMin - distToTarget;
        }
        else if(
            // target is far
            distToTarget > actionRangeMax
        ){
            flyDir = DirectionTowards(ep, aimTarget);
            force = distToTarget - actionRangeMin;
        }

        if(
            flyDir != 0
        ){
            ApplyImpulse(ep, flyDir, force * 0.8,
                Relative.ToWorld, ContraryMotion.Cancel);
        }
    }

    Wait(3, WaitBehavior.AbortWhenFalse);
    WaitUntilServerLoadLimitRelease();
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/Mod/Explosion ----------
define bombScale : 
    enemyType == EnemyType.Minion ?     2 :
    enemyType == EnemyType.Elite ?      4 :
    enemyType == EnemyType.SubBoss ?    6 :
    enemyType == EnemyType.Boss ?       6 :
    0;

rule: "EnemyBot/Mod/Explosion"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    enemyModType == EnemyModType.Explosion
){
    define bombSize! =      bombScale * 0.2;
    define blastRange! =    bombScale * 1.2;
    define blastDamage! =   bombScale * 100;
    define bombPos! = PositionOf() + Vector(0, 0.2, 0);
    define bombIcon! = CreateIcon(AllPlayers(humanTeam), bombPos, Icon.Warning, IconRev.VisibleToAndColor, cautionColor, true);
    define bombEfct! = CreateEffect(ap(ta), Effect.Sphere, cautionColor, bombPos, bombSize, EffectRev.Color);

    for(define index! = 0; index < 3; index++){
        PlayEffect(ap(ta), PlayEffect.RingExplosion, Color.Yellow, bombPos, blastRange * 2);
        PlayEffect(ap(ta), PlayEffect.DebuffImpactSound, null, bombPos, 75);
        Wait(1.0, WaitBehavior.IgnoreCondition);
    }

    define targets! = PlayersWithinRadius(bombPos, blastRange, humanTeam, RadiusLOS.SurfacesAndAllBarriers);
    ApplyBlastImpulse(targets, bombPos, blastRange, 4);
    SetStatus(targets, ep, Status.Burning, 3);
    Damage(targets, ep, blastDamage / 2);
    StartDamageOverTime(targets, ep, 3, blastDamage / 2);
    PlayContinuousBlast(Color.Red, bombPos, blastRange, bombScale, bombScale);
    DestroyIcon(bombIcon);
    DestroyEffect(bombEfct);
}

// TAG EnemyBot/Mod/Freeze ----------
define freezeSecond :
    enemyType == EnemyType.Minion ?     4 :
    enemyType == EnemyType.Elite ?      6 :
    enemyType == EnemyType.SubBoss ?    8 :
    enemyType == EnemyType.Boss ?       8 :
    0;

rule: "EnemyBot/Mod/Freeze"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyModType == EnemyModType.Freeze &&
    IsAlive(ep) &&
    actionState == ActionState.Attack
){
    define target!;
    
    while(true){
        if(
            aimTarget != null &&
            IsAlive(aimTarget) &&
            IsOnGround(aimTarget)
        ){
            target = aimTarget;
            break;
        }
        Wait(1.0, WaitBehavior.AbortWhenFalse);
    }

    define icon! = CreateIcon(AllPlayers(humanTeam), target, Icon.ExclamationMark, IconRev.VisibleToAndColor, cautionColor, true);
    define effect! = CreateEffect(AllPlayers(humanTeam), Effect.BadAura, Color.Blue, ep, freezeSecond / 4, EffectRev.PositionAndRadius);
    define tryCount! = 0;
    define isFirstTeleport! = true;

    while(
        tryCount < freezeSecond &&
        IsAlive(ep) &&
        IsAlive(target) &&
        IsOnGround(target)
    ){
        teleportPosition = PositionOf(target) + Normalize(VectorWithOutY(DirectionTowards(target, ep)));
        // show pre teleport effect
        if(isFirstTeleport){ PlayTeleportEffect(true, true); }
        Teleport(ep, teleportPosition);
        // show teleport effect
        if(isFirstTeleport){ PlayTeleportEffect(false, true); }
        isFirstTeleport = false;
        Wait(0.5, WaitBehavior.IgnoreCondition);
        PressButton(ep, Button.Melee);
        SetStatus(ep, ep, Status.Rooted, 1.5);
        SetStatus(target, ep, Status.Frozen, 1.5);
        

        aimTarget = target;
        SetFacing(target, DirectionTowards(EyePosition(target), EyePosition(ep)));
        Wait(0.5, WaitBehavior.IgnoreCondition);
        tryCount ++;
    }

    DestroyEffect(effect);
    DestroyIcon(icon);
    ClearStatus(ep, Status.Frozen);
    ClearStatus(target, Status.Frozen);
    StartFacingAimTarget();
    Wait(3.0, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}


// TAG EnemyBot/CautionColor ----------
define cautionColor: isBlink ? Color.Red : Color.Yellow;

globalvar define isBlink;

rule: "EnemyBot/CautionColor/blinkColor"
Event.OngoingGlobal
if(
    initCompleted
){
    while(true){
        isBlink = !isBlink;
        Wait(0.2, WaitBehavior.AbortWhenFalse);
    }
}

// TAG EnemyBot/ThreatIcon ----------
playervar define threatIcon;

define isThreatIconActive: 
    IsAlive() &&
    !IsInSpawnRoom();

rule: "EnemyBot/ThreatIcon/show"
Event.OngoingPlayer
if(
    enemyTeam == TeamOf() &&
    IsBossClass(ep) &&
    isThreatIconActive
){
    // show threat icon to boss enemys for easy to caution enemy from player
    DestroyIcon(threatIcon);
    threatIcon = CreateIcon(AllPlayers(), ep, Icon.Skull,
        IconRev.Position, enemyTeamColor, false);
}

rule: "EnemyBot/ThreatIcon/hide"
Event.OngoingPlayer
if(
    enemyTeam == TeamOf() &&
    IsBossClass(ep) &&
    !isThreatIconActive
){
    DestroyIcon(threatIcon);
}

// TAG EnemyBot/Teleport ----------
define placableAreaSize: 15;
globalvar define placableAreaExtendSize;
define placableAreaExtendSizeScaleOnPointCapture: 0.6;
define placableAreaExtendSizeScaleOnPayloadEscort: 0.4;
define placableAreaOffset: ActionRange.CanFind;   // bot can find other range

globalvar define teleportBasePosition;
playervar define teleportPosition;
define teleportAreaSize: 5;
define teleportAreaForceUpdateSize: teleportAreaSize * 1.5;

define CanSnapMapSurface()"CanSnapMapSurface"{
    // walkable position is far
    return 
    !(
        (
            CurrentMap() == Map.Kings_Row ||
            CurrentMap() == Map.Kings_Row_Winter
        )
            &&
        ObjectiveIndex() == 0
            &&
        !IsTeamOnObject(humanTeam)
    );
}

// TAG EnemyBot/Teleport/GetTeleportBasePositionByClosestPlayer
define searchPositionTryCountMax: 10;

define GetTeleportBasePositionByClosestPlayer() globalvar "GetTeleportBasePositionByClosestPlayer"{
    define returnPosition! = null;
    define canSnapMap = CanSnapMapSurface();
    define objectPosition = CurrentObjectOnPosition();
    define closePlayer = ClosestPlayerTo(objectPosition, humanTeam);
    define closePlayerPosition = PositionOf(closePlayer);

    for(define searchPositionTryCount = 0; searchPositionTryCount < searchPositionTryCountMax; searchPositionTryCount++){
        // select candidatePosition at almost middle position of close player and object
        define candidatePosition =
            closePlayerPosition
                +
            RandomPosition(
                placableAreaSize,
                placableAreaSize,
                placableAreaSize
            )
                + 
            (
                DirectionTowards(closePlayerPosition, objectPosition)
                    *
                DistanceBetween(closePlayerPosition, objectPosition) * 0.3
            );
        
        if(
            canSnapMap
        ){
            candidatePosition = NearestWalkablePosition(candidatePosition);
        }
        else{
            candidatePosition = BelowPosition(candidatePosition + Vector(0, placableAreaSize * 2.0, 0));
        }

        if(
            // has line to close player
            IsInLineOfSight(
                PositionOffsetY1() + candidatePosition,
                PositionOffsetY1() + closePlayerPosition,
                BarrierLOS.NoBarriersBlock
            )
        ){
            returnPosition = candidatePosition;
            break;
        }
        Wait(0.1, WaitBehavior.IgnoreCondition);
    }

    return returnPosition;
}

// TAG EnemyBot/Teleport/GetTeleportBasePositionByObject
globalvar define blockedPos;
globalvar define positionObjectAhead;

define GetTeleportBasePositionByObject() globalvar "GetTeleportBasePositionByObject"{
    define returnPosition! = null;
    define canSnapMap = CanSnapMapSurface();
    define objectPosition = CurrentObjectOnPosition();

    if(
        // has object direction
        HasObjectDirection()
    ){
        if(
            // player on object
            IsTeamOnObject(humanTeam)
        ){
            // get teleportAreaExtendSize by object position and blockedPos
            define cutoutDistance! = placableAreaOffset - DistanceBetween(objectPosition, blockedPos);
            // get teleportAreaExtendSize by cutoutDistance with scale
            placableAreaExtendSize = cutoutDistance * placableAreaExtendSizeScaleOnPayloadEscort;
        }
        else{
            // clear extend size by non cut off distance of object direction
            placableAreaExtendSize = 0;
        }

        // overwrite position by positionObjectAhead
        objectPosition = positionObjectAhead;
    }
    else{
        // get teleportAreaExtendSize by fixed value of non object direction
        placableAreaExtendSize = placableAreaSize * placableAreaExtendSizeScaleOnPointCapture;
    }

    for(define searchPositionTryCount = 0; searchPositionTryCount < searchPositionTryCountMax; searchPositionTryCount++){
        // select candidatePosition at object ahead
        define candidatePosition =
            objectPosition
                +
            RandomPosition(
                placableAreaSize + placableAreaExtendSize,
                placableAreaSize + placableAreaExtendSize,
                placableAreaSize + placableAreaExtendSize
            );

        if(
            canSnapMap
        ){
            candidatePosition = NearestWalkablePosition(candidatePosition);
        }
        else{
            candidatePosition = BelowPosition(candidatePosition + Vector(0, placableAreaSize * 2.0, 0));
        }

        if(
            // has line to object
            IsInLineOfSight(
                PositionOffsetY1() + candidatePosition,
                PositionOffsetY1() + objectPosition,
                BarrierLOS.NoBarriersBlock
            )
        ){
            returnPosition = candidatePosition;
            break;
        }
        Wait(0.1, WaitBehavior.IgnoreCondition);
    }
    
    return returnPosition;
}

// TAG EnemyBot/Teleport/GetTeleportPositionByTeleportBasePosition
define GetTeleportPositionByTeleportBasePosition() playervar "GetTeleportPositionByTeleportBasePosition"{
    define returnPosition! = null;
    define canSnapMap = CanSnapMapSurface();
    define objectPosition = CurrentObjectOnPosition();
    define closePlayer = ClosestPlayerTo(objectPosition, humanTeam);

    if(
        IsInSpawnRoom(closePlayer)
    ){
        return returnPosition;
    }

    for(define searchPositionTryCount = 0; searchPositionTryCount < searchPositionTryCountMax; searchPositionTryCount++){
        // select teleportPosition from teleportBasePosition around
        define candidatePosition = 
            teleportBasePosition
                +
            RandomPosition(
                teleportAreaSize,
                teleportAreaSize,
                teleportAreaSize
            );

        if(
            canSnapMap
        ){
            candidatePosition = NearestWalkablePosition(candidatePosition);
        }
        else{
            candidatePosition = BelowPosition(candidatePosition + Vector(0, teleportAreaSize * 2.0, 0));
        }

        if(
            // Has line to close player
            IsInLineOfSight(
                PositionOffsetY1() + candidatePosition,
                EyePosition(closePlayer),
                BarrierLOS.NoBarriersBlock
            )    
        ){
            returnPosition = candidatePosition;
            break;
        }
        Wait(0.1, WaitBehavior.IgnoreCondition);
    }

    return returnPosition;
}

playervar define telBeam!;
define showTeleportBeamTime: 0.5;

void PlayTeleportEffect(define isBefore!, define isBeamFromBody!) playervar "PlayTeleportEffect"{
    // if before teleport
    if(isBefore){
        // show teleport beam to own position
        DestroyEffect(telBeam);

        telBeam = CreateBeamEffect(AllPlayers(),
            BeamType.BadBeam,
            isBeamFromBody ? 
                BodyPosition(ep) :
                teleportPosition + Vector(0, 30, 0),
            teleportPosition,
            enemyTeamColor, EffectRev.VisibleToPositionAndRadius);
        // wait for show teleport shadow of before
        Wait(showTeleportBeamTime / 2, WaitBehavior.IgnoreCondition);

        // play teleport shadow to own position
        PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, enemyTeamColor, PositionOf(ep), 1);
        // play teleport blast to teleport positon
        PlayEffect(AllPlayers(), PlayEffect.BadExplosion, enemyTeamColor, teleportPosition, 2);

        // wait for show teleport shadow of before
        Wait(showTeleportBeamTime / 2, WaitBehavior.IgnoreCondition);
    }
    else{
        // hide teleport beam to teleport positon
        DestroyEffect(telBeam);
        // play teleport shadow to teleport positon
        PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, enemyTeamColor, PositionOf(ep), 1);
        // play teleport sound
        PlayEffect(AllPlayers(), PlayEffect.RingExplosionSound, null, PositionOf(ep), 75);
    }
}

void DoTeleport(define isBeamFromBody!, define isTeleportToOnObject!)"DoTeleport"{
    define newPosition! = null;

    // do emergency teleport as threat enemy 
    if(
        isTeleportToOnObject
    ){
        // set teleportPosition by object position
        newPosition = BlockedPositon(CurrentObjectPosition(), objectDirection, 6);
        ApplyImpulse(ep, Down(), 1, Relative.ToWorld, ContraryMotion.Cancel);
    }
    else{
        // set teleportPosition by common position
        newPosition = GetTeleportPositionByTeleportBasePosition();
    }

    if(
        newPosition != null
    ){
        // update teleportPosition by new position
        teleportPosition = newPosition;
        // wait teleport until game start.
        WaitUntil(IsGameInProgress(), MaxValue());

        if(IsInSpawnRoom()){
            define waitTime! = 
                // set delay time proportional to slot number for load distributing
                ((maxCreateEnemyBotNum - SlotOf() - 1) * 0.5) *
                // scale by alive enemy num
                (NumberOfLivingPlayers() / NumberOfPlayers());
            Wait(waitTime, WaitBehavior.IgnoreCondition);
        }

        // show pre teleport effect
        PlayTeleportEffect(true, isBeamFromBody);
        // Teleport
        Teleport(ep, teleportPosition);
        // show teleport effect
        PlayTeleportEffect(false, isBeamFromBody);
    }
}

// TAG EnemyBot/Teleport/UpdateTeleportBasePosition ----------
globalvar define needUpdateTeleportBasePosition!;

rule: "EnemyBot/Teleport/UpdateTeleportBasePosition"
Event.OngoingGlobal
if(
    IsInPreLoadAssetTime()
){
    define objectPos! = CurrentObjectOnPosition();

    if(HasObjectDirection()){
        // get blockedPos by extension line collision position
        blockedPos = BlockedPositon(objectPos, objectDirection, placableAreaOffset);
        // get positionObjectAhead by between object position and blockedPos
        positionObjectAhead = ShiftedPosition(
            objectPos,
            DirectionTowards(objectPos, blockedPos),
            DistanceBetween(objectPos, blockedPos) * 0.75
        );
    }

    // if has not update flag of commonTeleportBasePosition
    if(!needUpdateTeleportBasePosition){
        // set update flag
        if(
            // by probability
            IsTrueProbability(10)
        ){
            needUpdateTeleportBasePosition = true;
            // dbgHudTxt(<"UP POS BY PRB">);
        }
        else if(
            // position invalid
            teleportBasePosition == null
        ){
            needUpdateTeleportBasePosition = true;
            // dbgHudTxt(<"UP POS BY POS INV">);
        }
        else if(
            // position too close player
            DistanceBetween(
                teleportBasePosition,
                ClosestPlayerTo(teleportBasePosition, humanTeam)
            ) <= teleportAreaForceUpdateSize        
        ){
            needUpdateTeleportBasePosition = true;
            // dbgHudTxt(<"UP POS BY CRS PLR">);
        }
        else if(
            // too close from spawn point
            DistanceBetween(
                teleportBasePosition,
                SpawnPoints(humanTeam)[0]
            ) <= ActionRange.Middle
        ){
            needUpdateTeleportBasePosition = true;
            // dbgHudTxt(<"UP POS BY CRS SPN PNT">);
        }
        else{
            if(
                // player on object
                IsTeamOnObject(humanTeam)
            ){
                define checkPos! = HasObjectDirection() ? positionObjectAhead : objectPos;
                if(
                    // not line from checkPos
                    !IsInLineOfSight(
                        PositionOffsetY1() + teleportBasePosition,
                        PositionOffsetY1() + checkPos,
                        BarrierLOS.NoBarriersBlock
                    )
                ){
                    needUpdateTeleportBasePosition = true;
                    // dbgHudTxt(<"UP POS BY NON LINE OBJ OR AHD">);
                }
                else{
                    // dbgHudTxt(<"POS KEP">);
                }
            }
            else{
                if(
                    // not line from closest object player
                    !IsInLineOfSight(
                        PositionOffsetY1() + teleportBasePosition,
                        PositionOffsetY1() + PositionOf(ClosestPlayerTo(objectPos, humanTeam)),
                        BarrierLOS.NoBarriersBlock
                    )
                ){
                    needUpdateTeleportBasePosition = true;
                    // dbgHudTxt(<"UP POS BY NON LINE PLR">);
                }
                else{
                    // dbgHudTxt(<"POS KEP">);
                }
            }
        } 
    }
    
    // if has update flag of commonTeleportBasePosition
    if(
        needUpdateTeleportBasePosition
    ){
        define newPosition! = null;
        // calc new position
        if(
            // player on object
            IsTeamOnObject(humanTeam)
        ){
            // calc by object
            newPosition = GetTeleportBasePositionByObject();
        }
        else{
            // calc by closest player
            newPosition = GetTeleportBasePositionByClosestPlayer();
        }

        // found position
        if(
            newPosition != null
        ){
            // update commonTeleportBasePosition by new position
            teleportBasePosition = newPosition;
            // release update flag
            needUpdateTeleportBasePosition = false;

            // dbgHudTxt(<"UP POS OK">);
        }
        else{
            // dbgHudTxt(<"UP POS NG">);
        }
    }

    Wait(teleportBasePosition == null ? 1 : 3, WaitBehavior.IgnoreCondition);
    // WaitUntilServerLoadLimitRelease();
    LoopIfConditionIsTrue();
}

globalvar define sucideCount!;

rule: "EnemyBot/Teleport/ResetTeleportBasePosition"
Event.OnDeath
if(
    !needUpdateTeleportBasePosition &&
    TeamOf() == enemyTeam &&
    Attacker() == ep
){
    sucideCount ++;

    if(sucideCount >= 3){
        // reset by invalid position
        needUpdateTeleportBasePosition = true;
        sucideCount = 0;
    }
}

rule: "EnemyBot/Teleport/cooldownSucideCount"
Event.OngoingGlobal
if(
    sucideCount > 0
){
    Wait(1.0, WaitBehavior.IgnoreCondition);
    sucideCount --;
    LoopIfConditionIsTrue();
}

rule: "EnemyBot/Teleport/teleportByRespawn"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsInPreLoadAssetTime() &&
    IsInSpawnRoom()
){
    DoTeleport(false, false);
    Wait(1.0, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/Teleport/teleportByIdleForDefendObject ----------
rule: "EnemyBot/Teleport/teleportByIdleForDefendObject"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsGameInProgress() &&
    !IsInSpawnRoom() &&
    IsAlive()
){
    define isFinaleDefence;

    while(true){
        Wait(3, WaitBehavior.AbortWhenFalse);

        isFinaleDefence = 
            // is boss
            IsBossClass(ep) &&
            // player team close win
            IsCloseWin(humanTeam);

            if(
                // finale
                isFinaleDefence
            ){
                // do teleport instantly
                break;
            }
            else if(
                // not in ult
                !IsUsingUltimate() &&
                // by health high
                IsTrueProbability(NormalizedHealth() * 100) &&
                // has not line to teleportBasePosition
                !IsInLineOfSight(EyePosition(ep), PositionOffsetY1() + teleportBasePosition) 
            ){
                // do teleport instantly
                break;
            }
    }

    // teleport
    DoTeleport(true, isFinaleDefence);
    Wait(1.0, WaitBehavior.IgnoreCondition);
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/EnemyAbility/SpawnRush ----------
globalvar define spawnRushInterval;
globalvar define spawnRushCount;

rule: "EnemyBot/EnemyAbility/SpawnRush"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    // set default interval by object progress
    spawnRushInterval = ObjectProgressScaledInterval(humanTeam, 25, 40) + RandomInteger(-5, 5);
    // apply workshop setting
    spawnRushInterval *= WorkshopSettingReal("Enemy Bot Settings", "Spawn-Rush Interval Scale", 1.0, 0.0, 100, 4);
    // round for counting
    spawnRushInterval = RoundToInteger(spawnRushInterval, Rounding.Up);
    for(;spawnRushInterval > 0; spawnRushInterval--){
        Wait(1, WaitBehavior.IgnoreCondition);
    }

    // action
    define spawnRushDuration! = RandomInteger(10, 20);
    spawnRushDuration *= WorkshopSettingReal("Enemy Bot Settings", "Spawn-Rush Duration Scale", 1.0, 0.0, 100, 5);
    define deployInterval! = RandomInteger(1, 3);
    spawnRushCount = RoundToInteger(spawnRushDuration / deployInterval, Rounding.Down);
    for(; spawnRushCount > 0; spawnRushCount--){
        Respawn(
            FilteredArray(
                AllDeadPlayers(enemyTeam),
                (
                    ae.enemyType != EnemyType.Boss
                )
            )
        );
        
        Wait(deployInterval, WaitBehavior.IgnoreCondition);
    }

    Wait(1, WaitBehavior.IgnoreCondition);
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/EnemyAbility/ShotCall ----------
globalvar define shotCallInterval;

rule: "EnemyBot/EnemyAbility/ShotCall"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    // set default interval by object progress
    shotCallInterval = ObjectProgressScaledInterval(humanTeam, 25, 40) + RandomInteger(-5, 5);
    // apply workshop setting
    shotCallInterval *= WorkshopSettingReal("Enemy Bot Settings", "All-Out-Ultmate Interval Scale", 1.0, 0.0, 100, 6);
    // round for counting
    shotCallInterval = RoundToInteger(shotCallInterval, Rounding.Up);
    for(;shotCallInterval > 0; shotCallInterval--){
        Wait(1, WaitBehavior.IgnoreCondition);
    }

    // action
    define activeEnemys! = AllPlayers(enemyTeam);
    define shotCallDelay! = RandomReal(0.2, 1.0);
    for(define scLoopIndex! = 0; scLoopIndex < CountOf(activeEnemys); scLoopIndex ++){
        if(
            IsAlive(activeEnemys[scLoopIndex]) &&
            !IsInSpawnRoom(activeEnemys[scLoopIndex])
        ){
            SetUltimateCharge(activeEnemys[scLoopIndex], DefaultPercentage());
            PressButton(activeEnemys[scLoopIndex], Button.Ultimate);

            Wait(shotCallDelay, WaitBehavior.IgnoreCondition);
        }
    }

    Wait(1, WaitBehavior.IgnoreCondition);
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/EnemyAbility/MoreUltimate ----------
define moreAbilityInterval: RandomReal(0.1, 1);

playervar define moreUltProb;

rule: "EnemyBot/EnemyAbility/moreUltimate"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsBossClass(ep) &&
    IsAlive() &&
    actionState != ActionState.Non &&
    IsUsingUltimate()
){
    moreUltProb = DefaultPercentage();

    while(
        IsAlive() &&
        IsTrueProbability(moreUltProb)
    ){
        WaitUntil(!IsUsingUltimate(), MaxValue());
        SetUltimateCharge(ep, DefaultPercentage());
        Wait(moreAbilityInterval, WaitBehavior.IgnoreCondition);
        PressButton(ep, Button.Ultimate);
    }
    moreUltProb = 0;

    WaitUntil(!IsUsingUltimate(), MaxValue());
    Wait(1.0, WaitBehavior.IgnoreCondition);
}

globalvar define decreaseProb! =
    WorkshopSettingReal("Enemy Bot Settings", "(Sub boss & Boss) Rapid-Fire-Ultimate Termination Scale", 1.0, 0.0, 100, 8)
        * 10.0;

rule: "EnemyBot/EnemyAbility/decreaseMultiUltimateProb"
Event.OngoingPlayer
if(
    moreUltProb > 0
){
    Wait(1.0, WaitBehavior.IgnoreCondition);
    moreUltProb -= moreUltProb < decreaseProb ? moreUltProb : decreaseProb;
    LoopIfConditionIsTrue();
}

// TAG Debug ----------
rule: "DebugGlobalAction"
Event.OngoingGlobal
Team.All
if(
    initCompleted
){
    // teleportBasePosition icon
    CreateIcon(debugMode != DebugMode.Non ? hp : null, teleportBasePosition, Icon.ArrowDown,
        IconRev.VisibleToAndPosition, enemyTeamColor, true);
    // teleportBasePosition orb
    CreateEffect(debugMode != DebugMode.Non ? hp : null, Effect.Orb, enemyTeamColor,
        PositionOffsetY1() + teleportBasePosition, 1, EffectRev.VisibleToPositionAndRadius);
    // // positionObjectAhead orb
    // CreateEffect(debugMode != DebugMode.Non ? hp : null, Effect.Orb, Color.White,
    //         positionObjectAhead, 1, EffectRev.VisibleToPositionAndRadius);

    // // teleportAreaSize ring
    // CreateEffect(debugMode != DebugMode.Non ? hp : null, Effect.Ring, Color.Red,
    //         teleportBasePosition, teleportAreaSize, EffectRev.VisibleToPositionAndRadius);
    // // teleportAreaForceUpdateRange ring
    // CreateEffect(debugMode != DebugMode.Non ? hp : null, Effect.Ring, Color.Yellow,
    //         teleportBasePosition, teleportAreaForceUpdateSize, EffectRev.VisibleToPositionAndRadius);

    // // placable teleportPosition area size sphere
    // CreateEffect(debugMode != DebugMode.Non ? hp : null,
    //         Effect.Sphere, Color.White,
    //         HasObjectDirection() ?
    //                 positionObjectAhead :
    //                 CurrentObjectOnPosition(),
    //         placableAreaSize + placableAreaExtendSize,
    //         EffectRev.VisibleToPositionAndRadius);

    // // object -> positionObjectAhead beam
    // CreateBeamEffect(debugMode != DebugMode.Non ? hp : null, BeamType.GoodBeam, 
    //         CurrentObjectOnPosition(),
    //         positionObjectAhead, 
    //         Color.White, EffectRev.VisibleToPositionAndRadius);
    // // positionObjectAhead or object -> commonTeleportBasePosition beam
    // CreateBeamEffect(debugMode != DebugMode.Non ? hp : null, BeamType.GoodBeam, 
    //         HasObjectDirection() ? positionObjectAhead : CurrentObjectOnPosition(),
    //         PositionOffsetY1() + teleportBasePosition, 
    //         Color.Red, EffectRev.VisibleToPositionAndRadius);


    define serverLoadHistory = [];
    define serverLoadHistoryIndex = 0;
    define serverLoadHistoryNum = 30;
    define forceModRate = WorkshopSettingReal("Friend Bot Settings", "Force Mod Rate (when player team in disadvantage, friend bot use powerfull mod)", 1.0, 0.0, 100, 2);

    while(true){
        // auto use friend bot hero mod
        if(
            IsTrueProbability(GameProgressDiff(humanTeam) * -0.05 * forceModRate)
        ){
            forceHeroMod();
        }

        if(
            IsGodMode()
        ){
            // force spawn rush
            if(spawnRushInterval > 0){
                spawnRushInterval = 0;
            }

            // force hero mod to gunship
            hp.heroModType = HeroModType.GUNSHIP_GUNNER;

            // force use gunship a frined
            if(IsTrueEverySeconds(3)){
                define last! = FirstOf(
                    SortedArray(
                        FilteredArray(
                            AllPlayers(humanTeam),
                            (
                                IsDummyBot(ae)
                            )
                        ),
                        -SlotOf(ae)
                    )
                );

                if(
                    last != null &&
                    !last.isTransformed
                ){
                    last.heroModType = HeroModType.GUNSHIP_GUNNER;
                    SetUltimateCharge(last, DefaultPercentage());
                    PressButton(last, Button.Ultimate);
                }
            }
        }

        Wait(1);
    }
}

// rule: "DebugPlayerAction"
// Event.OngoingPlayer
// Team.All
// if(
//     ep == hp &&
//     HasSpawned() &&
//     IsJumping()
// ){
//     define player = RandomValueInArray(AllPlayers(humanTeam));
//     player.heroModType = HeroModType.SHOT_CALL;
//     SetUltimateCharge(player, 100);
//     // Wait(1);
//     // Loop();
// }

rule: "DebugPlayJoinPlayerSound"
Event.OnPlayerJoin
Team.All
if(
    !IsDummyBot()
){
    define positionArray! = [
        PositionOf(hp),
        SpawnPoints(humanTeam)[0],
        CurrentObjectPosition(),
        SpawnPoints(enemyTeam)[0]
    ];

    for(define index! = 0; index < 5; index++){
        for(define index2! = 0; index2 < 5; index2++){
            PlayEffect(HostPlayer(),
                PlayEffect.BuffImpactSound,
                null, positionArray[index2], MaxValue());
        }
        Wait(0.5);
    }
}

globalvar define playerDeathCount! = 0;  // for debug
globalvar define enemyDeathCount! = [0,0,0,0];  // for debug

rule: "Debug/countDeath"
Event.OnDeath
if(
    Attacker() != ep
){
    // death count for debug
    if(TeamOf() == humanTeam){
        playerDeathCount ++;
    }
    else{
        enemyDeathCount[
            enemyType == EnemyType.Minion ?     0 :
            enemyType == EnemyType.Elite ?      1 :
            enemyType == EnemyType.SubBoss ?    2 :
            enemyType == EnemyType.Boss ?       3 :
                                                0
        ] ++;
    }
}

rule: "Debug/initDebugMode"
Event.OngoingGlobal
Team.All
if(
    IsGameInProgress()
){
    define isGodMode! = WorkshopSettingToggle("Z_Debug Settings", "God mode (Always spawn gunships and enemies spawn rate max)", false, MaxValue());

    if(isGodMode){
        debugMode = DebugMode.GodMode;
        ShowDebugHud(hp);
    }
    else if(!IsHostPlayerInGame()){
        debugMode = DebugMode.ShowParam;
        ShowDebugHud(hp);
    }
    else{
        debugMode = DebugMode.Non;
    }
}

rule: "Debug/changeDebugMode"
Event.OngoingPlayer
Team.All
if(
    hp == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Jump) 
){
    // change debug mode
    WaitLongPressConfirm();
    
    if(debugMode >= DebugMode.Last - 1){
        debugMode = DebugMode.Non;
    }
    else{
        debugMode ++;
    }

    // reload hud
    HideDebugHud();
    ShowDebugHud(hp);
}

globalvar define debugHuds;

define Last():
    CountOf(debugHuds);

define FirstEnemyOf(in define enemyType):
    FirstOf(FilteredArray(AllPlayers(enemyTeam), ae.enemyType == enemyType));

define FirstBossClassEnemy():
    FirstOf(FilteredArray(AllPlayers(enemyTeam), IsBossClass(ae)));

// show debug icon and hud
void ShowDebugHud(define player!)"ShowDebugHud"{
    if(
        debugMode == DebugMode.GodMode
    ){
        wm(); debugHuds[Last()] = CreateDebugHud("●God Mode", true, cautionColor);
    }

    if(
        debugMode == DebugMode.Recording
    ){
        EnableInspectorRecording();
        wm(); debugHuds[Last()] = CreateDebugHud("●Log Recording", true, cautionColor);
    }
    else{
        DisableInspectorRecording();
    }

    if(
        debugMode >= DebugMode.Non
    ){
        wm(); debugHuds[Last()] = CreateDebugHud("human player Num", HumanPlayerNum(humanTeam), HumanPlayerNum(humanTeam) <= 1 ? Color.Team2 : Color.Yellow);
    }
    
    if(
        debugMode >= DebugMode.ServerLoad
    ){
        // wm(); debugHuds[Last()] = CreateDebugHud("Server Load Peak", ServerLoadPeak(), ServerLoadPeak() >= ServerLoad.FULL ? Color.Red : ServerLoadPeak() >= ServerLoad.HIGH ? Color.Yellow : Color.Gray);
        // wm(); debugHuds[Last()] = CreateDebugHud("Server Load Avrg", ServerLoadAverage(), ServerLoadAverage() >= ServerLoad.FULL ? Color.Red : ServerLoadAverage() >= ServerLoad.HIGH ? Color.Yellow : Color.Gray);
        wm(); debugHuds[Last()] = CreateDebugHud("Server Load", ServerLoad(), ServerLoad() >= ServerLoad.FULL ? Color.Red : ServerLoad() >= maxLoadLimit ? Color.Yellow : Color.Gray);
        wm(); debugHuds[Last()] = CreateDebugHud("Server Load Limit", loadLimit, loadLimit < maxLoadLimit ? Color.Yellow : Color.Gray);
        wm(); debugHuds[Last()] = CreateDebugHud("Game Speed", gameSpeed, gameSpeed < gameSpeedMax ? Color.Yellow : Color.Gray);
        wm(); debugHuds[Last()] = CreateDebugHud("Count Action Wait", countActionWait, Color.Gray);
        wm(); debugHuds[Last()] = CreateDebugHud("Count Game Speed Decrease", countGameSpeedDecrease, countGameSpeedDecrease > 0 ? Color.Yellow : Color.Gray);
    }

    if(
        debugMode >= DebugMode.ShowParam
    ){  
        // player team
        wm(); debugHuds[Last()] = CreateDebugHud("Team player Num", <"<0> / <1>", NumberOfLivingPlayers(humanTeam), NumberOfPlayers(humanTeam)>, NumberOfLivingPlayers(humanTeam) < NumberOfPlayers(humanTeam) ? Color.Yellow : humanTeamColor);
        wm(); debugHuds[Last()] = CreateDebugHud("Reload Asset Interval", reloadFriendBotAssetInterval, reloadFriendBotAssetInterval <= 5 ? Color.Yellow : Color.Team2);
        wm(); debugHuds[Last()] = CreateDebugHud("Asset Number", friendBotAssetNo, Color.Team2);
        wm(); debugHuds[Last()] = CreateDebugHud("Death Count", playerDeathCount, Color.Team2);
        wm(); debugHuds[Last()] = CreateDebugHud("Object Progress", ObjectProgress(humanTeam), Color.Team2);
        wm(); debugHuds[Last()] = CreateDebugHud("Game Progress Diff", GameProgressDiff(humanTeam), Color.Team2);

        // enemy team
        wm(); debugHuds[Last()] = CreateDebugHud("Team player num", <"<0> / <1>", NumberOfLivingPlayers(enemyTeam), NumberOfPlayers(enemyTeam)>, NumberOfLivingPlayers(enemyTeam) < NumberOfPlayers(enemyTeam) ? Color.Yellow : enemyTeamColor);
        wm(); debugHuds[Last()] = CreateDebugHud("Reload Asset Interval", reloadEnemyAssetInterval, reloadEnemyAssetInterval <= 5 ? Color.Yellow : enemyTeamColor);
        wm(); debugHuds[Last()] = CreateDebugHud("Asset Number", enemyAssetNo, enemyTeamColor);
        wm(); debugHuds[Last()] = CreateDebugHud("Mod Number", enemyModNo, enemyTeamColor);
        wm(); debugHuds[Last()] = CreateDebugHud("Death Count", <"<0>, <1>, <2>, <3>",
            enemyDeathCount[0], enemyDeathCount[1], enemyDeathCount[2], enemyDeathCount[3]>, enemyTeamColor);
        wm(); debugHuds[Last()] = CreateDebugHud("Spawn Time scale", spawnTimeScale, enemyTeamColor);
        wm(); debugHuds[Last()] = CreateDebugHud("Spawn Time", <"<0>, <1>, <2>, <3>",
            FirstEnemyOf(EnemyType.Minion).confirmSpawnTime,
            FirstEnemyOf(EnemyType.Elite).confirmSpawnTime,
            FirstEnemyOf(EnemyType.SubBoss).confirmSpawnTime,
            FirstEnemyOf(EnemyType.Boss).confirmSpawnTime>, enemyTeamColor);
        wm(); debugHuds[Last()] = CreateDebugHud("Dealt Damage ", <"<0>, <1>, <2>, <3>",
            FirstEnemyOf(EnemyType.Minion).confirmDealtDamage,
            FirstEnemyOf(EnemyType.Elite).confirmDealtDamage,
            FirstEnemyOf(EnemyType.SubBoss).confirmDealtDamage,
            FirstEnemyOf(EnemyType.Boss).confirmDealtDamage>, enemyTeamColor);
        wm(); debugHuds[Last()] = CreateDebugHud("Spawn Rush Interval", spawnRushInterval, spawnRushInterval <= 5 ? Color.Yellow : enemyTeamColor);
        wm(); debugHuds[Last()] = CreateDebugHud("Spawn Rush Count", spawnRushCount, spawnRushCount > 0 ? Color.Yellow : enemyTeamColor);
        wm(); debugHuds[Last()] = CreateDebugHud("Shot Call Interval", shotCallInterval, shotCallInterval <= 5 ? Color.Yellow : enemyTeamColor);
        wm(); debugHuds[Last()] = CreateDebugHud("More Ult Prob SubBoss", FirstEnemyOf(EnemyType.SubBoss).moreUltProb, FirstEnemyOf(EnemyType.SubBoss).moreUltProb > 0 ? Color.Yellow : enemyTeamColor);
        wm(); debugHuds[Last()] = CreateDebugHud("More Ult Prob Boss", FirstEnemyOf(EnemyType.Boss).moreUltProb, FirstEnemyOf(EnemyType.Boss).moreUltProb > 0 ? Color.Yellow : enemyTeamColor);
        wm(); debugHuds[Last()] = CreateDebugHud("Sucide Count", sucideCount, sucideCount > 0 ? Color.Yellow : enemyTeamColor);
        // wm(); debugHuds[Last()] = CreateDebugHud("Focus Target", focusTarget, Color.Yellow);
    }
}

// Hide debug icon and hud
void HideDebugHud()"HideDebugHud"{
    for(gLoopIndex = 0; gLoopIndex < CountOf(debugHuds); gLoopIndex ++){
        DestroyHudText(debugHuds[gLoopIndex]);
    }
}

rule: "Debug/resetBotList"
Event.OngoingPlayer
Team.All
if(
    hp == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Crouch)
){
    WaitLongPressConfirm();
    reloadEnemyAssetInterval = 0;
    WaitLongPressConfirm();
    // WaitUntil(reloadEnemyAssetInterval > 0, 10);
    reloadFriendBotAssetInterval = 0;
}

rule: "Debug/triggerRushAndShotCall"
Event.OngoingPlayer
Team.All
Player.All
if(
    hp == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Reload)
){
    WaitLongPressConfirm();
    spawnRushInterval = 0;
    
    WaitLongPressConfirm();
    shotCallInterval = 0;
}

// globalvar define focusTarget!;

// rule: "Debug/setFocusTarget"
// Event.OngoingPlayer
// Team.All
// Player.All
// if(
//     hp == ep &&
//     IsButtonHeld(ep, Button.Interact) &&
//     IsButtonHeld(ep, Button.PrimaryFire)
// ){
//     if(
//         VerticalFacingAngleOf(ep) >= 45
//     ){
//         if(focusTarget == null){
//             focusTarget = ep;
//             PlayEffect(ep, PlayEffect.BuffImpactSound, ep, null, MaxValue());
//         }
//         else{
//             focusTarget = null;
//             PlayEffect(ep, PlayEffect.DebuffImpactSound, ep, null, MaxValue());
//         }
//     }
//     else{ 
//         focusTarget = PlayerClosestToReticle(ep, OppositeTeamOf(ta));
//         PlayEffect(ep, PlayEffect.BuffImpactSound, ep, null, MaxValue());
//     }
// }

// rule: "Debug/focusTarget"
// Event.OngoingGlobal
// if(
//     focusTarget != null
// ){
//     if(
//         IsAlive(focusTarget)
//     ){
//         define bots! = FilteredArray(
//             AllLivingPlayers(EnemyTeamOf(focusTarget)),
//             (
//                 IsDummyBot(ae) &&
//                 ae.actionState != ActionState.Non
//             )
//         );
//         bots.actionState = ActionState.Attack;
//         bots.aimTarget = focusTarget;
//     }

//     dbgPlyEft(focusTarget);

//     Wait(1, WaitBehavior.IgnoreCondition);
//     WaitUntilServerLoadLimitRelease();
//     LoopIfConditionIsTrue();
// }


rule: "Debug/forceHeroMod"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.PrimaryFire)
){
    // kill players on aim center
    WaitLongPressConfirm();
    forceHeroMod();

    LoopIfConditionIsTrue();
}

void forceHeroMod()"forceHeroMod"{
    define player! = 
        RandomValueInArray(
            FilteredArray(
                AllPlayers(humanTeam),
                (
                    IsDummyBot(ae) &&
                    !ae.isTransformed
                )
            )
        );

    player.heroModType = RandomValueInArray([
        HeroModType.HEALING_SYRINGE,
        HeroModType.SAVIOR,
        HeroModType.POWERFUL_GIFT,
        HeroModType.SUPER_ULT,
        HeroModType.SHOT_CALL,
        HeroModType.ARTILLERY_REQUEST,
        HeroModType.STRAFING_REQUEST,
        HeroModType.GRUDGE_FIRE_BALL,
        HeroModType.GRUDGE_LIGHTNING,
        HeroModType.BEAM_SNIPER,
        HeroModType.TITAN_FORM,
        HeroModType.GUNSHIP_GUNNER,
        HeroModType.GUNSHIP_GUNNER,
        HeroModType.GUNSHIP_GUNNER
    ]);

    if(IsDead(player)){
        Resurrect(player);
    }
    player.grudgePower = 100;
    SetUltimateCharge(player, DefaultPercentage());
    PressButton(player, Button.Ultimate);
}
