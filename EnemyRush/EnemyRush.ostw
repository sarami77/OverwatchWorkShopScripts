import "EnemyRush.setting.json";
import "../Lib/Debug.del";
import "../Lib/Utility.del";
import "../Lib/ServerOverLoadMeasures.del";
import "../Lib/Bot.del";
import "../Lib/Buddy.del";
import "../Lib/Vote.del";
import "../Lib/HeroMod.del";

// TAG Signature and infomation ----------
disabled rule: "[PVE] ENEMY RUSH ver.8.0 / Share code [V7PEF]. You allowed copy or modify code." -1 {}
disabled rule: "This mod was provaide by WORKSHOP.CODES. Check detail with XXXX" -1 {}
disabled rule: "This script was generated by ItsDeltin/Overwatch-Script-To-Workshop. Check detail with https://github.com/ItsDeltin/Overwatch-Script-To-Workshop" -1 {}
disabled rule: "This original script was created by sarami77#1868. Check detail with https://github.com/sarami77/OverwatchWorkShopScripts" -1 {}

// TAG Initialize ----------
define playerTeam: Team.Team2;
define enemyTeam: Team.Team1;
define allTeam: Team.All;

globalvar define initCompleted;

rule: "Initialize/initialize"
Event.OngoingGlobal
{
    // Stop records to reduce server load
    DisableInspectorRecording();

    // If run it right after loading the server, some scripts fail, so wait 3 seconds
    Wait(5, WaitBehavior.AbortWhenFalse);

    // Start watch over load
    slowControlHandler = SlowControlHandler.ServerOverLoadMeasures;

    // show version and share code
    CreateHudText(AllPlayers(),
        null, "[PVE] ENEMY RUSH ver.8.0 / Share code [V7PEF]", null,
        Location.Left, -999,
        Color.White, Color.Gray, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleAlways);

    // Notify completion of init game setting and start game main logic
    initCompleted = true;
}

// TAG Round ----------
rule: "Round/shortenAssemblePhase"
Event.OngoingGlobal
if(
    IsAssemblingHeroes()
){
    SetMatchTime(40);

    // wait player join server
    Wait(10, WaitBehavior.AbortWhenFalse);
    
    if(
        // no human
        HumanPlayerNum(playerTeam) <= 0
            ||
        // host human only
        (
            // 1 human only
            HumanPlayerNum(playerTeam) == 1
                &&
            // human is host player
            hp ==
                FirstOf(
                    FilteredArray(
                        AllPlayers(playerTeam),
                        !IsDummyBot(ae)
                    )
                )
        )
    ){
        // omit assemble phase
        SetMatchTime(0);
    }
}

rule: "Round/shortenSetupPhase"
Event.OngoingGlobal
if(
    IsInSetup()
){
    SetMatchTime(40);

    if(
        // no human
        HumanPlayerNum(playerTeam) <= 0
    ){
        // omit setup phase
        SetMatchTime(0);
    }
}

// globalvar define matchTimeScale! = WorkshopSettingReal("Game Settings", "Match Time Scale", 1.0, 0.01, 100, 1);

// rule: "Round/AddMatchTime1"
// Event.OngoingGlobal
// if(
//     IsGameInProgress()
// ){
//     // defualt add 300s
//     SetMatchTime(MatchTime() + (300 * (1 - matchTimeScale)));
// }

// rule: "Round/AddMatchTime2"
// Event.OngoingGlobal
// if(
//     IsObjectiveComplete(0)
// ){
//     // defualt add 180s
//     SetMatchTime(MatchTime() + (180 * (1 - matchTimeScale)));
// }

// rule: "Round/AddMatchTime3"
// Event.OngoingGlobal
// if(
//     IsObjectiveComplete(1)
// ){
//     // defualt add 120s
//     SetMatchTime(MatchTime() + (120 * (1 - matchTimeScale)));
// }

// TAG Object ----------
globalvar define prevObjectPosition;

globalvar define objectDirection;

define HasObjectDirection(): objectDirection != null;

rule: "Object/updateObjectDirection"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    Wait(0.1);
    prevObjectPosition = CurrentObjectPosition();

    while(true){
        define nowObjectPosition! = CurrentObjectPosition();
        if(
            IsPlayerOnObject &&
            nowObjectPosition != prevObjectPosition
        ){
            objectDirection = DirectionTowards(prevObjectPosition, nowObjectPosition);
            prevObjectPosition = nowObjectPosition;
        }
        WaitUpdateMediumCycle();
    }
}

// TAG FinalStand ----------
rule: "FinalStand/FinalStand"
Event.OngoingGlobal
if(
    IsGameInProgress() &&
    IsOverTime()
){
    BigMessage(AllPlayers(), "Final Stand !");
    slowControlHandler = SlowControlHandler.GameLogic;
    SetSlowMotion(10);
    Wait(0.25, WaitBehavior.IgnoreCondition);   // show slow

    // buff player team
    PlayEffectsToTeam(playerTeam);
    Heal(AllLivingPlayers(playerTeam), null, MaxValue());
    SetUltimateCharge(AllLivingPlayers(playerTeam), 100);
    Resurrect(AllDeadPlayers(playerTeam));

    // buff enemy team
    spawnRushInterval = 0;
    shotCallInterval = 0;

    Wait(0.25, WaitBehavior.IgnoreCondition);   // show slow

    SetSlowMotion(DefaultPercentage());
    slowControlHandler = SlowControlHandler.ServerOverLoadMeasures;
}

// TAG Player/Config ----------
rule: "Player/Config/SetRespawnMaxTimeAndOutline"
Event.OngoingPlayer
if(
    initCompleted &&
    HasSpawned()
){
    if(!IsDummyBot()){
        // // set green outline to human player
        // StartForcingPlayerOutlines(
        //     ep,
        //     AllPlayers(playerTeam),
        //     true,
        //     Color.Green,
        //     OutlineType.Always
        // );
    }

    // set max respawn time
    define respawnTime! = 10 * WorkshopSettingReal("Player Settings", "Max Respawn Time Scale", 1.0, 0.01, 100, 1);
    SetRespawnMaxTime(ep, respawnTime);
}

// TAG Player/HumanIcon ----------
playervar define icon!;

rule: "Player/Icon/showHumanIcon"
Event.OngoingPlayer
if(
    playerTeam == TeamOf() &&
    HasSpawned() &&
    !IsDummyBot() &&
    IsAlive()
){
    DestroyIcon(icon);
    icon = CreateIcon(AllPlayers(), ep, Icon.Club,
        IconRev.Position, Color.Team2, false);
}

rule: "Player/Config/hideHumanIcon"
Event.OngoingPlayer
if(
    playerTeam == TeamOf() &&
    HasSpawned() &&
    !IsDummyBot() &&
    !IsAlive()
){
    DestroyIcon(icon);
}

// TAG Buddy/BotActive ----------
define canBuddyBotActive:
    IsAlive();

rule: "Buddy/BotActive/activate"
Event.OngoingPlayer
if(
    TeamOf() == playerTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    canBuddyBotActive
){
    isBotActive = true;
}

rule: "Buddy/BotActive/deactive"
Event.OngoingPlayer
if(
    TeamOf() == playerTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    !canBuddyBotActive
){
    isBotActive = false;
}

// TAG Buddy/Config ----------
rule: "Buddy/Config/SetWatchUpdateRate"
Event.OngoingPlayer
if(
    TeamOf() == playerTeam &&
    IsDummyBot() &&
    HasSpawned()
){
    watchUpdateRate = 1.0;
}

// TAG Buddy/Asset ----------
define buddyAssetList:
    [
        // fix hero asset
        [   // assetNo 0
            // recommend
            [EnemyType.Non,    Hero.Mercy,      1],
            [EnemyType.Non,    Hero.Genji,      1],
            [EnemyType.Non,    Hero.Reinhardt,  1],
            [EnemyType.Non,    Hero.Ana,        1],
            [EnemyType.Non,    Hero.Hanzo,      1],
            [EnemyType.Non,    Hero.Mauga,      1],
            [EnemyType.Non,    Hero.Zenyatta,   1],
            [EnemyType.Non,    Hero.Soldier76,  1]
        ],
        [   // assetNo 1
            // recommend
            [EnemyType.Non,    Hero.Moira,      1],
            [EnemyType.Non,    Hero.Reaper,     1],
            [EnemyType.Non,    Hero.Ramattra,   1],
            [EnemyType.Non,    Hero.Baptiste,   1],
            [EnemyType.Non,    Hero.Sojourn,    1],
            [EnemyType.Non,    Hero.Mauga,      1],
            [EnemyType.Non,    Hero.Brigitte,   1],
            [EnemyType.Non,    Hero.Genji,      1]
        ],
        [   // assetNo 2
            // recommend
            [EnemyType.Non,    Hero.Illari,     1],
            [EnemyType.Non,    Hero.Sojourn,    1],
            [EnemyType.Non,    Hero.Ramattra,   1],
            [EnemyType.Non,    Hero.Lifeweaver, 1],
            [EnemyType.Non,    Hero.Ashe,       1],
            [EnemyType.Non,    Hero.Mauga,      1],
            [EnemyType.Non,    Hero.Kiriko,     1],
            [EnemyType.Non,    Hero.Cassidy,    1]
        ],
        // 3,4,5,6,7,8,9,
        [],[],[],[],[],[],[],

        // random hero asset
        [
            // assetNo 10
            // random with fix role
            [EnemyType.Non,    RandomSupportHero,  1],
            [EnemyType.Non,    RandomTankHero,     1],
            [EnemyType.Non,    RandomDamageHero,   1],
            [EnemyType.Non,    RandomSupportHero,  1],
            [EnemyType.Non,    RandomTankHero,     1],
            [EnemyType.Non,    RandomDamageHero,   1],
            [EnemyType.Non,    RandomSupportHero,  1],
            [EnemyType.Non,    RandomDamageHero,   1]
        ],
        [
            // assetNo 11
            // random with non role
            [EnemyType.Non,    RandomHero, 1],
            [EnemyType.Non,    RandomHero, 1],
            [EnemyType.Non,    RandomHero, 1],
            [EnemyType.Non,    RandomHero, 1],
            [EnemyType.Non,    RandomHero, 1],
            [EnemyType.Non,    RandomHero, 1],
            [EnemyType.Non,    RandomHero, 1],
            [EnemyType.Non,    RandomHero, 1]
        ],
        [
            // assetNo 12
            // many damage role
            [EnemyType.Non,    FavoriteSupportHero(), 1],
            [EnemyType.Non,    FavoriteSupportHero(), 1],
            [EnemyType.Non,    FavoriteDamageHero(),  6]
        ],
        [
            // assetNo 13
            // many tank role
            [EnemyType.Non,    FavoriteSupportHero(), 1],
            [EnemyType.Non,    FavoriteSupportHero(), 1],
            [EnemyType.Non,    FavoriteTankHero(),    6]
        ],
        // 14,15,16,17,18,19,
        [],[],[],[],[],[],

        // debug asset
        [
            // assetNo 20
            // for debug
            [EnemyType.Non,    Hero.Lucio,  4],
            [EnemyType.Non,    Hero.Cassidy,3],
            [EnemyType.Non,    Hero.Sigma,  1]
        ]
    ];

define buddyAssetNoLotteryList: [
    // fix hero asset
    0, 0,
    1, 1,
    2, 2,

    // random hero asset
    10, 10, 10,
    11,
    12,
    13

    // for debug
    // 20
];

globalvar define isLockedCreateBotsByAsset! = false;

void CreateBotsByAssetWithMutexLock(in define asset!, in define team!, in define addLimitNum!){ 
    // can't implement as subroutin for mutex  
    define forceReleaseCount! = 0;
    while(isLockedCreateBotsByAsset){
        if(forceReleaseCount < 5){
            forceReleaseCount ++;
        }
        else{
            break;
        }
        Wait(1, WaitBehavior.IgnoreCondition);
    }
    isLockedCreateBotsByAsset = true;
    CreateBotsByAsset(asset, team, addLimitNum);
    isLockedCreateBotsByAsset = false;
}

define PlayerNum():
    CountOf(
        FilteredArray(
            AllPlayers(playerTeam),
            !IsDummyBot(ae)
        )
    );

define BuddyNum():
    CountOf(
        FilteredArray(
            AllPlayers(playerTeam),
            IsDummyBot(ae)
        )
    );

define needBuddyNum:
    maxBuddyBotNum - PlayerNum();

globalvar define maxBuddyBotNum! =
    WorkshopSettingInteger("Ally Bot Settings", "Filling Slot Count (join as proxy when player slot absent)", 8, 0, 8, 1);

globalvar define buddyAssetNo!;

globalvar define forceReloadBuddyAsset! = false;

// TAG Buddy/Asset/Interval ----------
define AssetChangeInterval(): RandomInteger(120, 180);
globalvar define reloadBuddyAssetInterval! = -1;

rule: "Buddy/BotAssetInterval/reloadReloadBuddyAsset"
Event.OngoingGlobal
if(
    initCompleted
){
    define prevAssetNo! = -1;

    while(true){
        // if force reload, skip change assetNo and set interval
        if(!forceReloadBuddyAsset){
            // choice asset by random
            buddyAssetNo = RandomValueInArray(buddyAssetNoLotteryList);
            // set default interval
            reloadBuddyAssetInterval = AssetChangeInterval();
        }

        if(
            // force reload
            forceReloadBuddyAsset ||
            // assetNo changed
            prevAssetNo != buddyAssetNo
        ){
            // save current assetNo
            prevAssetNo = buddyAssetNo;
            // save avg ult charge of bots
            define ultCharge! = GetAvgUltChgOfDummyBot(playerTeam);
            // create bots by asset
            DestroyBots(playerTeam);
            CreateBotsByAssetWithMutexLock(buddyAssetList[buddyAssetNo], playerTeam, needBuddyNum);
            // restore avg ult charge of bots
            SetAvgUltChgOfDummyBot(playerTeam, ultCharge);
        }

        // relealse force reload
        forceReloadBuddyAsset = false;
        // wait start intarval until game start.
        WaitUntil(IsGameInProgress() || forceReloadBuddyAsset, MaxValue());

        for(;reloadBuddyAssetInterval > 0 && !forceReloadBuddyAsset; reloadBuddyAssetInterval--){
            Wait(1, WaitBehavior.IgnoreCondition);
        }
    }
}

rule: "Buddy/tuneAssetMemberNum"
Event.OngoingGlobal
if(
    initCompleted
){
    define prevPlayerNum! = -1;

    // set initial asset no
    buddyAssetNo = RandomValueInArray(buddyAssetNoLotteryList);

    while(true){
        if(
            // create bot not locked
            !isLockedCreateBotsByAsset &&
            (
                // playerNum changed
                prevPlayerNum != PlayerNum() ||
                // not filed by need buddy number
                BuddyNum() != needBuddyNum ||
                // entity num than over slot num
                PlayerNum() + BuddyNum() > NumberOfSlots(playerTeam)
            )
        ){
            // save current playerNum
            prevPlayerNum = PlayerNum();
            // force reload asset
            //  but skip change assetNo, reset interval
            forceReloadBuddyAsset = true;
        }

        // check Interval
        WaitUpdateLongCycle();
    }
}

// TAG EnemyBot/BotActive ----------
define canEnemyBotActive:
    IsAlive() &&
    !IsInSpawnRoom();

rule: "EnemyBot/BotActive/activate"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    canEnemyBotActive    
){
    if(
        // has damage
        NormalizedHealth() < 1.0 ||
        // has line of close player
        IsInLineOfSight(
            EyePosition(),
            EyePosition(ClosestPlayerTo(ep, EnemyTeamOf(ep))))
    ){
        isBotActive = true;
        Abort();
    }
    Wait(0.5, WaitBehavior.IgnoreCondition);
    LoopIfConditionIsTrue();
}

rule: "EnemyBot/BotActive/deactive"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    !canEnemyBotActive
){
    isBotActive = false;
}

// TAG EnemyBot/Config ----------
define basicSpawnTimeMin: 
    confirmGameDifficulty == GameDifficulty.EASY ?      14 :
    confirmGameDifficulty == GameDifficulty.NORMAL ?    13 :
    confirmGameDifficulty == GameDifficulty.HARD ?      12 :
    confirmGameDifficulty == GameDifficulty.EXPERT ?    10 :
    confirmGameDifficulty == GameDifficulty.LEGENDARY ? 08 :
    confirmGameDifficulty == GameDifficulty.INSANITY ?  06 :
                                                        12 ;
define spawnTimeMinToMaxScale: 1.25;

define autoTuneDmgDltBase: 20;
define autoTuneDmgDltInitial :
    confirmGameDifficulty == GameDifficulty.EASY ?      10 :
    confirmGameDifficulty == GameDifficulty.NORMAL ?    20 :
    confirmGameDifficulty == GameDifficulty.HARD ?      30 :
    confirmGameDifficulty == GameDifficulty.EXPERT ?    50 :
    confirmGameDifficulty == GameDifficulty.LEGENDARY ? 70 :
    confirmGameDifficulty == GameDifficulty.INSANITY ?  90 :
                                                        20 ;

define autoTuneDmgDltLimit:
    confirmGameDifficulty == GameDifficulty.EASY ?      40 :
    confirmGameDifficulty == GameDifficulty.NORMAL ?    50 :
    confirmGameDifficulty == GameDifficulty.HARD ?      60 :
    confirmGameDifficulty == GameDifficulty.EXPERT ?    80 :
    confirmGameDifficulty == GameDifficulty.LEGENDARY ? 100:
    confirmGameDifficulty == GameDifficulty.INSANITY ?  120:
                                                        50  ;

define upValueScale:
    confirmGameDifficulty == GameDifficulty.EASY ?      2.0 : 
    confirmGameDifficulty == GameDifficulty.NORMAL ?    2.0 : 
    confirmGameDifficulty == GameDifficulty.HARD ?      2.0 : 
    confirmGameDifficulty == GameDifficulty.EXPERT ?    2.0 : 
    confirmGameDifficulty == GameDifficulty.LEGENDARY ? 2.0 : 
    confirmGameDifficulty == GameDifficulty.INSANITY ?  2.0 :
                                                        2.0 ;

define downValueScale:
    confirmGameDifficulty == GameDifficulty.EASY ?      9.0 :
    confirmGameDifficulty == GameDifficulty.NORMAL ?    8.0 :
    confirmGameDifficulty == GameDifficulty.HARD ?      7.0 :
    confirmGameDifficulty == GameDifficulty.EXPERT ?    5.0 :
    confirmGameDifficulty == GameDifficulty.LEGENDARY ? 3.0 :
    confirmGameDifficulty == GameDifficulty.INSANITY ?  1.0 :
                                                        8.0 ;

// TAG EnemyBot/EnemyType ----------
playervar define eachDealtDamageScale!;
playervar define eachMaxSpawnInterval!;
playervar define eachMinSpawnInterval!;
playervar define eachChargeUltInterval!;
playervar define eachBodyScale!;
playervar define eachDeathCost!;

define dealHealScale: IsSupportHero(HeroOf()) ? 3.0 : 1.0;

rule: "EnemyBot/EnemyType/setEnemyType"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    enemyType != EnemyType.Non &&
    confirmGameDifficulty != GameDifficulty.NO_VOTE
){
    // disable builtin respawn for avoid auto teamup
    DisableRespawning();

    // enemy bot don't retreat
    enableRetreat = false;

    // setEnemyType
    if(enemyType == EnemyType.Minion){
        StartForcingDummyBotName(ep, "Minion");
        watchUpdateRate =       4;
        
        eachDeathCost =         25;
        SetMaxHealth(ep,        25);
        SetHealingDealt(ep,     25 * dealHealScale);
        SetHealingReceived(ep,  25);

        eachDealtDamageScale =  0.5;
        eachChargeUltInterval = 60;
        eachMinSpawnInterval =  basicSpawnTimeMin * 1;
        eachMaxSpawnInterval =  eachMinSpawnInterval * spawnTimeMinToMaxScale;
        eachBodyScale =         0.7;
        StartScalingPlayer(ep, eachBodyScale, false);
        StartModifyingHeroVoiceLines(ep, 1.5, false);
    }
    else if(enemyType == EnemyType.Elite){
        StartForcingDummyBotName(ep, "Elite");
        watchUpdateRate =       2;

        eachDeathCost =         100;
        SetMaxHealth(ep,        100);
        SetHealingDealt(ep,     100 * dealHealScale);
        SetHealingReceived(ep,  100);

        eachDealtDamageScale =  1.0;
        eachChargeUltInterval = 30;
        eachMinSpawnInterval =  basicSpawnTimeMin * 2;
        eachMaxSpawnInterval =  eachMinSpawnInterval * spawnTimeMinToMaxScale;
        eachBodyScale =         1.0;
        StartScalingPlayer(ep, eachBodyScale, false);
        StartModifyingHeroVoiceLines(ep, 1.0, false);
    }
    else if(enemyType == EnemyType.SubBoss){
        StartForcingDummyBotName(ep, "Sub Boss");
        watchUpdateRate =       1;

        eachDeathCost =         500;
        SetMaxHealth(ep,        500);
        SetHealingDealt(ep,     150 * dealHealScale);
        SetHealingReceived(ep,  150);

        eachDealtDamageScale =  1.5;
        eachChargeUltInterval = 15;
        eachMinSpawnInterval =  basicSpawnTimeMin * 4;
        eachMaxSpawnInterval =  eachMinSpawnInterval * spawnTimeMinToMaxScale;
        eachBodyScale =         1.5;
        StartScalingPlayer(ep, eachBodyScale, false);
        StartModifyingHeroVoiceLines(ep, 0.5, false);
    }
    else if(enemyType == EnemyType.Boss){
        StartForcingDummyBotName(ep, "Boss");
        watchUpdateRate =       1;

        eachDeathCost =         1000;
        SetMaxHealth(ep,        1000);
        SetHealingDealt(ep,     150 * dealHealScale);
        SetHealingReceived(ep,  150);

        eachDealtDamageScale =  1.5;
        eachChargeUltInterval = 15;
        eachMinSpawnInterval =  basicSpawnTimeMin * 6;
        eachMaxSpawnInterval =  eachMinSpawnInterval * spawnTimeMinToMaxScale;
        eachBodyScale =         2.5;
        StartScalingPlayer(ep, eachBodyScale, false);
        StartModifyingHeroVoiceLines(ep, 0.1, false);
        
        // set addtinal health
        Wait(0.1, WaitBehavior.IgnoreCondition);
        AddHealthPoolToPlayer(ep, HealthType.Armor, MaxHealth(ep) * 0.5, true, false);
        AddHealthPoolToPlayer(ep, HealthType.Shields, MaxHealth(ep) * 0.5, true, false);
    }

    // set yellow outline to threat enemy
    if(IsBossClassEnemy(ep)){
        // StartForcingPlayerOutlines(
        //     ep,
        //     AllPlayers(playerTeam),
        //     true,
        //     Color.Yellow,
        //     OutlineType.Default
        // ); 
    }

    // update params
    UpdateEachDealtDamage();
    UpdateEachSpawnInterval();
}

rule: "EnemyBot/EnemyType/setFullHealth"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.Non &&
    IsAlive()
){
    // heal to max health
    Wait(0.5, WaitBehavior.IgnoreCondition);
    while(Health() < MaxHealth()){
        Heal(ep, null, MaxValue());
        Wait(0.5, WaitBehavior.IgnoreCondition);
    }
}

// TAG EnemyBot/BossIcon ----------
rule: "Player/Icon/showBossIcon"
Event.OngoingPlayer
if(
    enemyTeam == TeamOf() &&
    IsBossClassEnemy(ep) &&
    (
        IsAlive() &&
        !IsInSpawnRoom()
    )
){
    DestroyIcon(icon);
    icon = CreateIcon(AllPlayers(), ep, Icon.Skull,
        IconRev.Position, Color.Team1, false);
}

rule: "Player/Config/hideBossIcon"
Event.OngoingPlayer
if(
    enemyTeam == TeamOf() &&
    IsBossClassEnemy(ep) &&
    !(
        IsAlive() &&
        !IsInSpawnRoom()
    )
){
    DestroyIcon(icon);
}

// TAG EnemyBot/Asset ----------
define maxCreateEnemyBotNum: 8;

globalvar define sameHero!;

define enemyAssetList:
    [
        // random hero asset
        [   
            // assetNo 0
            // basic
            [EnemyType.SubBoss,     RandomHero,         1],
            [EnemyType.Elite,       RandomHero,         3],
            [EnemyType.Minion,      RandomHero,         4]
        ],
        [   
            // assetNo 1
            // sub boss and minion
            [EnemyType.SubBoss,     RandomHero,         1],
            [EnemyType.Minion,      RandomHero,         7]
        ],
        [   
            // assetNo 2
            // all elite
            [EnemyType.Elite,       RandomHero,         3],
            [EnemyType.Elite,       RandomHero,         3],
            [EnemyType.Elite,       RandomHero,         2]
        ],
        [   
            // assetNo 3
            // all elites same hero
            [EnemyType.Elite,       sameHero,           8]
        ],
        [   
            // assetNo 4
            // half elite
            [EnemyType.Elite,       RandomHero,         4],
            [EnemyType.Minion,      RandomHero,         4]
        ],
        [   
            // assetNo 5
            // all minion
            [EnemyType.Minion,      rva([FavoriteDamageHero(), FavoriteTankHero()]),   8]
        ],
        [   
            // assetNo 6
            // double sub boss
            [EnemyType.SubBoss,     RandomHero,         1],
            [EnemyType.SubBoss,     RandomHero,         1],
            [EnemyType.Minion,      RandomHero,         6]
        ],
        [   
            // assetNo 7
            // triple sub boss
            [EnemyType.SubBoss,     RandomHero,         1],
            [EnemyType.SubBoss,     RandomHero,         1],
            [EnemyType.SubBoss,     RandomHero,         1]
        ],
        [   
            // assetNo 8
            // damage boss with minion
            [EnemyType.Boss,        FavoriteDamageHero(),          1],
            [EnemyType.Minion,      RandomHero,         7]
        ],
        // 9,
        [],

        // fix hero asset
        [   
            // assetNo 10
            // Reinhardt army
            [EnemyType.SubBoss,     Hero.Reinhardt,     1],
            [EnemyType.Elite,       Hero.Reinhardt,     3],
            [EnemyType.Minion,      Hero.Reinhardt,     4]
        ],
        [   
            // assetNo 11
            // Soldier76 army
            [EnemyType.SubBoss,     Hero.Soldier76,     1],
            [EnemyType.Elite,       Hero.Soldier76,     3],
            [EnemyType.Minion,      Hero.Soldier76,     4]
        ],
        [   
            // assetNo 12
            // Pharah army
            [EnemyType.SubBoss,     Hero.Pharah,        1],
            [EnemyType.Elite,       Hero.Pharah,        3],
            [EnemyType.Minion,      Hero.Pharah,        4]
        ],
        [   
            // assetNo 13
            // Roadhog army
            [EnemyType.SubBoss,     Hero.Roadhog,       1],
            [EnemyType.Elite,       Hero.Roadhog,       3],
            [EnemyType.Minion,      Hero.Roadhog,       4]
        ],
        [   
            // assetNo 14
            // Bastion army
            [EnemyType.SubBoss,     Hero.Bastion,       1],
            [EnemyType.Elite,       Hero.Bastion,       3],
            [EnemyType.Minion,      Hero.Bastion,       4]
        ],
        [   
            // assetNo 15
            // gun and tank
            [EnemyType.Boss,        Hero.Widowmaker,    1],
            [EnemyType.SubBoss,     Hero.Widowmaker,    3],
            [EnemyType.Minion,      FavoriteTankHero(), 4]   
        ],
        [
            // assetNo 16
            // gun and shield
            [EnemyType.SubBoss,     Hero.Mauga,       1],
            [EnemyType.Elite,       Hero.Sigma,       3],
            [EnemyType.Minion,      Hero.Bastion,     4] 
        ],
        // 17,18,19,
        [],[],[],

        // progress asset
        [
            // assetNo 20
            // damage boss
            [EnemyType.Boss,        FavoriteDamageHero(),   1],
            [EnemyType.Elite,       RandomHero,             3],
            [EnemyType.Minion,      RandomHero,             4]
        ],
        [
            // assetNo 21
            // damage boss with tank elite
            [EnemyType.Boss,        FavoriteDamageHero(),   1],
            [EnemyType.Elite,       FavoriteTankHero(),     5],
            [EnemyType.Minion,      RandomHero,             6]
        ],
        [
            // assetNo 22
            // tank boss
            [EnemyType.Boss,        FavoriteTankHero(),     1],
            [EnemyType.Elite,       FavoriteDamageHero(),   3],
            [EnemyType.Minion,      RandomHero,             4]
        ],
        [
            // assetNo 23
            // double damage boss
            [EnemyType.Boss,        FavoriteDamageHero(),   1],
            [EnemyType.Boss,        FavoriteDamageHero(),   1],
            [EnemyType.Minion,      RandomHero,             6]
        ],
        // 24,25,26,27,28,29,
        [],[],[],[],[],[],

        // debug asset
        [
            // assetNo 30
            [EnemyType.Elite,      RandomValueInArray([
                Hero.Ramattra,
                Hero.WreckingBall,
                Hero.Symmetra,
                Hero.Lucio,
                Hero.Illari
            ]),         12]
        ]
    ];

define enemyAssetNoLotteryList: [
    // random hero asset
    0, 0, 0, 0,
    1, 1, 1, 1,
    2, 2, 2, 2,
    3, 3,
    4, 4,
    5,
    6,
    7,
    8,

    // fix hero asset
    10,10,
    11,11,
    12,
    13,
    14,
    15,15,15,15,
    16

    // for debug
    // 30
];


// TAG EnemyBot/Asset/Interval ----------
globalvar define reloadEnemyAssetInterval! = -1;
globalvar define enemyAssetNo! = -1;
globalvar define hasProgressAssetNo! = false;

rule: "EnemyBot/Asset/Interval/reloadReloadEnemyAsset"
Event.OngoingGlobal
if(
    initCompleted &&
    (
        IsGameInProgress() ||
        (
            IsInSetup() &&
            MatchTime() <= 5
        )
    )
){
    while(true){
        // play effect at all enemy
        PlayEffectsToTeam(enemyTeam);

        // if hasProgressAssetNo, skip change assetNo
        if(!hasProgressAssetNo){
            // choice asset by random
            enemyAssetNo = RandomValueInArray(enemyAssetNoLotteryList);
            // set default interval
            reloadEnemyAssetInterval = AssetChangeInterval();
            // change some hero
            sameHero = RandomHero;
        }

        // relealse hasProgressAssetNo
        hasProgressAssetNo = false;

        // create bots by asset
        DestroyBots(enemyTeam);
        CreateBotsByAssetWithMutexLock(enemyAssetList[enemyAssetNo], enemyTeam, maxCreateEnemyBotNum);
        // wait start intarval until game start.
        WaitUntil(IsGameInProgress(), MaxValue());

        for(;
            reloadEnemyAssetInterval > 0 &&
            // if hasProgressAssetNo, skip interval count and reload asset
            !hasProgressAssetNo;
            reloadEnemyAssetInterval--){
            Wait(1, WaitBehavior.IgnoreCondition);
        }
    }
}

rule: "EnemyBot/Asset/Interval/reloadBotAssetIntervalByProgress"
Event.OngoingGlobal
if(
    initCompleted &&
    IsGameInProgress()
){
    define progressStage! = 0;

    while(true){
        define progress! = ObjectProgress(playerTeam);
        if(CurrentGameMode() == GameMode.Push){
            progress = progress - 50;
            progress *= 2;
        }
        
        define progressAssetNo! = -1;
        define progressAssetInterval!;

        if(
            progressStage == 0 && progress >= 10
        ){
            if(!HasObjectDirection()){
                spawnRushInterval = 0;
            }
            progressStage ++;
        }
        else if(
            progressStage == 1 && progress >= 20
        ){
            if(!HasObjectDirection()){
                spawnRushInterval = 0;
            }
            progressStage ++;
        }
        else if(
            progressStage == 2 && progress >= 30
        ){
            progressAssetNo = 20;
            progressAssetInterval = (AssetChangeInterval() - 60);
            progressStage ++;
        }
        else if(
            progressStage == 3 && progress >= 60
        ){
            progressAssetNo = 21;
            progressAssetInterval = (AssetChangeInterval() - 60);
            progressStage ++;
        }
        else if(
            progressStage == 4 && progress >= (FinaleProgress() - 5)
        ){
            progressAssetNo = RandomValueInArray([22, 23]);
            progressAssetInterval = MaxValue();
            progressStage ++;
        }

        // has progress asset
        if(progressAssetNo != -1){
            // set assetNo from progress asset
            // set interval from progress asset interval
            enemyAssetNo = progressAssetNo;
            reloadEnemyAssetInterval = progressAssetInterval;
            // set flag for skip change assetNo
            hasProgressAssetNo = true;
        }

        // check Interval
        WaitUpdateMediumCycle();
    }
}

void PlayEffectsToTeam(define team!) "PlayEffectsToTeam"{
    define players! = AllPlayers(team);
    for(define playersIndex! = 0; playersIndex < CountOf(players); playersIndex ++){
        // play blast
        PlayEffect(
            AllPlayers(), PlayEffect.BadExplosion,
            TeamOf(players[playersIndex]) == enemyTeam ?
                enemyColor :
                Color.Yellow,
            BodyPosition(players[playersIndex]),
            TeamOf(players[playersIndex]) == enemyTeam ?
                players[playersIndex].eachBodyScale * 1.5 : 
                1.5
            );
    }
    Wait(0.1, WaitBehavior.IgnoreCondition);
}


// TAG EnemyBot/Effect ----------
define enemyColor: Color.Team1;

define IsBossClassEnemy(in define player):
    player.enemyType == EnemyType.SubBoss ||
    player.enemyType == EnemyType.Boss;

define isInCombat:
    actionState != ActionState.Non &&
    (
        IsAlive() &&
        !IsInSpawnRoom()
    );

// TAG EnemyBot/Teleport ----------
define teleportAreaSize: 8;
define teleportAreaExtendScaleByNonObjectDirection: teleportAreaSize * 1.0;
define teleportAreaExtendScaleByBlockedAheadDist: 0.4;
define teleportAreaOffsetDistFromObject: 40;
define minDistOfRenewCommonTeleportBasePosition: teleportAreaSize * 1.0;
define probOfRenewCommonTeleportBasePosition: 5;
define probOfReuseCommonTeleportBasePosition: 90;

define IsPlayerOnObject: (0 < NumberOfPlayersOnObjective(playerTeam));
define IsEnemyOnObject: (0 < NumberOfPlayersOnObjective(enemyTeam));
define searchPositionInterval: 0.2;
define searchPositionTryCountMax: (1 / searchPositionInterval) * 3;

playervar define teleportPosition;
globalvar define commonTeleportBasePosition;

define CanEncountPosition(define position)"CanEncountPosition"{
    define canEncount = false;

    define player = ClosestPlayerTo(position, playerTeam);
    if(
        // position valid
        position != null
                &&
        // // not close to near enemy
        // DistanceBetween(position, player) >= minDistToEnemyWhenTeleport
        //      &&
        // Has line to near enemy
        IsInLineOfSight(
            PositionOffsetY1() + position,
            PositionOffsetY1() + PositionOf(player),
            BarrierLOS.NoBarriersBlock)
    ){
        canEncount = true;
    }

    return canEncount;
}

define GetTeleportPositionByClosestPlayer() playervar "GetTeleportPositionByClosestPlayer"{
    define canTelPosition = null;

    define objectPosition = CurrentObjectPosition();
    if(objectPosition == null){
        return false;
    }

    define teleportBasePosition = PositionOf(ClosestPlayerTo(objectPosition, playerTeam));

    if(
        // walkable position is far
        (
            CurrentMap() == Map.Kings_Row ||
            CurrentMap() == Map.Kings_Row_Winter
        )
            &&
        ObjectiveIndex() == 0
    ){
        canTelPosition =
            teleportBasePosition
                + 
            (
                DirectionTowards(teleportBasePosition, objectPosition)
                    *
                DistanceBetween(teleportBasePosition, objectPosition) * 0.5
            )
                +
            RandomPosition(
                teleportAreaSize,
                teleportAreaSize,
                teleportAreaSize
            );
    }

    for(define searchPositionTryCount = 0; searchPositionTryCount < searchPositionTryCountMax; searchPositionTryCount++){
        // select teleportPosition from middle of Object and teleportBasePosition
        define candidatePosition =
            NearestWalkablePosition(
                teleportBasePosition
                    + 
                (
                    DirectionTowards(teleportBasePosition, objectPosition)
                        *
                    DistanceBetween(teleportBasePosition, objectPosition) * 0.5
                )
                    +
                RandomPosition(
                    teleportAreaSize,
                    teleportAreaSize,
                    teleportAreaSize
                )
            );

        if(
            // can encount enemy
            CanEncountPosition(candidatePosition)
        ){
            canTelPosition = candidatePosition;
            break;
        }

        WaitReleaseServerLoad(ServerLoadType.GameMain);
        Wait(searchPositionInterval, WaitBehavior.AbortWhenFalse);
    }

    return canTelPosition;
}

globalvar define teleportAreaExtendSize;
globalvar define blockedPositionObjectAhead;

define GetTeleportPositionByObjectDirection() playervar "GetTeleportPositionByObjectDirection"{
    define canTelPosition = null;

    define teleportBasePosition = CurrentObjectOnPosition();
    if(teleportBasePosition == null){
        return false;
    }

    // If there is a wall in the Object direction and the offset distance of the teleport area is not enough,
    //   increase the teleport area size by cut off distance
    if(
        // has object direction
        HasObjectDirection()
    ){
        if(
            // player on object
            IsPlayerOnObject
        ){
            // get blocked position of Object ahead
            blockedPositionObjectAhead = BlockedPositon(teleportBasePosition, objectDirection, teleportAreaOffsetDistFromObject);
            // change teleportBasePosition to blocked position
            teleportBasePosition = blockedPositionObjectAhead;
            // get teleportAreaExtendSize by cut off distance with scale
            teleportAreaExtendSize =
                (
                    // get cut off distance by blocked position
                    teleportAreaOffsetDistFromObject -
                    DistanceBetween(blockedPositionObjectAhead, blockedPositionObjectAhead)
                ) *
                // apply extend scale
                teleportAreaExtendScaleByBlockedAheadDist;
        }
        else{
            // clear extend size by non cut off distance of object direction
            teleportAreaExtendSize = 0;
        }
    }
    else{
        // get teleportAreaExtendSize by fixed value of non object direction
        teleportAreaExtendSize = teleportAreaExtendScaleByNonObjectDirection;
    }

    for(define searchPositionTryCount = 0; searchPositionTryCount < searchPositionTryCountMax; searchPositionTryCount++){
        // select teleportPosition from teleportBasePosition around
        define candidatePosition = 
            NearestWalkablePosition(
                teleportBasePosition
                    +
                RandomPosition(
                    teleportAreaSize + teleportAreaExtendSize,
                    teleportAreaSize + teleportAreaExtendSize,
                    teleportAreaSize + teleportAreaExtendSize
                )
            );

        if(
            // can encount enemy
            CanEncountPosition(candidatePosition)
        ){
            canTelPosition = candidatePosition;
            break;
        }

        WaitReleaseServerLoad(ServerLoadType.GameMain);
        Wait(searchPositionInterval, WaitBehavior.AbortWhenFalse);
    }

    return canTelPosition;
}

define GetTeleportPositionByCommonPosition() playervar "GetTeleportPositionByCommonPosition"{
    define canTelPosition = null;

    define teleportBasePosition = commonTeleportBasePosition;
    if(teleportBasePosition == null){
        return false;
    }

    for(define searchPositionTryCount = 0; searchPositionTryCount < searchPositionTryCountMax; searchPositionTryCount++){
        // select teleportPosition from teleportBasePosition around
        define candidatePosition = 
            NearestWalkablePosition(
                teleportBasePosition
                    +
                RandomPosition(
                    teleportAreaSize,
                    teleportAreaSize,
                    teleportAreaSize
                )
            );

        if(
            // can encount enemy
            CanEncountPosition(candidatePosition)
        ){
            canTelPosition = candidatePosition;
            break;
        }

        WaitReleaseServerLoad(ServerLoadType.GameMain);
        Wait(searchPositionInterval, WaitBehavior.AbortWhenFalse);
    }

    return canTelPosition;
}

playervar define telBeam;

void TeleportWithEffect(define isBeamFromBody!) playervar "TeleportWithEffect"{
    if(teleportPosition == null){return;}

    if(IsInSpawnRoom()){
        Wait(SlotOf() * 0.2, WaitBehavior.AbortWhenFalse);
    }

    // show pre teleport effect
    PlayTeleportEffect(true, isBeamFromBody);
    // Teleport
    Teleport(ep, teleportPosition);
    // show teleport effect
    PlayTeleportEffect(false, isBeamFromBody);
    // hide teleport beam effect
    DestroyEffect(telBeam);
}

define showTeleportBeamTime: 0.5;
define scaleBodySizeToEffectSize: 1.5;

void PlayTeleportEffect(define isBefore!, define isBeamFromBody!) playervar "PlayTeleportEffect"{
    define effectSize! = eachBodyScale * scaleBodySizeToEffectSize;

    // if before teleport
    if(isBefore){
        // play teleport shadow to own position
        PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, enemyColor, PositionOf(ep), effectSize);
        // play teleport blast to teleport positon
        PlayEffect(AllPlayers(), PlayEffect.BadExplosion, enemyColor, teleportPosition, effectSize);
        // show teleport beam to own position
        DestroyEffect(telBeam);
        // define fromSky! = true;
        telBeam = CreateBeamEffect(AllPlayers(),
            BeamType.BadBeam,
            isBeamFromBody ? 
                PositionOf() + Vector(0, eachBodyScale * 1.2, 0) :
                teleportPosition + Vector(0, 30, 0),
            teleportPosition + Vector(0, eachBodyScale * 1.2, 0),
            enemyColor, EffectRev.VisibleToPositionAndRadius);
        // wait for show teleport shadow of before
        Wait(showTeleportBeamTime, WaitBehavior.IgnoreCondition);
    }
    else{
        // hide teleport beam to teleport positon
        DestroyEffect(telBeam);
        // play teleport shadow to teleport positon
        PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, enemyColor, PositionOf(ep), effectSize);
        // play teleport sound
        PlayEffect(AllPlayers(), PlayEffect.RingExplosionSound, null, PositionOf(ep), 75);
    }
}

void DoTeleport(define isBeamFromBody!, define isEmgTeleport!)"DoTeleport"{
    define needGetNewPosition!;

    if(!isEmgTeleport){
        // set teleportPosition with update commonTeleportBasePosition
        if(
            // has need update flag
            needUpdateCommonTeleportBasePosition
        ){
            needGetNewPosition = true;
        }
        // set teleportPosition
        else{
            if(
                commonTeleportBasePosition != null &&
                // by prob
                IsProbabilityTrue(probOfReuseCommonTeleportBasePosition)
            ){
                needGetNewPosition = false;
            }
            else{
                needGetNewPosition = true;
            }
        }
    }
    else{
        needGetNewPosition = false;
    }

    // do emergency teleport as threat enemy 
    if(
        isEmgTeleport
    ){
        // set teleportPosition by object position
        teleportPosition = CurrentObjectOnPosition() + (objectDirection * 3);
    }
    else if(needGetNewPosition){
        // set teleportPosition by calc new position
        if(
            // player on object
            IsPlayerOnObject
        ){
            teleportPosition = GetTeleportPositionByObjectDirection();
        }
        else if(
            IsNeedEscortObject(enemyTeam)
        ){
            teleportPosition = CurrentObjectPosition();
        }
        else{
            teleportPosition = GetTeleportPositionByClosestPlayer();
        }

        if(needUpdateCommonTeleportBasePosition){
            if(teleportPosition != null){
                // renew common position
                commonTeleportBasePosition = teleportPosition;
                needUpdateCommonTeleportBasePosition = false;
            }
        }
    }
    else{
        // set teleportPosition by reuse common position
        teleportPosition = GetTeleportPositionByCommonPosition();
    }


    if(teleportPosition != null){
        // teleport to teleportPosition
        TeleportWithEffect(isBeamFromBody);
    }
}

// TAG EnemyBot/Teleport/CheckUpdateCommonTeleportBasePosition ----------
globalvar define needUpdateCommonTeleportBasePosition!;
globalvar define baseSmoke!;

rule: "EnemyBot/Teleport/CheckUpdateCommonTeleportBasePosition"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    // if(baseSmoke == null){
    //     // base smoke
    //     baseSmoke = CreateEffect(commonTeleportBasePosition != null ? AllPlayers() : null,
    //         Effect.Cloud, enemyColor, commonTeleportBasePosition,
    //         teleportAreaSize, EffectRev.VisibleToPositionAndRadius);
    // }

    // need check update
    if(!needUpdateCommonTeleportBasePosition){
        // set update flag of commonTeleportBasePosition

        if(
            // position invalid
            commonTeleportBasePosition == null
        ){
            needUpdateCommonTeleportBasePosition = true;
        }
        else if(
            // by prob
            IsProbabilityTrue(probOfRenewCommonTeleportBasePosition)
        ){
            needUpdateCommonTeleportBasePosition = true;
        }
        else if(
            // too close to near enemy
            DistanceBetween(
                commonTeleportBasePosition,
                ClosestPlayerTo(commonTeleportBasePosition, playerTeam)) < minDistOfRenewCommonTeleportBasePosition        
        ){
            needUpdateCommonTeleportBasePosition = true;
        }
        else if(
            // player on object
            IsPlayerOnObject &&
            HasObjectDirection() ?
                // position too far from bloeckd position
                DistanceBetween(commonTeleportBasePosition, blockedPositionObjectAhead) > teleportAreaSize + teleportAreaExtendSize :
                // position too far from object position
                DistanceBetween(commonTeleportBasePosition, CurrentObjectPosition()) > teleportAreaSize
        ){
            needUpdateCommonTeleportBasePosition = true;
        }
        else if(
            // player on object
            IsPlayerOnObject &&
            // Has not line to objectPosition or blockedPosition
            !IsInLineOfSight(
                PositionOffsetY1() + commonTeleportBasePosition,
                CurrentObjectOnPosition(),
                BarrierLOS.NoBarriersBlock)
        ){
            needUpdateCommonTeleportBasePosition = true;
        }
    }

    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}

rule: "EnemyBot/Teleport/clearCommonTeleportBasePosition"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    Attacker() == ep
){
    if(IsProbabilityTrue(25)){
        // reset position by enemy sucide of invalid position
        needUpdateCommonTeleportBasePosition = true;
    }
}

rule: "EnemyBot/Teleport/teleportByRespawn"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsGameInProgress() &&
    IsInSpawnRoom()
){
    DoTeleport(false, false);
    Wait(1, WaitBehavior.AbortWhenFalse);
    WaitReleaseServerLoad(ServerLoadType.GameMain);
    LoopIfConditionIsTrue();
}

define checkTeleportConditionInterval: 1;
define checkTeleportConditionMaxCount: 3;

rule: "EnemyBot/Teleport/teleportOrHopForDefendObjectOnIdle"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsGameInProgress() &&
    !IsInSpawnRoom() &&
    IsAlive()
){
    define checkConditionCount = 0;

    while(checkConditionCount < checkTeleportConditionMaxCount){
        if(
            // player on object
            IsPlayerOnObject &&
            // far from object
            DistanceBetween(ep, CurrentObjectPosition()) > ActionRange.CanFind
        ){
            // do teleport instantly
            break;
        }
        else if(
            // has line of close player
            IsInLineOfSight(
                EyePosition(ep),
                EyePosition(ClosestPlayerTo(ep, EnemyTeamOf(ep))))
        ){
            // reset count
            checkConditionCount = 0;
        }
        else{
            // keep position and count up
            checkConditionCount ++;
        }

        Wait(checkTeleportConditionInterval, WaitBehavior.AbortWhenFalse);
        WaitReleaseServerLoad(ServerLoadType.GameMain);
    }

    define objectPosition! = CurrentObjectPosition();
    define dist! = DistanceBetween(ep, objectPosition);
    if(
        IsNeedEscortObject(enemyTeam) &&
        IsInLineOfSight(
            EyePosition(ep),
            PositionOffsetY1() + objectPosition)
    ){
        ApplyImpulse(ep, 
            VectorTowards(ep, objectPosition + Vector(0, dist * 0.25, 0)),
            dist * 2.5,
            Relative.ToWorld, ContraryMotion.Cancel);
    }
    else{
        // teleport
        DoTeleport(false, false);
    }


    LoopIfConditionIsTrue();
}

// TAG EnemyBot/SpawnInterval ----------

define showDeadEffectTime: 1.0;
globalvar define spawnTimeScale;
playervar define confirmSpawnInterval;

void UpdateEachSpawnInterval()"UpdateEachSpawnInterval"{
    define diff! = GameProgressDiff(playerTeam);
    if(70 <= diff){
        spawnTimeScale = 0;
    }
    else if(40 <= diff && diff < 70){
        spawnTimeScale = 0.25;
    }
    else if(10 <= diff && diff < 40){
        spawnTimeScale = 0.5;
    }
    else if(-10 <= diff && diff < 10){
        spawnTimeScale = 1.0;
    }
    else if(-40 <= diff && diff < -10){
        spawnTimeScale = 1.5;
    }
    else if(-70 <= diff && diff < -40){
        spawnTimeScale = 2.0;
    }
    else if(diff < -70){
        spawnTimeScale = 2.5;
    }

    confirmSpawnInterval = ObjectProgressScaledInterval(playerTeam, eachMinSpawnInterval, eachMaxSpawnInterval, 0);
    confirmSpawnInterval *= spawnTimeScale;
    confirmSpawnInterval *= WorkshopSettingReal("Enemy Bot Settings", "Basic Spawn Intarval Scale", 1.0, 0.01, 100, 1);
    // SetRespawnMaxTime(ep, confirmSpawnInterval);
}

rule: "EnemyBot/SpawnInterval/update"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.Non &&
    IsGameInProgress()
){
    UpdateEachSpawnInterval();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

rule: "EnemyBot/SpawnInterval/waitRespawn"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    IsDead()
){
    Wait(showDeadEffectTime, WaitBehavior.AbortWhenFalse);
    if(Attacker() != ep){
        Wait(confirmSpawnInterval, WaitBehavior.AbortWhenFalse);
    }
    Respawn();
    // fail safe
    Wait(1, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/DealtDamage ----------
globalvar define autoTuneDmgDlt;
globalvar define enemyDeathCount = [0,0,0,0];  // for debug
globalvar define playerDeathCount = 0;  // for debug

rule: "EnemyBot/DealtDamage/init"
Event.OngoingGlobal
if(
    confirmGameDifficulty != GameDifficulty.NO_VOTE
){
    autoTuneDmgDlt = autoTuneDmgDltInitial;
}

rule: "EnemyBot/DealtDamage/upTune"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    Attacker() != ep
){
    define upValue! = eachDeathCost * 0.01;
    upValue *= upValueScale;
    autoTuneDmgDlt += upValue;
    autoTuneDmgDlt = autoTuneDmgDlt > autoTuneDmgDltLimit ? autoTuneDmgDltLimit : autoTuneDmgDlt;

    enemyDeathCount[ep.enemyType - 1] ++;
        // dbgLogFile(<"autoTuneDmgDlt = <0>, upValue = <1>, enemyDeathCount[<2>] = <3>", autoTuneDmgDlt, upValue, ep.enemyType - 1, enemyDeathCount[ep.enemyType - 1]>);
}

rule: "EnemyBot/DealtDamage/downTune"
Event.OnDeath
if(
    TeamOf() == playerTeam &&
    Attacker() != ep
){
    define downValue! = NumberOfSlots(playerTeam) / NumberOfPlayers(playerTeam);
    if(!IsDummyBot(ep)){
        downValue *= 3;
    }
    else{
        downValue *= 1;
    }
    
    downValue *= downValueScale;
    autoTuneDmgDlt -= downValue;
    autoTuneDmgDlt = autoTuneDmgDlt < autoTuneDmgDltInitial ? autoTuneDmgDltInitial : autoTuneDmgDlt;

    playerDeathCount ++;
        // dbgLogFile(<"autoTuneDmgDlt = <0>, downValue = <2>, playerDeathCount = <2>", autoTuneDmgDlt, downValue, playerDeathCount>);
}

playervar define confirmDealtDamage;

void UpdateEachDealtDamage()"UpdateEachDealtDamage"{
    // set auto tune damage
    confirmDealtDamage = autoTuneDmgDlt;
    // apply setting scale
    confirmDealtDamage *= WorkshopSettingReal("Enemy Bot Settings", "Enemy Deal Damage Scale", 1.0, 0.01, 100, 0);
    // apply enemy type scale
    confirmDealtDamage *= eachDealtDamageScale;
    // apply team balance
    confirmDealtDamage /= ConvertToBalancedValue(1.5, playerTeam);
    SetDamageDealt(ep, confirmDealtDamage);
}

rule: "EnemyBot/DealtDamage/update"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.Non &&
    IsGameInProgress()
){
    UpdateEachDealtDamage();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/ReceivedDamage ----------
globalvar define confirmReceiveDamage;

void UpdateEachReceivedDamage()"UpdateEachReceivedDamage"{
    // set base damage
    confirmReceiveDamage = DefaultPercentage();
    // apply team balance
    confirmReceiveDamage *= ConvertToBalancedValue(1.5, playerTeam);
    SetDamageReceived(AllPlayers(enemyTeam), confirmReceiveDamage);
}

rule: "EnemyBot/ReceivedDamage/update"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    UpdateEachReceivedDamage();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/ChargeUltimate ----------
rule: "EnemyBot/ChargeUltimate/charge"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.Non &&
    IsGameInProgress() &&
    !IsUsingUltimate()
){
    SetUltimateCharge(ep, UltimateChargePercent() + (DefaultPercentage() / eachChargeUltInterval));
    WaitUpdateASecond();
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/ObstIcon ----------
playervar define obstIcon;
define warningColor: isBlink ? Color.Red : Color.Yellow;

rule: "EnemyBot/ObstIcon/show"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    (
        IsPlayerOnObject &&
        IsOnObjective(ep)
    )
){
    DestroyIcon(obstIcon);
    obstIcon = CreateIcon(AllPlayers(playerTeam), ep, Icon.ExclamationMark,
        IconRev.PositionAndColor, warningColor, true);
}

rule: "EnemyBot/ObstIcon/hide"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    !(
        IsPlayerOnObject &&
        IsOnObjective(ep)
    )
){
    DestroyIcon(obstIcon);
}

globalvar define isBlink;

rule: "EnemyBot/ObstIcon/blinkColor"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    while(true){
        isBlink = !isBlink;
        Wait(0.2, WaitBehavior.AbortWhenFalse);
    }
}

// TAG EnemyBot/EnemyAbility/SpawnRush ----------
globalvar define spawnRushInterval;
globalvar define spawnRushCount;

rule: "EnemyBot/EnemyAbility/SpawnRush"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    // set default interval
    spawnRushInterval = ObjectProgressScaledInterval(playerTeam, 20, 40, 5);
    spawnRushInterval *= WorkshopSettingReal("Enemy Bot Settings", "Spawn-Rush Interval Scale", 1.0, 0.01, 100, 2);
    spawnRushInterval = RoundToInteger(spawnRushInterval, Rounding.Up);
    for(;spawnRushInterval > 0; spawnRushInterval--){
        Wait(1, WaitBehavior.IgnoreCondition);
    }

    // show text
    // DestroyHudText(spawnRushWarningHud);
    // spawnRushWarningHud = CreateHudText(AllPlayers(),
    //     "ENEMY SPAWN RUSH INCOMING!", null, null,
    //     Location.Top, 10,
    //     warningIconColor, Color.White, Color.White,
    //     HudTextRev.Color, Spectators.VisibleAlways);

    // action
    define spawnRushDuration! = RandomInteger(5, 20);
    spawnRushDuration *= WorkshopSettingReal("Enemy Bot Settings", "Spawn-Rush Duration Scale", 1.0, 0.01, 100, 2);
    define deployRushInterval! = RandomInteger(1, 5);
    spawnRushCount = RoundToInteger(spawnRushDuration / deployRushInterval, Rounding.Down);
    for(; spawnRushCount > 0; spawnRushCount--){
        Respawn(
            FilteredArray(
                AllDeadPlayers(enemyTeam),
                (
                    ae.enemyType != EnemyType.Boss
                )
            )
        );
        
        Wait(deployRushInterval, WaitBehavior.IgnoreCondition);
        WaitReleaseServerLoad(ServerLoadType.GameMain);
    }

    // hide text
    // Wait(1, WaitBehavior.IgnoreCondition);
    // DestroyHudText(spawnRushWarningHud);

    LoopIfConditionIsTrue();
}

// TAG EnemyBot/EnemyAbility/ShotCall ----------
globalvar define shotCallInterval;

rule: "EnemyBot/EnemyAbility/ShotCall"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    // set default interval
    shotCallInterval = ObjectProgressScaledInterval(playerTeam, 20, 40, 5);
    shotCallInterval *= WorkshopSettingReal("Enemy Bot Settings", "All-Out-Ultmate Interval Scale", 1.0, 0.01, 100, 3);
    shotCallInterval = RoundToInteger(shotCallInterval, Rounding.Up);
    for(;shotCallInterval > 0; shotCallInterval--){
        Wait(1, WaitBehavior.IgnoreCondition);
    }

    // show text
    // DestroyHudText(shotCallWarningHud);
    // shotCallWarningHud = CreateHudText(AllPlayers(),
    //     "ENEMY ALL-OUT ULTIMATE INCOMING!", null, null,
    //     Location.Top, 11,
    //     warningIconColor, Color.White, Color.White,
    //     HudTextRev.Color, Spectators.VisibleAlways);

    // action
    define activeEnemys! = AllPlayers(enemyTeam);
    define shotCallDelay! = RandomReal(0.2, 1.0);
    for(define scLoopIndex! = 0; scLoopIndex < CountOf(activeEnemys); scLoopIndex ++){
        if(
            IsAlive(activeEnemys[scLoopIndex]) &&
            !IsInSpawnRoom(activeEnemys[scLoopIndex])
        ){
            SetUltimateCharge(activeEnemys[scLoopIndex], DefaultPercentage());
            PressButton(activeEnemys[scLoopIndex], Button.Ultimate);

            Wait(shotCallDelay, WaitBehavior.IgnoreCondition);
            WaitReleaseServerLoad(ServerLoadType.GameMain);
        }
    }

    // hide text
    // Wait(1, WaitBehavior.IgnoreCondition);
    // DestroyHudText(shotCallWarningHud);

    LoopIfConditionIsTrue();
}

// TAG EnemyBot/EnemyAbility/CombatTeleport ----------
playervar define combatTeleportInterval;

rule: "EnemyBot/EnemyAbility/CombatTeleport"
Event.OngoingPlayer
if(
    IsGameInProgress() &&
    TeamOf() == enemyTeam &&
    IsBossClassEnemy(ep)
){
    // set default interval
    combatTeleportInterval = ObjectProgressScaledInterval(playerTeam, 10, 20, 5);
    combatTeleportInterval *= WorkshopSettingReal("Enemy Bot Settings", "(Sub Boss & Boss) Combat-Teleport Interval Scale", 1.0, 0.01, 100, 4);
    if(actionRangeMax == ActionRange.Melee){
        combatTeleportInterval *= 1;
    }
    else if(actionRangeMax == ActionRange.Close){
        combatTeleportInterval *= 2.0;
    } 
    else if(actionRangeMax == ActionRange.Middle){
        combatTeleportInterval *= 3.0;
    } 
    else if(actionRangeMax == ActionRange.Far){
        combatTeleportInterval *= 4;
    }
    combatTeleportInterval = RoundToInteger(combatTeleportInterval, Rounding.Up);

    define isEmgTeleport! = false;

    for(;combatTeleportInterval > 0; combatTeleportInterval --){
        if(
            // player team close win
            IsCloseWin(playerTeam) &&
            // enemy not on object
            !IsEnemyOnObject &&
            // player on object
            IsPlayerOnObject
        ){
            // instantly teleport for defend object in finale phase
            isEmgTeleport = true;
            break;
        }

        Wait(1, WaitBehavior.IgnoreCondition);
        WaitReleaseServerLoad(ServerLoadType.GameMain);
    }

    if(IsAlive()){
        // teleport with teleport beam from body
        // teleport with emergency by close lose
        DoTeleport(true, isEmgTeleport);
    }
    LoopIfConditionIsTrue();
}

define moreAbilityProb: DefaultPercentage();
define moreAbilityInterval: RandomReal(0.1, 3);

globalvar define moreUltProb;

rule: "EnemyBot/EnemyAbility/moreUltimate"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsBossClassEnemy(ep) &&
    IsAlive() &&
    actionState != ActionState.Non &&
    IsUsingUltimate()
){
    WaitUntil(!IsUsingUltimate(), MaxValue());    
    
    moreUltProb = moreAbilityProb;
    while(
        IsAlive() &&
        IsProbabilityTrue(moreUltProb)
    ){
        SetUltimateCharge(ep, DefaultPercentage());
        WaitReleaseServerLoad(ServerLoadType.GameMain);
        Wait(moreAbilityInterval, WaitBehavior.IgnoreCondition);
        PressButton(ep, Button.Ultimate);
        WaitUntil(!IsUsingUltimate(), MaxValue());
    }
    moreUltProb = 0;

    WaitUntil(!IsUsingUltimate(), MaxValue());
    Wait(1, WaitBehavior.IgnoreCondition);
}

globalvar define decreaseProb! =
    WorkshopSettingReal("Enemy Bot Settings", "(Sub boss & Boss) Rapid-Fire-Ultimate Termination Scale", 1.0, 0.01, 10, 5) * 10;

rule: "EnemyBot/EnemyAbility/decreaseMultiUltimateProb"
Event.OngoingGlobal
if(
    moreUltProb > 0
){
    moreUltProb -= moreUltProb < decreaseProb ? moreUltProb : decreaseProb;
    Wait(1.0, WaitBehavior.IgnoreCondition);
    LoopIfConditionIsTrue();
}

// rule: "EnemyBot/EnemyAbility/moreAbility1"
// Event.OngoingPlayer
// if(
//     TeamOf() == enemyTeam &&
//     IsBossClassEnemy(ep) &&
//     IsAlive() &&
//     actionState != ActionState.Non &&
//     IsUsingAbility1()
// ){
//     while(
//         IsAlive() &&
//         IsProbabilityTrue(moreAbilityProb)
//     ){
//         WaitUntil(!IsUsingAbility1(), 30);
//         AddAbilityStock(Button.Ability1, 1);
//         WaitReleaseServerLoad(ServerLoadType.GameMain);
//         Wait(moreAbilityInterval, WaitBehavior.AbortWhenFalse);
//         PressButton(ep, Button.Ability1);
//     }
// }

// rule: "EnemyBot/EnemyAbility/moreAbility2"
// Event.OngoingPlayer
// if(
//     TeamOf() == enemyTeam &&
//     IsBossClassEnemy(ep) &&
//     IsAlive() &&
//     actionState != ActionState.Non &&
//     IsUsingAbility2()
// ){
//     while(
//         IsAlive() &&
//         IsProbabilityTrue(moreAbilityProb)
//     ){
//         WaitUntil(!IsUsingAbility2(), 30);
//         AddAbilityStock(Button.Ability2, 1);
//         WaitReleaseServerLoad(ServerLoadType.GameMain);
//         Wait(moreAbilityInterval, WaitBehavior.AbortWhenFalse);
//         PressButton(ep, Button.Ability2);
//     }
// }

// rule: "EnemyBot/EnemyAbility/moreSecondary"
// Event.OngoingPlayer
// if(
//     TeamOf() == enemyTeam &&
//     IsBossClassEnemy(ep) &&
//     IsAlive() &&
//     actionState != ActionState.Non &&
//     IsFiringSecondary()
// ){
//     while(
//         IsAlive() &&
//         IsProbabilityTrue(moreAbilityProb)
//     ){
//         WaitUntil(!IsFiringSecondary(), 30);
//         AddAbilityStock(Button.SecondaryFire, 1);
//         WaitReleaseServerLoad(ServerLoadType.GameMain);
//         Wait(moreAbilityInterval, WaitBehavior.IgnoreCondition);
//         PressButton(ep, Button.SecondaryFire);
//     }
// }

// TAG Debug ----------

globalvar define countDetectTriggerServerLoadPerSecond;

rule: "DebugGlobalAction"
Event.OngoingGlobal
Team.All
if(
    initCompleted
){
    // // enemy common teleport positon blue icon
    // CreateIcon(commonTeleportBasePosition != null ? hp : null,
    //     commonTeleportBasePosition + PositionOffsetY1(), Icon.Spiral,
    //     IconRev.VisibleToAndPosition, enemyColor, true);
    // // teleportAreaSize blue ring
    // CreateEffect(commonTeleportBasePosition != null ? hp : null, Effect.Ring, enemyColor,
    //     commonTeleportBasePosition + PositionOffsetY1(), teleportAreaSize, EffectRev.VisibleToPositionAndRadius);
    // // minDistOfRenewCommon white ring
    // CreateEffect(commonTeleportBasePosition != null ? hp : null, Effect.Ring, Color.White,
    //     commonTeleportBasePosition + PositionOffsetY1(), minDistOfRenewCommonTeleportBasePosition * 0.97, EffectRev.VisibleToPositionAndRadius);
    // // commonTeleportBasePosition -> blockedPosition or objectPosition white beam
    // CreateBeamEffect(hp, BeamType.GoodBeam, 
    //     PositionOffsetY1() + commonTeleportBasePosition, 
    //     CurrentObjectOnPosition(),
    //     Color.White, EffectRev.VisibleToPositionAndRadius);
    // // blockedPositionObjectAhead blue orb
    // CreateEffect(HasObjectDirection() ? hp : null,
    //     Effect.Orb, enemyColor, blockedPositionObjectAhead,
    //     1, EffectRev.VisibleToPositionAndRadius);
    // // placable teleportPosition area size blue sphere
    // CreateEffect(hp,
    //     Effect.Sphere, enemyColor,
    //     HasObjectDirection() ? blockedPositionObjectAhead : CurrentObjectOnPosition(),
    //     teleportAreaSize + teleportAreaExtendSize,
    //     EffectRev.VisibleToPositionAndRadius);
    // // object -> blockedPosition blue beam
    // CreateBeamEffect(HasObjectDirection() ? hp : null, BeamType.BadBeam, 
    //     CurrentObjectOnPosition(),
    //     blockedPositionObjectAhead, 
    //     enemyColor, EffectRev.VisibleToPositionAndRadius);

    define pastSecond = 1;

    while(true){
        countDetectTriggerServerLoadPerSecond = countWaitActionByServerLoad / pastSecond;
        pastSecond ++;

        // StartForcingPlayerOutlines(
        //     AllLivingPlayers(enemyTeam),
        //     hp,
        //     true,
        //     Color.Red,
        //     OutlineType.Always
        // );

        // auto recall gunship
        if(
            IsProbabilityTrue((8 - (HumanPlayerNum(playerTeam))) * 0.05) &&
            IsGameInProgress()
        ){
            debugBuddyHeroPerk();
        }
        Wait(1);
    }
}

// rule: "DebugPlayerAction"
// Event.OngoingPlayer
// Team.All
// if(
//     ep == hp &&
//     initCompleted
// ){
//     SetUltimateCharge(ep, 0);
//     Wait(1);
//     Loop();
// }

rule: "DebugPlayJoinPlayerSound"
Event.OnPlayerJoin
Team.All
if(
    initCompleted &&
    !IsDummyBot()
){
    define positionArray! = [
        PositionOf(hp),
        SpawnPoints(playerTeam)[0],
        CurrentObjectPosition(),
        SpawnPoints(enemyTeam)[0]
    ];

    for(define index! = 0; index < 6; index++){
        for(define index2! = 0; index2 < 6; index2++){
            PlayEffect(HostPlayer(),
                PlayEffect.BuffImpactSound,
                null, positionArray[index2], MaxValue());
        }
        Wait(0.5);
    }
}

rule: "Debug/initDebugMode"
Event.OngoingGlobal
Team.All
if(
    initCompleted
){
    if(IsHostPlayerInGame()){
        debugMode = DebugMode.Non;
    }
    else{
        debugMode = DebugMode.DebugParam;
        ShowDebugHud(hp);
    }
}

rule: "Debug/changeDebugMode"
Event.OngoingPlayer
Team.All
if(
    hp == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Jump) 
){
    // change debug mode
    WaitLongPressConfirm();
    
    if(debugMode >= DebugMode.Recording){
        debugMode = DebugMode.Non;
    }
    else{
        debugMode ++;
    }

    // reload hud
    HideDebugHud();
    ShowDebugHud(hp);
}

globalvar define debugHuds;

define Last():
    CountOf(debugHuds);

define FirstEnemyOf(in define enemyType):
    FirstOf(FilteredArray(AllPlayers(enemyTeam), ae.enemyType == enemyType));

define FirstBossClassEnemy():
    FirstOf(FilteredArray(AllPlayers(enemyTeam), IsBossClassEnemy(ae)));

// show debug icon and hud
void ShowDebugHud(define player!)"ShowDebugHud"{
    if(
        debugMode >= DebugMode.Recording
    ){
        EnableInspectorRecording();
        debugHuds[Last()] = CreateDebugHud("Recording", true, Color.Red);
    }
    else{
        DisableInspectorRecording();
    }

    if(
        debugMode >= DebugMode.Non
    ){
        debugHuds[Last()] = CreateDebugHud("human player Num", HumanPlayerNum(playerTeam), HumanPlayerNum(playerTeam) <= 1 ? Color.Team2 : Color.Yellow);
    }
    
    if(
        debugMode >= DebugMode.ServerLoad
    ){
        debugHuds[Last()] = CreateDebugHud("Server Load", ServerLoad(),
            isServerLoadLevel(ServerLoadLevel.Overload) ? Color.Red :
            isServerLoadLevel(ServerLoadLevel.Busy) ? Color.Yellow :
            isServerLoadLevel(ServerLoadLevel.Hot) ? Color.Green :
            isServerLoadLevel(ServerLoadLevel.Warm) ? Color.Blue :
            Color.Gray);
        // debugHuds[Last()] = CreateDebugHud("Server Load Average", ServerLoadAverage(), ServerLoadAverage() < 255 ? Color.Gray : Color.Yellow);
        // debugHuds[Last()] = CreateDebugHud("Server Load Peak", ServerLoadPeak(), ServerLoadPeak() < 255 ? Color.Gray : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("game Logic Speed", gameLogicSpeed, gameLogicSpeed >= 100 ? Color.Gray : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("count Game Logic Speed Decrease", countGameLogicSpeedDecrease, Color.Gray);
        debugHuds[Last()] = CreateDebugHud("count Wait Action By Server Load", countWaitActionByServerLoad, Color.Gray);
        debugHuds[Last()] = CreateDebugHud("count Wait Action By Server Load Per Second", countDetectTriggerServerLoadPerSecond, Color.Gray);
    }

    if(
        debugMode >= DebugMode.DebugParam
    ){  
        // player team
        debugHuds[Last()] = CreateDebugHud("team player Num", <"<0> / <1>", NumberOfLivingPlayers(playerTeam), NumberOfPlayers(playerTeam)>, NumberOfLivingPlayers(playerTeam) >= NumberOfPlayers(playerTeam) ? Color.Team2 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("reload Asset Interval", reloadBuddyAssetInterval, reloadBuddyAssetInterval > 5 ? Color.Team2 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("asset Number", buddyAssetNo, Color.Team2);
        debugHuds[Last()] = CreateDebugHud("death Count", playerDeathCount, Color.Team2);

        // enemy team
        debugHuds[Last()] = CreateDebugHud("team player num", <"<0> / <1>", NumberOfLivingPlayers(enemyTeam), NumberOfPlayers(enemyTeam)>, NumberOfLivingPlayers(enemyTeam) >= NumberOfPlayers(enemyTeam) ? Color.Team1 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("reload Asset Interval", reloadEnemyAssetInterval, reloadEnemyAssetInterval > 5 ? Color.Team1 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("Asset Number", enemyAssetNo, Color.Team1);
        debugHuds[Last()] = CreateDebugHud("death Count", <"<0>, <1>, <2>, <3>", enemyDeathCount[0], enemyDeathCount[1], enemyDeathCount[2], enemyDeathCount[3]>, Color.Team1);
        debugHuds[Last()] = CreateDebugHud("auto Tune Dmg Dlt", autoTuneDmgDlt, Color.Team1);
        debugHuds[Last()] = CreateDebugHud("Game Progress Diff", GameProgressDiff(playerTeam), Color.Team1);
        debugHuds[Last()] = CreateDebugHud("spawn Time scale", spawnTimeScale, Color.Team1);
        debugHuds[Last()] = CreateDebugHud("spawn Interval", <"<0>, <1>, <2>, <3>",
            FirstEnemyOf(EnemyType.Minion).confirmSpawnInterval,
            FirstEnemyOf(EnemyType.Elite).confirmSpawnInterval,
            FirstEnemyOf(EnemyType.SubBoss).confirmSpawnInterval,
            FirstEnemyOf(EnemyType.Boss).confirmSpawnInterval>, Color.Team1);
        debugHuds[Last()] = CreateDebugHud("spawn Rush Interval", spawnRushInterval, spawnRushInterval > 5 ? Color.Team1 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("spawn Rush Count", spawnRushCount, spawnRushCount <= 0 ? Color.Team1 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("shot Call Interval", shotCallInterval, shotCallInterval > 5 ? Color.Team1 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("combat Teleport Interval",
            FirstBossClassEnemy().combatTeleportInterval,
            FirstBossClassEnemy().combatTeleportInterval > 5 ? Color.Team1 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("more Ult Prob", moreUltProb, moreUltProb <= 0 ? Color.Team1 : Color.Yellow);      
    }
}

// Hide debug icon and hud
void HideDebugHud()"HideDebugHud"{
    for(gLoopIndex = 0; gLoopIndex < CountOf(debugHuds); gLoopIndex ++){
        DestroyHudText(debugHuds[gLoopIndex]);
    }
}

rule: "Debug/resetBotList"
Event.OngoingPlayer
Team.All
if(
    hp == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Crouch)
){
    WaitLongPressConfirm();
    reloadEnemyAssetInterval = 0;
    WaitLongPressConfirm();
    WaitUntil(reloadEnemyAssetInterval > 0, 10);
    reloadBuddyAssetInterval = 0;
}

rule: "Debug/triggerRushAndShotCall"
Event.OngoingPlayer
Team.All
Player.All
if(
    hp == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Reload)
){
    WaitLongPressConfirm();
    AllPlayers(enemyTeam).combatTeleportInterval = 0;
    WaitLongPressConfirm();
    spawnRushInterval = 0;
    WaitLongPressConfirm();
    shotCallInterval = 0;
}

playervar define tempName!;

rule: "Debug/deployGunship"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.PrimaryFire)
){
    // kill players on aim center
    WaitLongPressConfirm();
    debugBuddyHeroPerk();

    LoopIfConditionIsTrue();
}

void debugBuddyHeroPerk()"debugBuddyHeroPerk"{
    define player! = 
        FirstOf(
            SortedArray(
                FilteredArray(
                    AllPlayers(playerTeam),
                    (
                        IsDummyBot(ae) &&
                        !ae.isTransformed
                    )
                ),
                DistanceBetween(ae, CurrentObjectPosition())
            )
        );

    player.heroModType = RandomValueInArray([
        HeroModType.ARTILLERY_REQUEST,
        HeroModType.STRAFING_REQUEST,
        HeroModType.GRUDGE_FIRE_BALL,
        HeroModType.GRUDGE_LIGHTNING,
        HeroModType.BEAM_SNIPER,
        HeroModType.TITAN_FORM,
        HeroModType.GUNSHIP_GUNNER
    ]);

    if(IsDead(player)){
        Resurrect(player);
    }
    player.grudgePower = 100;
    SetUltimateCharge(player, DefaultPercentage());
    PressButton(player, Button.Ultimate);
}
