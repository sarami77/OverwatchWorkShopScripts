import "EnemyRush.setting.json";
import "../Lib/Debug.del";
import "../Lib/Utility.del";
import "../Lib/ServerOverLoadMeasures.del";
import "../Lib/Bot.del";
import "../Lib/Buddy.del";
import "../Lib/Vote.del";
import "../Lib/HeroMod.del";
// import "Translate.del";

// rule: "PreCompileTest"
// Event.OngoingGlobal
// {
//     define text = "TEST_"+ TS(TSKey.HERO_MOD_MEDIC_TITLE);
//     define text2 = "TEST_"+ TS(TSKey.HERO_MOD_NOMOD_DETAIL);
// }

// TAG Signature and infomation ----------
disabled rule: "[PVE] ENEMY RUSH ver.10.5 / Share code [V7PEF]. You allowed copy or modify code." -1 {}
disabled rule: "This script was generated by ItsDeltin/Overwatch-Script-To-Workshop. Check detail with https://github.com/ItsDeltin/Overwatch-Script-To-Workshop" -1 {}
disabled rule: "This original script was created by sarami77#1868. Check detail with https://github.com/sarami77/OverwatchWorkShopScripts" -1 {}

// TAG Initialize ----------
define humanTeam: Team.Team2;
define enemyTeam: Team.Team1;
define allTeam: Team.All;

globalvar define initCompleted;

rule: "Initialize/initialize"
Event.OngoingGlobal
{
    // Stop records to reduce server load
    DisableInspectorRecording();

    // If run it right after loading the server, some scripts fail, so wait 6 seconds
    Wait(6, WaitBehavior.AbortWhenFalse);

    // Start watch over load
    slowControlHandler = SlowControlHandler.ServerOverLoadMeasures;

    // show version and share code
    CreateHudText(AllPlayers(),
        null, "[PVE] ENEMY RUSH ver.10.5 / Share code [V7PEF]", null,
        Location.Left, -999,
        Color.White, Color.Gray, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleAlways);

    // Notify completion of init game setting and start game main logic
    initCompleted = true;
}

// TAG Round ----------
rule: "Round/shortenAssemblePhase"
Event.OngoingGlobal
if(
    IsAssemblingHeroes()
){
    SetMatchTime(40);

    // wait player join server
    Wait(10, WaitBehavior.AbortWhenFalse);
    
    if(
        // no human
        HumanPlayerNum(humanTeam) <= 0
            ||
        // host human only
        (
            // 1 human only
            HumanPlayerNum(humanTeam) == 1
                &&
            // human is host player
            hp ==
                FirstOf(
                    FilteredArray(
                        AllPlayers(humanTeam),
                        !IsDummyBot(ae)
                    )
                )
        )
    ){
        // omit assemble phase
        SetMatchTime(0);
    }
}

rule: "Round/shortenSetupPhase"
Event.OngoingGlobal
if(
    IsInSetup()
){
    SetMatchTime(50);

    if(
        // no human
        HumanPlayerNum(humanTeam) <= 0
    ){
        // omit setup phase
        SetMatchTime(0);
    }
}

// globalvar define matchTimeScale! = WorkshopSettingReal("Game Settings", "Match Time Scale", 1.0, 0.01, 100, 1);

// rule: "Round/AddMatchTime1"
// Event.OngoingGlobal
// if(
//     IsGameInProgress()
// ){
//     // defualt add 300s
//     SetMatchTime(MatchTime() + (300 * (1 - matchTimeScale)));
// }

// rule: "Round/AddMatchTime2"
// Event.OngoingGlobal
// if(
//     IsObjectiveComplete(0)
// ){
//     // defualt add 180s
//     SetMatchTime(MatchTime() + (180 * (1 - matchTimeScale)));
// }

// rule: "Round/AddMatchTime3"
// Event.OngoingGlobal
// if(
//     IsObjectiveComplete(1)
// ){
//     // defualt add 120s
//     SetMatchTime(MatchTime() + (120 * (1 - matchTimeScale)));
// }

// TAG TIPS ----------
globalvar define tipsText!;
rule: "TIPS/showTIPS"
Event.OngoingGlobal
if(
    initCompleted
){
    CreateInWorldText(AllPlayers(),
        <"[TIPS]\n\r<0>", tipsText>,
        SpawnPoints(humanTeam)[0] + Vector(0, 3, 0), 1.0,
        Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString, Color.White, Spectators.VisibleAlways
    );

    while(true){
        tipsText = RandomValueInArray([
            /// valid until 120 character ___________________________________________________________________________________________|
            // about spawn
            "Enemy team often causes spawn rush.\n\rSpawn rate is maximized for a dozen seconds.\n\rBe careful not to get surrounded.",
            "Enemy can spawn anywhere in player's line of sight.\n\r Watch arround, even if you on high ground or in enclosed areas.",
            "Don't miss sound of enemies spawning.\n\r Sometimes enemies will surprise you from behind or sides.",
            "Enemy bots try spawn to positions where can see directly player.\n\rIf player is not seem, will be retry positining.",
            "Enemy bots spawn in groups from fixed locations,\n\rbut can be forced to change locations by player approaching.",
            // about enemy
            "Enemy team use ULTs combo just like human team.\n\rWatch out, combo attacks when hear enemy ULT calls in multiple.",
            "Enemy team knows player's health.\n\rthey try attack low health player as team.\n\rremenber, this is PVE but not 1vs1.",
            "Support heroes enemy bots has low fire power, but 2x deal heal.\n\rThe combo with boss-class is a threat.",
            // about boss
            "Boss-class enemies try continuously multiple use ULTs after cooldown.\n\rKeep watch even if stoped boss's ULT with stun.",
            "Boss-class enemies teleport in combat for avoid danger or take map advantage.\n\rWatch trajectory to don't miss.",
            "Boss-class enemies spawn at checkpoints for short time.\n\rAt final point, boss enemy spawn and must be defeated to win.",
            // about bots
            "Friend bots use mods just like human players.\n\r include Attack MODs, support MODs, etc, all mod.",
            "Friend bots are not as well play as human players,\n\rbut they has buff of reduce damage taken 30%.",
            "For reduce server load, BOT is bad at finding map abyss.\n\rThey sometime fall to abyss and instantly return.",
            "Widowmaker Bot's headshot accuracy is already cheat-like,\n\rbut it becomes more perfect when using ULT. I reported!",
            // about game difficulty
            "The most popular game difficulty seems to be [EXPERT]...\n\rare you try more higher?",
            "[HERO MUST DIE] has 3x enemy spawn rate as [NORMAL].\n\rdeal damage is 4x.\n\rcan try this?",
            "When game difficulty changes, only enemy spawn rate and deal damage will change.\n\rMax health will not change.",
            "If no one has voted for the game difficulty, [NORMAL] will be confirmed.",
            "The higher game difficulty, the higher enemy's deal damage will be,\n\rso use tanks cover or wall more important.",
            // about MOD
            "The most popular MOD seems to be [TITAN FORM]...\n\rNow, hammer time!",
            "Combo of extended ULT MODs incluide [SHOT CALL] is powerful,\n\rbut some MODs are not supported for game balance.",
            "If you use [GUARD DOG] to well,\n\rcan powerfully stop even boss-class enemies.",
            "[POWERFULL GIFT] is more powerful as more ult charge.\n\rcan fill up the teammate's ULT charge one after another.",
            "Actually, [GUNSHIP GUNNER]'s NUKE CANON and [GRUDGE FIRE BALL] are the same attack.",
            "[TITAN FORM] and [GUNSHIP GUNNER] are will get stuck in the map,\n\rif you don't think about where to use it.",
            // about game system
            "Equiped [Good Game] system.\n\rMonitor game progress and kill rates of both teams to create close matches as can.",
            "Equiped [workshop settings].\n\rCan be customized using the GUI, enemy spaw rate, friend bots count, etc.",
            "Even if no players are present,\n\rCan watch skirmishes of BOTs from the spectator."
        ]);
        Wait(20, WaitBehavior.IgnoreCondition);
    }
}

// TAG FinalStand ----------
globalvar define hasFinalStand! = true;

rule: "FinalStand/FinalStand"
Event.OngoingGlobal
if(
    IsGameInProgress() &&
    IsOverTime() &&
    hasFinalStand
){
    BigMessage(AllPlayers(humanTeam), "Final Stand !");
    slowControlHandler = SlowControlHandler.GameLogic;
    SetSlowMotion(10);
    Wait(0.25, WaitBehavior.IgnoreCondition);   // show slow

    // buff player team
    PlayEffectsToTeam(humanTeam);
    Heal(AllLivingPlayers(humanTeam), null, MaxValue());
    SetUltimateCharge(AllLivingPlayers(humanTeam), 100);
    Resurrect(AllDeadPlayers(humanTeam));
    Wait(0.25, WaitBehavior.IgnoreCondition);   // show slow

    SetSlowMotion(DefaultPercentage());
    slowControlHandler = SlowControlHandler.ServerOverLoadMeasures;
    Wait(1, WaitBehavior.IgnoreCondition);
    
    CreateHudText(
        AllPlayers(humanTeam),
        null, null, "No next \"final stand\"", Location.Left, 999, null, null, cautionColor, HudTextRev.Color, Spectators.VisibleNever);
    hasFinalStand = false;
}

// TAG Player/Config ----------
rule: "Player/Config/init"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    HasSpawned()
){
    // set max respawn time
    define respawnTime! = 10 * WorkshopSettingReal("Player Settings", "Max Respawn Time Scale", 1.0, 0.0, 100, 1);
    define receiveDamage! = 100 * WorkshopSettingReal("Player Settings", "Receive Damage Scale", 1.0, 0.0, 100, 2);

    if(!IsDummyBot()){
        // human player
        SetRespawnMaxTime(ep, respawnTime);
        SetDamageReceived(ep, receiveDamage);

        // show operation message
        Wait(5, WaitBehavior.IgnoreCondition);
        if(IsInSetup()){
            BigMessage(ep, "You can Choose game difficulty vote and hero mod." + NL + "Check top left of screen!");
            PlayEffect(ep, PlayEffect.BuffImpactSound, ep, null, MaxValue());
            WaitUntil(MatchTime() <= 10, 60);
            
            if(IsInSetup()){
                BigMessage(ep, "Already Choose game difficulty vote and hero mod?" + NL + "Are you ready?");
                PlayEffect(ep, PlayEffect.BuffImpactSound, ep, null, MaxValue());
            }
        }
        else{
            BigMessage(ep, "You can Choose hero mod." + NL + "Check top left of screen!");
            PlayEffect(ep, PlayEffect.BuffImpactSound, ep, null, MaxValue());
        }  
    }
    else{
        // dummy bot
        // respawn time 30% cut
        SetRespawnMaxTime(ep, respawnTime * 0.7);
        // receive damage 30% cut
        SetDamageReceived(ep, receiveDamage * 0.7);
    }
}

// TAG Player/HumanIcon ----------
playervar define humanIcon!;

define isHumanIconActive: 
    IsAlive();

rule: "Player/HumanIcon/show"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    HasSpawned() &&
    !IsDummyBot() &&
    isHumanIconActive
){
    // show human icon to human players for easy to find other human from human player
    DestroyIcon(humanIcon);
    humanIcon = CreateIcon(AllPlayers(), ep, Icon.Asterisk,
        IconRev.Position, Color.Team2, false);
}

rule: "Player/HumanIcon/hide"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    HasSpawned() &&
    !IsDummyBot() &&
    !isHumanIconActive
){
    DestroyIcon(humanIcon);
}

// TAG FriendBot/BotActive ----------
define canFriendBotBotActive:
    IsAlive();

rule: "FriendBot/BotActive/activate"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    canFriendBotBotActive
){
    isBotActive = true;
}

rule: "FriendBot/BotActive/deactive"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    !canFriendBotBotActive
){
    isBotActive = false;
}

// TAG FriendBot/Config ----------
rule: "FriendBot/Config/init"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    IsDummyBot() &&
    HasSpawned()
){
    watchUpdateRate = 1.0;
}

// TAG FriendBot/Asset ----------
globalvar define maxFriendBotBotNum! =
    WorkshopSettingInteger("Friend Bot Settings", "Bot Count (when player slot empty, join instead. will switch to player by join.)", 8, 0, 8, 1);

define pMax: maxFriendBotBotNum;

define friendBotAssetList:
    [
        // fix hero asset
        [   // assetNo 0
            // recommend
            [EnemyType.Non,     Hero.Mercy,      1],
            [EnemyType.Non,     Hero.Genji,      1],
            [EnemyType.Non,     Hero.Reinhardt,  1],
            [EnemyType.Non,     Hero.Ana,        1],
            [EnemyType.Non,     Hero.Hanzo,      1],
            [EnemyType.Non,     Hero.Mauga,      1],
            [EnemyType.Non,     Hero.Zenyatta,   1],
            [EnemyType.Non,     Hero.Soldier76,  1]
        ],
        [   // assetNo 1
            // recommend
            [EnemyType.Non,     Hero.Moira,      1],
            [EnemyType.Non,     Hero.Reaper,     1],
            [EnemyType.Non,     Hero.Ramattra,   1],
            [EnemyType.Non,     Hero.Baptiste,   1],
            [EnemyType.Non,     Hero.Sojourn,    1],
            [EnemyType.Non,     Hero.Mauga,      1],
            [EnemyType.Non,     Hero.Brigitte,   1],
            [EnemyType.Non,     Hero.Genji,      1]
        ],
        [   // assetNo 2
            // recommend
            [EnemyType.Non,     Hero.Illari,     1],
            [EnemyType.Non,     Hero.Sojourn,    1],
            [EnemyType.Non,     Hero.Ramattra,   1],
            [EnemyType.Non,     Hero.Lifeweaver, 1],
            [EnemyType.Non,     Hero.Ashe,       1],
            [EnemyType.Non,     Hero.Mauga,      1],
            [EnemyType.Non,     Hero.Kiriko,     1],
            [EnemyType.Non,     Hero.Cassidy,    1]
        ],
        // 3,4
        [],[],

        // random hero asset
        [
            // assetNo 5
            // random with fix role
            [EnemyType.Non,     RandomSupportHero,  1],
            [EnemyType.Non,     RandomTankHero,     1],
            [EnemyType.Non,     RandomDamageHero,   1],
            [EnemyType.Non,     RandomSupportHero,  1],
            [EnemyType.Non,     RandomTankHero,     1],
            [EnemyType.Non,     RandomDamageHero,   1],
            [EnemyType.Non,     RandomSupportHero,  1],
            [EnemyType.Non,     RandomDamageHero,   1]
        ],
        [
            // assetNo 6
            // random with non role
            [EnemyType.Non,     RandomHero, 1],
            [EnemyType.Non,     RandomHero, 1],
            [EnemyType.Non,     RandomHero, 1],
            [EnemyType.Non,     RandomHero, 1],
            [EnemyType.Non,     RandomHero, 1],
            [EnemyType.Non,     RandomHero, 1],
            [EnemyType.Non,     RandomHero, 1],
            [EnemyType.Non,     RandomHero, 1]
        ],
        [
            // assetNo 7
            // same hero
            [EnemyType.Non,     FavoriteSupportHero(), 1],
            [EnemyType.Non,     FavoriteSupportHero(), 1],
            [EnemyType.Non,     favSameHero,    pMax - 2]
        ]
    ];

define FriendBotAssetNoLotteryList: [
    // fix hero asset
    0,
    1,
    2,

    // random hero asset
    5, 5, 5,
    6,
    7, 7
];

globalvar define isLockedCreateBotsByAsset! = false;

void CreateBotsByAssetWithMutexLock(in define asset!, in define team!, in define addLimitNum!){ 
    // can't implement as subroutin for mutex  
    define forceReleaseCount! = 0;
    while(isLockedCreateBotsByAsset){
        if(forceReleaseCount < 5){
            forceReleaseCount ++;
        }
        else{
            break;
        }
        Wait(1, WaitBehavior.IgnoreCondition);
    }
    isLockedCreateBotsByAsset = true;
    CreateBotsByAsset(asset, team, addLimitNum);
    isLockedCreateBotsByAsset = false;
}

// TAG FriendBot/Asset/Interval ----------
define PlayerNum():
    CountOf(
        FilteredArray(
            AllPlayers(humanTeam),
            !IsDummyBot(ae)
        )
    );

define FriendBotNum():
    CountOf(
        FilteredArray(
            AllPlayers(humanTeam),
            IsDummyBot(ae)
        )
    );

define needFriendBotNum:
    maxFriendBotBotNum - PlayerNum();

globalvar define friendBotAssetNo!;

globalvar define forceReloadFriendBotAsset! = false;

define AssetChangeInterval(): RandomInteger(120, 180);
globalvar define reloadFriendBotAssetInterval! = -1;

rule: "FriendBot/BotAssetInterval/reloadReloadFriendBotAsset"
Event.OngoingGlobal
if(
    initCompleted
){
    while(true){
        // if force reload, skip change assetNo and set interval
        if(!forceReloadFriendBotAsset){
            // choice asset by random
            friendBotAssetNo = RandomValueInArray(FriendBotAssetNoLotteryList);
            // set default interval
            reloadFriendBotAssetInterval = AssetChangeInterval();
        }

        // get asset
        define asset! = friendBotAssetList[friendBotAssetNo];

        // valid asset
        if(
            0 < CountOf(asset)
        ){
            // save avg ult charge of bots before reload asset
            define ultCharge! = GetAvgUltChgOfDummyBot(humanTeam);
            // reload bots by asset
            DestroyBots(humanTeam);
            CreateBotsByAssetWithMutexLock(asset, humanTeam, needFriendBotNum);
            // restore avg ult charge of bots
            SetAvgUltChgOfDummyBot(humanTeam, ultCharge);
            // wait start intarval until game start.
            WaitUntil(IsGameInProgress() || forceReloadFriendBotAsset, MaxValue());
            // release force reload flag
            forceReloadFriendBotAsset = false;

            for(
                ;
                reloadFriendBotAssetInterval > 0;
                reloadFriendBotAssetInterval--
            ){
                Wait(1, WaitBehavior.IgnoreCondition);
                if(
                    // interrupt force reload
                    forceReloadFriendBotAsset ||
                    // create bot error
                    0 >= NumberOfPlayers(humanTeam)
                ){
                    break;
                }
            }
        }
        else{
            errLog(<"FriendBot asset is invalid">);
        }

        // avoid infite loop clash
        Wait(1, WaitBehavior.IgnoreCondition);
    }
}

rule: "FriendBot/tuneAssetMemberNum"
Event.OngoingGlobal
if(
    initCompleted
){
    define prevPlayerNum! = -1;

    // set initial asset no
    friendBotAssetNo = RandomValueInArray(FriendBotAssetNoLotteryList);

    while(true){
        if(
            // create bot not locked
            !isLockedCreateBotsByAsset &&
            (
                // playerNum changed
                prevPlayerNum != PlayerNum() ||
                // not filed by need FriendBot number
                FriendBotNum() != needFriendBotNum ||
                // entity num than over slot num
                PlayerNum() + FriendBotNum() > NumberOfSlots(humanTeam)
            )
        ){
            // save current playerNum
            prevPlayerNum = PlayerNum();
            // force reload asset
            forceReloadFriendBotAsset = true;
        }

        // check Interval
        WaitUpdateLongCycle();
    }
}

// TAG EnemyBot/BotActive ----------
define canEnemyBotActive:
    IsAlive() &&
    !IsInSpawnRoom();

rule: "EnemyBot/BotActive/activate"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    canEnemyBotActive    
){
    define closePlayer! = ClosestPlayerTo(ep, EnemyTeamOf(ep));
    SetFacing(ep, DirectionTowards(EyePosition(), EyePosition(closePlayer)));

    if(
        // has damage
        NormalizedHealth() < 1.0 ||
        // has line of close player
        IsInLineOfSight(
            EyePosition(),
            EyePosition(closePlayer))
    ){
        // start bot
        isBotActive = true;
        Abort();
    }
    Wait(0.5, WaitBehavior.IgnoreCondition);
    LoopIfConditionIsTrue();
}

rule: "EnemyBot/BotActive/deactive"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    !canEnemyBotActive
){
    // stop bot for reduce server load
    isBotActive = false;
}

// TAG EnemyBot/Config ----------
define basicSpawnTimeBase: 12;
define basicSpawnTime:
    confirmGameDifficulty == GameDifficulty.EASY ?      basicSpawnTimeBase * 1.0 :
    confirmGameDifficulty == GameDifficulty.NORMAL ?    basicSpawnTimeBase * 0.9 :  //-0.1
    confirmGameDifficulty == GameDifficulty.HARD ?      basicSpawnTimeBase * 0.8 :  //-0.1
    confirmGameDifficulty == GameDifficulty.EXPERT ?    basicSpawnTimeBase * 0.7 :  //-0.1
    confirmGameDifficulty == GameDifficulty.LEGENDARY ? basicSpawnTimeBase * 0.5 :  //-0.2
    confirmGameDifficulty == GameDifficulty.INSANITY ?  basicSpawnTimeBase * 0.3 :  //-0.2
                                                        basicSpawnTimeBase * 1.0 ;

define autoTuneDmgDltMin :
    confirmGameDifficulty == GameDifficulty.EASY ?      10 :
    confirmGameDifficulty == GameDifficulty.NORMAL ?    20 :    //+10
    confirmGameDifficulty == GameDifficulty.HARD ?      30 :    //+10
    confirmGameDifficulty == GameDifficulty.EXPERT ?    40 :    //+10
    confirmGameDifficulty == GameDifficulty.LEGENDARY ? 60 :    //+20
    confirmGameDifficulty == GameDifficulty.INSANITY ?  80 :    //+20
                                                        10 ; 

define autoTuneDmgDltMax:
    confirmGameDifficulty == GameDifficulty.EASY ?      50 :
    confirmGameDifficulty == GameDifficulty.NORMAL ?    60 :    //+10
    confirmGameDifficulty == GameDifficulty.HARD ?      70 :    //+10
    confirmGameDifficulty == GameDifficulty.EXPERT ?    80 :    //+10
    confirmGameDifficulty == GameDifficulty.LEGENDARY ? 100:    //+20
    confirmGameDifficulty == GameDifficulty.INSANITY ?  120:    //+20
                                                        50 ;

define upValueScaleBase: 0.6;
define upValueScale:
    confirmGameDifficulty == GameDifficulty.EASY ?      upValueScaleBase * 1 : 
    confirmGameDifficulty == GameDifficulty.NORMAL ?    upValueScaleBase * 1 : 
    confirmGameDifficulty == GameDifficulty.HARD ?      upValueScaleBase * 1 : 
    confirmGameDifficulty == GameDifficulty.EXPERT ?    upValueScaleBase * 1 : 
    confirmGameDifficulty == GameDifficulty.LEGENDARY ? upValueScaleBase * 1 : 
    confirmGameDifficulty == GameDifficulty.INSANITY ?  upValueScaleBase * 1 :
                                                        upValueScaleBase * 1 ;

define downValueScaleBase: upValueScaleBase * 3;
define downValueScale:
    confirmGameDifficulty == GameDifficulty.EASY ?      downValueScaleBase * 1.0 :
    confirmGameDifficulty == GameDifficulty.NORMAL ?    downValueScaleBase * 0.9 :  //-0.1
    confirmGameDifficulty == GameDifficulty.HARD ?      downValueScaleBase * 0.8 :  //-0.1
    confirmGameDifficulty == GameDifficulty.EXPERT ?    downValueScaleBase * 0.7 :  //-0.1
    confirmGameDifficulty == GameDifficulty.LEGENDARY ? downValueScaleBase * 0.5 :  //-0.2
    confirmGameDifficulty == GameDifficulty.INSANITY ?  downValueScaleBase * 0.3 :  //-0.2
                                                        downValueScaleBase * 1.0 ;

define enemyTeamColor: Color.Team1;

define IsBossClass(in define player):
    player.enemyType == EnemyType.SubBoss ||
    player.enemyType == EnemyType.Boss;

define dealHealScale: IsSupportHero(HeroOf()) ? 2.0 : 1.0;

playervar define damageDealt!;
playervar define spawnInterval!;
playervar define chargeUltInterval!;
playervar define deathCost!;

rule: "EnemyBot/Config/update"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    enemyType != EnemyType.Non &&
    confirmGameDifficulty != GameDifficulty.NO_VOTE &&
    IsGameInProgress()
){
    // disable builtin respawn for avoid auto teamup
    DisableRespawning();
    // disable retreat cuz enemy bot
    enableRetreat = false;

    define name!;
    define scale!;
    define voiceLine!;
    define maxHealth!;
    define healReceived!;
    define healDealt!;
    define moveSpeed!;
    define gravity!;
    
    // init config by enemy type
    if(enemyType == EnemyType.Minion){
        // fixed config
        name =              "Minion";
        watchUpdateRate =   8;
        deathCost =         1;
        chargeUltInterval = 60;

        scale =             0.7;
        voiceLine =         1.5;
        maxHealth =         25;
        healReceived =      25;
        healDealt =         25 * dealHealScale;
        moveSpeed =         100;
        gravity =           100;
        // scalable config by update function
        spawnInterval =     basicSpawnTime * 1;
        damageDealt =       50;
    }
    else if(enemyType == EnemyType.Elite){
        // fixed config
        name =              "Elite";
        watchUpdateRate =   4;
        deathCost =         2;
        chargeUltInterval = 30;

        scale =             1.0;
        voiceLine =         1.0;
        maxHealth =         100;
        healReceived =      100;
        healDealt =         100 * dealHealScale;
        moveSpeed =         100;
        gravity =           100;
        // scalable config by update function
        spawnInterval =     basicSpawnTime * 2;
        damageDealt =       100;
    }
    else if(enemyType == EnemyType.SubBoss){
        // fixed config
        name =              "SubBoss";
        watchUpdateRate =   1;
        deathCost =         8;
        chargeUltInterval = 15;

        scale =             1.5;
        voiceLine =         0.5;
        maxHealth =         600;
        healReceived =      200;
        healDealt =         200 * dealHealScale;
        moveSpeed =         100;
        gravity =           100;
        // scalable config by update function
        spawnInterval =     basicSpawnTime * 4;
        damageDealt =       150;
    }
    else if(enemyType == EnemyType.Boss){
        // fixed config
        name =              "Boss";
        watchUpdateRate =   1;
        deathCost =         8;
        chargeUltInterval = 15;

        scale =             2.5;
        voiceLine =         0.1;
        maxHealth =         1000;
        healReceived =      200;
        healDealt =         200 * dealHealScale;
        moveSpeed =         100;
        gravity =           100;
        // scalable config by update function
        spawnInterval =     basicSpawnTime * 4;
        damageDealt =       200;
    }

    StartForcingDummyBotName(ep, name);
    StartScalingPlayer(ep, scale, false);
    StartModifyingHeroVoiceLines(ep, voiceLine, false);
    SetMaxHealth(ep, maxHealth);
    SetHealingReceived(ep, healReceived);
    SetHealingDealt(ep, healDealt);
    SetMoveSpeed(ep, moveSpeed);
    SetGravity(ep, gravity);

    if(enemyType == EnemyType.Boss){
        // set addtinal health and total 2x health 
        // wait max health change finish
        Wait(0.2, WaitBehavior.IgnoreCondition);
        AddHealthPoolToPlayer(ep, HealthType.Armor, MaxHealth() * 0.5, true, false);
        AddHealthPoolToPlayer(ep, HealthType.Shields, MaxHealth() * 0.5, true, false);

        Wait(0.2, WaitBehavior.IgnoreCondition);
        while(NormalizedHealth() < 1.0){
            Heal(ep, null, MaxValue());
            Wait(0.2, WaitBehavior.IgnoreCondition);
        }
    }

    while(true){
        // update scalable config
        UpdateEachSpawnInterval();
        UpdateEachDealtDamage();
        WaitUpdateLongCycle();
    }
}

// TAG EnemyBot/Config/SpawnInterval ----------
define showDeadEffectTime: 1.0;
globalvar define spawnTimeScale;
playervar define confirmSpawnInterval;

rule: "EnemyBot/Config/SpawnInterval/waitingRespawn"
Event.OnDeath
if(
    TeamOf() == enemyTeam
){
    // wait for show dead effect
    Wait(showDeadEffectTime, WaitBehavior.AbortWhenFalse);
    // if sucide, skip wait timer
    if(Attacker() != ep){
        // wait for respawn by each timer
        Wait(confirmSpawnInterval, WaitBehavior.AbortWhenFalse);
    }
    if(IsDead()){
        Respawn();
    }
}

void UpdateEachSpawnInterval()"UpdateEachSpawnInterval"{
    // tune enemy spawen interval for make close match
    define diff! = GameProgressDiff(humanTeam);

    // tune interval by game progress diff
    if(70 <= diff){
        spawnTimeScale = 0;
    }
    else if(40 <= diff && diff < 70){
        spawnTimeScale = 0.25;
    }
    else if(10 <= diff && diff < 40){
        spawnTimeScale = 0.5;
    }
    // team even, default enemy respawn
    else if(-10 <= diff && diff < 10){
        spawnTimeScale = 1.0;
    }
    // enemy team advantage, slow enemy respawn
    else if(-40 <= diff && diff < -10){
        spawnTimeScale = 1.5;
    }
    else if(-70 <= diff && diff < -40){
        spawnTimeScale = 2.0;
    }
    else if(diff < -70){
        spawnTimeScale = 3.0;
    }

    // set default interval by object progress
    confirmSpawnInterval = spawnInterval;
    // apply each enemy type scale
    confirmSpawnInterval *= spawnTimeScale;
    // apply workshop setting
    confirmSpawnInterval *= WorkshopSettingReal("Enemy Bot Settings", "Basic Spawn Intarval Scale", 1.0, 0.0, 100, 1);
}

// TAG EnemyBot/Config/DealtDamage ----------
playervar define confirmDealtDamage;
globalvar define autoTuneDmgDlt;
globalvar define enemyDeathCount = [0,0,0,0];  // for debug
globalvar define playerDeathCount = 0;  // for debug

rule: "EnemyBot/Config/DealtDamage/init"
Event.OngoingGlobal
if(
    confirmGameDifficulty != GameDifficulty.NO_VOTE &&
    IsGameInProgress()
){
    autoTuneDmgDlt = (autoTuneDmgDltMin + autoTuneDmgDltMax) / 2;
}

rule: "EnemyBot/Config/DealtDamage/upTune"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    Attacker() != ep
){
    // up enemy deal damage by enemy dead, tune detailed difficulty
    define upValue! = deathCost;
    upValue *= upValueScale;
    // up deal damage
    autoTuneDmgDlt += upValue;
    autoTuneDmgDlt = autoTuneDmgDlt > autoTuneDmgDltMax ? autoTuneDmgDltMax : autoTuneDmgDlt;
    // death count for debug
    enemyDeathCount[ep.enemyType - 1] ++;
}

rule: "EnemyBot/Config/DealtDamage/downTune"
Event.OnDeath
if(
    TeamOf() == humanTeam &&
    Attacker() != ep
){
    // down enemy deal damage by player dead, tune detailed difficulty
    define downValue! = NumberOfSlots(humanTeam) / NumberOfPlayers(humanTeam);

    if(!IsDummyBot(ep)){
        // human player has influence 3times 
        downValue *= 3;
    }
    else{
        // bot player has single influence
        downValue *= 1;
    }
    downValue *= downValueScale;
    // down deal damage
    autoTuneDmgDlt -= downValue;
    autoTuneDmgDlt = autoTuneDmgDlt < autoTuneDmgDltMin ? autoTuneDmgDltMin : autoTuneDmgDlt;
    // death count for debug
    playerDeathCount ++;
}

void UpdateEachDealtDamage()"UpdateEachDealtDamage"{
    // set auto tune damage
    confirmDealtDamage = autoTuneDmgDlt;
    // apply setting scale
    confirmDealtDamage *= WorkshopSettingReal("Enemy Bot Settings", "Enemy Deal Damage Scale", 1.0, 0.0, 100, 0);
    // apply enemy type scale
    confirmDealtDamage *= (damageDealt / 100);
    // apply team balance
    confirmDealtDamage /= ConvertToBalancedValue(1.5, humanTeam);
    SetDamageDealt(ep, confirmDealtDamage);
}

// TAG EnemyBot/Config/ReceivedDamage ----------
globalvar define confirmReceiveDamage;

rule: "EnemyBot/Config/ReceivedDamage/update"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    while(true){
        UpdateGlobalReceivedDamage();

        WaitUpdateLongCycle();
    }
}

void UpdateGlobalReceivedDamage()"UpdateGlobalReceivedDamage"{
    // set base damage
    confirmReceiveDamage = DefaultPercentage();
    // apply team balance
    confirmReceiveDamage *= ConvertToBalancedValue(1.5, humanTeam);
    SetDamageReceived(AllPlayers(enemyTeam), confirmReceiveDamage);
}

// TAG EnemyBot/Config/ChargeUltimate ----------
rule: "EnemyBot/ChargeUltimate/charge"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.Non &&
    IsGameInProgress() &&
    !IsUsingUltimate()
){
    SetUltimateCharge(ep, UltimateChargePercent() + (DefaultPercentage() / chargeUltInterval));
    WaitUpdateASecond();
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/Asset ----------
globalvar define maxCreateEnemyBotNum! = 
    WorkshopSettingInteger("Enemy Bot Settings", "Bot Count (! when too many BOTs, may reduce game performance and stability.)", 8, 0, 16, 0);

define eMax: maxCreateEnemyBotNum;

globalvar define allSameHero!;
globalvar define favSameHero!;

define enemyAssetList:
    [
        // random hero asset
        [   
            // assetNo 0
            // basic
            [EnemyType.SubBoss,     RandomHero,             1],
            [EnemyType.Elite,       RandomHero,             eMax / 2 - 1],
            [EnemyType.Minion,      RandomHero,             eMax / 2]
        ],
        [   
            // assetNo 1
            // sub boss and minion
            [EnemyType.SubBoss,     RandomHero,             1],
            [EnemyType.Minion,      RandomHero,             eMax]
        ],
        [   
            // assetNo 2
            // all elite
            [EnemyType.Elite,       RandomHero,             eMax / 3],
            [EnemyType.Elite,       RandomHero,             eMax / 3],
            [EnemyType.Elite,       RandomHero,             eMax / 3]
        ],
        [   
            // assetNo 3
            // all elites same hero
            [EnemyType.Elite,       allSameHero,               eMax]
        ],
        [   
            // assetNo 4
            // half elite
            [EnemyType.Elite,       RandomHero,             eMax / 2],
            [EnemyType.Minion,      RandomHero,             eMax / 2]
        ],
        [   
            // assetNo 5
            // all minion
            [EnemyType.Minion,      rva([
                                        FavoriteDamageHero(),
                                        FavoriteTankHero()
                                    ]),                     eMax]
        ],
        [   
            // assetNo 6
            // double sub boss
            [EnemyType.SubBoss,     RandomHero,             1],
            [EnemyType.SubBoss,     RandomHero,             1],
            [EnemyType.Minion,      RandomHero,             eMax - 2]
        ],
        [   
            // assetNo 7
            // triple sub boss
            [EnemyType.SubBoss,     RandomHero,             1],
            [EnemyType.SubBoss,     RandomHero,             1],
            [EnemyType.SubBoss,     RandomHero,             1]
        ],
        [   
            // assetNo 8
            // damage boss with minion
            [EnemyType.Boss,        FavoriteDamageHero(),   1],
            [EnemyType.Minion,      RandomHero,             eMax - 1]
        ],
        [
            // assetNo 9
            // fav sameHero
            [EnemyType.SubBoss,     favSameHero,            1],
            [EnemyType.Elite,       favSameHero,            eMax / 2 - 1],
            [EnemyType.Minion,      favSameHero,            eMax / 2]
        ],
        [
            // assetNo 10
            // snipers
            [EnemyType.Boss,        Hero.Widowmaker,        1],
            [EnemyType.SubBoss,     Hero.Widowmaker,        3],
            [EnemyType.Elite,       FavoriteTankHero(),     eMax - 4]
        ],
        [],[],[],[],

        // progress asset
        [
            // assetNo 15
            // damage boss
            [EnemyType.Boss,        FavoriteDamageHero(),   1],
            [EnemyType.Elite,       RandomHero,             eMax / 2 - 1],
            [EnemyType.Minion,      RandomHero,             eMax / 2]
        ],
        [
            // assetNo 16
            // damage boss with tank elite
            [EnemyType.Boss,        FavoriteDamageHero(),   1],
            [EnemyType.Elite,       FavoriteTankHero(),     eMax / 2 - 1],
            [EnemyType.Minion,      RandomHero,             eMax / 2]
        ],
        [
            // assetNo 17
            // tank boss
            [EnemyType.Boss,        FavoriteTankHero(),     1],
            [EnemyType.Elite,       FavoriteDamageHero(),   eMax / 2 - 1],
            [EnemyType.Minion,      RandomHero,             eMax / 2]
        ],
        [
            // assetNo 18
            // double damage boss
            [EnemyType.Boss,        FavoriteDamageHero(),   1],
            [EnemyType.Boss,        FavoriteDamageHero(),   1],
            [EnemyType.Minion,      RandomHero,             eMax - 2]
        ],

        [
            // assetNo 19
            // debug
            [EnemyType.Elite,       Hero.WreckingBall,               eMax]
        ]
    ];

define enemyAssetNoLotteryList: [
    // basic
    0, 0,
    // sub boss and minion 
    1, 1,
    // all elite
    2, 2,
    // all elites same hero 
    3, 3,
    // half elite
    4, 4,
    // all minion
    5, 
    // double sub boss
    6, 6,
    // triple sub boss
    7, 
    // damage boss with minion
    8,
    // fav sameHero
    9,
    // snipers
    10
];


// TAG EnemyBot/Asset/Interval ----------
globalvar define reloadEnemyAssetInterval! = -1;
globalvar define enemyAssetNo! = -1;
globalvar define forceReloadEnemyAsset! = false;

rule: "EnemyBot/Asset/Interval/reloadReloadEnemyAsset"
Event.OngoingGlobal
if(
    IsGameInProgress() ||
    (
        IsInSetup() &&
        MatchTime() <= 5
    )
){
    while(true){
        // if force reload, skip change assetNo and set interval
        if(!forceReloadEnemyAsset){
            // choice asset by random
            enemyAssetNo = RandomValueInArray(enemyAssetNoLotteryList);
            // set default interval
            reloadEnemyAssetInterval = AssetChangeInterval();
            // change some hero
            allSameHero = RandomHero;
            favSameHero = RandomValueInArray([
                FavoriteDamageHero(),
                FavoriteTankHero()
            ]);
        }

        // get asset
        define asset! = enemyAssetList[enemyAssetNo];

        // valid asset
        if(
            0 < CountOf(asset)
        ){
            // play effect at all enemy
            PlayEffectsToTeam(enemyTeam);
            // reload bots by asset
            DestroyBots(enemyTeam);
            CreateBotsByAssetWithMutexLock(asset, enemyTeam, maxCreateEnemyBotNum);
            // wait start intarval until game start.
            WaitUntil(IsGameInProgress(), MaxValue());
            // release force reload flag
            forceReloadEnemyAsset = false;

            for(
                ;
                // if hasProgressAssetNo, skip interval count and reload asset instanty
                reloadEnemyAssetInterval > 0;
                reloadEnemyAssetInterval--
            ){
                Wait(1, WaitBehavior.IgnoreCondition);
                if(
                    // interrupt force reload
                    forceReloadEnemyAsset ||
                    // create bot error
                    0 >= NumberOfPlayers(enemyTeam)
                ){
                    break;
                }
            }
        }
        else{
            errLog(<"enemy asset is invalid">);
        }
        
        // avoid infite loop clash
        Wait(1, WaitBehavior.IgnoreCondition);
    }
}

rule: "EnemyBot/Asset/Interval/reloadBotAssetIntervalByProgress"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    define progressStage! = 0;

    while(true){
        define progress! = ObjectProgress(humanTeam);
        if(CurrentGameMode() == GameMode.Push){
            progress = progress - 50;
            progress *= 2;
        }
        
        define progressAssetNo! = -1;
        define progressAssetInterval!;

        if(
            progressStage == 0 && progress >= 10
        ){
            if(!HasObjectDirection()){
                spawnRushInterval = 0;
            }
            progressStage ++;
        }
        else if(
            progressStage == 1 && progress >= 20
        ){
            if(!HasObjectDirection()){
                spawnRushInterval = 0;
            }
            progressStage ++;
        }
        else if(
            progressStage == 2 && progress >= 30
        ){
            progressAssetNo = 15;
            progressAssetInterval = (AssetChangeInterval() - 60);
            progressStage ++;
        }
        else if(
            progressStage == 3 && progress >= 60
        ){
            progressAssetNo = 16;
            progressAssetInterval = (AssetChangeInterval() - 60);
            progressStage ++;
        }
        else if(
            progressStage == 4 && progress >= (FinaleProgress() - 5)
        ){
            progressAssetNo = RandomValueInArray([17, 18]);
            progressAssetInterval = MaxValue();
            progressStage ++;
        }

        // has progress asset
        if(progressAssetNo != -1){
            // set assetNo from progress asset
            // set interval from progress asset interval
            enemyAssetNo = progressAssetNo;
            reloadEnemyAssetInterval = progressAssetInterval;
            // force reload asset
            forceReloadEnemyAsset = true;
        }

        // check Interval
        WaitUpdateMediumCycle();
    }
}

void PlayEffectsToTeam(define team!) "PlayEffectsToTeam"{
    define players! = AllPlayers(team);
    for(define playersIndex! = 0; playersIndex < CountOf(players); playersIndex ++){
        // play blast
        PlayEffect(
            AllPlayers(), PlayEffect.GoodPickupEffect,
            TeamOf(players[playersIndex]) == enemyTeam ?
                enemyTeamColor :
                Color.Yellow,
            players[playersIndex],
            1
        );
    }
    Wait(0.1, WaitBehavior.IgnoreCondition);
}


// TAG EnemyBot/CautionColor ----------
define cautionColor: isBlink ? Color.Red : Color.Yellow;

globalvar define isBlink;

rule: "EnemyBot/CautionColor/blinkColor"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    while(true){
        isBlink = !isBlink;
        Wait(0.2, WaitBehavior.AbortWhenFalse);
    }
}

// TAG EnemyBot/CautionIcon ----------
playervar define cautionIcon;

define isCautionIconActive: 
    IsPlayerOnObject &&
    IsOnObjective(ep);

rule: "EnemyBot/CautionIcon/show"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    isCautionIconActive
){
    // show caution icon to enemys for easy to find interfering enemy from player
    DestroyIcon(cautionIcon);
    cautionIcon = CreateIcon(AllPlayers(humanTeam), ep, Icon.ExclamationMark,
        IconRev.PositionAndColor, cautionColor, true);
}

rule: "EnemyBot/CautionIcon/hide"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    !isCautionIconActive
){
    DestroyIcon(cautionIcon);
}

// TAG EnemyBot/ThreatIcon ----------
playervar define threatIcon;

define isThreatIconActive: 
    IsAlive() &&
    !IsInSpawnRoom();

rule: "EnemyBot/ThreatIcon/show"
Event.OngoingPlayer
if(
    enemyTeam == TeamOf() &&
    IsBossClass(ep) &&
    isThreatIconActive
){
    // show threat icon to boss enemys for easy to caution enemy from player
    DestroyIcon(threatIcon);
    threatIcon = CreateIcon(AllPlayers(), ep, Icon.Skull,
        IconRev.Position, enemyTeamColor, false);
}

rule: "EnemyBot/ThreatIcon/hide"
Event.OngoingPlayer
if(
    enemyTeam == TeamOf() &&
    IsBossClass(ep) &&
    !isThreatIconActive
){
    DestroyIcon(threatIcon);
}

// TAG Object ----------
globalvar define prevObjectPosition;
globalvar define objectDirection;
globalvar define blockedPos;
globalvar define positionObjectAhead;

define HasObjectDirection(): objectDirection != null;

rule: "Object/updateObjectDirectionAndPositionObjectAhead"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    Wait(0.1);  // wait object position change to enable
    prevObjectPosition = CurrentObjectPosition();

    while(true){
        define nowObjectPosition! = CurrentObjectPosition();
        if(
            IsPlayerOnObject &&
            nowObjectPosition != prevObjectPosition
        ){
            // update objectDirection
            objectDirection = DirectionTowards(prevObjectPosition, nowObjectPosition);
            // set prev position for next judge
            prevObjectPosition = nowObjectPosition;

        }

        WaitUpdateMediumCycle();
    }
}

// TAG EnemyBot/Teleport ----------
define placableAreaSize: 12;
globalvar define placableAreaExtendSize;
define placableAreaExtendSizeScaleOnPointCapture: 0.6;
define placableAreaExtendSizeScaleOnPayloadEscort: 0.4;
define placableAreaOffset: ActionRange.CanFind;   // bot can find other range

globalvar define teleportBasePosition;
playervar define teleportPosition;
define teleportAreaSize: 8;
define teleportAreaForceUpdateSize: teleportAreaSize * 1.01;    // same as teleportAreaSize

define IsPlayerOnObject: (0 < NumberOfPlayersOnObjective(humanTeam));
define IsEnemyOnObject: (0 < NumberOfPlayersOnObjective(enemyTeam));

// TAG EnemyBot/Teleport/GetTeleportBasePositionByClosestPlayer
define GetTeleportBasePositionByClosestPlayer() globalvar "GetTeleportBasePositionByClosestPlayer"{
    define returnPosition;
    define objectPosition = CurrentObjectOnPosition();
    define basePosition = PositionOf(ClosestPlayerTo(objectPosition, humanTeam));

    if(
        objectPosition == null ||
        basePosition == null
    ){
        return null;
    }

    // select teleportPosition
    returnPosition = 
        basePosition
            +
        RandomPosition(
            placableAreaSize,
            placableAreaSize,
            placableAreaSize
        )
            + 
        (
            DirectionTowards(basePosition, objectPosition)
                *
            DistanceBetween(basePosition, objectPosition) * 0.5
        );

    return returnPosition;
}

// TAG EnemyBot/Teleport/GetTeleportBasePositionByObject
define GetTeleportBasePositionByObject() globalvar "GetTeleportBasePositionByObject"{
    define returnPosition;
    define basePosition = CurrentObjectOnPosition();

    if(basePosition == null){
        return null;
    }

    if(
        // has object direction
        HasObjectDirection()
    ){
        if(
            // player on object
            IsPlayerOnObject
        ){
            // get teleportAreaExtendSize by object position and blockedPos
            define cutoutDistance! = placableAreaOffset - DistanceBetween(basePosition, blockedPos);
            // get teleportAreaExtendSize by cutoutDistance with scale
            placableAreaExtendSize = cutoutDistance * placableAreaExtendSizeScaleOnPayloadEscort;
        }
        else{
            // clear extend size by non cut off distance of object direction
            placableAreaExtendSize = 0;
        }

        // overwrite position by positionObjectAhead
        basePosition = positionObjectAhead;
    }
    else{
        // get teleportAreaExtendSize by fixed value of non object direction
        placableAreaExtendSize = placableAreaSize * placableAreaExtendSizeScaleOnPointCapture;
    }

    // select teleportPosition
    returnPosition = 
        basePosition
            +
        RandomPosition(
            placableAreaSize + placableAreaExtendSize,
            placableAreaSize + placableAreaExtendSize,
            placableAreaSize + placableAreaExtendSize
    );
    
    return returnPosition;
}

define searchPositionInterval: 0.1;
define searchPositionTryCountMax: 10;

define CanSnapMapSurface()"CanSnapMapSurface"{
    // walkable position is far
    return 
    !(
        (
            CurrentMap() == Map.Kings_Row ||
            CurrentMap() == Map.Kings_Row_Winter
        )
            &&
        ObjectiveIndex() == 0
            &&
        !IsPlayerOnObject
    );
}

define CanEncountPosition(define position) globalvar "CanEncountPosition"{
    define canEncount = false;

    if(
        // position valid
        position != null
                &&
        // Has line to near player
        IsInLineOfSight(
            position + PositionOffsetY1(),
            PositionOf(ClosestPlayerTo(position, humanTeam)) + PositionOffsetY1(),
            BarrierLOS.NoBarriersBlock
        )    
    ){
        canEncount = true;
    }

    return canEncount;
}

// TAG EnemyBot/Teleport/GetTeleportPositionByTeleportBasePosition
define GetTeleportPositionByTeleportBasePosition() playervar "GetTeleportPositionByTeleportBasePosition"{
    define returnPosition = null;
    define basePosition = teleportBasePosition;

    if(basePosition == null){
        return null;
    }

    for(define searchPositionTryCount = 0; searchPositionTryCount < searchPositionTryCountMax; searchPositionTryCount++){
        // select teleportPosition from teleportBasePosition around
        define candidatePosition = 
            basePosition
                +
            RandomPosition(
                teleportAreaSize,
                teleportAreaSize,
                teleportAreaSize
            );

        if(CanSnapMapSurface()){
            candidatePosition = NearestWalkablePosition(candidatePosition);
        }
        else{
            candidatePosition = BelowPosition(candidatePosition + Vector(0, teleportAreaSize * 2, 0));
        }

        if(
            // can encount player
            CanEncountPosition(candidatePosition)
        ){
            returnPosition = candidatePosition;
            break;
        }

        WaitReleaseServerLoad(ServerLoadType.GameMain);
        Wait(searchPositionInterval, WaitBehavior.AbortWhenFalse);
    }

    return returnPosition;
}

playervar define telBeam;

define maxDelayTime: 1.0;

void TeleportWithEffect(define isBeamFromBody!) playervar "TeleportWithEffect"{
    if(teleportPosition == null){return;}

    if(IsInSpawnRoom()){
        define waitTime! = RandomInteger(0.0, maxDelayTime);
            // // each order
            // SlotOf() *
            // // delay time unit by max delay time
            // (maxDelayTime / NumberOfPlayers(enemyTeam)) * 
            // // scale by alive bot num (not include self)
            // (NumberOfLivingPlayers(enemyTeam) - 1) / (NumberOfPlayers(enemyTeam) - 1);

        // dbgHudTxt(<"<1>, waitTime = <0>", waitTime, SlotOf()>);
        Wait(waitTime, WaitBehavior.AbortWhenFalse);
    }

    // show pre teleport effect
    PlayTeleportEffect(true, isBeamFromBody);
    // Teleport
    Teleport(ep, teleportPosition);
    // show teleport effect
    PlayTeleportEffect(false, isBeamFromBody);
}

define showTeleportBeamTime: 0.5;

void PlayTeleportEffect(define isBefore!, define isBeamFromBody!) playervar "PlayTeleportEffect"{
    // if before teleport
    if(isBefore){
        // show teleport beam to own position
        DestroyEffect(telBeam);

        telBeam = CreateBeamEffect(AllPlayers(),
            BeamType.BadBeam,
            isBeamFromBody ? 
                BodyPosition(ep) :
                teleportPosition + Vector(0, 30, 0),
            teleportPosition,
            enemyTeamColor, EffectRev.VisibleToPositionAndRadius);
        // wait for show teleport shadow of before
        Wait(showTeleportBeamTime / 2, WaitBehavior.IgnoreCondition);

        // play teleport shadow to own position
        PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, enemyTeamColor, PositionOf(ep), 1);
        // play teleport blast to teleport positon
        PlayEffect(AllPlayers(), PlayEffect.BadExplosion, enemyTeamColor, teleportPosition, 2);

        // wait for show teleport shadow of before
        Wait(showTeleportBeamTime / 2, WaitBehavior.IgnoreCondition);
    }
    else{
        // hide teleport beam to teleport positon
        DestroyEffect(telBeam);
        // play teleport shadow to teleport positon
        PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, enemyTeamColor, PositionOf(ep), 1);
        // play teleport sound
        PlayEffect(AllPlayers(), PlayEffect.RingExplosionSound, null, PositionOf(ep), 75);
    }
}

void DoTeleport(define isBeamFromBody!, define isEmgTeleport!)"DoTeleport"{
    define needGetNewPosition!;

    // do emergency teleport as threat enemy 
    if(
        isEmgTeleport
    ){
        // set teleportPosition by object position
        teleportPosition = BlockedPositon(CurrentObjectPosition(), objectDirection, 6);
    }
    else{
        // set teleportPosition by common position
        teleportPosition = GetTeleportPositionByTeleportBasePosition();
    }

    if(
        teleportPosition != null
    ){
        // teleport to teleportPosition
        TeleportWithEffect(isBeamFromBody);
    }
}

// TAG EnemyBot/Teleport/UpdateCommonTeleportBasePosition ----------
globalvar define needUpdateCommonTeleportBasePosition!;

rule: "EnemyBot/Teleport/UpdateCommonTeleportBasePosition"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    define objectPos! = CurrentObjectOnPosition();

    if(HasObjectDirection()){
        // get blockedPos by extension line collision position
        blockedPos = BlockedPositon(objectPos, objectDirection, placableAreaOffset);
        // get positionObjectAhead by between object position and blockedPos
        positionObjectAhead = ShiftedPosition(
            objectPos,
            DirectionTowards(objectPos, blockedPos),
            DistanceBetween(objectPos, blockedPos) * 0.75
        );
    }

    // if has not update flag of commonTeleportBasePosition
    if(!needUpdateCommonTeleportBasePosition){
        // set update flag
        if(
            // position invalid
            teleportBasePosition == null
        ){
            needUpdateCommonTeleportBasePosition = true;
            // dbgHudTxt(<"UP POS BY POS INV">);
        }
        else if(
            // position too close player
            DistanceBetween(
                teleportBasePosition,
                ClosestPlayerTo(teleportBasePosition, humanTeam)
            ) <= teleportAreaForceUpdateSize        
        ){
            needUpdateCommonTeleportBasePosition = true;
            // dbgHudTxt(<"UP POS BY CRS PLR">);
        }
        else{
            if(
                // player on object
                IsPlayerOnObject
            ){
                define checkPos! = HasObjectDirection() ? positionObjectAhead : objectPos;
                if(
                    // too far from checkPos
                    DistanceBetween(
                        teleportBasePosition,
                        checkPos
                    ) > placableAreaSize + placableAreaExtendSize
                ){
                    needUpdateCommonTeleportBasePosition = true;
                    // dbgHudTxt(<"UP POS BY FAR OBJ OR AHD">);
                }
                else if(
                    // has not line from positionObjectAhead
                    !IsInLineOfSight(
                        teleportBasePosition + PositionOffsetY1(),
                        checkPos,
                        BarrierLOS.NoBarriersBlock
                    )
                ){
                    needUpdateCommonTeleportBasePosition = true;
                    // dbgHudTxt(<"UP POS BY NON LINE OBJ OR AHD">);
                }
                else{
                    // dbgHudTxt(<"POS KEP">);
                }
            }
            else{
                if(
                    // position has not line to closest object player
                    !IsInLineOfSight(
                        teleportBasePosition + PositionOffsetY1(),
                        PositionOf(ClosestPlayerTo(CurrentObjectPosition(), humanTeam)) + PositionOffsetY1(),
                        BarrierLOS.NoBarriersBlock
                    )
                ){
                    needUpdateCommonTeleportBasePosition = true;
                    // dbgHudTxt(<"UP POS BY NON LINE PLT">);
                }
                else{
                    // dbgHudTxt(<"POS KEP">);
                }
            }
        } 
    }
    
    // if has update flag of commonTeleportBasePosition
    if(
        needUpdateCommonTeleportBasePosition
    ){
        define newPosition! = null;
        // calc new position
        if(
            // player on object
            IsPlayerOnObject
        ){
            // calc by object
            newPosition = GetTeleportBasePositionByObject();
        }
        else if(
            !IsNeedEscortObject(enemyTeam)
        ){
            // calc by closest player
            newPosition = GetTeleportBasePositionByClosestPlayer();
        }
        else{
            // without calc, set object position for escort 
            newPosition = CurrentObjectPosition();
        }

        // found position
        if(newPosition != null){
            // update commonTeleportBasePosition by new position
            teleportBasePosition = newPosition;
            // release update flag
            needUpdateCommonTeleportBasePosition = false;

            // dbgHudTxt(<"UP POS OK">);
        }
        else{
            // dbgHudTxt(<"UP POS NG">);
        }
    }

    WaitUpdateMediumCycle();
    WaitReleaseServerLoad(ServerLoadType.GameMain);
    LoopIfConditionIsTrue();
}

rule: "EnemyBot/Teleport/clearCommonTeleportBasePosition"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    teleportBasePosition != null &&
    Attacker() == ep
){
    if(IsProbabilityTrue(25)){
        // reset position by enemy sucide in invalid position
        needUpdateCommonTeleportBasePosition = true;
    }
}

rule: "EnemyBot/Teleport/teleportByRespawn"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsGameInProgress() &&
    IsInSpawnRoom() &&
    teleportBasePosition != null
){
    DoTeleport(false, false);
    Wait(1, WaitBehavior.AbortWhenFalse);
    WaitReleaseServerLoad(ServerLoadType.GameMain);
    LoopIfConditionIsTrue();
}

define checkTeleportConditionInterval: 2;
define checkTeleportConditionMaxCount: 2;

rule: "EnemyBot/Teleport/teleportOrHopForDefendObjectOnIdle"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsGameInProgress() &&
    !IsInSpawnRoom() &&
    IsAlive()
){
    define checkConditionCount = 0;

    while(checkConditionCount < checkTeleportConditionMaxCount){
        Wait(checkTeleportConditionInterval, WaitBehavior.AbortWhenFalse);
        WaitReleaseServerLoad(ServerLoadType.GameMain);

        if(
            // player on object
            IsPlayerOnObject &&
            // far from object
            DistanceBetween(ep, CurrentObjectPosition()) > ActionRange.CanFind
        ){
            // do teleport instantly
            break;
        }
        else if(
            // Has line to near player
            IsInLineOfSight(
                EyePosition(ep),
                EyePosition(ClosestPlayerTo(ep, humanTeam)),
                BarrierLOS.NoBarriersBlock
            )
        ){
            // keep position and reset count
            checkConditionCount = 0;
        }
        else{
            // keep position and count up
            checkConditionCount ++;

        }
    }

    // teleport
    DoTeleport(false, false);

    LoopIfConditionIsTrue();
}

// TAG EnemyBot/EnemyAbility/SpawnRush ----------
globalvar define spawnRushInterval;
globalvar define spawnRushCount;

rule: "EnemyBot/EnemyAbility/SpawnRush"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    // set default interval by object progress
    spawnRushInterval = ObjectProgressScaledInterval(humanTeam, 30, 60) + RandomInteger(0, 5);
    // apply workshop setting
    spawnRushInterval *= WorkshopSettingReal("Enemy Bot Settings", "Spawn-Rush Interval Scale", 1.0, 0.0, 100, 2);
    // round for counting
    spawnRushInterval = RoundToInteger(spawnRushInterval, Rounding.Up);
    for(;spawnRushInterval > 0; spawnRushInterval--){
        Wait(1, WaitBehavior.IgnoreCondition);
    }

    // action
    define spawnRushDuration! = RandomInteger(5, 25);
    spawnRushDuration *= WorkshopSettingReal("Enemy Bot Settings", "Spawn-Rush Duration Scale", 1.0, 0.0, 100, 2);
    define deployRushInterval! = RandomInteger(1, 5);
    spawnRushCount = RoundToInteger(spawnRushDuration / deployRushInterval, Rounding.Down);
    for(; spawnRushCount > 0; spawnRushCount--){
        Respawn(
            FilteredArray(
                AllDeadPlayers(enemyTeam),
                (
                    ae.enemyType != EnemyType.Boss
                )
            )
        );
        Wait(deployRushInterval, WaitBehavior.IgnoreCondition);
        WaitReleaseServerLoad(ServerLoadType.GameMain);
    }

    LoopIfConditionIsTrue();
}

// TAG EnemyBot/EnemyAbility/ShotCall ----------
globalvar define shotCallInterval;

rule: "EnemyBot/EnemyAbility/ShotCall"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    // set default interval by object progress
    shotCallInterval = ObjectProgressScaledInterval(humanTeam, 30, 60) + RandomInteger(0, 5);
    // apply workshop setting
    shotCallInterval *= WorkshopSettingReal("Enemy Bot Settings", "All-Out-Ultmate Interval Scale", 1.0, 0.0, 100, 3);
    // round for counting
    shotCallInterval = RoundToInteger(shotCallInterval, Rounding.Up);
    for(;shotCallInterval > 0; shotCallInterval--){
        Wait(1, WaitBehavior.IgnoreCondition);
    }

    // action
    define activeEnemys! = AllPlayers(enemyTeam);
    define shotCallDelay! = RandomReal(0.2, 1.0);
    for(define scLoopIndex! = 0; scLoopIndex < CountOf(activeEnemys); scLoopIndex ++){
        if(
            IsAlive(activeEnemys[scLoopIndex]) &&
            !IsInSpawnRoom(activeEnemys[scLoopIndex])
        ){
            SetUltimateCharge(activeEnemys[scLoopIndex], DefaultPercentage());
            PressButton(activeEnemys[scLoopIndex], Button.Ultimate);

            Wait(shotCallDelay, WaitBehavior.IgnoreCondition);
            WaitReleaseServerLoad(ServerLoadType.GameMain);
        }
    }

    LoopIfConditionIsTrue();
}

// TAG EnemyBot/EnemyAbility/CombatTeleport ----------
playervar define combatTeleportInterval;

rule: "EnemyBot/EnemyAbility/CombatTeleport"
Event.OngoingPlayer
if(
    IsGameInProgress() &&
    TeamOf() == enemyTeam &&
    IsBossClass(ep)
){
    // set default interval by object progress
    combatTeleportInterval = ObjectProgressScaledInterval(humanTeam, 10, 20) + RandomInteger(0, 5);
    // apply workshop setting
    combatTeleportInterval *= WorkshopSettingReal("Enemy Bot Settings", "(Sub Boss & Boss) Combat-Teleport Interval Scale", 1.0, 0.0, 100, 4);
    // apply scale by each enemy action range
    if(actionRangeMax == ActionRange.Melee){
        combatTeleportInterval *= 1;
    }
    else if(actionRangeMax == ActionRange.Close){
        combatTeleportInterval *= 2.0;
    } 
    else if(actionRangeMax == ActionRange.Middle){
        combatTeleportInterval *= 3.0;
    } 
    else if(actionRangeMax == ActionRange.Far){
        combatTeleportInterval *= 4;
    }
    combatTeleportInterval = RoundToInteger(combatTeleportInterval, Rounding.Up);

    define isEmgTeleport! = false;

    for(;combatTeleportInterval > 0; combatTeleportInterval --){
        Wait(1, WaitBehavior.IgnoreCondition);

        if(
            // player team close win
            IsCloseWin(humanTeam) &&
            // enemy not on object
            !IsEnemyOnObject &&
            // player on object
            IsPlayerOnObject
        ){
            // interrupt teleport for defend object in finale phase
            isEmgTeleport = true;
            break;
        }

        WaitReleaseServerLoad(ServerLoadType.GameMain);
    }

    if(IsAlive()){
        // teleport with teleport beam from body
        // teleport with emergency by close lose
        DoTeleport(true, isEmgTeleport);
    }
    LoopIfConditionIsTrue();
}

define moreAbilityProb: DefaultPercentage();
define moreAbilityInterval: RandomReal(0.1, 3);

globalvar define moreUltProb;

rule: "EnemyBot/EnemyAbility/moreUltimate"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsBossClass(ep) &&
    IsAlive() &&
    actionState != ActionState.Non &&
    IsUsingUltimate()
){
    WaitUntil(!IsUsingUltimate(), MaxValue());    
    
    moreUltProb = moreAbilityProb;
    while(
        IsAlive() &&
        IsProbabilityTrue(moreUltProb)
    ){
        SetUltimateCharge(ep, DefaultPercentage());
        WaitReleaseServerLoad(ServerLoadType.GameMain);
        Wait(moreAbilityInterval, WaitBehavior.IgnoreCondition);

        PressButton(ep, Button.Ultimate);
        WaitUntil(!IsUsingUltimate(), MaxValue());
    }
    moreUltProb = 0;

    WaitUntil(!IsUsingUltimate(), MaxValue());
    Wait(1, WaitBehavior.IgnoreCondition);
}

globalvar define decreaseProb! =
    WorkshopSettingReal("Enemy Bot Settings", "(Sub boss & Boss) Rapid-Fire-Ultimate Termination Scale", 1.0, 0.0, 100, 5) * 10;

rule: "EnemyBot/EnemyAbility/decreaseMultiUltimateProb"
Event.OngoingGlobal
if(
    moreUltProb > 0
){
    moreUltProb -= moreUltProb < decreaseProb ? moreUltProb : decreaseProb;
    Wait(1.0, WaitBehavior.IgnoreCondition);
    LoopIfConditionIsTrue();
}

// TAG Debug ----------
globalvar define countDetectTriggerServerLoadPerSecond;

rule: "DebugGlobalAction"
Event.OngoingGlobal
Team.All
if(
    IsGameInProgress()
){
    // // commonTeleportBasePosition orb
    // CreateEffect(teleportBasePosition != null ? hp : null, Effect.Orb, Color.Red,
        //     teleportBasePosition + PositionOffsetY1(), 1, EffectRev.VisibleToPositionAndRadius);
    // // positionObjectAhead orb
    // CreateEffect(positionObjectAhead != null ? hp : null, Effect.Orb, Color.White,
        //     positionObjectAhead, 1, EffectRev.VisibleToPositionAndRadius);

    // // teleportAreaSize ring
    // CreateEffect(teleportBasePosition != null ? hp : null, Effect.Ring, Color.Red,
        //     teleportBasePosition, teleportAreaSize, EffectRev.VisibleToPositionAndRadius);
    // // teleportAreaForceUpdateRange ring
    // CreateEffect(teleportBasePosition != null ? hp : null, Effect.Ring, Color.Yellow,
        //     teleportBasePosition, teleportAreaForceUpdateSize, EffectRev.VisibleToPositionAndRadius);

    // // placable teleportPosition area size sphere
    // CreateEffect(hp,
        //     Effect.Sphere, Color.White,
        //     HasObjectDirection() ?
            //         positionObjectAhead :
            //         CurrentObjectOnPosition(),
        //     placableAreaSize + placableAreaExtendSize,
        //     EffectRev.VisibleToPositionAndRadius);

    // // object -> positionObjectAhead beam
    // CreateBeamEffect(HasObjectDirection() ? hp : null, BeamType.GoodBeam, 
        //     CurrentObjectOnPosition(),
        //     positionObjectAhead, 
        //     Color.White, EffectRev.VisibleToPositionAndRadius);
    // // positionObjectAhead or object -> commonTeleportBasePosition beam
    // CreateBeamEffect(hp, BeamType.GoodBeam, 
        //     HasObjectDirection() ? positionObjectAhead : CurrentObjectOnPosition(),
        //     teleportBasePosition + PositionOffsetY1(), 
        //     Color.Red, EffectRev.VisibleToPositionAndRadius);
    // // commonTeleportBasePosition -> host player or object beam
    // CreateBeamEffect(hp, BeamType.GoodBeam, 
        //     HasSpawned(hp) ? hp : CurrentObjectOnPosition(),
        //     teleportBasePosition + PositionOffsetY1(), 
        //     Color.Blue, EffectRev.VisibleToPositionAndRadius);

    define pastSecond = 1;

    while(true){
        countDetectTriggerServerLoadPerSecond = countWaitActionByServerLoad / pastSecond;
        pastSecond ++;

        // auto use friend bot hero mod
        if(
            IsProbabilityTrue(GameProgressDiff(humanTeam) * -0.15) &&
            IsGameInProgress()
        ){
            forceHeroMod();
        }
        Wait(1);
    }
}

// rule: "DebugPlayerAction"
// Event.OngoingPlayer
// Team.All
// if(
//     ep == hp &&
//     HasSpawned() &&
//     IsJumping()
// ){
//     define player = RandomValueInArray(AllPlayers(humanTeam));
//     player.heroModType = HeroModType.SHOT_CALL;
//     SetUltimateCharge(player, 100);
//     // Wait(1);
//     // Loop();
// }

rule: "DebugPlayJoinPlayerSound"
Event.OnPlayerJoin
Team.All
if(
    !IsDummyBot()
){
    define positionArray! = [
        PositionOf(hp),
        SpawnPoints(humanTeam)[0],
        CurrentObjectPosition(),
        SpawnPoints(enemyTeam)[0]
    ];

    for(define index! = 0; index < 5; index++){
        for(define index2! = 0; index2 < 5; index2++){
            PlayEffect(HostPlayer(),
                PlayEffect.DebuffImpactSound,
                null, positionArray[index2], MaxValue());
        }
        Wait(0.5);
    }
}

rule: "Debug/initDebugMode"
Event.OngoingGlobal
Team.All
if(
    initCompleted
){
    if(IsHostPlayerInGame()){
        debugMode = DebugMode.Non;
    }
    else{
        debugMode = DebugMode.DebugParam;
        ShowDebugHud(hp);
    }
}

rule: "Debug/changeDebugMode"
Event.OngoingPlayer
Team.All
if(
    hp == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Jump) 
){
    // change debug mode
    WaitLongPressConfirm();
    
    if(debugMode >= DebugMode.Recording){
        debugMode = DebugMode.Non;
    }
    else{
        debugMode ++;
    }

    // reload hud
    HideDebugHud();
    ShowDebugHud(hp);
}

globalvar define debugHuds;

define Last():
    CountOf(debugHuds);

define FirstEnemyOf(in define enemyType):
    FirstOf(FilteredArray(AllPlayers(enemyTeam), ae.enemyType == enemyType));

define FirstBossClassEnemy():
    FirstOf(FilteredArray(AllPlayers(enemyTeam), IsBossClass(ae)));

// show debug icon and hud
void ShowDebugHud(define player!)"ShowDebugHud"{
    if(
        debugMode >= DebugMode.Recording
    ){
        EnableInspectorRecording();
        debugHuds[Last()] = CreateDebugHud("●Recording", true, Color.Red);
    }
    else{
        DisableInspectorRecording();
    }

    if(
        debugMode >= DebugMode.Non
    ){
        debugHuds[Last()] = CreateDebugHud("human player Num", HumanPlayerNum(humanTeam), HumanPlayerNum(humanTeam) <= 1 ? Color.Team2 : Color.Yellow);
    }
    
    if(
        debugMode >= DebugMode.ServerLoad
    ){
        debugHuds[Last()] = CreateDebugHud("Server Load", ServerLoad(),
            isServerLoadLevel(ServerLoadLevel.Overload) ? Color.Red :
            isServerLoadLevel(ServerLoadLevel.Busy) ? Color.Yellow :
            isServerLoadLevel(ServerLoadLevel.Hot) ? Color.Green :
            isServerLoadLevel(ServerLoadLevel.Warm) ? Color.Blue :
            Color.Gray);
        // debugHuds[Last()] = CreateDebugHud("Server Load Average", ServerLoadAverage(), ServerLoadAverage() < 255 ? Color.Gray : Color.Yellow);
        // debugHuds[Last()] = CreateDebugHud("Server Load Peak", ServerLoadPeak(), ServerLoadPeak() < 255 ? Color.Gray : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("game Logic Speed", gameLogicSpeed, gameLogicSpeed >= 100 ? Color.Gray : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("count Game Logic Speed Decrease", countGameLogicSpeedDecrease, Color.Gray);
        debugHuds[Last()] = CreateDebugHud("count Wait Action By Server Load", countWaitActionByServerLoad, Color.Gray);
        debugHuds[Last()] = CreateDebugHud("count Wait Action By Server Load Per Second", countDetectTriggerServerLoadPerSecond, Color.Gray);
    }

    if(
        debugMode >= DebugMode.DebugParam
    ){  
        // player team
        debugHuds[Last()] = CreateDebugHud("team player Num", <"<0> / <1>", NumberOfLivingPlayers(humanTeam), NumberOfPlayers(humanTeam)>, NumberOfLivingPlayers(humanTeam) >= NumberOfPlayers(humanTeam) ? Color.Team2 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("reload Asset Interval", reloadFriendBotAssetInterval, reloadFriendBotAssetInterval > 5 ? Color.Team2 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("asset Number", friendBotAssetNo, Color.Team2);
        debugHuds[Last()] = CreateDebugHud("death Count", playerDeathCount, Color.Team2);

        // enemy team
        debugHuds[Last()] = CreateDebugHud("team player num", <"<0> / <1>", NumberOfLivingPlayers(enemyTeam), NumberOfPlayers(enemyTeam)>, NumberOfLivingPlayers(enemyTeam) >= NumberOfPlayers(enemyTeam) ? enemyTeamColor : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("reload Asset Interval", reloadEnemyAssetInterval, reloadEnemyAssetInterval > 5 ? enemyTeamColor : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("Asset Number", enemyAssetNo, enemyTeamColor);
        debugHuds[Last()] = CreateDebugHud("death Count", <"<0>, <1>, <2>, <3>", enemyDeathCount[0], enemyDeathCount[1], enemyDeathCount[2], enemyDeathCount[3]>, enemyTeamColor);
        debugHuds[Last()] = CreateDebugHud("auto Tune Dmg Dlt", autoTuneDmgDlt, enemyTeamColor);
        debugHuds[Last()] = CreateDebugHud("Game Progress Diff", GameProgressDiff(humanTeam), enemyTeamColor);
        debugHuds[Last()] = CreateDebugHud("spawn Time scale", spawnTimeScale, enemyTeamColor);
        debugHuds[Last()] = CreateDebugHud("spawn Interval", <"<0>, <1>, <2>, <3>",
            FirstEnemyOf(EnemyType.Minion).confirmSpawnInterval,
            FirstEnemyOf(EnemyType.Elite).confirmSpawnInterval,
            FirstEnemyOf(EnemyType.SubBoss).confirmSpawnInterval,
            FirstEnemyOf(EnemyType.Boss).confirmSpawnInterval>, enemyTeamColor);
        debugHuds[Last()] = CreateDebugHud("spawn Rush Interval", spawnRushInterval, spawnRushInterval > 5 ? enemyTeamColor : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("spawn Rush Count", spawnRushCount, spawnRushCount <= 0 ? enemyTeamColor : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("shot Call Interval", shotCallInterval, shotCallInterval > 5 ? enemyTeamColor : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("combat Teleport Interval",
            FirstBossClassEnemy().combatTeleportInterval,
            FirstBossClassEnemy().combatTeleportInterval > 5 ? enemyTeamColor : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("more Ult Prob", moreUltProb, moreUltProb <= 0 ? enemyTeamColor : Color.Yellow);      
    }
}

// Hide debug icon and hud
void HideDebugHud()"HideDebugHud"{
    for(gLoopIndex = 0; gLoopIndex < CountOf(debugHuds); gLoopIndex ++){
        DestroyHudText(debugHuds[gLoopIndex]);
    }
}

rule: "Debug/resetBotList"
Event.OngoingPlayer
Team.All
if(
    hp == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Crouch)
){
    WaitLongPressConfirm();
    reloadEnemyAssetInterval = 0;
    WaitLongPressConfirm();
    WaitUntil(reloadEnemyAssetInterval > 0, 10);
    reloadFriendBotAssetInterval = 0;
}

rule: "Debug/triggerRushAndShotCall"
Event.OngoingPlayer
Team.All
Player.All
if(
    hp == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Reload)
){
    WaitLongPressConfirm();
    AllPlayers(enemyTeam).combatTeleportInterval = 0;
    WaitLongPressConfirm();
    spawnRushInterval = 0;
    WaitLongPressConfirm();
    shotCallInterval = 0;
}

playervar define tempName!;

rule: "Debug/deployGunship"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.PrimaryFire)
){
    // kill players on aim center
    WaitLongPressConfirm();
    forceHeroMod();

    LoopIfConditionIsTrue();
}

void forceHeroMod()"forceHeroMod"{
    define player! = 
        RandomValueInArray(
            FilteredArray(
                AllPlayers(humanTeam),
                (
                    IsDummyBot(ae) &&
                    !ae.isTransformed
                )
            )
        );

    player.heroModType = RandomValueInArray([
        HeroModType.HEALING_SYRINGE,
        HeroModType.SAVIOR,
        HeroModType.POWERFUL_GIFT,
        HeroModType.SUPER_ULT,
        HeroModType.SHOT_CALL,
        HeroModType.ARTILLERY_REQUEST,
        HeroModType.STRAFING_REQUEST,
        HeroModType.GRUDGE_FIRE_BALL,
        HeroModType.GRUDGE_LIGHTNING,
        HeroModType.BEAM_SNIPER,
        HeroModType.TITAN_FORM,
        HeroModType.GUNSHIP_GUNNER,
        HeroModType.GUNSHIP_GUNNER,
        HeroModType.GUNSHIP_GUNNER
    ]);

    if(IsDead(player)){
        Resurrect(player);
    }
    player.grudgePower = 100;
    SetUltimateCharge(player, DefaultPercentage());
    PressButton(player, Button.Ultimate);
}
