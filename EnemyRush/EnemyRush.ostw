import "EnemyRush.setting.json";
import "../Lib/Debug.del";
import "../Lib/Utility.del";
import "../Lib/ServerOverLoadMeasures.del";
import "../Lib/Bot.del";
import "../Lib/Buddy.del";
import "../Lib/Vote.del";
import "../Lib/HeroMod.del";

// TAG Signature and infomation ----------
disabled rule: "[PVE] ENEMY RUSH ver.9.6 / Share code [V7PEF]. You allowed copy or modify code." -1 {}
disabled rule: "This mod was provaide by WORKSHOP.CODES. Check detail with XXXX" -1 {}
disabled rule: "This script was generated by ItsDeltin/Overwatch-Script-To-Workshop. Check detail with https://github.com/ItsDeltin/Overwatch-Script-To-Workshop" -1 {}
disabled rule: "This original script was created by sarami77#1868. Check detail with https://github.com/sarami77/OverwatchWorkShopScripts" -1 {}

// TAG Initialize ----------
define playerTeam: Team.Team2;
define enemyTeam: Team.Team1;
define allTeam: Team.All;

globalvar define initCompleted;

rule: "Initialize/initialize"
Event.OngoingGlobal
{
    // Stop records to reduce server load
    DisableInspectorRecording();

    // If run it right after loading the server, some scripts fail, so wait 3 seconds
    Wait(5, WaitBehavior.AbortWhenFalse);

    // Start watch over load
    slowControlHandler = SlowControlHandler.ServerOverLoadMeasures;

    // show version and share code
    CreateHudText(AllPlayers(),
        null, "[PVE] ENEMY RUSH ver.9.6 / Share code [V7PEF]", null,
        Location.Left, -999,
        Color.White, Color.Gray, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleAlways);

    // Notify completion of init game setting and start game main logic
    initCompleted = true;
}

// TAG Round ----------
rule: "Round/shortenAssemblePhase"
Event.OngoingGlobal
if(
    IsAssemblingHeroes()
){
    SetMatchTime(40);

    // wait player join server
    Wait(10, WaitBehavior.AbortWhenFalse);
    
    if(
        // no human
        HumanPlayerNum(playerTeam) <= 0
            ||
        // host human only
        (
            // 1 human only
            HumanPlayerNum(playerTeam) == 1
                &&
            // human is host player
            hp ==
                FirstOf(
                    FilteredArray(
                        AllPlayers(playerTeam),
                        !IsDummyBot(ae)
                    )
                )
        )
    ){
        // omit assemble phase
        SetMatchTime(0);
    }
}

rule: "Round/shortenSetupPhase"
Event.OngoingGlobal
if(
    IsInSetup()
){
    SetMatchTime(40);

    if(
        // no human
        HumanPlayerNum(playerTeam) <= 0
    ){
        // omit setup phase
        SetMatchTime(0);
    }
}

// globalvar define matchTimeScale! = WorkshopSettingReal("Game Settings", "Match Time Scale", 1.0, 0.01, 100, 1);

// rule: "Round/AddMatchTime1"
// Event.OngoingGlobal
// if(
//     IsGameInProgress()
// ){
//     // defualt add 300s
//     SetMatchTime(MatchTime() + (300 * (1 - matchTimeScale)));
// }

// rule: "Round/AddMatchTime2"
// Event.OngoingGlobal
// if(
//     IsObjectiveComplete(0)
// ){
//     // defualt add 180s
//     SetMatchTime(MatchTime() + (180 * (1 - matchTimeScale)));
// }

// rule: "Round/AddMatchTime3"
// Event.OngoingGlobal
// if(
//     IsObjectiveComplete(1)
// ){
//     // defualt add 120s
//     SetMatchTime(MatchTime() + (120 * (1 - matchTimeScale)));
// }

// TAG FinalStand ----------
globalvar define hasFinalStand! = true;

rule: "FinalStand/FinalStand"
Event.OngoingGlobal
if(
    IsGameInProgress() &&
    IsOverTime() &&
    hasFinalStand
){
    BigMessage(AllPlayers(playerTeam), "Final Stand !");
    slowControlHandler = SlowControlHandler.GameLogic;
    SetSlowMotion(10);
    Wait(0.25, WaitBehavior.IgnoreCondition);   // show slow

    // buff player team
    PlayEffectsToTeam(playerTeam);
    Heal(AllLivingPlayers(playerTeam), null, MaxValue());
    SetUltimateCharge(AllLivingPlayers(playerTeam), 100);
    Resurrect(AllDeadPlayers(playerTeam));
    Wait(0.25, WaitBehavior.IgnoreCondition);   // show slow

    SetSlowMotion(DefaultPercentage());
    slowControlHandler = SlowControlHandler.ServerOverLoadMeasures;
    Wait(1, WaitBehavior.IgnoreCondition);
    
    CreateHudText(
        AllPlayers(playerTeam),
        null, null, "No next \"final stand\"", Location.Left, 999, null, null, cautionColor, HudTextRev.Color, Spectators.VisibleNever);
    hasFinalStand = false;
}

// TAG Player/Config ----------
rule: "Player/Config/init"
Event.OngoingPlayer
if(
    initCompleted &&
    HasSpawned()
){
    // set max respawn time
    define respawnTime! = 10 * WorkshopSettingReal("Player Settings", "Max Respawn Time Scale", 1.0, 0.01, 100, 1);
    define receiveDamage! = 100 * WorkshopSettingReal("Player Settings", "Receive Damage Scale", 1.0, 0.01, 100, 2);

    if(!IsDummyBot()){
        // human player
        SetRespawnMaxTime(ep, respawnTime);
        SetDamageReceived(ep, receiveDamage);

        // show operation message
        Wait(5, WaitBehavior.IgnoreCondition);
        if(IsInSetup()){
            BigMessage(ep, "You can choose game difficulty vote and hero mod." + NL + "Check top left of screen!");
            PlayEffect(ep, PlayEffect.BuffImpactSound, ep, null, MaxValue());

            WaitUntil(MatchTime() <= 10, 60);

            BigMessage(ep, "Have you chosen game difficulty vote and hero mod?" + NL + "are you ready?");
            PlayEffect(ep, PlayEffect.BuffImpactSound, ep, null, MaxValue());
        }
        else{
            BigMessage(ep, "You can choose hero mod." + NL + "Check top left of screen!");
            PlayEffect(ep, PlayEffect.BuffImpactSound, ep, null, MaxValue());
        }  
    }
    else{
        // dummy bot
        // respawn time 30% cut
        SetRespawnMaxTime(ep, respawnTime * 0.7);
        // receive damage 30% cut
        SetDamageReceived(ep, receiveDamage * 0.7);
    }
}

// TAG Player/HumanIcon ----------
playervar define humanIcon!;

define isHumanIconActive: 
    IsAlive();

rule: "Player/HumanIcon/show"
Event.OngoingPlayer
if(
    playerTeam == TeamOf() &&
    HasSpawned() &&
    !IsDummyBot() &&
    isHumanIconActive
){
    // show human icon to human players for easy to find other human from human player
    DestroyIcon(humanIcon);
    humanIcon = CreateIcon(AllPlayers(), ep, Icon.Asterisk,
        IconRev.Position, Color.Team2, false);
}

rule: "Player/HumanIcon/hide"
Event.OngoingPlayer
if(
    playerTeam == TeamOf() &&
    HasSpawned() &&
    !IsDummyBot() &&
    !isHumanIconActive
){
    DestroyIcon(humanIcon);
}

// TAG Buddy/BotActive ----------
define canBuddyBotActive:
    IsAlive();

rule: "Buddy/BotActive/activate"
Event.OngoingPlayer
if(
    TeamOf() == playerTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    canBuddyBotActive
){
    isBotActive = true;
}

rule: "Buddy/BotActive/deactive"
Event.OngoingPlayer
if(
    TeamOf() == playerTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    !canBuddyBotActive
){
    isBotActive = false;
}

// TAG Buddy/Config ----------
rule: "Buddy/Config/init"
Event.OngoingPlayer
if(
    TeamOf() == playerTeam &&
    IsDummyBot() &&
    HasSpawned()
){
    watchUpdateRate = 1.0;
}

// TAG Buddy/Asset ----------
define buddyAssetList:
    [
        // fix hero asset
        [   // assetNo 0
            // recommend
            [EnemyType.Non,    Hero.Mercy,      1],
            [EnemyType.Non,    Hero.Genji,      1],
            [EnemyType.Non,    Hero.Reinhardt,  1],
            [EnemyType.Non,    Hero.Ana,        1],
            [EnemyType.Non,    Hero.Hanzo,      1],
            [EnemyType.Non,    Hero.Mauga,      1],
            [EnemyType.Non,    Hero.Zenyatta,   1],
            [EnemyType.Non,    Hero.Soldier76,  1]
        ],
        [   // assetNo 1
            // recommend
            [EnemyType.Non,    Hero.Moira,      1],
            [EnemyType.Non,    Hero.Reaper,     1],
            [EnemyType.Non,    Hero.Ramattra,   1],
            [EnemyType.Non,    Hero.Baptiste,   1],
            [EnemyType.Non,    Hero.Sojourn,    1],
            [EnemyType.Non,    Hero.Mauga,      1],
            [EnemyType.Non,    Hero.Brigitte,   1],
            [EnemyType.Non,    Hero.Genji,      1]
        ],
        [   // assetNo 2
            // recommend
            [EnemyType.Non,    Hero.Illari,     1],
            [EnemyType.Non,    Hero.Sojourn,    1],
            [EnemyType.Non,    Hero.Ramattra,   1],
            [EnemyType.Non,    Hero.Lifeweaver, 1],
            [EnemyType.Non,    Hero.Ashe,       1],
            [EnemyType.Non,    Hero.Mauga,      1],
            [EnemyType.Non,    Hero.Kiriko,     1],
            [EnemyType.Non,    Hero.Cassidy,    1]
        ],
        // 3,4,5,6,7,8,9,
        [],[],[],[],[],[],[],

        // random hero asset
        [
            // assetNo 10
            // random with fix role
            [EnemyType.Non,    RandomSupportHero,  1],
            [EnemyType.Non,    RandomTankHero,     1],
            [EnemyType.Non,    RandomDamageHero,   1],
            [EnemyType.Non,    RandomSupportHero,  1],
            [EnemyType.Non,    RandomTankHero,     1],
            [EnemyType.Non,    RandomDamageHero,   1],
            [EnemyType.Non,    RandomSupportHero,  1],
            [EnemyType.Non,    RandomDamageHero,   1]
        ],
        [
            // assetNo 11
            // random with non role
            [EnemyType.Non,    RandomHero, 1],
            [EnemyType.Non,    RandomHero, 1],
            [EnemyType.Non,    RandomHero, 1],
            [EnemyType.Non,    RandomHero, 1],
            [EnemyType.Non,    RandomHero, 1],
            [EnemyType.Non,    RandomHero, 1],
            [EnemyType.Non,    RandomHero, 1],
            [EnemyType.Non,    RandomHero, 1]
        ],
        [
            // assetNo 12
            // many damage role
            [EnemyType.Non,    FavoriteSupportHero(), 1],
            [EnemyType.Non,    FavoriteSupportHero(), 1],
            [EnemyType.Non,    FavoriteDamageHero(),  6]
        ],
        [
            // assetNo 13
            // many tank role
            [EnemyType.Non,    FavoriteSupportHero(), 1],
            [EnemyType.Non,    FavoriteSupportHero(), 1],
            [EnemyType.Non,    FavoriteTankHero(),    6]
        ],
        // 14,15,16,17,18,19,
        [],[],[],[],[],[],

        // debug asset
        [
            // assetNo 20
            // for debug
            [EnemyType.Non,    Hero.Lucio,  4],
            [EnemyType.Non,    Hero.Cassidy,3],
            [EnemyType.Non,    Hero.Sigma,  1]
        ]
    ];

define buddyAssetNoLotteryList: [
    // fix hero asset
    0, 0,
    1, 1,
    2, 2,

    // random hero asset
    10, 10, 10,
    11,
    12,
    13

    // for debug
    // 20
];

globalvar define isLockedCreateBotsByAsset! = false;

void CreateBotsByAssetWithMutexLock(in define asset!, in define team!, in define addLimitNum!){ 
    // can't implement as subroutin for mutex  
    define forceReleaseCount! = 0;
    while(isLockedCreateBotsByAsset){
        if(forceReleaseCount < 5){
            forceReleaseCount ++;
        }
        else{
            break;
        }
        Wait(1, WaitBehavior.IgnoreCondition);
    }
    isLockedCreateBotsByAsset = true;
    CreateBotsByAsset(asset, team, addLimitNum);
    isLockedCreateBotsByAsset = false;
}

define PlayerNum():
    CountOf(
        FilteredArray(
            AllPlayers(playerTeam),
            !IsDummyBot(ae)
        )
    );

define BuddyNum():
    CountOf(
        FilteredArray(
            AllPlayers(playerTeam),
            IsDummyBot(ae)
        )
    );

define needBuddyNum:
    maxBuddyBotNum - PlayerNum();

globalvar define maxBuddyBotNum! =
    WorkshopSettingInteger("Ally Bot Settings", "Filling Slot Count (join as proxy when player slot absent)", 8, 0, 8, 1);

globalvar define buddyAssetNo!;

globalvar define forceReloadBuddyAsset! = false;

// TAG Buddy/Asset/Interval ----------
define AssetChangeInterval(): RandomInteger(120, 180);
globalvar define reloadBuddyAssetInterval! = -1;

rule: "Buddy/BotAssetInterval/reloadReloadBuddyAsset"
Event.OngoingGlobal
if(
    initCompleted
){
    define prevAssetNo! = -1;

    while(true){
        // if force reload, skip change assetNo and set interval
        if(!forceReloadBuddyAsset){
            // choice asset by random
            buddyAssetNo = RandomValueInArray(buddyAssetNoLotteryList);
            // set default interval
            reloadBuddyAssetInterval = AssetChangeInterval();
        }

        if(
            // force reload
            forceReloadBuddyAsset ||
            // assetNo changed
            prevAssetNo != buddyAssetNo
        ){
            // save current assetNo
            prevAssetNo = buddyAssetNo;
            // save avg ult charge of bots
            define ultCharge! = GetAvgUltChgOfDummyBot(playerTeam);
            // create bots by asset
            DestroyBots(playerTeam);
            CreateBotsByAssetWithMutexLock(buddyAssetList[buddyAssetNo], playerTeam, needBuddyNum);
            // restore avg ult charge of bots
            SetAvgUltChgOfDummyBot(playerTeam, ultCharge);
        }

        // relealse force reload
        forceReloadBuddyAsset = false;
        // wait start intarval until game start.
        WaitUntil(IsGameInProgress() || forceReloadBuddyAsset, MaxValue());

        for(;reloadBuddyAssetInterval > 0 && !forceReloadBuddyAsset; reloadBuddyAssetInterval--){
            Wait(1, WaitBehavior.IgnoreCondition);
        }
    }
}

rule: "Buddy/tuneAssetMemberNum"
Event.OngoingGlobal
if(
    initCompleted
){
    define prevPlayerNum! = -1;

    // set initial asset no
    buddyAssetNo = RandomValueInArray(buddyAssetNoLotteryList);

    while(true){
        if(
            // create bot not locked
            !isLockedCreateBotsByAsset &&
            (
                // playerNum changed
                prevPlayerNum != PlayerNum() ||
                // not filed by need buddy number
                BuddyNum() != needBuddyNum ||
                // entity num than over slot num
                PlayerNum() + BuddyNum() > NumberOfSlots(playerTeam)
            )
        ){
            // save current playerNum
            prevPlayerNum = PlayerNum();
            // force reload asset
            //  but skip change assetNo, reset interval
            forceReloadBuddyAsset = true;
        }

        // check Interval
        WaitUpdateLongCycle();
    }
}

// TAG EnemyBot/BotActive ----------
define canEnemyBotActive:
    IsAlive() &&
    !IsInSpawnRoom();

rule: "EnemyBot/BotActive/activate"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    canEnemyBotActive    
){
    if(
        // has damage
        NormalizedHealth() < 1.0 ||
        // has line of close player
        IsInLineOfSight(
            EyePosition(),
            EyePosition(ClosestPlayerTo(ep, EnemyTeamOf(ep))))
    ){
        isBotActive = true;
        Abort();
    }
    Wait(0.5, WaitBehavior.IgnoreCondition);
    LoopIfConditionIsTrue();
}

rule: "EnemyBot/BotActive/deactive"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    !canEnemyBotActive
){
    isBotActive = false;
}

// TAG EnemyBot/Config ----------
define basicSpawnTimeBase: 12.0;
define basicSpawnTimeMin:
    confirmGameDifficulty == GameDifficulty.EASY ?      basicSpawnTimeBase * 1.1 :
    confirmGameDifficulty == GameDifficulty.NORMAL ?    basicSpawnTimeBase * 1.0 :
    confirmGameDifficulty == GameDifficulty.HARD ?      basicSpawnTimeBase * 0.9 :
    confirmGameDifficulty == GameDifficulty.EXPERT ?    basicSpawnTimeBase * 0.7 :
    confirmGameDifficulty == GameDifficulty.LEGENDARY ? basicSpawnTimeBase * 0.5 :
    confirmGameDifficulty == GameDifficulty.INSANITY ?  basicSpawnTimeBase * 0.2 :
                                                        basicSpawnTimeBase * 1.1 ;
define spawnTimeMinToMaxScale: 1.25;

define autoTuneDmgDltBase: 20;
define autoTuneDmgDltInitial :
    confirmGameDifficulty == GameDifficulty.EASY ?      10  :
    confirmGameDifficulty == GameDifficulty.NORMAL ?    20  :
    confirmGameDifficulty == GameDifficulty.HARD ?      30  :
    confirmGameDifficulty == GameDifficulty.EXPERT ?    50  :
    confirmGameDifficulty == GameDifficulty.LEGENDARY ? 70  :
    confirmGameDifficulty == GameDifficulty.INSANITY ?  100 :
                                                        10  ; 

define autoTuneDmgDltLimit:
    confirmGameDifficulty == GameDifficulty.EASY ?      40  :
    confirmGameDifficulty == GameDifficulty.NORMAL ?    50  :
    confirmGameDifficulty == GameDifficulty.HARD ?      60  :
    confirmGameDifficulty == GameDifficulty.EXPERT ?    80  :
    confirmGameDifficulty == GameDifficulty.LEGENDARY ? 100 :
    confirmGameDifficulty == GameDifficulty.INSANITY ?  130 :
                                                        40  ;

define upValueScaleBase: 0.3;
define upValueScale:
    confirmGameDifficulty == GameDifficulty.EASY ?      upValueScaleBase * 1 : 
    confirmGameDifficulty == GameDifficulty.NORMAL ?    upValueScaleBase * 1 : 
    confirmGameDifficulty == GameDifficulty.HARD ?      upValueScaleBase * 1 : 
    confirmGameDifficulty == GameDifficulty.EXPERT ?    upValueScaleBase * 1 : 
    confirmGameDifficulty == GameDifficulty.LEGENDARY ? upValueScaleBase * 1 : 
    confirmGameDifficulty == GameDifficulty.INSANITY ?  upValueScaleBase * 1 :
                                                        upValueScaleBase * 1 ;

define downValueScaleBase: 1.0;
define downValueScale:
    confirmGameDifficulty == GameDifficulty.EASY ?      downValueScaleBase * 1.1 :
    confirmGameDifficulty == GameDifficulty.NORMAL ?    downValueScaleBase * 1.0 :
    confirmGameDifficulty == GameDifficulty.HARD ?      downValueScaleBase * 0.9 :
    confirmGameDifficulty == GameDifficulty.EXPERT ?    downValueScaleBase * 0.7 :
    confirmGameDifficulty == GameDifficulty.LEGENDARY ? downValueScaleBase * 0.5 :
    confirmGameDifficulty == GameDifficulty.INSANITY ?  downValueScaleBase * 0.2 :
                                                        downValueScaleBase * 1.1 ;

define enemyColor: Color.Team1;

define IsBossClass(in define player):
    player.enemyType == EnemyType.SubBoss ||
    player.enemyType == EnemyType.Boss;

define dealHealScale: IsSupportHero(HeroOf()) ? 2.0 : 1.0;

playervar define eachDealtDamageScale!;
playervar define eachMaxSpawnInterval!;
playervar define eachMinSpawnInterval!;
playervar define eachChargeUltInterval!;
playervar define eachDeathCost!;

rule: "EnemyBot/Config/update"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    enemyType != EnemyType.Non &&
    confirmGameDifficulty != GameDifficulty.NO_VOTE &&
    IsGameInProgress()
){
    // disable builtin respawn for avoid auto teamup
    DisableRespawning();
    
    // init config by enemy type
    if(enemyType == EnemyType.Minion){
        StartForcingDummyBotName(ep, "Minion");
        watchUpdateRate =       4;
        
        eachDeathCost =         1;
        SetMaxHealth(ep,        25);
        SetHealingReceived(ep,  25);
        SetHealingDealt(ep,     25 * dealHealScale);

        eachDealtDamageScale =  0.25;
        eachChargeUltInterval = 60;
        StartScalingPlayer(ep, 0.7, false);
        StartModifyingHeroVoiceLines(ep, 1.5, false);
    }
    else if(enemyType == EnemyType.Elite){
        StartForcingDummyBotName(ep, "Elite");
        watchUpdateRate =       2;

        eachDeathCost =         2;
        SetMaxHealth(ep,        100);
        SetHealingReceived(ep,  100);
        SetHealingDealt(ep,     100 * dealHealScale);

        eachDealtDamageScale =  1.0;
        eachChargeUltInterval = 30;
        StartScalingPlayer(ep, 1.0, false);
        StartModifyingHeroVoiceLines(ep, 1.0, false);
    }
    else if(enemyType == EnemyType.SubBoss){
        StartForcingDummyBotName(ep, "Sub Boss");
        watchUpdateRate =       1;

        eachDeathCost =         8;
        SetMaxHealth(ep,        600);
        SetHealingReceived(ep,  200);
        SetHealingDealt(ep,     200 * dealHealScale);

        eachDealtDamageScale =  1.5;
        eachChargeUltInterval = 15;
        StartScalingPlayer(ep, 1.5, false);
        StartModifyingHeroVoiceLines(ep, 0.5, false);
    }
    else if(enemyType == EnemyType.Boss){
        StartForcingDummyBotName(ep, "Boss");
        watchUpdateRate =       1;

        eachDeathCost =         8;
        SetMaxHealth(ep,        1000);
        SetHealingReceived(ep,  200);
        SetHealingDealt(ep,     200 * dealHealScale);

        eachDealtDamageScale =  2.0;
        eachChargeUltInterval = 15;
        StartScalingPlayer(ep, 2.5, false);
        StartModifyingHeroVoiceLines(ep, 0.1, false);
        
        // set addtinal health and total health 2000%
        // wait max health change finish
        Wait(0.2, WaitBehavior.IgnoreCondition);
        AddHealthPoolToPlayer(ep, HealthType.Armor, MaxHealth() * 0.5, true, false);
        AddHealthPoolToPlayer(ep, HealthType.Shields, MaxHealth() * 0.5, true, false);
    }

    Wait(0.2, WaitBehavior.IgnoreCondition);
    while(NormalizedHealth() < 1.0){
        Heal(ep, null, MaxValue());
        Wait(0.2, WaitBehavior.IgnoreCondition);
    }

    while(true){
        // update config
        UpdateEachSpawnInterval();
        UpdateEachDealtDamage();

        WaitUpdateLongCycle();
    }
}

// TAG EnemyBot/Config/SpawnInterval ----------
define showDeadEffectTime: 1.0;
globalvar define spawnTimeScale;
playervar define confirmSpawnInterval;

rule: "EnemyBot/Config/SpawnInterval/waitingRespawn"
Event.OnDeath
if(
    TeamOf() == enemyTeam
){
    // wait for show dead effect
    Wait(showDeadEffectTime, WaitBehavior.AbortWhenFalse);
    // if sucide, skip wait timer
    if(Attacker() != ep){
        // wait for respawn by each timer
        Wait(confirmSpawnInterval, WaitBehavior.AbortWhenFalse);
    }
    Respawn();
}

void UpdateEachSpawnInterval()"UpdateEachSpawnInterval"{
    // set spawn interval min max
    if(enemyType == EnemyType.Minion){
        eachMinSpawnInterval =  basicSpawnTimeMin * 1;
        eachMaxSpawnInterval =  eachMinSpawnInterval * spawnTimeMinToMaxScale;
    }
    else if(enemyType == EnemyType.Elite){
        eachMinSpawnInterval =  basicSpawnTimeMin * 2;
        eachMaxSpawnInterval =  eachMinSpawnInterval * spawnTimeMinToMaxScale;
    }
    else if(enemyType == EnemyType.SubBoss){
        eachMinSpawnInterval =  basicSpawnTimeMin * 4;
        eachMaxSpawnInterval =  eachMinSpawnInterval * spawnTimeMinToMaxScale;
    }
    else if(enemyType == EnemyType.Boss){
        eachMinSpawnInterval =  basicSpawnTimeMin * 4;
        eachMaxSpawnInterval =  eachMinSpawnInterval * spawnTimeMinToMaxScale;
    }

    // tune enemy spawen interval for make close match
    define diff! = GameProgressDiff(playerTeam);

    // player team advantage, fast enemy respawn
    if(70 <= diff){
        spawnTimeScale = 0;
    }
    else if(40 <= diff && diff < 70){
        spawnTimeScale = 0.25;
    }
    else if(10 <= diff && diff < 40){
        spawnTimeScale = 0.5;
    }
    // team even, default enemy respawn
    else if(-10 <= diff && diff < 10){
        spawnTimeScale = 1.0;
    }
    // enemy team advantage, slow enemy respawn
    else if(-40 <= diff && diff < -10){
        spawnTimeScale = 1.5;
    }
    else if(-70 <= diff && diff < -40){
        spawnTimeScale = 2.0;
    }
    else if(diff < -70){
        spawnTimeScale = 3.0;
    }

    // set default interval by object progress
    confirmSpawnInterval = ObjectProgressScaledInterval(playerTeam, eachMinSpawnInterval, eachMaxSpawnInterval, 0);
    // apply each enemy type scale
    confirmSpawnInterval *= spawnTimeScale;
    // apply workshop setting
    confirmSpawnInterval *= WorkshopSettingReal("Enemy Bot Settings", "Basic Spawn Intarval Scale", 1.0, 0.01, 100, 1);
}

// TAG EnemyBot/Config/DealtDamage ----------
playervar define confirmDealtDamage;
globalvar define autoTuneDmgDlt;
globalvar define enemyDeathCount = [0,0,0,0];  // for debug
globalvar define playerDeathCount = 0;  // for debug

rule: "EnemyBot/Config/DealtDamage/init"
Event.OngoingGlobal
if(
    confirmGameDifficulty != GameDifficulty.NO_VOTE
){
    autoTuneDmgDlt = autoTuneDmgDltInitial;
}

rule: "EnemyBot/Config/DealtDamage/upTune"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    Attacker() != ep
){
    // up enemy deal damage by enemy dead, tune detailed difficulty
    define upValue! = eachDeathCost;
    upValue *= upValueScale;
    // up deal damage
    autoTuneDmgDlt += upValue;
    autoTuneDmgDlt = autoTuneDmgDlt > autoTuneDmgDltLimit ? autoTuneDmgDltLimit : autoTuneDmgDlt;
    // death count for debug
    enemyDeathCount[ep.enemyType - 1] ++;
}

rule: "EnemyBot/Config/DealtDamage/downTune"
Event.OnDeath
if(
    TeamOf() == playerTeam &&
    Attacker() != ep
){
    // down enemy deal damage by player dead, tune detailed difficulty
    define downValue! = NumberOfSlots(playerTeam) / NumberOfPlayers(playerTeam);

    if(!IsDummyBot(ep)){
        // human player has influence 3times 
        downValue *= 3;
    }
    else{
        // bot player has single influence
        downValue *= 1;
    }
    downValue *= downValueScale;
    // down deal damage
    autoTuneDmgDlt -= downValue;
    autoTuneDmgDlt = autoTuneDmgDlt < autoTuneDmgDltInitial ? autoTuneDmgDltInitial : autoTuneDmgDlt;
    // death count for debug
    playerDeathCount ++;
}

void UpdateEachDealtDamage()"UpdateEachDealtDamage"{
    // set auto tune damage
    confirmDealtDamage = autoTuneDmgDlt;
    // apply setting scale
    confirmDealtDamage *= WorkshopSettingReal("Enemy Bot Settings", "Enemy Deal Damage Scale", 1.0, 0.01, 100, 0);
    // apply enemy type scale
    confirmDealtDamage *= eachDealtDamageScale;
    // apply team balance
    confirmDealtDamage /= ConvertToBalancedValue(1.5, playerTeam);
    SetDamageDealt(ep, confirmDealtDamage);
}

// TAG EnemyBot/Config/ReceivedDamage ----------
globalvar define confirmReceiveDamage;

rule: "EnemyBot/Config/ReceivedDamage/update"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    while(true){
        UpdateGlobalReceivedDamage();

        WaitUpdateLongCycle();
    }
}

void UpdateGlobalReceivedDamage()"UpdateGlobalReceivedDamage"{
    // set base damage
    confirmReceiveDamage = DefaultPercentage();
    // apply team balance
    confirmReceiveDamage *= ConvertToBalancedValue(1.5, playerTeam);
    SetDamageReceived(AllPlayers(enemyTeam), confirmReceiveDamage);
}

// TAG EnemyBot/ChargeUltimate ----------
rule: "EnemyBot/ChargeUltimate/charge"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.Non &&
    IsGameInProgress() &&
    !IsUsingUltimate()
){
    SetUltimateCharge(ep, UltimateChargePercent() + (DefaultPercentage() / eachChargeUltInterval));
    WaitUpdateASecond();
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/CautionColor ----------
define cautionColor: isBlink ? Color.Red : Color.Yellow;

globalvar define isBlink;

rule: "EnemyBot/CautionColor/blinkColor"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    while(true){
        isBlink = !isBlink;
        Wait(0.2, WaitBehavior.AbortWhenFalse);
    }
}

// TAG EnemyBot/CautionIcon ----------
playervar define cautionIcon;

define isCautionIconActive: 
    IsPlayerOnObject &&
    IsOnObjective(ep);

rule: "EnemyBot/CautionIcon/show"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    isCautionIconActive
){
    // show caution icon to enemys for easy to find interfering enemy from player
    DestroyIcon(cautionIcon);
    cautionIcon = CreateIcon(AllPlayers(playerTeam), ep, Icon.ExclamationMark,
        IconRev.PositionAndColor, cautionColor, true);
}

rule: "EnemyBot/CautionIcon/hide"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    !isCautionIconActive
){
    DestroyIcon(cautionIcon);
}

// TAG EnemyBot/ThreatIcon ----------
playervar define threatIcon;

define isThreatIconActive: 
    IsAlive() &&
    !IsInSpawnRoom();

rule: "EnemyBot/ThreatIcon/show"
Event.OngoingPlayer
if(
    enemyTeam == TeamOf() &&
    IsBossClass(ep) &&
    isThreatIconActive
){
    // show threat icon to boss enemys for easy to caution enemy from player
    DestroyIcon(threatIcon);
    threatIcon = CreateIcon(AllPlayers(), ep, Icon.Skull,
        IconRev.Position, Color.Team1, false);
}

rule: "EnemyBot/ThreatIcon/hide"
Event.OngoingPlayer
if(
    enemyTeam == TeamOf() &&
    IsBossClass(ep) &&
    !isThreatIconActive
){
    DestroyIcon(threatIcon);
}

// TAG EnemyBot/Asset ----------
define maxCreateEnemyBotNum: 8;

globalvar define sameHero!;

define enemyAssetList:
    [
        // random hero asset
        [   
            // assetNo 0
            // basic
            [EnemyType.SubBoss,     RandomHero,         1],
            [EnemyType.Elite,       RandomHero,         3],
            [EnemyType.Minion,      RandomHero,         4]
        ],
        [   
            // assetNo 1
            // sub boss and minion
            [EnemyType.SubBoss,     RandomHero,         1],
            [EnemyType.Minion,      RandomHero,         7]
        ],
        [   
            // assetNo 2
            // all elite
            [EnemyType.Elite,       RandomHero,         3],
            [EnemyType.Elite,       RandomHero,         3],
            [EnemyType.Elite,       RandomHero,         2]
        ],
        [   
            // assetNo 3
            // all elites same hero
            [EnemyType.Elite,       sameHero,           8]
        ],
        [   
            // assetNo 4
            // half elite
            [EnemyType.Elite,       RandomHero,         4],
            [EnemyType.Minion,      RandomHero,         4]
        ],
        [   
            // assetNo 5
            // all minion
            [EnemyType.Minion,      rva([FavoriteDamageHero(), FavoriteTankHero()]),   8]
        ],
        [   
            // assetNo 6
            // double sub boss
            [EnemyType.SubBoss,     RandomHero,         1],
            [EnemyType.SubBoss,     RandomHero,         1],
            [EnemyType.Minion,      RandomHero,         6]
        ],
        [   
            // assetNo 7
            // triple sub boss
            [EnemyType.SubBoss,     RandomHero,         1],
            [EnemyType.SubBoss,     RandomHero,         1],
            [EnemyType.SubBoss,     RandomHero,         1]
        ],
        [   
            // assetNo 8
            // damage boss with minion
            [EnemyType.Boss,        FavoriteDamageHero(),          1],
            [EnemyType.Minion,      RandomHero,         7]
        ],
        // 9,
        [],

        // fix hero asset
        [   
            // assetNo 10
            // Reinhardt army
            [EnemyType.SubBoss,     Hero.Reinhardt,     1],
            [EnemyType.Elite,       Hero.Reinhardt,     3],
            [EnemyType.Minion,      Hero.Reinhardt,     4]
        ],
        [   
            // assetNo 11
            // Soldier76 army
            [EnemyType.SubBoss,     Hero.Soldier76,     1],
            [EnemyType.Elite,       Hero.Soldier76,     3],
            [EnemyType.Minion,      Hero.Soldier76,     4]
        ],
        [   
            // assetNo 12
            // Pharah army
            [EnemyType.SubBoss,     Hero.Pharah,        1],
            [EnemyType.Elite,       Hero.Pharah,        3],
            [EnemyType.Minion,      Hero.Pharah,        4]
        ],
        [   
            // assetNo 13
            // Roadhog army
            [EnemyType.SubBoss,     Hero.Roadhog,       1],
            [EnemyType.Elite,       Hero.Roadhog,       3],
            [EnemyType.Minion,      Hero.Roadhog,       4]
        ],
        [   
            // assetNo 14
            // Bastion army
            [EnemyType.SubBoss,     Hero.Bastion,       1],
            [EnemyType.Elite,       Hero.Bastion,       3],
            [EnemyType.Minion,      Hero.Bastion,       4]
        ],
        [   
            // assetNo 15
            // sniper and tank
            [EnemyType.Boss,        Hero.Widowmaker,    1],
            [EnemyType.SubBoss,     Hero.Widowmaker,    2],
            [EnemyType.Minion,      FavoriteTankHero(), 5]   
        ],
        [
            // assetNo 16
            // gun and shield
            [EnemyType.SubBoss,     Hero.Mauga,         1],
            [EnemyType.Elite,       FavoriteTankHero(), 3],
            [EnemyType.Minion,      Hero.Bastion,       4] 
        ],
        // 17,18,19,
        [],[],[],

        // progress asset
        [
            // assetNo 20
            // damage boss
            [EnemyType.Boss,        FavoriteDamageHero(),   1],
            [EnemyType.Elite,       RandomHero,             3],
            [EnemyType.Minion,      RandomHero,             4]
        ],
        [
            // assetNo 21
            // damage boss with tank elite
            [EnemyType.Boss,        FavoriteDamageHero(),   1],
            [EnemyType.Elite,       FavoriteTankHero(),     5],
            [EnemyType.Minion,      RandomHero,             6]
        ],
        [
            // assetNo 22
            // tank boss
            [EnemyType.Boss,        FavoriteTankHero(),     1],
            [EnemyType.Elite,       FavoriteDamageHero(),   3],
            [EnemyType.Minion,      RandomHero,             4]
        ],
        [
            // assetNo 23
            // double damage boss
            [EnemyType.Boss,        FavoriteDamageHero(),   1],
            [EnemyType.Boss,        FavoriteDamageHero(),   1],
            [EnemyType.Minion,      RandomHero,             6]
        ],
        // 24,25,26,27,28,29,
        [],[],[],[],[],[],

        // debug asset
        [
            // assetNo 30
            [EnemyType.Elite,      RandomValueInArray([
                Hero.Ramattra,
                Hero.WreckingBall,
                Hero.Symmetra,
                Hero.Lucio,
                Hero.Illari
            ]),         12]
        ]
    ];

define enemyAssetNoLotteryList: [
    // random hero asset
    0, 0, 0, 0,
    1, 1, 1, 1,
    2, 2, 2, 2,
    3, 3,
    4, 4,
    5, 
    6, 6, 6, 
    7, 
    8, 

    // fix hero asset
    10, 10,
    11, 11,
    12,
    13,
    14,
    15, 15,
    16

    // for debug
    // 23
];


// TAG EnemyBot/Asset/Interval ----------
globalvar define reloadEnemyAssetInterval! = -1;
globalvar define enemyAssetNo! = -1;
globalvar define hasProgressAssetNo! = false;

rule: "EnemyBot/Asset/Interval/reloadReloadEnemyAsset"
Event.OngoingGlobal
if(
    initCompleted &&
    (
        IsGameInProgress() ||
        (
            IsInSetup() &&
            MatchTime() <= 5
        )
    )
){
    while(true){
        // play effect at all enemy
        PlayEffectsToTeam(enemyTeam);

        // if hasProgressAssetNo, skip change assetNo
        if(!hasProgressAssetNo){
            // choice asset by random
            enemyAssetNo = RandomValueInArray(enemyAssetNoLotteryList);
            // set default interval
            reloadEnemyAssetInterval = AssetChangeInterval();
            // change some hero
            sameHero = RandomHero;
        }

        // relealse hasProgressAssetNo
        hasProgressAssetNo = false;

        // create bots by asset
        DestroyBots(enemyTeam);
        CreateBotsByAssetWithMutexLock(enemyAssetList[enemyAssetNo], enemyTeam, maxCreateEnemyBotNum);
        // wait start intarval until game start.
        WaitUntil(IsGameInProgress(), MaxValue());

        for(;
            reloadEnemyAssetInterval > 0 &&
            // if hasProgressAssetNo, skip interval count and reload asset
            !hasProgressAssetNo;
            reloadEnemyAssetInterval--){
            Wait(1, WaitBehavior.IgnoreCondition);
        }
    }
}

rule: "EnemyBot/Asset/Interval/reloadBotAssetIntervalByProgress"
Event.OngoingGlobal
if(
    initCompleted &&
    IsGameInProgress()
){
    define progressStage! = 0;

    while(true){
        define progress! = ObjectProgress(playerTeam);
        if(CurrentGameMode() == GameMode.Push){
            progress = progress - 50;
            progress *= 2;
        }
        
        define progressAssetNo! = -1;
        define progressAssetInterval!;

        if(
            progressStage == 0 && progress >= 10
        ){
            if(!HasObjectDirection()){
                spawnRushInterval = 0;
            }
            progressStage ++;
        }
        else if(
            progressStage == 1 && progress >= 20
        ){
            if(!HasObjectDirection()){
                spawnRushInterval = 0;
            }
            progressStage ++;
        }
        else if(
            progressStage == 2 && progress >= 30
        ){
            progressAssetNo = 20;
            progressAssetInterval = (AssetChangeInterval() - 60);
            progressStage ++;
        }
        else if(
            progressStage == 3 && progress >= 60
        ){
            progressAssetNo = 21;
            progressAssetInterval = (AssetChangeInterval() - 60);
            progressStage ++;
        }
        else if(
            progressStage == 4 && progress >= (FinaleProgress() - 5)
        ){
            progressAssetNo = RandomValueInArray([22, 23]);
            progressAssetInterval = MaxValue();
            progressStage ++;
        }

        // has progress asset
        if(progressAssetNo != -1){
            // set assetNo from progress asset
            // set interval from progress asset interval
            enemyAssetNo = progressAssetNo;
            reloadEnemyAssetInterval = progressAssetInterval;
            // set flag for skip change assetNo
            hasProgressAssetNo = true;
        }

        // check Interval
        WaitUpdateMediumCycle();
    }
}

void PlayEffectsToTeam(define team!) "PlayEffectsToTeam"{
    define players! = AllPlayers(team);
    for(define playersIndex! = 0; playersIndex < CountOf(players); playersIndex ++){
        // play blast
        PlayEffect(
            AllPlayers(), PlayEffect.GoodPickupEffect,
            TeamOf(players[playersIndex]) == enemyTeam ?
                enemyColor :
                Color.Yellow,
            players[playersIndex],
            1
        );
    }
    Wait(0.1, WaitBehavior.IgnoreCondition);
}

// TAG Object ----------
globalvar define prevObjectPosition;
globalvar define objectDirection;
globalvar define blockedPos;
globalvar define positionObjectAhead;

define HasObjectDirection(): objectDirection != null;

rule: "Object/updateObjectDirectionAndPositionObjectAhead"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    Wait(0.1);  // wait object position change to enable
    prevObjectPosition = CurrentObjectPosition();

    while(true){
        define nowObjectPosition! = CurrentObjectPosition();
        if(
            IsPlayerOnObject &&
            nowObjectPosition != prevObjectPosition
        ){
            // update objectDirection
            objectDirection = DirectionTowards(prevObjectPosition, nowObjectPosition);
            // set prev position for next judge
            prevObjectPosition = nowObjectPosition;

        }

        WaitUpdateMediumCycle();
    }
}

// TAG EnemyBot/Teleport ----------
define teleportAreaSize: 6;
define teleportAreaExtendSizeScaleByNonObjectDirection: 1.5;
define teleportAreaExtendSizeScaleByCutoffDist: 0.5;
define teleportAreaOffsetDistFromObject: ActionRange.CanFind;   // bot can find other range
define minDistOfRenewCommonTeleportBasePosition: teleportAreaSize * 1;    // same as teleportAreaSize

define IsPlayerOnObject: (0 < NumberOfPlayersOnObjective(playerTeam));
define IsEnemyOnObject: (0 < NumberOfPlayersOnObjective(enemyTeam));
define searchPositionInterval: 0.2;
define searchPositionTryCountMax: 10;

playervar define teleportPosition;
globalvar define commonTeleportBasePosition;

define CanEncountPosition(define position)"CanEncountPosition"{
    define canEncount = false;

    if(
        // position valid
        position != null
                &&
        // Has line to near player
        IsInLineOfSight(
            PositionOffsetY1() + position,
            PositionOffsetY1() + ClosestPlayerTo(position, playerTeam),
            BarrierLOS.NoBarriersBlock
        )            
    ){
        canEncount = true;
    }

    return canEncount;
}

define GetTeleportPositionByClosestPlayer() globalvar "GetTeleportPositionByClosestPlayer"{
    define canTelPosition = null;

    define objectPosition = CurrentObjectOnPosition();
    if(objectPosition == null){
        return null;
    }

    define teleportBasePosition = PositionOf(ClosestPlayerTo(objectPosition, playerTeam));

    if(
        // walkable position is far
        (
            CurrentMap() == Map.Kings_Row ||
            CurrentMap() == Map.Kings_Row_Winter
        )
            &&
        ObjectiveIndex() == 0
    ){
        canTelPosition =
            teleportBasePosition
                + 
            (
                DirectionTowards(teleportBasePosition, objectPosition)
                    *
                DistanceBetween(teleportBasePosition, objectPosition) * 0.5
            )
                +
            RandomPosition(
                teleportAreaSize,
                teleportAreaSize,
                teleportAreaSize
            );
        return canTelPosition;
    }

    for(define searchPositionTryCount = 0; searchPositionTryCount < searchPositionTryCountMax; searchPositionTryCount++){
        // select teleportPosition from middle of Object and teleportBasePosition
        define candidatePosition =
            NearestWalkablePosition(
                teleportBasePosition
                    + 
                (
                    DirectionTowards(teleportBasePosition, objectPosition)
                        *
                    DistanceBetween(teleportBasePosition, objectPosition) * 0.5
                )
                    +
                RandomPosition(
                    teleportAreaSize,
                    teleportAreaSize,
                    teleportAreaSize
                )
            );

        if(
            // can encount player
            CanEncountPosition(candidatePosition)
        ){
            canTelPosition = candidatePosition;
            break;
        }

        WaitReleaseServerLoad(ServerLoadType.GameMain);
        Wait(searchPositionInterval, WaitBehavior.AbortWhenFalse);
    }

    return canTelPosition;
}

globalvar define teleportAreaExtendSize;

define GetTeleportPositionByObject() globalvar "GetTeleportPositionByObject"{
    define canTelPosition = null;

    define teleportBasePosition = CurrentObjectOnPosition();
    if(teleportBasePosition == null){
        return null;
    }

    if(
        // has object direction
        HasObjectDirection()
    ){
        if(
            // player on object
            IsPlayerOnObject
        ){
            // get teleportAreaExtendSize by object position and blockedPos
            define cutoffDistance = teleportAreaOffsetDistFromObject - DistanceBetween(teleportBasePosition, blockedPos);
            // get teleportAreaExtendSize by cutoffDistance with scale
            teleportAreaExtendSize = cutoffDistance * teleportAreaExtendSizeScaleByCutoffDist;
        }
        else{
            // clear extend size by non cut off distance of object direction
            teleportAreaExtendSize = 0;
        }

        // overwrite position by positionObjectAhead
        teleportBasePosition = positionObjectAhead;
    }
    else{
        // get teleportAreaExtendSize by fixed value of non object direction
        teleportAreaExtendSize = teleportAreaSize * teleportAreaExtendSizeScaleByNonObjectDirection;
    }

    for(define searchPositionTryCount = 0; searchPositionTryCount < searchPositionTryCountMax; searchPositionTryCount++){
        // select teleportPosition from teleportBasePosition around
        define candidatePosition = 
            NearestWalkablePosition(
                teleportBasePosition
                    +
                RandomPosition(
                    teleportAreaSize + teleportAreaExtendSize,
                    teleportAreaSize + teleportAreaExtendSize,
                    teleportAreaSize + teleportAreaExtendSize
                )
            );

        if(
            // can encount player
            CanEncountPosition(candidatePosition)
        ){
            canTelPosition = candidatePosition;
            break;
        }

        WaitReleaseServerLoad(ServerLoadType.GameMain);
        Wait(searchPositionInterval, WaitBehavior.AbortWhenFalse);
    }

    return canTelPosition;
}

define GetTeleportPositionByCommonPosition() playervar "GetTeleportPositionByCommonPosition"{
    define canTelPosition = null;

    define teleportBasePosition = commonTeleportBasePosition;
    if(teleportBasePosition == null){
        return null;
    }

    for(define searchPositionTryCount = 0; searchPositionTryCount < searchPositionTryCountMax; searchPositionTryCount++){
        // select teleportPosition from teleportBasePosition around
        define candidatePosition = 
            NearestWalkablePosition(
                teleportBasePosition
                    +
                RandomPosition(
                    teleportAreaSize,
                    teleportAreaSize,
                    teleportAreaSize
                )
            );

        if(
            // can encount player
            CanEncountPosition(candidatePosition)
        ){
            canTelPosition = candidatePosition;
            break;
        }

        WaitReleaseServerLoad(ServerLoadType.GameMain);
        Wait(searchPositionInterval, WaitBehavior.AbortWhenFalse);
    }

    return canTelPosition;
}

playervar define telBeam;

void TeleportWithEffect(define isBeamFromBody!) playervar "TeleportWithEffect"{
    if(teleportPosition == null){return;}

    if(IsInSpawnRoom()){
        Wait(SlotOf() * 0.2, WaitBehavior.AbortWhenFalse);
    }

    // show pre teleport effect
    PlayTeleportEffect(true, isBeamFromBody);
    // Teleport
    Teleport(ep, teleportPosition);
    // show teleport effect
    PlayTeleportEffect(false, isBeamFromBody);
    // hide teleport beam effect
    DestroyEffect(telBeam);
}

define showTeleportBeamTime: 0.5;

void PlayTeleportEffect(define isBefore!, define isBeamFromBody!) playervar "PlayTeleportEffect"{
    // if before teleport
    if(isBefore){
        // show teleport beam to own position
        DestroyEffect(telBeam);

        telBeam = CreateBeamEffect(AllPlayers(),
            BeamType.BadBeam,
            isBeamFromBody ? 
                BodyPosition(ep) :
                teleportPosition + Vector(0, 30, 0),
            teleportPosition,
            enemyColor, EffectRev.VisibleToPositionAndRadius);
        // wait for show teleport shadow of before
        Wait(showTeleportBeamTime / 2, WaitBehavior.IgnoreCondition);

        // play teleport shadow to own position
        PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, enemyColor, PositionOf(ep), 1);
        // play teleport blast to teleport positon
        PlayEffect(AllPlayers(), PlayEffect.BadExplosion, enemyColor, teleportPosition, 2);

        // wait for show teleport shadow of before
        Wait(showTeleportBeamTime / 2, WaitBehavior.IgnoreCondition);
    }
    else{
        // hide teleport beam to teleport positon
        DestroyEffect(telBeam);
        // play teleport shadow to teleport positon
        PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, enemyColor, PositionOf(ep), 1);
        // play teleport sound
        PlayEffect(AllPlayers(), PlayEffect.RingExplosionSound, null, PositionOf(ep), 75);
    }
}

void DoTeleport(define isBeamFromBody!, define isEmgTeleport!)"DoTeleport"{
    define needGetNewPosition!;

    // do emergency teleport as threat enemy 
    if(
        isEmgTeleport
    ){
        // set teleportPosition by object position
        teleportPosition = BlockedPositon(CurrentObjectPosition(), objectDirection, 6);
    }
    else{
        // set teleportPosition by common position
        teleportPosition = GetTeleportPositionByCommonPosition();
    }

    if(
        teleportPosition != null
    ){
        // teleport to teleportPosition
        TeleportWithEffect(isBeamFromBody);
    }
}

// TAG EnemyBot/Teleport/CheckUpdateCommonTeleportBasePosition ----------
globalvar define needUpdateCommonTeleportBasePosition!;

rule: "EnemyBot/Teleport/UpdateCommonTeleportBasePosition"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    define objectPos = CurrentObjectOnPosition();

    if(HasObjectDirection()){
        // get blockedPos by extension line collision position
        blockedPos = BlockedPositon(objectPos, objectDirection, teleportAreaOffsetDistFromObject);
        // get positionObjectAhead by between object position and blockedPos
        positionObjectAhead = ShiftedPosition(
            objectPos,
            DirectionTowards(objectPos, blockedPos),
            DistanceBetween(objectPos, blockedPos) * 0.75
        );
    }

    // if has not update flag of commonTeleportBasePosition
    if(!needUpdateCommonTeleportBasePosition){
        // set update flag
        if(
            // position invalid
            commonTeleportBasePosition == null
        ){
            needUpdateCommonTeleportBasePosition = true;
            // dbgHudTxt(<"update position by position invalid">);
        }
        else if(
            // position close to near player
            DistanceBetween(
                commonTeleportBasePosition,
                ClosestPlayerTo(commonTeleportBasePosition, playerTeam)) < minDistOfRenewCommonTeleportBasePosition        
        ){
            needUpdateCommonTeleportBasePosition = true;
            // dbgHudTxt(<"update position by close to near player">);
        }
        else{
            if(
                // player on object
                IsPlayerOnObject
            ){
                if(
                    // has payload
                    HasObjectDirection() ?
                        // position too far to bloeckd position
                        DistanceBetween(
                            PositionOffsetY1() + commonTeleportBasePosition,
                            positionObjectAhead
                        ) > (teleportAreaSize + teleportAreaExtendSize)
                    :
                        // position too far to object position
                        DistanceBetween(
                            PositionOffsetY1() + commonTeleportBasePosition,
                            objectPos
                        ) > teleportAreaSize
                ){
                    needUpdateCommonTeleportBasePosition = true;
                    // dbgHudTxt(<"update position by too far to object">);
                }
                else if(
                    // has payload
                    HasObjectDirection() ?
                        // position has not line to bloeckd position
                        !IsInLineOfSight(
                            PositionOffsetY1() + commonTeleportBasePosition,
                            positionObjectAhead,
                            BarrierLOS.NoBarriersBlock
                        )
                    :
                        // position has not line to object position
                        !IsInLineOfSight(
                            PositionOffsetY1() + commonTeleportBasePosition,
                            objectPos,
                            BarrierLOS.NoBarriersBlock
                        )
                ){
                    needUpdateCommonTeleportBasePosition = true;
                    // dbgHudTxt(<"update position by has not line to object">);
                }
                else{
                    // dbgHudTxt(<"* keep position with player on object">);
                }
            }
            else{
                if(
                    // position has not line to closest object player
                    !IsInLineOfSight(
                        PositionOffsetY1() + commonTeleportBasePosition,
                        PositionOffsetY1() + ClosestPlayerTo(CurrentObjectPosition(), playerTeam),
                        BarrierLOS.NoBarriersBlock
                    )
                ){
                    needUpdateCommonTeleportBasePosition = true;
                    // dbgHudTxt(<"update position by has not line to closest player">);
                }
                else{
                    // dbgHudTxt(<"* keep position with not player on object">);
                }
            }
        } 
    }
    
    // if has update flag of commonTeleportBasePosition
    if(
        needUpdateCommonTeleportBasePosition
    ){
        define newPosition! = null;
        // calc new position
        if(
            // player on object
            IsPlayerOnObject
        ){
            // calc by object
            newPosition = GetTeleportPositionByObject();
        }
        else if(
            !IsNeedEscortObject(enemyTeam)
        ){
            // calc by closest player
            newPosition = GetTeleportPositionByClosestPlayer();
        }
        else{
            // without calc, set object position for escort 
            newPosition = CurrentObjectPosition();
        }

        // found position
        if(newPosition != null){
            // update commonTeleportBasePosition by new position
            commonTeleportBasePosition = newPosition;
            // release update flag
            needUpdateCommonTeleportBasePosition = false;
        }
        else{
            // dbgHudTxt(<"! position not found">);
        }
    }

    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}

rule: "EnemyBot/Teleport/clearCommonTeleportBasePosition"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    Attacker() == ep
){
    if(IsProbabilityTrue(25)){
        // reset position by enemy sucide in invalid position
        needUpdateCommonTeleportBasePosition = true;
    }
}

rule: "EnemyBot/Teleport/teleportByRespawn"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsGameInProgress() &&
    IsInSpawnRoom()
){
    DoTeleport(false, false);
    Wait(1, WaitBehavior.AbortWhenFalse);
    WaitReleaseServerLoad(ServerLoadType.GameMain);
    LoopIfConditionIsTrue();
}

define checkTeleportConditionInterval: 1;
define checkTeleportConditionMaxCount: 3;

rule: "EnemyBot/Teleport/teleportOrHopForDefendObjectOnIdle"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsGameInProgress() &&
    !IsInSpawnRoom() &&
    IsAlive()
){
    define checkConditionCount = 0;

    while(checkConditionCount < checkTeleportConditionMaxCount){
        if(
            // player on object
            IsPlayerOnObject &&
            // far from object
            DistanceBetween(ep, CurrentObjectPosition()) > ActionRange.CanFind
        ){
            // do teleport instantly
            break;
        }
        else if(
            // has line of close player
            IsInLineOfSight(
                EyePosition(ep),
                EyePosition(ClosestPlayerTo(ep, EnemyTeamOf(ep))))
        ){
            // reset count
            checkConditionCount = 0;
        }
        else{
            // keep position and count up
            checkConditionCount ++;
        }

        Wait(checkTeleportConditionInterval, WaitBehavior.AbortWhenFalse);
        WaitReleaseServerLoad(ServerLoadType.GameMain);
    }

    define objectPosition! = CurrentObjectPosition();
    define dist! = DistanceBetween(ep, objectPosition);
    if(
        IsNeedEscortObject(enemyTeam) &&
        IsInLineOfSight(
            EyePosition(ep),
            PositionOffsetY1() + objectPosition)
    ){
        ApplyImpulse(ep, 
            VectorTowards(ep, objectPosition + Vector(0, dist * 0.25, 0)),
            dist * 2.5,
            Relative.ToWorld, ContraryMotion.Cancel);
    }
    else{
        // teleport
        DoTeleport(false, false);
    }

    LoopIfConditionIsTrue();
}

// TAG EnemyBot/EnemyAbility/SpawnRush ----------
globalvar define spawnRushInterval;
globalvar define spawnRushCount;

rule: "EnemyBot/EnemyAbility/SpawnRush"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    // set default interval by object progress
    spawnRushInterval = ObjectProgressScaledInterval(playerTeam, 20, 40, 5);
    // apply workshop setting
    spawnRushInterval *= WorkshopSettingReal("Enemy Bot Settings", "Spawn-Rush Interval Scale", 1.0, 0.01, 100, 2);
    // round for counting
    spawnRushInterval = RoundToInteger(spawnRushInterval, Rounding.Up);
    for(;spawnRushInterval > 0; spawnRushInterval--){
        Wait(1, WaitBehavior.IgnoreCondition);
    }

    // action
    define spawnRushDuration! = RandomInteger(5, 20);
    spawnRushDuration *= WorkshopSettingReal("Enemy Bot Settings", "Spawn-Rush Duration Scale", 1.0, 0.01, 100, 2);
    define deployRushInterval! = RandomInteger(1, 3);
    spawnRushCount = RoundToInteger(spawnRushDuration / deployRushInterval, Rounding.Down);
    for(; spawnRushCount > 0; spawnRushCount--){
        Respawn(
            FilteredArray(
                AllDeadPlayers(enemyTeam),
                (
                    ae.enemyType != EnemyType.Boss
                )
            )
        );
        
        Wait(deployRushInterval, WaitBehavior.IgnoreCondition);
        WaitReleaseServerLoad(ServerLoadType.GameMain);
    }

    LoopIfConditionIsTrue();
}

// TAG EnemyBot/EnemyAbility/ShotCall ----------
globalvar define shotCallInterval;

rule: "EnemyBot/EnemyAbility/ShotCall"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    // set default interval by object progress
    shotCallInterval = ObjectProgressScaledInterval(playerTeam, 20, 40, 5);
    // apply workshop setting
    shotCallInterval *= WorkshopSettingReal("Enemy Bot Settings", "All-Out-Ultmate Interval Scale", 1.0, 0.01, 100, 3);
    // round for counting
    shotCallInterval = RoundToInteger(shotCallInterval, Rounding.Up);
    for(;shotCallInterval > 0; shotCallInterval--){
        Wait(1, WaitBehavior.IgnoreCondition);
    }

    // action
    define activeEnemys! = AllPlayers(enemyTeam);
    define shotCallDelay! = RandomReal(0.2, 1.0);
    for(define scLoopIndex! = 0; scLoopIndex < CountOf(activeEnemys); scLoopIndex ++){
        if(
            IsAlive(activeEnemys[scLoopIndex]) &&
            !IsInSpawnRoom(activeEnemys[scLoopIndex])
        ){
            SetUltimateCharge(activeEnemys[scLoopIndex], DefaultPercentage());
            PressButton(activeEnemys[scLoopIndex], Button.Ultimate);

            Wait(shotCallDelay, WaitBehavior.IgnoreCondition);
            WaitReleaseServerLoad(ServerLoadType.GameMain);
        }
    }

    LoopIfConditionIsTrue();
}

// TAG EnemyBot/EnemyAbility/CombatTeleport ----------
playervar define combatTeleportInterval;

rule: "EnemyBot/EnemyAbility/CombatTeleport"
Event.OngoingPlayer
if(
    IsGameInProgress() &&
    TeamOf() == enemyTeam &&
    IsBossClass(ep)
){
    // set default interval by object progress
    combatTeleportInterval = ObjectProgressScaledInterval(playerTeam, 10, 20, 5);
    // apply workshop setting
    combatTeleportInterval *= WorkshopSettingReal("Enemy Bot Settings", "(Sub Boss & Boss) Combat-Teleport Interval Scale", 1.0, 0.01, 100, 4);
    // apply scale by each enemy action range
    if(actionRangeMax == ActionRange.Melee){
        combatTeleportInterval *= 1;
    }
    else if(actionRangeMax == ActionRange.Close){
        combatTeleportInterval *= 2.0;
    } 
    else if(actionRangeMax == ActionRange.Middle){
        combatTeleportInterval *= 3.0;
    } 
    else if(actionRangeMax == ActionRange.Far){
        combatTeleportInterval *= 4;
    }
    combatTeleportInterval = RoundToInteger(combatTeleportInterval, Rounding.Up);

    define isEmgTeleport! = false;

    for(;combatTeleportInterval > 0; combatTeleportInterval --){
        Wait(1, WaitBehavior.IgnoreCondition);

        if(
            // player team close win
            IsCloseWin(playerTeam) &&
            // enemy not on object
            !IsEnemyOnObject &&
            // player on object
            IsPlayerOnObject
        ){
            // interrupt teleport for defend object in finale phase
            isEmgTeleport = true;
            break;
        }

        WaitReleaseServerLoad(ServerLoadType.GameMain);
    }

    if(IsAlive()){
        // teleport with teleport beam from body
        // teleport with emergency by close lose
        DoTeleport(true, isEmgTeleport);
    }
    LoopIfConditionIsTrue();
}

define moreAbilityProb: DefaultPercentage();
define moreAbilityInterval: RandomReal(0.1, 3);

globalvar define moreUltProb;

rule: "EnemyBot/EnemyAbility/moreUltimate"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsBossClass(ep) &&
    IsAlive() &&
    actionState != ActionState.Non &&
    IsUsingUltimate()
){
    WaitUntil(!IsUsingUltimate(), MaxValue());    
    
    moreUltProb = moreAbilityProb;
    while(
        IsAlive() &&
        IsProbabilityTrue(moreUltProb)
    ){
        SetUltimateCharge(ep, DefaultPercentage());
        WaitReleaseServerLoad(ServerLoadType.GameMain);
        Wait(moreAbilityInterval, WaitBehavior.IgnoreCondition);

        PressButton(ep, Button.Ultimate);
        WaitUntil(!IsUsingUltimate(), MaxValue());
    }
    moreUltProb = 0;

    WaitUntil(!IsUsingUltimate(), MaxValue());
    Wait(1, WaitBehavior.IgnoreCondition);
}

globalvar define decreaseProb! =
    WorkshopSettingReal("Enemy Bot Settings", "(Sub boss & Boss) Rapid-Fire-Ultimate Termination Scale", 1.0, 0.01, 10, 5) * 10;

rule: "EnemyBot/EnemyAbility/decreaseMultiUltimateProb"
Event.OngoingGlobal
if(
    moreUltProb > 0
){
    moreUltProb -= moreUltProb < decreaseProb ? moreUltProb : decreaseProb;
    Wait(1.0, WaitBehavior.IgnoreCondition);
    LoopIfConditionIsTrue();
}

// TAG Debug ----------
globalvar define countDetectTriggerServerLoadPerSecond;

rule: "DebugGlobalAction"
Event.OngoingGlobal
Team.All
if(
    initCompleted
){
    // // commonTeleportBasePosition orb
    // CreateEffect(commonTeleportBasePosition != null ? hp : null, Effect.Orb, Color.White,
    //     PositionOffsetY1() + commonTeleportBasePosition, teleportAreaSize, EffectRev.VisibleToPositionAndRadius);
    // // positionObjectAhead orb
    // CreateEffect(positionObjectAhead != null ? hp : null, Effect.Orb, Color.Red,
    //     positionObjectAhead, teleportAreaSize, EffectRev.VisibleToPositionAndRadius);

    // // minDistOfRenewCommonTeleportBasePosition white ring
    // CreateEffect(commonTeleportBasePosition != null ? hp : null, Effect.Ring, Color.Yellow,
    //     PositionOffsetY1() + commonTeleportBasePosition, minDistOfRenewCommonTeleportBasePosition * 0.95, EffectRev.VisibleToPositionAndRadius);
    // // teleportAreaSize ring
    // CreateEffect(commonTeleportBasePosition != null ? hp : null, Effect.Ring, Color.Red,
    //     PositionOffsetY1() + commonTeleportBasePosition, teleportAreaSize, EffectRev.VisibleToPositionAndRadius);

    // // placable teleportPosition area size sphere
    // CreateEffect(hp,
    //     Effect.Sphere, Color.Red,
    //     HasObjectDirection() ? positionObjectAhead : CurrentObjectOnPosition(),
    //     teleportAreaSize + teleportAreaExtendSize,
    //     EffectRev.VisibleToPositionAndRadius);

    // // object -> positionObjectAhead beam
    // CreateBeamEffect(HasObjectDirection() ? hp : null, BeamType.GoodBeam, 
    //     CurrentObjectOnPosition(),
    //     positionObjectAhead, 
    //     Color.Red, EffectRev.VisibleToPositionAndRadius);
    // // positionObjectAhead or object -> commonTeleportBasePosition beam
    // CreateBeamEffect(hp, BeamType.GoodBeam, 
    //     HasObjectDirection() ? positionObjectAhead : CurrentObjectOnPosition(),
    //     PositionOffsetY1() + commonTeleportBasePosition, 
    //     Color.White, EffectRev.VisibleToPositionAndRadius);
    // // commonTeleportBasePosition -> host player or object beam
    // CreateBeamEffect(HasSpawned(hp) ? hp : null, BeamType.GoodBeam, 
    //     PositionOffsetY1() + commonTeleportBasePosition, 
    //     PositionOffsetY1() + hp,
    //     Color.Blue, EffectRev.VisibleToPositionAndRadius);

    define pastSecond = 1;

    while(true){
        countDetectTriggerServerLoadPerSecond = countWaitActionByServerLoad / pastSecond;
        pastSecond ++;

        // auto recall gunship
        if(
            IsProbabilityTrue((8 - (HumanPlayerNum(playerTeam))) * 0.05) &&
            IsGameInProgress()
        ){
            debugBuddyHeroPerk();
        }
        Wait(1);
    }
}

// rule: "DebugPlayerAction"
// Event.OngoingPlayer
// Team.All
// if(
//     ep == hp &&
//     HasSpawned() &&
//     IsJumping()
// ){
//     define player = RandomValueInArray(AllPlayers(playerTeam));
//     player.heroModType = HeroModType.SHOT_CALL;
//     SetUltimateCharge(player, 100);
//     // Wait(1);
//     // Loop();
// }

rule: "DebugPlayJoinPlayerSound"
Event.OnPlayerJoin
Team.All
if(
    initCompleted &&
    !IsDummyBot()
){
    define positionArray! = [
        PositionOf(hp),
        SpawnPoints(playerTeam)[0],
        CurrentObjectPosition(),
        SpawnPoints(enemyTeam)[0]
    ];

    for(define index! = 0; index < 5; index++){
        for(define index2! = 0; index2 < 5; index2++){
            PlayEffect(HostPlayer(),
                PlayEffect.DebuffImpactSound,
                null, positionArray[index2], MaxValue());
        }
        Wait(0.5);
    }
}

rule: "Debug/initDebugMode"
Event.OngoingGlobal
Team.All
if(
    initCompleted
){
    if(IsHostPlayerInGame()){
        debugMode = DebugMode.Non;
    }
    else{
        debugMode = DebugMode.DebugParam;
        ShowDebugHud(hp);
    }
}

rule: "Debug/changeDebugMode"
Event.OngoingPlayer
Team.All
if(
    hp == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Jump) 
){
    // change debug mode
    WaitLongPressConfirm();
    
    if(debugMode >= DebugMode.Recording){
        debugMode = DebugMode.Non;
    }
    else{
        debugMode ++;
    }

    // reload hud
    HideDebugHud();
    ShowDebugHud(hp);
}

globalvar define debugHuds;

define Last():
    CountOf(debugHuds);

define FirstEnemyOf(in define enemyType):
    FirstOf(FilteredArray(AllPlayers(enemyTeam), ae.enemyType == enemyType));

define FirstBossClassEnemy():
    FirstOf(FilteredArray(AllPlayers(enemyTeam), IsBossClass(ae)));

// show debug icon and hud
void ShowDebugHud(define player!)"ShowDebugHud"{
    if(
        debugMode >= DebugMode.Recording
    ){
        EnableInspectorRecording();
        debugHuds[Last()] = CreateDebugHud("Recording", true, Color.Red);
    }
    else{
        DisableInspectorRecording();
    }

    if(
        debugMode >= DebugMode.Non
    ){
        debugHuds[Last()] = CreateDebugHud("human player Num", HumanPlayerNum(playerTeam), HumanPlayerNum(playerTeam) <= 1 ? Color.Team2 : Color.Yellow);
    }
    
    if(
        debugMode >= DebugMode.ServerLoad
    ){
        debugHuds[Last()] = CreateDebugHud("Server Load", ServerLoad(),
            isServerLoadLevel(ServerLoadLevel.Overload) ? Color.Red :
            isServerLoadLevel(ServerLoadLevel.Busy) ? Color.Yellow :
            isServerLoadLevel(ServerLoadLevel.Hot) ? Color.Green :
            isServerLoadLevel(ServerLoadLevel.Warm) ? Color.Blue :
            Color.Gray);
        // debugHuds[Last()] = CreateDebugHud("Server Load Average", ServerLoadAverage(), ServerLoadAverage() < 255 ? Color.Gray : Color.Yellow);
        // debugHuds[Last()] = CreateDebugHud("Server Load Peak", ServerLoadPeak(), ServerLoadPeak() < 255 ? Color.Gray : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("game Logic Speed", gameLogicSpeed, gameLogicSpeed >= 100 ? Color.Gray : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("count Game Logic Speed Decrease", countGameLogicSpeedDecrease, Color.Gray);
        debugHuds[Last()] = CreateDebugHud("count Wait Action By Server Load", countWaitActionByServerLoad, Color.Gray);
        debugHuds[Last()] = CreateDebugHud("count Wait Action By Server Load Per Second", countDetectTriggerServerLoadPerSecond, Color.Gray);
    }

    if(
        debugMode >= DebugMode.DebugParam
    ){  
        // player team
        debugHuds[Last()] = CreateDebugHud("team player Num", <"<0> / <1>", NumberOfLivingPlayers(playerTeam), NumberOfPlayers(playerTeam)>, NumberOfLivingPlayers(playerTeam) >= NumberOfPlayers(playerTeam) ? Color.Team2 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("reload Asset Interval", reloadBuddyAssetInterval, reloadBuddyAssetInterval > 5 ? Color.Team2 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("asset Number", buddyAssetNo, Color.Team2);
        debugHuds[Last()] = CreateDebugHud("death Count", playerDeathCount, Color.Team2);

        // enemy team
        debugHuds[Last()] = CreateDebugHud("team player num", <"<0> / <1>", NumberOfLivingPlayers(enemyTeam), NumberOfPlayers(enemyTeam)>, NumberOfLivingPlayers(enemyTeam) >= NumberOfPlayers(enemyTeam) ? Color.Team1 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("reload Asset Interval", reloadEnemyAssetInterval, reloadEnemyAssetInterval > 5 ? Color.Team1 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("Asset Number", enemyAssetNo, Color.Team1);
        debugHuds[Last()] = CreateDebugHud("death Count", <"<0>, <1>, <2>, <3>", enemyDeathCount[0], enemyDeathCount[1], enemyDeathCount[2], enemyDeathCount[3]>, Color.Team1);
        debugHuds[Last()] = CreateDebugHud("auto Tune Dmg Dlt", autoTuneDmgDlt, Color.Team1);
        debugHuds[Last()] = CreateDebugHud("Game Progress Diff", GameProgressDiff(playerTeam), Color.Team1);
        debugHuds[Last()] = CreateDebugHud("spawn Time scale", spawnTimeScale, Color.Team1);
        debugHuds[Last()] = CreateDebugHud("spawn Interval", <"<0>, <1>, <2>, <3>",
            FirstEnemyOf(EnemyType.Minion).confirmSpawnInterval,
            FirstEnemyOf(EnemyType.Elite).confirmSpawnInterval,
            FirstEnemyOf(EnemyType.SubBoss).confirmSpawnInterval,
            FirstEnemyOf(EnemyType.Boss).confirmSpawnInterval>, Color.Team1);
        debugHuds[Last()] = CreateDebugHud("spawn Rush Interval", spawnRushInterval, spawnRushInterval > 5 ? Color.Team1 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("spawn Rush Count", spawnRushCount, spawnRushCount <= 0 ? Color.Team1 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("shot Call Interval", shotCallInterval, shotCallInterval > 5 ? Color.Team1 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("combat Teleport Interval",
            FirstBossClassEnemy().combatTeleportInterval,
            FirstBossClassEnemy().combatTeleportInterval > 5 ? Color.Team1 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("more Ult Prob", moreUltProb, moreUltProb <= 0 ? Color.Team1 : Color.Yellow);      
    }
}

// Hide debug icon and hud
void HideDebugHud()"HideDebugHud"{
    for(gLoopIndex = 0; gLoopIndex < CountOf(debugHuds); gLoopIndex ++){
        DestroyHudText(debugHuds[gLoopIndex]);
    }
}

rule: "Debug/resetBotList"
Event.OngoingPlayer
Team.All
if(
    hp == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Crouch)
){
    WaitLongPressConfirm();
    reloadEnemyAssetInterval = 0;
    WaitLongPressConfirm();
    WaitUntil(reloadEnemyAssetInterval > 0, 10);
    reloadBuddyAssetInterval = 0;
}

rule: "Debug/triggerRushAndShotCall"
Event.OngoingPlayer
Team.All
Player.All
if(
    hp == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Reload)
){
    WaitLongPressConfirm();
    AllPlayers(enemyTeam).combatTeleportInterval = 0;
    WaitLongPressConfirm();
    spawnRushInterval = 0;
    WaitLongPressConfirm();
    shotCallInterval = 0;
}

playervar define tempName!;

rule: "Debug/deployGunship"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.PrimaryFire)
){
    // kill players on aim center
    WaitLongPressConfirm();
    debugBuddyHeroPerk();

    LoopIfConditionIsTrue();
}

void debugBuddyHeroPerk()"debugBuddyHeroPerk"{
    define player! = 
        FirstOf(
            SortedArray(
                FilteredArray(
                    AllPlayers(playerTeam),
                    (
                        IsDummyBot(ae) &&
                        !ae.isTransformed
                    )
                ),
                DistanceBetween(ae, CurrentObjectPosition())
            )
        );

    player.heroModType = RandomValueInArray([
        HeroModType.ARTILLERY_REQUEST,
        HeroModType.STRAFING_REQUEST,
        HeroModType.GRUDGE_FIRE_BALL,
        HeroModType.GRUDGE_LIGHTNING,
        HeroModType.BEAM_SNIPER,
        HeroModType.TITAN_FORM,
        HeroModType.GUNSHIP_GUNNER
    ]);

    if(IsDead(player)){
        Resurrect(player);
    }
    player.grudgePower = 100;
    SetUltimateCharge(player, DefaultPercentage());
    PressButton(player, Button.Ultimate);
}
