import "Utility.del";

// Message display for debugging that can be seen only by the host player
globalvar define debugMode!;

enum DebugMode{
    Non,
    SlowLevelOnly,
    ShowParam,
    WithRecord
}

// define isInDebugMode: debugMode != DebugMode.Non;
define isInDebugMode: true;

define debugShowTime: 0.3;

void dbgMsg(define msg)"dbgMsg"{
    if(isInDebugMode){
        SmallMessage(HostPlayer(), "dbg: "+ msg);
    }
}

void dbgLog(define msg)"dbgLog"{
    if(isInDebugMode){
        LogToInspector("dbg: "+ msg);
    }
}

define maxDbgHudTxtNum: 25;
globalvar define dbgHudTxtEntity! = [];
globalvar define dbgHudTxtIndex! = 0;

globalvar define dbgHudTxtCount! = 0;

Number dbgHudTxt(define msg)"dbgHudTxt"{
    dbgHudTxtCount ++;
    if(isInDebugMode){
        if(dbgHudTxtIndex >= maxDbgHudTxtNum)
        {
            dbgHudTxtIndex = 0;
        }
        DestroyHudText(dbgHudTxtEntity[dbgHudTxtIndex]);
        dbgHudTxtEntity[dbgHudTxtIndex] = 
            CreateHudText(HostPlayer(),
                null, "[" + dbgHudTxtCount + "] dbg: "+ msg, null,
                Location.Right, -MaxValue(),
                Color.White, Color.Yellow, Color.White,
                HudTextRev.None, Spectators.VisibleNever);
        dbgHudTxtIndex ++;
    }
    return dbgHudTxtEntity[dbgHudTxtIndex];
}

void destoryAllDbgHudTxt()"destoryAllDbgHudTxt"{
    for(gLoopIndex = 0; gLoopIndex < CountOf(dbgHudTxtEntity); gLoopIndex ++){
        DestroyHudText(dbgHudTxtEntity[gLoopIndex]);
    }
    dbgHudTxtIndex = 0;
}

define CreateDebugHud(define caption, define value, define color):
    CreateHudText(HostPlayer(),
        null,
        <"<0> = <1>", caption, value>,
        null,
        Location.Left, -1,
        Color.White, color, Color.White,
        HudTextRev.VisibleToStringAndColor, Spectators.VisibleNever);

void errLog(define msg)"errLog"{
    dbgHudTxt("err! " + msg);
}

globalvar define dbgWldTxtEntity! = 0;

void dbgWldTxt(define position, define msg)"dbgWldTxt"{
    if(isInDebugMode){
        WaitUntil(dbgWldTxtEntity == 0, debugShowTime);
        DestroyInWorldText(dbgWldTxtEntity);
        dbgWldTxtEntity = CreateInWorldText(HostPlayer(),
            "dbg: "+ msg, 
            position, 1, Clipping.DoNotClip, InworldTextRev.None,
            Color.Yellow, Spectators.VisibleNever);
        Wait(debugShowTime, WaitBehavior.IgnoreCondition);
        DestroyInWorldText(dbgWldTxtEntity);
        dbgWldTxtEntity = 0;
    }
}

void dbgIcn(define position)"dbgIcn"{
    if(isInDebugMode){
        CreateIcon(HostPlayer(),
            position, Icon.X, IconRev.VisibleToPositionAndColor,
            Color.Yellow, true);
    }
}

void dbgEft(define position)"dbgIcn"{
    if(isInDebugMode){
        CreateEffect(HostPlayer(),
            Effect.Sphere, Color.Yellow, position, 1,
            EffectRev.VisibleToPositionRadiusAndColor);
    }
}

void dbgPlyEft(define position)"dbgPlyEft"{
    if(isInDebugMode){    
        PlayEffect(HostPlayer(),
            PlayEffect.GoodPickupEffect,
            Color.Yellow, position, 1);
    }
}

globalvar define dbgPlyBemEftEntity;

void dbgPlyBemEft(define startPos!, define endPos!)"dbgPlyBemEft"{
    if(isInDebugMode){
        DestroyEffect(dbgPlyBemEftEntity[0]);
        DestroyEffect(dbgPlyBemEftEntity[1]);

        dbgPlyBemEftEntity = [];
        dbgPlyBemEftEntity[0] = CreateBeamEffect(HostPlayer(),
            BeamType.GoodBeam, startPos, endPos,
            Color.Yellow, EffectRev.PositionAndRadius);
        dbgPlyBemEftEntity[1] = CreateEffect(HostPlayer(),
            Effect.Orb, Color.Yellow, startPos, 1, EffectRev.PositionAndRadius);

        Wait(debugShowTime, WaitBehavior.IgnoreCondition);

        DestroyEffect(dbgPlyBemEftEntity[0]);
        DestroyEffect(dbgPlyBemEftEntity[1]);
    }
}

void dbgPlySud()"dbgPlySud"{
    if(isInDebugMode){    
        PlayEffect(HostPlayer(),
            PlayEffect.BuffImpactSound,
            Color.Yellow, HostPlayer(), MaxValue());
    }
}

// Debug Action
rule: "Debug/increaseMatchTime"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    !IsButtonHeld(ep, Button.Ability1) &&
    IsButtonHeld(ep, Button.Ability2)){

    WaitLongPressConfirm();
    SetMatchTime(MatchTime() + 30);
    LoopIfConditionIsTrue();
}

rule: "Debug/decreaseMatchTime"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Ability1) &&
    !IsButtonHeld(ep, Button.Ability2)
){
    WaitLongPressConfirm();
    SetMatchTime(MatchTime() - 30);
    LoopIfConditionIsTrue();
}

globalvar define isPauseMatchTime;

rule: "Debug/pauseMatchTime"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Ability1) &&
    IsButtonHeld(ep, Button.Ability2)
){
    WaitLongPressConfirm();
    if(!isPauseMatchTime){
        PauseMatchTime();
        isPauseMatchTime = true;
    }
    else{
        UnpauseMatchTime();
        isPauseMatchTime = false;
    }
}

rule: "Debug/reviveHealUltCharge"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == EventPlayer() &&
    IsButtonHeld(EventPlayer(), Button.Interact) &&
    IsButtonHeld(EventPlayer(), Button.Ultimate)
){
    // Give revive, full health, charge ult to all player
    WaitLongPressConfirm();
    // If own player dead by abyss, teleport player to map surface
    if(IsDeadByAbyss()){
        Teleport(EventPlayer(), NearestWalkablePosition(EventPlayer()));
        Wait(0.1, WaitBehavior.IgnoreCondition);    // wait teleport
    }
    Resurrect(AllPlayers(TeamOf()));
    Heal(AllPlayers(TeamOf()), null, MaxValue());
    Wait(0.5, WaitBehavior.AbortWhenFalse);    // wait release ult button 
    SetUltimateCharge(AllPlayers(TeamOf()), DefaultPercentage());

    Wait(0.5, WaitBehavior.AbortWhenFalse);    // wait release ult button 
    Resurrect(AllPlayers(EnemyTeamOf()));
    Heal(AllPlayers(EnemyTeamOf()), null, MaxValue());
    Wait(0.5, WaitBehavior.AbortWhenFalse);    // wait release ult button 
    SetUltimateCharge(AllPlayers(EnemyTeamOf()), DefaultPercentage());
}

rule: "Debug/teleportPlayers"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == EventPlayer() &&
    IsButtonHeld(EventPlayer(), Button.Interact) &&
    IsButtonHeld(EventPlayer(), Button.Melee)
){
    // Teleport player to aim center
    WaitLongPressConfirm();
    Teleport(AllPlayers(TeamOf()), 
        AimingPosition()
    );

    Wait(0.5, WaitBehavior.AbortWhenFalse);    // wait release ult button 
    Teleport(AllPlayers(EnemyTeamOf()), 
        AimingPosition()
    );
}

rule: "Debug/lowHealthOrKillAimPlayer"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == EventPlayer() &&
    IsButtonHeld(EventPlayer(), Button.Interact) &&
    IsButtonHeld(EventPlayer(), Button.PrimaryFire)
){
    // kill players on aim center
    WaitLongPressConfirm();
    SetPlayerHealth(
        PlayersWithinRadius(
            AimingPosition(), 5, Team.All, RadiusLOS.Off),
        25);

    Wait(0.5, WaitBehavior.AbortWhenFalse);    // wait release ult button 
    Kill(
        PlayersWithinRadius(
            AimingPosition(), 5, Team.All, RadiusLOS.Off),
        EventPlayer());
}

rule: "Debug/killEnemyTeamPlayers"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == EventPlayer() &&
    IsButtonHeld(EventPlayer(), Button.Interact) &&
    IsButtonHeld(EventPlayer(), Button.SecondaryFire)
){
    // kill players on aim center
    WaitLongPressConfirm();
    Kill(AllPlayers(EnemyTeamOf()), ep);
}