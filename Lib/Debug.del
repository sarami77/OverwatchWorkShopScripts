import "Utility.del";

// Message display for debugging that can be seen only by the host player
globalvar define debugMode!;

enum DebugMode{
    Non,
    SlowLevelOnly,
    ShowParam,
    WithRecord
}

// define isInDebugMode: debugMode != DebugMode.Non;
define isInDebugMode: true;

define debugShowTime: 0.2;

void dbgMsg(define msg)"dbgMsg"{
    if(isInDebugMode){
        SmallMessage(HostPlayer(), "dbg: "+ msg);
    }
}

void dbgLog(define msg)"dbgLog"{
    if(isInDebugMode){
        LogToInspector("dbg: "+ msg);
    }
}

define maxDbgHudTxtNum: 30;
globalvar define dbgHudTxtEntity! = [];
globalvar define dbgHudTxtIndex! = 0;

globalvar define dbgHudTxtCount! = 0;

Number dbgHudTxt(define msg)"dbgHudTxt"{
    dbgHudTxtCount ++;
    if(isInDebugMode){
        if(dbgHudTxtIndex >= maxDbgHudTxtNum)
        {
            dbgHudTxtIndex = 0;
        }
        DestroyHudText(dbgHudTxtEntity[dbgHudTxtIndex]);
        dbgHudTxtEntity[dbgHudTxtIndex] = 
            CreateHudText(HostPlayer(),
                null, "[" + dbgHudTxtCount + "] dbg: "+ msg, null,
                Location.Right, MaxValue(),
                Color.White, Color.Yellow, Color.White,
                HudTextRev.None, Spectators.VisibleNever);
        dbgHudTxtIndex ++;
    }
    return dbgHudTxtEntity[dbgHudTxtIndex];
}

void destoryAllDbgHudTxt()"destoryAllDbgHudTxt"{
    for(gLoopIndex = 0; gLoopIndex < CountOf(dbgHudTxtEntity); gLoopIndex ++){
        DestroyHudText(dbgHudTxtEntity[gLoopIndex]);
    }
    dbgHudTxtIndex = 0;
}

define CreateDebugHud(define caption, define value, define color):
    CreateHudText(HostPlayer(),
        null,
        <"<0> = <1>", caption, value>,
        null,
        Location.Left, -1,
        Color.White, color, Color.White,
        HudTextRev.VisibleToStringAndColor, Spectators.VisibleNever);

void errLog(define msg)"errLog"{
    dbgHudTxt("err! " + msg);
}

globalvar define dbgWldTxtEntity! = 0;

void dbgWldTxt(define position, define msg)"dbgWldTxt"{
    if(isInDebugMode){
        WaitUntil(dbgWldTxtEntity == 0, debugShowTime);
        DestroyInWorldText(dbgWldTxtEntity);
        dbgWldTxtEntity = CreateInWorldText(HostPlayer(),
            "dbg: "+ msg, 
            position, 1, Clipping.DoNotClip, InworldTextRev.None,
            Color.Yellow, Spectators.VisibleNever);
        Wait(debugShowTime, WaitBehavior.IgnoreCondition);
        DestroyInWorldText(dbgWldTxtEntity);
        dbgWldTxtEntity = 0;
    }
}

void dbgIcn(define position)"dbgIcn"{
    if(isInDebugMode){
        CreateIcon(HostPlayer(),
            position, Icon.X, IconRev.VisibleToPositionAndColor,
            Color.Yellow, true);
    }
}

void dbgEft(define position)"dbgIcn"{
    if(isInDebugMode){
        CreateEffect(HostPlayer(),
            Effect.Sphere, Color.Yellow, position, 1,
            EffectRev.VisibleToPositionRadiusAndColor);
    }
}

void dbgPlyEft(define position)"dbgPlyEft"{
    if(isInDebugMode){    
        PlayEffect(HostPlayer(),
            PlayEffect.GoodPickupEffect,
            Color.Yellow, position, 1);
    }
}

globalvar define dbgPlyBemEftEntity! = 0;

void dbgPlyBemEft(define position, define position2)"dbgPlyBemEft"{
    if(isInDebugMode){
        WaitUntil(dbgPlyBemEftEntity == 0, debugShowTime);
        DestroyEffect(dbgPlyBemEftEntity);
        dbgPlyBemEftEntity = CreateBeamEffect(HostPlayer(),
            BeamType.GoodBeam, position, position2,
            Color.Yellow, EffectRev.VisibleToPositionAndRadius);
        Wait(debugShowTime, WaitBehavior.IgnoreCondition);
        DestroyEffect(dbgPlyBemEftEntity);
        dbgPlyBemEftEntity = 0;
    }
}

void dbgPlySud()"dbgPlySud"{
    if(isInDebugMode){    
        PlayEffect(HostPlayer(),
            PlayEffect.BuffImpactSound,
            Color.Yellow, HostPlayer(), MaxValue());
    }
}

rule: "Debug/reviveHealUltCharge"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == EventPlayer() &&
    IsButtonHeld(EventPlayer(), Button.Interact) &&
    IsButtonHeld(EventPlayer(), Button.Ultimate)
){
    // Give revive, full health, charge ult to all player
    WaitLongPressConfirm();
    // If own player dead by abyss, teleport player to map surface
    if(IsDeadByAbyss()){
        Teleport(EventPlayer(), NearestWalkablePosition(EventPlayer()));
        Wait(0.1, WaitBehavior.IgnoreCondition);    // wait teleport
    }
    Resurrect(AllPlayers(TeamOf()));
    Heal(AllPlayers(TeamOf()), null, MaxValue());
    Wait(0.5, WaitBehavior.AbortWhenFalse);    // wait release ult button 
    SetUltimateCharge(AllPlayers(TeamOf()), DefaultPercentage());

    Wait(0.5, WaitBehavior.AbortWhenFalse);    // wait release ult button 
    Resurrect(AllPlayers(EnemyTeamOf()));
    Heal(AllPlayers(EnemyTeamOf()), null, MaxValue());
    Wait(0.5, WaitBehavior.AbortWhenFalse);    // wait release ult button 
    SetUltimateCharge(AllPlayers(EnemyTeamOf()), DefaultPercentage());
}

rule: "Debug/teleportPlayers"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == EventPlayer() &&
    IsButtonHeld(EventPlayer(), Button.Interact) &&
    IsButtonHeld(EventPlayer(), Button.Melee)
){
    // Teleport player to aim center
    WaitLongPressConfirm();
    Teleport(AllPlayers(TeamOf()), 
        AimingPosition()
    );

    Wait(0.5, WaitBehavior.AbortWhenFalse);    // wait release ult button 
    Teleport(AllPlayers(EnemyTeamOf()), 
        AimingPosition()
    );
}

/*
rule: "Debug/freezeOtherPlayer"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == EventPlayer() &&
    IsButtonHeld(EventPlayer(), Button.Interact) &&
    IsButtonHeld(EventPlayer(), Button.Jump) &&
    IsButtonHeld(EventPlayer(), Button.PrimaryFire)
){
    // Teleport player to aim center
    WaitLongPressConfirm();
    SetStatus(AllPlayers(Team.All), null, Status.Frozen, 30);
    WaitChangeState();
    ClearStatus(EventPlayer(), Status.Frozen);
}
*/

/*
rule: "Debug/killAimPlayer"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == EventPlayer() &&
    IsButtonHeld(EventPlayer(), Button.Interact) &&
    IsButtonHeld(EventPlayer(), Button.PrimaryFire)
){
    // kill players on aim center
    WaitLongPressConfirm();
    Kill(
        PlayersWithinRadius(
            AimingPosition(), 5, Team.All, RadiusLOS.Off),
        EventPlayer());
}
*/

rule: "Debug/lowHealthAimPlayer"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == EventPlayer() &&
    IsButtonHeld(EventPlayer(), Button.Interact) &&
    IsButtonHeld(EventPlayer(), Button.PrimaryFire)
){
    // kill players on aim center
    WaitLongPressConfirm();
    SetPlayerHealth(
        PlayersWithinRadius(
            AimingPosition(), 5, Team.All, RadiusLOS.Off),
        25);

    Wait(0.5, WaitBehavior.AbortWhenFalse);    // wait release ult button 
    Kill(
        PlayersWithinRadius(
            AimingPosition(), 5, Team.All, RadiusLOS.Off),
        EventPlayer());
}