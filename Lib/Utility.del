import "Debug.del";

// TAG ArgumentAlias ----------
define ep: EventPlayer();
define ae: ArrayElement();

// TAG isServerOverLoading ----------
define isServerOverLoading: 255 <= ServerLoad();

// TAG LoopIndex ----------
// If Wait occurs during a loop, it conflicts with other processing and the loop index, so use a separate variable.
globalvar define gLoopIndex!;
playervar define pLoopIndex!;

// TAG Constants ----------
// Maximum value in game script
// Use in unlimited changing status, unlimited dealt heal or damage, etc
define MaxValue(): 1000000;

// Maximum distance when aiming
// If the value is extremely larger than 1000, the aiming position will shift, so 1000 is recommended.
define MaxLength(): 1000;

// Default value of parcentage
define DefaultPercentage(): 100;

// An offset in the Y direction because the point is buried in the surface
define PositionOffset(): Vector(0, 0.6, 0);

define PositionOffsetY1(): Vector(0, 1, 0);

define VectorWithOutY(define vector):
    Vector(XOf(vector), 0, ZOf(vector));

define VectorScaledY(define vector, define scale):
    Vector(XOf(vector), YOf(vector * scale), ZOf(vector));

define IsOverTime(): MatchTime() == 0 && IsGameInProgress();

// TAG Probability ----------
define ProbabilityTrue(define probability): RandomInteger(1, 100) <= probability;

// TAG Wait ----------
// Wait for the large message to be erased for the player to read
void WaitBigMessageHide(){ Wait(4, WaitBehavior.AbortWhenFalse); }

// Wait time before switching the game to the next phase
void WaitNextPhase(){ Wait(4, WaitBehavior.AbortWhenFalse); }

// Waiting time to confirm the button long press operation
void WaitShortPressConfirm(){ Wait(0.2, WaitBehavior.IgnoreCondition); }
void WaitLongPressConfirm(){ Wait(0.4, WaitBehavior.AbortWhenFalse); }

// Waiting time to confirm the cancel operation
void WaitCancelPressConfirm(){ Wait(1.2, WaitBehavior.AbortWhenFalse); }

// Timer for drawing objects such as text HUD
// If many HUDs are created at once, they will be dropped.
void WaitRedraw(){ Wait(0.01, WaitBehavior.AbortWhenFalse); }

// The fixed wait time from when the bound conditions are met until the action is executed.
// If the condition changes frequently, the server load will be high, so wait for the action to be executed.
void WaitConditionConfirmed(){ Wait(0.2, WaitBehavior.AbortWhenFalse); }

// Wait time to show PlayEffect generated to entity
// If teleport an entity immediately after PlayEffect, use PlayEffect because it will not be visible.
void WaitPlayEffect(){ Wait(0.6, WaitBehavior.IgnoreCondition); }

// Wait timer for apply impulses of entity
// To ensure that the dead body immediately after ApplyImpulse can obtain thrust
void WaitEntityImpulse(){ Wait(0.05, WaitBehavior.IgnoreCondition); }

// Wait timer for applying continuous impulses in a cycle
// Used when expelling an entity from a prohibited area, etc
void WaitApplyImpulseCycle(){ Wait(0.1, WaitBehavior.AbortWhenFalse); }

// Wait timer for playing continuous blast in a cycle
// Used for flashy productions such as big explosions
void WaitContinuousBlastCycle(){ Wait(0.1, WaitBehavior.IgnoreCondition); }

// Wait timer for processing that needs updating in a short loop cycle
// Used for processing that should have a particularly precise processing interval such as repeat give heal, repeat apply impulse
void WaitUpdateVeryShortCycle(){ Wait(0.1, WaitBehavior.AbortWhenFalse); }

// Wait timer for processing that needs updating in a short loop cycle
// Used for processing that should have a particularly precise processing interval such as repeat give heal, repeat apply impulse
void WaitUpdateShortCycle(){ Wait(0.2, WaitBehavior.AbortWhenFalse); }

// Wait timer for processing that needs updating in a medium loop cycle
// Used for processing related to general enemy gameplay such as player regeneration
void WaitUpdateMediumCycle(){ Wait(1, WaitBehavior.AbortWhenFalse); }

// Wait timer for processing that needs updating in a long loop cycle
// Used for processing related to events that do not occur frequently such as player entry and exit
void WaitUpdateLongCycle(){ Wait(3, WaitBehavior.AbortWhenFalse); }

// A wait to immediately force the operation associated with the changed state property.
void WaitChangeState(){ Wait(0.1, WaitBehavior.IgnoreCondition); }

// TAG ButtonGuide ----------
define ButtonGuide(Button button):
    <"[<0>]", InputBindingString(button)>;

// TAG ButtonPress ----------
playervar define intaractDoublePressed!;

// TAG parallelAnimationNum ----------
define parallelAnimationNum: 2;

// TAG minMoveImpulse ----------
define minMoveImpulse: 20;

// TAG canRidingRange ----------
define canRidingRange : 6.0;


// TAG DoublePressed ----------
rule: "Player/intaractDoublePressed"
Event.OngoingPlayer
Team.Team1
Player.All
if(
    !intaractDoublePressed &&
    IsButtonHeld(ep, Button.Interact)
){
    WaitUntil(!IsButtonHeld(ep, Button.Interact), 0.3);
    AbortIf(IsButtonHeld(ep, Button.Interact));
    WaitUntil(IsButtonHeld(ep, Button.Interact), 0.3);
    AbortIf(!IsButtonHeld(ep, Button.Interact));
    intaractDoublePressed = true;
}

rule: "Player/releaseDoublePressed"
Event.OngoingPlayer
Team.Team1
Player.All
if(
    intaractDoublePressed
){
    WaitConditionConfirmed();
    intaractDoublePressed = false;
}

// TAG BlockDetect ----------
define walkMeterPerSec: 5.5; // avarage hero speed

Boolean IsBlockedBetween(define position1!, define position2!)"IsBlockedBetween"{
    Boolean isBlocked = false;
    define hitPosition! = RayCastHitPosition(
        position1,
        position1 + (Normalize(VectorTowards(position1, position2)) * DistanceBetween(position1, position2)),
        null,
        ep,
        false);  
    if(
        DistanceBetween(position1, hitPosition) < DistanceBetween(position1, position2)
    ){
        isBlocked = true;
    }
    return isBlocked;
}

Vector BlockedPositon(define position!, define direction!, define distance!){
    define hitPosition! = RayCastHitPosition(
        position,
        position + (Normalize(direction) * distance),
        null,
        ep,
        false);
    return hitPosition;
}

Vector BlockedPositonByLocalVector(define localVector!, define distance!){
    define blockedPosition! = BlockedPositon(
        EyePosition(), 
        WorldVectorOf(localVector, ep),
        distance
    );
    return blockedPosition;
}

// TAG AbyssDetect ----------
define detectAbyssLength: 6;

Boolean IsBelowAbyss(define basePos)"IsBelowAbyss"{
    define isAbyss! = !IsBlockedBetween(basePos, basePos + (Down() * detectAbyssLength));
    // if(isAbyss){
    //     dbgPlyEft(basePos);
    //     dbgPlyBemEft(EyePosition(), basePos);
    // }
    return isAbyss;
}

// TAG WallDetect ----------
Boolean IsThereWall(define basePos)"IsThereWall"{
    return IsBlockedBetween(EyePosition(), basePos);
}

// Determine if death by Abyss
// Binding the NearestWalkablePosition to a Condition is too much for the server, so call it as a function
define IsDeadByAbyss():
    DistanceBetween(ep, NearestWalkablePosition(ep)) > 10;

// TAG Direction ----------
define RandomDirection(): 
    DirectionFromAngles(RandomReal(0, 360), RandomReal(0, 360));

// TAG Position ----------
// Random position within a specified vector
Vector RandomPosition(define x, define y, define z):
    Vector(
        RandomReal(-x, x),
        RandomReal(-y, y), 
        RandomReal(-z, z)
    );

Vector ShiftedPosition(define position, define direction, define distance)"ShiftedPosition"{
    Vector movedPosition = position + (Normalize(direction) * distance);
    return movedPosition;
}

// Aiming position of EventPlayer
define AimingPosition():
    RayCastHitPosition(
        EyePosition(ep),
        EyePosition(ep) +
            (FacingDirectionOf(ep) * MaxLength()),
        AllPlayers(EnemyTeamOf()),
        ep, false);

// Aiming position of EventPlayer
define AimingPositionWithLimit(define limit):
    RayCastHitPosition(
        EyePosition(ep),
        EyePosition(ep) +
            (FacingDirectionOf(ep) * limit),
        AllPlayers(EnemyTeamOf()),
        ep, false);

define AimingPositionWithObjectLimit(define limit):
    RayCastHitPosition(
        EyePosition(ep),
        EyePosition(ep) +
            (FacingDirectionOf(ep) * limit),
        AllPlayers(EnemyTeamOf()),
        ep, true);

// Aiming position of EventPlayer. but sight line collision ignore player entity
define AimingPositionIgnorePlayer():
    RayCastHitPosition(
        EyePosition(ep),
        EyePosition(ep) + FacingDirectionOf(
            ep
        ) * MaxLength(),
        null,
        ep, false);

define BelowPosition(define position):
    RayCastHitPosition(
        (position + Vector(0, 0.1, 0)),
        (position + Vector(0, 0.1, 0)) + (Down() * MaxLength()),
        AllPlayers(EnemyTeamOf()),
        ep, false);

define InvalidPosition():
        Vector(0, -MaxLength(), 0);

define IsInSpawnRoomPosition(define pos, define team):
    IsTrueForAny(
        SpawnPoints(team),
        (
            IsInLineOfSight(ae + Up(), pos + Up())
        )
    );

Vector CurrentObjectPosition()"CurrentObjectPosition"{
    Vector objPos;
    define mode! = CurrentGameMode();
    define objNo = CurrentObjectNo();

    if(mode == GameMode.Assault){
        objPos = ObjectivePosition(objNo);
    }
    else if(mode == GameMode.Escort){
        objPos = PayloadPosition();
    }
    else if(mode == GameMode.Hybrid){
        objPos = PayloadPosition();
    }
    else{
        // errLog("ERROR ON CurrentObjectPosition");
    }
    return objPos;
}

Number CurrentObjectNo()"CurrentObjectNo"{
    Number curObjNo;
    if(!IsObjectiveComplete(0)){
        curObjNo = 0;
    }
    else if(!IsObjectiveComplete(1)){
        curObjNo = 1;
    }
    else if(!IsObjectiveComplete(2)){
        curObjNo = 2;
    }
    else{
        // errLog("ERROR ON CurrentObjectNo");
    }
    return curObjNo;
}



// TAG Player ----------
// Aiming Player of EventPlayer.
define AimingPlayer():
    FirstOf(
        SortedArray(
            FilteredArray(
                PlayersInViewAngle(
                    ep,
                    EnemyTeamOf(),
                    15
                ),
                (
                    IsAlive(ae) &&
                    IsInLineOfSight(ep, ae, BarrierLOS.NoBarriersBlock)
                )
            ),
            DistanceBetween(ep, ae)
        )
    );

// TAG Team ----------
define EnemyTeamOf(): 
    OppositeTeamOf(TeamOf());

// TAG Balance ----------
// Buff scale value determined according to the unbalance of the teamscale value determined according to the unbalance of the team
// You can change the buff amount by changing the scale value.
define ConvertToBalancedValue(define scale!, define team!)"ConvertToBalancedValue"{
    define amount!;
    define activePlayerNum!;

    if(team == Team.Team1 || team == Team.Team2){
        activePlayerNum = 
            CountOf(
                FilteredArray(
                    AllPlayers(team),
                    HasSpawned(ae)
                )
            );
        activePlayerNum = Max(activePlayerNum, 1);
        amount = NumberOfSlots(team) / activePlayerNum;
    }
    else{
        amount = 1;
    }

    amount -= 1;
    amount *= scale;
    amount += 1;
    return amount;
}

// TAG Communication ----------
void PlayRandomVoiceLine(define player!)"PlayRandomVoiceLine"{
    switch(RandomInteger(0, 3)){
        case 0:
        Communicate(player, Communication.VoiceLineUp);
        break;
        case 1:
        Communicate(player, Communication.VoiceLineDown);
        break;
        case 2:
        Communicate(player, Communication.VoiceLineLeft);
        break;
        case 3:
        Communicate(player, Communication.VoiceLineRight);
        break;
        default:
    }
}

void PlayRandomEmote(define player!)"PlayRandomEmote"{
    switch(RandomInteger(0, 3)){
        case 0:
        Communicate(player, Communication.EmoteUp);
        break;
        case 1:
        Communicate(player, Communication.EmoteDown);
        break;
        case 2:
        Communicate(player, Communication.EmoteLeft);
        break;
        case 3:
        Communicate(player, Communication.EmoteRight);
        break;
        default:
    }
}

// TAG Effect ----------
// Conspicuous explosion that repeatedly plays effects
void PlayContinuousBlast(Color color, define position, define size, define effectCount, define soundCount){
    while(
        0 < effectCount ||
        0 < soundCount
    ){
        // play blast
        if(0 < effectCount){
            PlayEffect(
                AllPlayers(Team.All), PlayEffect.BadExplosion,
                color, position, size * 2.0);
            PlayEffect(
                AllPlayers(Team.All), PlayEffect.RingExplosion,
                color, position, size * 3.0);
            effectCount--;
        }

        // play blast sound
        if(0 < soundCount){
            PlayEffect(
                AllPlayers(Team.All), PlayEffect.RingExplosionSound,
                Color.White, position, MaxLength());
            soundCount --;
        }

        // has remain count
        if(
            0 < effectCount ||
            0 < soundCount
        ){
            Wait(0.1, WaitBehavior.IgnoreCondition);
        }
    }
}

// TAG Impulse ----------
void ApplyBlastImpulse(define targets!, define blastCenter!, define blastRange!)"ApplyBlastImpulse"{
    // apply Impulse
    for(gLoopIndex = 0; gLoopIndex < CountOf(targets); gLoopIndex++){
        ApplyImpulse(targets[gLoopIndex],
            VectorTowards(blastCenter, targets[gLoopIndex] + (Up() * 2)),
            blastRange * 4,
            Relative.ToWorld, ContraryMotion.Cancel);
    }
    WaitEntityImpulse();
}

// TAG AutoAim ----------
define autoAimingPosition: EyePosition(autoAimingTarget) + (Up() * 0.175);
playervar define autoAimingTarget!;
playervar define autoAimTryCount!;
void StartAutoAiming()"StartAutoAiming"{
    autoAimTryCount = 0;
    while(
        !IsInViewAngle(
            ep, autoAimingPosition, 10) &&
        autoAimTryCount <= 10
    ){
        StartFacing(
            ep,
            DirectionTowards(
                EyePosition(),
                autoAimingPosition
            ),
            MaxValue(),
            Relative.ToWorld, FacingRev.DirectionAndTurnRate
        );   
        Wait(0.1, WaitBehavior.IgnoreCondition);
        autoAimTryCount ++;
    }
}

// TAG texxSize ----------
define basicInWorldTextSize: 0.8;

// TAG botSlot ----------
Number GetEmptySlot(define team!){
    define emptySlot!;
    for(gLoopIndex = 0; gLoopIndex < NumberOfSlots(team); gLoopIndex++)
    {
        if(!HasSpawned(PlayersInSlot(gLoopIndex, team))){
            break;
        }
    }
    if(gLoopIndex >= NumberOfSlots(team)){
        emptySlot = -1;
    }
    else{
        emptySlot = gLoopIndex;
    }
    return emptySlot;
}

// TAG ability ----------
define IsStealth(define player!):
    HeroOf(player) == Hero.Sombra &&
    IsUsingAbility1(player);

define IsGrapple(define player!):
    HeroOf(player) == Hero.WreckingBall &&
    IsFiringSecondary(player);

// TAG hero ----------
enum HeroRole{
    Tank,
    Damage,
    Support
}

HeroRole GetHeroRole(define hero!)"GetHeroRole"{
    define role!;
    switch(hero){
        case Hero.Dva:
        case Hero.Orisa:
        case Hero.Reinhardt:
        case Hero.Roadhog:
        case Hero.Sigma:
        case Hero.Winston:
        case Hero.WreckingBall:
        case Hero.Zarya:
        role = HeroRole.Tank;
        break;

        case Hero.Ashe:
        case Hero.Bastion:
        case Hero.Cassidy:
        case Hero.Doomfist:
        case Hero.Echo:
        case Hero.Genji:
        case Hero.Hanzo:
        case Hero.Junkrat:
        case Hero.Mei:
        case Hero.Pharah:
        case Hero.Reaper:
        case Hero.Soldier76:
        case Hero.Sombra:
        case Hero.Symmetra:
        case Hero.Torbjorn:
        case Hero.Tracer:
        case Hero.Widowmaker:
        role = HeroRole.Damage;
        break;

        case Hero.Ana:
        case Hero.Baptiste:
        case Hero.Brigitte:
        case Hero.Lucio:
        case Hero.Mercy:
        case Hero.Moira:
        case Hero.Zenyatta:
        role = HeroRole.Support;
        break;
    }

    return role;
}

Number GetHeroOriginalHealth(define hero!)"GetHeroOriginalHealth"{
    define health!;
    switch(hero){
        case Hero.Dva:
        case Hero.Roadhog:
        case Hero.WreckingBall:
        health = 600;
        break;

        case Hero.Reinhardt:
        case Hero.Winston:
        health = 500;
        break;

        case Hero.Orisa:
        health = 450;
        break;

        case Hero.Sigma:
        case Hero.Zarya:
        health = 400;
        break;

        case Hero.Bastion:
        health = 300;
        break;

        case Hero.Doomfist:
        case Hero.Torbjorn:
        case Hero.Mei:
        case Hero.Reaper:
        health = 250;
        break;

        case Hero.Cassidy:
        case Hero.Symmetra:
        health = 225;
        break;

        case Hero.Ashe:
        case Hero.Echo:
        case Hero.Genji:
        case Hero.Hanzo:
        case Hero.Junkrat:
        case Hero.Pharah:
        case Hero.Soldier76:
        case Hero.Sombra:
        case Hero.Ana:
        case Hero.Baptiste:
        case Hero.Brigitte:
        case Hero.Lucio:
        case Hero.Mercy:
        case Hero.Moira:
        case Hero.Zenyatta:
        health = 200;
        break;

        case Hero.Widowmaker:
        health = 175;
        break;

        case Hero.Tracer:
        health = 150;
        break;
    }

    return health;
}