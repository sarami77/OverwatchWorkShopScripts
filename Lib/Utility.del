import "Debug.del";

// TAG ArgumentAlias ----------
define ep: EventPlayer();
define ae: ArrayElement();
define rva(define array): RandomValueInArray(array);

// TAG isServerOverLoading ----------
define isServerOverLoading(): 255 <= ServerLoad();

define WaitUntilServerFree(){ WaitUntil(!isServerOverLoading(), 10); }

globalvar define countWaitRandomForDistributeServerLoad;

define WaitRandomForDistributeServerLoad() globalvar "WaitRandomForDistributeServerLoad"{
    if(isServerOverLoading()){
        countWaitRandomForDistributeServerLoad ++;
        WaitUntilServerFree();
        Wait(RandomReal(
            0,
            3), WaitBehavior.AbortWhenFalse);
    }
}

// TAG LoopIndex ----------
// If Wait occurs during a loop, it conflicts with other processing and the loop index, so use a separate variable.
globalvar define gLoopIndex!;
playervar define pLoopIndex!;

// TAG Constants ----------
// Maximum value in game script
// Use in unlimited changing status, unlimited dealt heal or damage, etc
define MaxValue(): 1000000;

// Maximum distance when aiming
// If the value is extremely larger than 1000, the aiming position will shift, so 1000 is recommended.
define MaxLength(): 1000;

// Default value of parcentage
define DefaultPercentage(): 100;

// An offset in the Y direction because the point is buried in the surface
define PositionOffset(): Vector(0, 0.7, 0);

define PositionOffsetY1(): Vector(0, 1, 0);

define VectorWithOutY(define vector):
    Normalize(
        Vector(
            XOf(vector), 0, ZOf(vector)
        )
    );

define VectorScaledY(define vector, define scale):
    Vector(XOf(vector), YOf(vector * scale), ZOf(vector));

define BodyPosition(define player): Midpoint(PositionOf(player), EyePosition(player));

define IsOverTime(): MatchTime() == 0 && IsGameInProgress();

Number TotalObjectProgress()"TotalObjectProgress"{
    Number progress;

    if(!IsGameInProgress()){
        progress = DefaultPercentage();
    }
    else{
        define mode = CurrentGameMode();
        if(mode == GameMode.Assault){
            if(CurrentObjectNo() == 0){
                progress = (PointCapturePercentage() * 0.5);
            }
            else{
                progress = 50 + (PointCapturePercentage() * 0.5);
            }
        }
        else if(mode == GameMode.Escort){
            progress = PayloadProgressPercentage();
        }
        else if(mode == GameMode.Hybrid){
            if(CurrentObjectNo() == 0){
                progress = (PointCapturePercentage() * 0.3);
            }
            else{
                progress = 30 + (PayloadProgressPercentage() * 0.7);
            }
        }
        else{
            errLog("ERROR ON TotalObjectProgress");
        }
    }
    return progress;
}

// TAG Probability ----------
define ProbabilityTrue(define probability): RandomInteger(1, 100) <= probability;

// TAG Wait ----------
// Wait for the large message to be erased for the player to read
void WaitBigMessageHide(){ Wait(4, WaitBehavior.AbortWhenFalse); }

// Wait time before switching the game to the next phase
void WaitNextPhase(){ Wait(3, WaitBehavior.AbortWhenFalse); }

// Waiting time to confirm the button long press operation
void WaitShortPressConfirm(){ Wait(0.2, WaitBehavior.IgnoreCondition); }
void WaitLongPressConfirm(){ Wait(0.4, WaitBehavior.AbortWhenFalse); }

// Waiting time to confirm the cancel operation
void WaitCancelPressConfirm(){ Wait(1.2, WaitBehavior.AbortWhenFalse); }

// Timer for drawing objects such as text HUD
// If many HUDs are created at once, they will be dropped.
void WaitRedraw(){ Wait(0.01, WaitBehavior.AbortWhenFalse); }

// The fixed wait time from when the bound conditions are met until the action is executed.
// If the condition changes frequently, the server load will be high, so wait for the action to be executed.
void WaitConditionConfirmed(){ Wait(0.2, WaitBehavior.AbortWhenFalse); }

// Wait time to show PlayEffect generated to entity
// If teleport an entity immediately after PlayEffect, use PlayEffect because it will not be visible.
void WaitPlayEffect(){ Wait(0.6, WaitBehavior.IgnoreCondition); }

// Wait timer for apply impulses of entity
// To ensure that the dead body immediately after ApplyImpulse can obtain thrust
void WaitEntityImpulse(){ Wait(0.05, WaitBehavior.IgnoreCondition); }

// Wait timer for applying continuous impulses in a cycle
// Used when expelling an entity from a prohibited area, etc
void WaitApplyImpulseCycle(){ Wait(0.1, WaitBehavior.AbortWhenFalse); }

// Wait timer for playing continuous blast in a cycle
// Used for flashy productions such as big explosions
void WaitContinuousBlastCycle(){ Wait(0.1, WaitBehavior.IgnoreCondition); }

// Wait timer for processing that needs updating in a short loop cycle
// Used for processing that should have a particularly precise processing interval such as repeat give heal, repeat apply impulse
void WaitUpdateVeryShortCycle(){ Wait(0.1, WaitBehavior.AbortWhenFalse); }

// Wait timer for processing that needs updating in a short loop cycle
// Used for processing that should have a particularly precise processing interval such as repeat give heal, repeat apply impulse
void WaitUpdateShortCycle(){ Wait(0.2, WaitBehavior.AbortWhenFalse); }

// Wait timer for processing that needs updating in a medium loop cycle
// Used for processing related to general enemy gameplay such as player regeneration
void WaitUpdateMediumCycle(){ Wait(2, WaitBehavior.AbortWhenFalse); }

// Wait timer for processing that needs updating in a long loop cycle
// Used for processing related to events that do not occur frequently such as player entry and exit
void WaitUpdateLongCycle(){ Wait(5, WaitBehavior.AbortWhenFalse); }

void WaitUpdateASecond(){ Wait(1, WaitBehavior.AbortWhenFalse); }

// A wait to immediately force the operation associated with the changed state property.
void WaitChangeState(){ Wait(0.1, WaitBehavior.IgnoreCondition); }

// TAG ButtonGuide ----------
define ButtonGuide(Button button):
    <"[<0>]", InputBindingString(button)>;

// TAG parallelAnimationNum ----------
define parallelAnimationNum: 2;

// TAG minMoveImpulse ----------
define minMoveImpulse: 20;

// TAG canRidingRange ----------
define canRidingRange : 6.0;

// TAG BlockDetect ----------
define walkMeterPerSec: 5.5; // avarage hero speed

Boolean IsBlockedBetween(define position1!, define position2!)"IsBlockedBetween"{
    Boolean isBlocked = false;

    define hitPosition! = BlockedPositon(
        position1,
        VectorTowards(position1, position2),
        DistanceBetween(position1, position2)
    );

    if(
        DistanceBetween(position1, hitPosition) < DistanceBetween(position1, position2)
    ){
        isBlocked = true;
    }
    return isBlocked;
}

Vector BlockedPositon(define position!, define direction!, define distance!)"BlockedPositon"{
    define hitPosition! = RayCastHitPosition(
        position,
        position + (Normalize(direction) * distance),
        null,
        null,
        false
    );
    return hitPosition;
}

Vector BlockedPositonByLocalVector(define localVector!, define distance!) playervar "BlockedPositonByLocalVector"{
    define blockedPosition! = BlockedPositon(
        EyePosition(ep), 
        WorldVectorOf(localVector, ep),
        distance
    );
    return blockedPosition;
}

define FacingTargetBetweenPosition(define distRate!, define distTarget!)"FacingTargetBetweenPosition"{
        StartFacing(
        ep, DirectionTowards(
                EyePosition(),
                BelowPosition(
                    PositionOf(ep) +
                    DirectionTowards(ep, distTarget) *
                    DistanceBetween(ep, distTarget) * distRate
                )
            ),
            300, Relative.ToWorld, FacingRev.DirectionAndTurnRate
        );
}

// TAG AbyssDetect ----------
define detectAbyssLength: 6;

Boolean IsBelowAbyss(define basePos)"IsBelowAbyss"{
    define isAbyss! = !IsBlockedBetween(basePos, basePos + (Down() * detectAbyssLength));
    return isAbyss;
}

// TAG WallDetect ----------
Boolean IsThereWall(define basePos)"IsThereWall"{
    return IsBlockedBetween(EyePosition(), basePos);
}

// Determine if death by Abyss
// Binding the NearestWalkablePosition to a Condition is too much for the server, so call it as a function
define IsDeadByAbyss():
    IsDead() &&
    DistanceBetween(ep, NearestWalkablePosition(ep)) > 5;

// TAG Direction ----------
define NoDirection(): Vector(0,0,0);

define RandomDirection(): 
    DirectionFromAngles(RandomReal(0, 360), RandomReal(0, 360));

// TAG Position ----------
// Random position within a specified vector
Vector RandomPosition(define x, define y, define z):
    Vector(
        RandomReal(-x, x),
        RandomReal(-y, y), 
        RandomReal(-z, z)
    );

Vector ShiftedPosition(define position, define direction, define distance)"ShiftedPosition"{
    Vector movedPosition = position + (Normalize(direction) * distance);
    return movedPosition;
}

// Aiming position of EventPlayer
define AimingPosition():
    RayCastHitPosition(
        EyePosition(ep),
        EyePosition(ep) +
            (FacingDirectionOf(ep) * MaxLength()),
        AllPlayers(EnemyTeamOf()),
        ep,
        false
    );

// Aiming position of EventPlayer
define AimingPositionWithLimit(define limit):
    RayCastHitPosition(
        EyePosition(ep),
        EyePosition(ep) +
            (FacingDirectionOf(ep) * limit),
        AllPlayers(EnemyTeamOf()),
        ep,
        false
    );

define AimingPositionWithObjectLimit(define limit):
    RayCastHitPosition(
        EyePosition(ep),
        EyePosition(ep) +
            (FacingDirectionOf(ep) * limit),
        AllPlayers(EnemyTeamOf()),
        ep,
        true
    );

// Aiming position of EventPlayer. but sight line collision ignore player entity
define AimingPositionIgnorePlayer():
    RayCastHitPosition(
        EyePosition(ep),
        EyePosition(ep) + FacingDirectionOf(
            ep
        ) * MaxLength(),
        null,
        ep,
        false
    );

define BelowPosition(define position):
    RayCastHitPosition(
        (position + Vector(0, 0.01, 0)),
        (position + Vector(0, 0.01, 0)) + (Down() * MaxLength()),
        null,
        null,
        false
    );

define InvalidPosition():
        Vector(0, -MaxLength(), 0);

define IsInSpawnRoomPosition(define pos, define team):
    IsTrueForAny(
        SpawnPoints(team),
        (
            IsInLineOfSight(ae + Up(), pos + Up())
        )
    );

Vector CurrentObjectPosition()"CurrentObjectPosition"{
    Vector objPos;
    define mode! = CurrentGameMode();
    define objNo = CurrentObjectNo();

    if(mode == GameMode.Assault){
        objPos = ObjectivePosition(objNo);
    }
    else if(mode == GameMode.Escort){
        objPos = PayloadPosition();
    }
    else if(mode == GameMode.Hybrid){
        if(!IsObjectiveComplete(0)){
            objPos = ObjectivePosition(objNo);
        }
        else{
            objPos = PayloadPosition();
        }
    }
    else if(mode == GameMode.Push){
        objPos = 0;
    }
    return objPos;
}

Number CurrentObjectNo()"CurrentObjectNo"{
    Number curObjNo;
    if(!IsObjectiveComplete(0)){
        curObjNo = 0;
    }
    else if(!IsObjectiveComplete(1)){
        curObjNo = 1;
    }
    else if(!IsObjectiveComplete(2)){
        curObjNo = 2;
    }
    else{
        // errLog("ERROR ON CurrentObjectNo");
    }
    return curObjNo;
}



// TAG Player ----------
// Aiming Player of EventPlayer.
define AimingPlayer():
    FirstOf(
        SortedArray(
            FilteredArray(
                PlayersInViewAngle(
                    ep,
                    EnemyTeamOf(),
                    15
                ),
                (
                    IsAlive(ae) &&
                    IsInLineOfSight(ep, ae, BarrierLOS.NoBarriersBlock)
                )
            ),
            DistanceBetween(ep, ae)
        )
    );

// TAG Team ----------
define EnemyTeamOf(): 
    OppositeTeamOf(TeamOf());

Number GetTeamNormalizedHealth()"GetTeamNormalizedHealth"{
    define teamHealth = 0;
    define teamList! = AllPlayers(Team.Team1);
    for(define idx! = 0; idx < CountOf(teamList); idx++){
        teamHealth += NormalizedHealth(teamList[idx]);
    }
    teamHealth /= CountOf(teamList);
    return teamHealth;
}

// TAG Balance ----------
// Buff scale value determined according to the unbalance of the teamscale value determined according to the unbalance of the team
// You can change the buff amount by changing the scale value.
define ConvertToBalancedValue(define scale!, define team!)"ConvertToBalancedValue"{
    define amount!;
    define playerNum!;

    playerNum = 
        CountOf(
            FilteredArray(
                AllPlayers(team),
                HasSpawned(ae)
            )
        );
    playerNum = Max(playerNum, 1);
    amount = NumberOfSlots(team) / playerNum;
    amount -= 1;
    amount *= scale;
    amount += 1;
    return amount;
}

// TAG Communication ----------
void PlayRandomVoiceLine(define player!)"PlayRandomVoiceLine"{
    switch(RandomInteger(0, 3)){
        case 0:
        Communicate(player, Communication.VoiceLineUp);
        break;
        case 1:
        Communicate(player, Communication.VoiceLineDown);
        break;
        case 2:
        Communicate(player, Communication.VoiceLineLeft);
        break;
        case 3:
        Communicate(player, Communication.VoiceLineRight);
        break;
        default:
    }
}

void PlayRandomEmote(define player!)"PlayRandomEmote"{
    switch(RandomInteger(0, 3)){
        case 0:
        Communicate(player, Communication.EmoteUp);
        break;
        case 1:
        Communicate(player, Communication.EmoteDown);
        break;
        case 2:
        Communicate(player, Communication.EmoteLeft);
        break;
        case 3:
        Communicate(player, Communication.EmoteRight);
        break;
        default:
    }
}

// TAG Effect ----------
// Conspicuous explosion that repeatedly plays effects
void PlayContinuousBlast(Color color, define position, define size, define effectCount, define soundCount){
    while(
        0 < effectCount ||
        0 < soundCount
    ){
        // play blast
        if(0 < effectCount){
            PlayEffect(
                AllPlayers(Team.All), PlayEffect.BadExplosion,
                color, position, size * 2.0);
            PlayEffect(
                AllPlayers(Team.All), PlayEffect.RingExplosion,
                color, position, size * 3.0);
            effectCount--;
        }

        // play blast sound
        if(0 < soundCount){
            PlayEffect(
                AllPlayers(Team.All), PlayEffect.RingExplosionSound,
                Color.White, position, MaxLength());
            soundCount --;
        }

        // has remain count
        if(
            0 < effectCount ||
            0 < soundCount
        ){
            Wait(0.1, WaitBehavior.IgnoreCondition);
        }
    }
}

// TAG Impulse ----------
void ApplyBlastImpulse(define targets!, define blastCenter!, define blastRange!)"ApplyBlastImpulse"{
    // apply Impulse
    for(gLoopIndex = 0; gLoopIndex < CountOf(targets); gLoopIndex++){
        ApplyImpulse(targets[gLoopIndex],
            VectorTowards(blastCenter, targets[gLoopIndex] + (Up() * 2)),
            blastRange * 4,
            Relative.ToWorld, ContraryMotion.Cancel);
    }
    WaitEntityImpulse();
}

// TAG AutoAim ----------
define autoAimingPosition:
    IsInAlternateForm(autoAimingTarget) ?
    EyePosition(autoAimingTarget) - Vector(0, 0.7, 0):
    EyePosition(autoAimingTarget) + Vector(0, 0.2, 0);

playervar define autoAimingTarget!;
playervar define autoAimTryCount!;
void StartAutoAiming()"StartAutoAiming"{
    autoAimTryCount = 0;
    while(
        !IsInViewAngle(
            ep, autoAimingPosition, 10) &&
        autoAimTryCount <= 10
    ){
        StartFacing(
            ep,
            DirectionTowards(
                EyePosition(),
                autoAimingPosition
            ),
            MaxValue(),
            Relative.ToWorld, FacingRev.DirectionAndTurnRate
        );   
        Wait(0.1, WaitBehavior.AbortWhenFalse);
        autoAimTryCount ++;
    }
}

// TAG textSize ----------
define basicInWorldTextSize: 0.8;

// TAG bot ----------
define builtinMaxSlotNum: 24;

define botCount: CountOf(FilteredArray(AllPlayers(Team.All), IsDummyBot(ae)));

define canCreateBot: (botCount < builtinMaxSlotNum);

Number GetEmptySlotNo(define team!)"getEmptySlotNo"{
    for(define slotNo! = 0; slotNo < builtinMaxSlotNum; slotNo++){
        if(PlayersInSlot(slotNo, team) == null) {
            return slotNo;
        }
    }
    errLog("getEmptySlotNo not found empty slot");
    return -1;
}

Number GetAvgUltChgOfDummyBot(define team!)"GetAvgUltChgOfDummyBot"{
    define botList! = FilteredArray(AllPlayers(team), IsDummyBot(ae));
    define ultCharge! = 0;
    for(define botListIndex! = 0; botListIndex < CountOf(botList); botListIndex++){
        if(IsUsingUltimate(botList[botListIndex])){
            ultCharge += DefaultPercentage();
        }
        else{
            ultCharge += UltimateChargePercent(botList[botListIndex]);
        }
    }
    ultCharge /= CountOf(botList);
    return ultCharge;
}

void SetAvgUltChgOfDummyBot(define team!, define ultCharge!)"SetAvgUltChgOfDummyBot"{
    define botList! = FilteredArray(AllPlayers(team), IsDummyBot(ae));
    for(define botListIndex! = 0; botListIndex < CountOf(botList); botListIndex++){
        SetUltimateCharge(botList[botListIndex], ultCharge);
    }
}

// TAG ability ----------
define IsDuplicated(define player!):
    HeroOf(player) == Hero.Echo &&
    IsDuplicating(player);

define IsStealth(define player!):
    (
        HeroOf(player) == Hero.Sombra &&
        IsUsingAbility1(player)
    ) ||
    (
        HeroOf(player) == Hero.Moira &&
        IsUsingAbility1(player)
    );

define IsGrapple(define player!):
    HeroOf(player) == Hero.WreckingBall &&
    IsFiringSecondary(player);

define CanResurrect(define player!):
    HeroOf(player) == Hero.Mercy &&
    AbilityCooldown(ep, Button.Ability2) <= 5;

define CanPhantom(define player!):
    HeroOf(player) == Hero.Kiriko &&
    AbilityCooldown(ep, Button.Ability1) <= 3 &&
    DistanceBetween(ep, ClosestPlayerTo(ep, TeamOf())) <= 35;

// TAG Flight ----------
void FlightTo(define target!, define destination!, define blastColor!, define blastSize!)"SlideTo"{
    define dist! = DistanceBetween(target, destination);
    define tryCount! = 10;
    while(
        tryCount > 0
    ){
        ApplyImpulse(target, 
            VectorTowards(target, destination + Vector(0, dist / 5, 0)),
            dist * 1.0,
            Relative.ToWorld, ContraryMotion.Cancel);
        // play blast
        PlayEffect(AllPlayers(), PlayEffect.BadExplosion,
            blastColor, target + Vector(0, -0.25, 0), blastSize);

        tryCount --;
        Wait(0.1, WaitBehavior.IgnoreCondition);
    }

    ApplyImpulse(target, 
        Down(),
        DistanceBetween(target, BelowPosition(target)) * 5.0,
        Relative.ToWorld, ContraryMotion.Cancel);
    // play blast
    PlayEffect(AllPlayers(), PlayEffect.BadExplosion,
        blastColor, target + Vector(0, -0.25, 0), blastSize);
}

// TAG hero ----------
define RandomHero: RandomValueInArray(AllHeroes());
define RandomTankHero: RandomValueInArray(AllTankHeroes());
define RandomDamageHero: RandomValueInArray(AllDamageHeroes());
define RandomSupportHero: RandomValueInArray(AllSupportHeroes());

define IsTankHero(define hero): IsTrueForAny(AllTankHeroes(), ae == hero);
define IsDamageHero(define hero): IsTrueForAny(AllDamageHeroes(), ae == hero);
define IsSupportHero(define hero): IsTrueForAny(AllSupportHeroes(), ae == hero);

Number GetHeroOriginalHealth(define hero!)"GetHeroOriginalHealth"{
    define health!;
    switch(hero){
        case Hero.Roadhog:
        case Hero.WreckingBall:
        health = 700;
        break;

        case Hero.Dva:
        health = 650;
        break;

        case Hero.Reinhardt:
        health = 625;
        break;

        case Hero.Orisa:
        case Hero.Sigma:
        case Hero.Winston:
        health = 550;
        break;

        case Hero.Zarya:
        health = 475;
        break;

        case Hero.Doomfist:
        health = 450;
        break;

        case Hero.JunkerQueen:
        health = 425;
        break;

        case Hero.Bastion:
        health = 300;
        break;

        case Hero.Mei:
        case Hero.Reaper:
        case Hero.Torbjorn:
        health = 250;
        break;

        case Hero.Cassidy:
        health = 225;
        break;

        case Hero.Ana:
        case Hero.Ashe:
        case Hero.Baptiste:
        case Hero.Brigitte:
        case Hero.Echo:
        case Hero.Genji:
        case Hero.Hanzo:
        case Hero.Junkrat:
        case Hero.Kiriko:
        case Hero.Lucio:
        case Hero.Mercy:
        case Hero.Moira:
        case Hero.Pharah:
        case Hero.Sojourn:
        case Hero.Soldier76:
        case Hero.Sombra:
        case Hero.Symmetra:
        case Hero.Widowmaker:
        case Hero.Zenyatta:
        health = 200;
        break;
        case Hero.Tracer:
        health = 150;
        break;
    }

    return health;
}

define favDamage: 
    rva([Hero.Reaper, Hero.Cassidy, Hero.Genji, Hero.Soldier76, Hero.Bastion, Hero.Tracer, Hero.Pharah, Hero.Echo, Hero.Hanzo, Hero.Widowmaker]);

define favTank: 
    rva([Hero.Reinhardt, Hero.Roadhog, Hero.Sigma, Hero.Doomfist, Hero.Orisa, Hero.Zarya, Hero.Ramattra]);

define favSupport: rva([Hero.Kiriko, Hero.Mercy, Hero.Ana, Hero.Baptiste, Hero.Moira]);

// TAG Revive ----------
void revive(define reviveHost!, define reviveTarget!, define feedBackRange!){
    Resurrect(reviveTarget);
    SetStatus(reviveTarget, null, Status.Invincible, 3);

    PlayEffect(
        AllPlayers(Team.All), PlayEffect.GoodPickupEffect,
        Color.Yellow, reviveTarget, 1);
    PlayEffect(
        AllPlayers(Team.All), PlayEffect.BuffExplosionSound,
        Color.White, reviveTarget, MaxLength());
    PlayEffect(
        AllPlayers(Team.All), PlayEffect.RingExplosion,
        Color.Yellow, reviveTarget, feedBackRange);

    SmallMessage(reviveHost,
        <"revived <0> <1>. @", reviveTarget, HeroIconString(HeroOf(reviveTarget))>);
    SmallMessage(reviveTarget,
        <"<0> <1> revived you. @", reviveHost, HeroIconString(HeroOf(reviveHost))>);
}

// TAG PlayerName ----------
define GetDummyName()"DummyName"{
    define name! = RandomValueInArray([
        "Adie @",
        "Adrian @",
        "Albert @",
        "Ben @",
        "Billy @",
        "Bob @",
        "Charles @",
        "Charly @",
        "Chris @",
        "Dan @",
        "Danny @",
        "Dom @",
        "Eddy @",
        "Eric @",
        "Ernie @",
        "Francis @",
        "Fred @",
        "Fred @",
        "Freddy @",
        "Gabby @",
        "Gene @",
        "Gil @",
        "Hank @",
        "Harold @",
        "Harry @",
        "Ice @",
        "Ike @",
        "Isaac @",
        "Jack @",
        "James @",
        "Jeff @",
        "Ken @",
        "Kenneth @",
        "Kenny @",
        "Lenny @",
        "Leo @",
        "Leonard @",
        "Martin @",
        "Michael @",
        "Mickey @",
        "Nathan @",
        "Nick @",
        "Nicolas @",
        "Patrick @",
        "Peter @",
        "Phillip @",
        "Raymond @",
        "Richard @",
        "Rob @",
        "Sam @",
        "Steven @",
        "Stuart @",
        "Ted @",
        "Terry @",
        "Thomas @",
        "Tim @",
        "Tom @",
        "Tony @",
        "Vic @",
        "Victor @",
        "Vincent @",
        "Walter @",
        "William @",
        "Willy @",
        "Xander @",
        "Xandres @",
        "Xman @",
        "Zach @",
        "Zachary @",
        "Zak @"
    ]);
    return name;
}
