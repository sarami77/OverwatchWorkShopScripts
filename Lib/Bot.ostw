import "Utility.ostw";
import "Debug.ostw";

// TAG Builtin -----------------------------------------------

define enemyColor: Color.Purple;

// TAG Bot/Debug ----------
disabled rule: "Bot/Debug/ShowDebugInfo"
Event.OngoingPlayer
if(
    HasSpawned() &&
    IsDummyBot()
){  
    // show status text
    CreateInWorldText(
        HostPlayer(), botInfo[BotInfo.statusText],
        ep + (Up() * 3), 1, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
        Color.White, Spectators.DefaultVisibility);
    // show status2 text
    CreateInWorldText(
        HostPlayer(), botInfo[BotInfo.statusText2],
        ep + (Up() * 2), 1, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
        Color.White, Spectators.DefaultVisibility);

    // show frontDetector path
    CreateBeamEffect(
        ep.botInfo[BotInfo.state] == State.Wandering ? HostPlayer() : null, BeamType.GoodBeam,
        botInfo[BotInfo.detectorRoot], botInfo[BotInfo.frontDetector],
        Color.White,
        EffectRev.VisibleToPositionRadiusAndColor);
    // show upperDetector path
    CreateBeamEffect(
        ep.botInfo[BotInfo.state] == State.Wandering ? HostPlayer() : null, BeamType.GoodBeam,
        botInfo[BotInfo.detectorRoot], botInfo[BotInfo.upperDetector],
        Color.Blue,
        EffectRev.VisibleToPositionRadiusAndColor);
    // show underDetector path
    CreateBeamEffect(
        ep.botInfo[BotInfo.state] == State.Wandering ? HostPlayer() : null, BeamType.GoodBeam,
        botInfo[BotInfo.frontDetector], botInfo[BotInfo.underDetector],
        Color.Green,
        EffectRev.VisibleToPositionRadiusAndColor);

    // show targetPos path
    CreateBeamEffect(
        ep.botInfo[BotInfo.state] == State.Combat || ep.botInfo[BotInfo.state] == State.Searching ? HostPlayer() : null,
        BeamType.GoodBeam,
        EyePosition(), botInfo[BotInfo.targetPos],
        Color.Red,
        EffectRev.VisibleToPositionRadiusAndColor);
    // show targetPos
    CreateEffect(
        ep.botInfo[BotInfo.state] == State.Searching ? HostPlayer() : null,
        Effect.Ring, Color.Red,
        botInfo[BotInfo.targetPos], targetPosRange, EffectRev.VisibleToPositionAndRadius);

    // show stackPos
    CreateEffect(
        ep.botInfo[BotInfo.state] == State.Stacked ? HostPlayer() : null,
        Effect.Ring, Color.White,
        ep.botInfo[BotInfo.stackPos], stackPosRange, EffectRev.VisibleToPositionAndRadius);
}

playervar define BotType;
enum BotType{
    None,
    Minion,
    Elite,
    Boss
}

// TAG Bot/Spawn ----------
enum BotAsset{
    BotType,
    hero,
    count
}

globalvar define botSlot;
globalvar define activeAssetNo;
globalvar define isSpawnedBot;

rule: "Bot/Spawn/CreateAllBotByBotAsset"
Event.OngoingPlayer
if(
    ep == HostPlayer() &&
    IsButtonHeld(ep, Button.Interact) &&
    !isSpawnedBot
){
    WaitLongPressConfirm();
    CreateAllBotByAsset();
}

void CreateAllBotByAsset()"CreateAllBotByAsset"{
    dbgMsg("Start Create All Bot By Bot Asset");
    Wait(0.5, WaitBehavior.IgnoreCondition);
    // define asset list
    define assetList =
    [
        // basic
        [
            [BotType.Boss,      Hero.Roadhog, 1],
            [BotType.Elite,     Hero.Mccree, 1],
            [BotType.Elite,     Hero.Reaper, 1],
            [BotType.Minion,    Hero.Zenyatta, 3]
        ],
        // melees
        [
            [BotType.Boss,      Hero.Reinhardt, 1],
            [BotType.Elite,     Hero.Reaper, 1],
            [BotType.Elite,     Hero.Mei, 1],
            [BotType.Minion,    Hero.Brigitte, 3]
        ],
        // long range
        [
            [BotType.Boss,      Hero.Orisa, 1],
            [BotType.Elite,     Hero.Bastion, 1],
            [BotType.Elite,     Hero.Widowmaker, 2],
            [BotType.Minion,    Hero.Soldier76, 2]
        ],
        // airforce
        [
            [BotType.Elite,     Hero.Pharah, 3],
            [BotType.Elite,     Hero.Echo, 3]
        ],
        // snipers
        [
            [BotType.Boss,      RandomValueInArray(AllTankHeroes()), 1],
            [BotType.Elite,     Hero.Widowmaker, 2],
            [BotType.Elite,     Hero.Hanzo, 1],
            [BotType.Elite,     Hero.Ana, 1],
            [BotType.Elite,     Hero.Ashe, 1]
        ],
        // random
        [
            [BotType.Boss,      RandomValueInArray(AllTankHeroes()),    1],
            [BotType.Elite,     RandomValueInArray(AllDamageHeroes()),  1],
            [BotType.Elite,     RandomValueInArray(AllDamageHeroes()),  1],
            [BotType.Minion,    RandomValueInArray(AllSupportHeroes()), 3]
        ],
        // dual boss
        [
            [BotType.Boss,      RandomValueInArray(AllTankHeroes()), 1],
            [BotType.Boss,      RandomValueInArray(AllDamageHeroes()), 1]
        ],
        // minion force
        [
            [BotType.Minion,    Hero.Reinhardt, 18]
        ]
    ];
    // change asset no
    activeAssetNo = RandomInteger(0, CountOf(assetList) - 1);
    // create bot by asset
    isSpawnedBot = true;
    define asset = ValueInArray(assetList, activeAssetNo);
    for(define assetIdx = 0; assetIdx < CountOf(asset); assetIdx++){
        for(define botCount = 0; botCount < asset[assetIdx][BotAsset.count]; botCount++){
            // create bot
            CreateDummyBot(
                asset[assetIdx][BotAsset.hero],
                Team.Team2,
                botSlot,
                SpawnPoints(Team.Team2)[0],
                Forward()
            );
            // set Bot type
            define spawnBot = PlayersInSlot(botSlot, Team.Team2);
            spawnBot.BotType = asset[assetIdx][BotAsset.BotType];
            Respawn(spawnBot);
            // next slot
            botSlot ++;
            Wait(0.5, WaitBehavior.IgnoreCondition);            
        }
    }

    dbgMsg("Finish Create All Bot By Bot Asset");
}

void DestroyAllBot()"DestroyAllBot"{
    define botNum = NumberOfPlayers(Team.Team2);
    if(0 < botNum){
        for(define idx = 0; idx < 24; idx ++){
            define spawnBot = PlayersInSlot(idx, Team.Team2);
            spawnBot.BotType = BotType.None;
            DestroyDummyBot(
                Team.Team2, idx);
        }
        botSlot = 0;
    }
}

// TAG Bot/BotType ----------
playervar define eachDealtDamageScale;
playervar define eachMaxSpawnInterval;
playervar define eachChargeUltInterval;

rule: "Bot/BotType/setBotType"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    BotType != BotType.None
){
    WaitConditionConfirmed();
    if(BotType == BotType.Minion){ 
        SetMaxHealth(EventPlayer(), 100 * 0.5);
        SetGravity(EventPlayer(), 75);
        StartScalingPlayer(EventPlayer(), 0.7, false);
        StartModifyingHeroVoiceLines(EventPlayer(), 1.25, false);
        eachDealtDamageScale = 0.5;
        eachMaxSpawnInterval = 3;
        eachChargeUltInterval = 60;
    }
    else if(BotType == BotType.Elite){
        SetMaxHealth(EventPlayer(), 100 * 2);
        SetGravity(EventPlayer(), 100);
        StartScalingPlayer(EventPlayer(), 1.0, false);
        StartModifyingHeroVoiceLines(EventPlayer(), 1.0, false);
        eachDealtDamageScale = 1.0;
        eachMaxSpawnInterval = 6;
        eachChargeUltInterval = 30;
    }
    else if(BotType == BotType.Boss){
        SetMaxHealth(EventPlayer(), 100 * 15);
        SetGravity(EventPlayer(), 200);
        StartScalingPlayer(EventPlayer(), 1.5, false);
        StartModifyingHeroVoiceLines(EventPlayer(), 0.75, false);
        eachDealtDamageScale = 1.5;
        eachMaxSpawnInterval = 12;
        eachChargeUltInterval = 15;
    }    

    SetRespawnMaxTime(EventPlayer(), eachMaxSpawnInterval);
    Wait(0.1, WaitBehavior.AbortWhenFalse);
    Heal(EventPlayer(), null, MaxValue());
}

// TAG Bot/Effect ----------
playervar define BotAppearanceEntitys;

rule: "Bot/Effect/showBotAppearance"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    BotType != BotType.None &&
    IsAlive()
){
    BotAppearanceEntitys = [];
    if(BotType == BotType.Minion){
        CreateEffect(AllPlayers(Team.All), Effect.Cloud, enemyColor,
            EventPlayer(), 1.0, EffectRev.VisibleToPositionAndRadius);
        BotAppearanceEntitys[0] = LastCreatedEntity();
        CreateInWorldText(
            AllPlayers(Team.All), "Minion", 
            EventPlayer(), 0.8, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            Color.White, Spectators.DefaultVisibility);
        BotAppearanceEntitys[1] = LastTextID();
    }
    else if(BotType == BotType.Elite){
        CreateEffect(AllPlayers(Team.All), Effect.Cloud, enemyColor,
            EventPlayer(), 2.0, EffectRev.VisibleToPositionAndRadius);
        BotAppearanceEntitys[0] = LastCreatedEntity();
        CreateInWorldText(
            AllPlayers(Team.All), "Elite", 
            EventPlayer(), 1.4, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            Color.Yellow, Spectators.DefaultVisibility);
        BotAppearanceEntitys[1] = LastTextID();
    }
    else if(BotType == BotType.Boss){
        CreateEffect(AllPlayers(Team.All), Effect.Cloud, enemyColor,
            EventPlayer(), 4.0, EffectRev.VisibleToPositionAndRadius);
        BotAppearanceEntitys[0] = LastCreatedEntity();
        CreateInWorldText(
            AllPlayers(Team.All), "Boss", 
            EventPlayer(), 2.0, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            Color.Red, Spectators.DefaultVisibility);
        BotAppearanceEntitys[1] = LastTextID();
    }
}

rule: "Bot/Effect/hideBotAppearance"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    BotType != BotType.None &&
    !IsAlive()
){
    DestroyEffect(BotAppearanceEntitys[0]);
    DestroyInWorldText(BotAppearanceEntitys[1]);
}

rule: "Bot/Effect/playDeadEffect"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    BotType != BotType.None &&
    IsDead()
){
    // Play blast effect when Bot dead
    // It's easier to understand if you killed an Bot, and you'll feel better
    if(BotType == BotType.Minion){
        PlayContinuousBlast(Color.Red, PositionOf(), 2, 1);
    }
    else if(BotType == BotType.Elite){
        PlayContinuousBlast(Color.Red, PositionOf(), 3, 2);
    }
    else if(BotType == BotType.Boss){
        PlayContinuousBlast(Color.Red, PositionOf(), 5, 3);
    }
}

// TAG Bot/ReceivedDamage ----------
globalvar define confirmReceiveDamage;

rule: "Bot/ReceivedDamage/updateByBalance //for game balance, increase by missing players count"
Event.OngoingGlobal
{
    // If don't enough players, adjust Bot received damage rate to make the game fair
    // Multiply damage rate
    confirmReceiveDamage = 100;
    // Apply balance multiplier
    confirmReceiveDamage *= ConvertToBalancedValue(0.7, Team.Team1);     // TAG Bot received damage scale
    SetDamageReceived(AllPlayers(Team.Team2), confirmReceiveDamage);

    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

// TAG Bot/DealtDamage ----------
playervar define confirmDealDamage;

rule: "Bot/DealtDamage/update"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    HasSpawned()
){
    // If don't enough players, adjust Bot dealt damage rate to make the game fair
    // And the round progresses, the Bot deal damage increases and becomes more difficult
    // Add damage rate according to the round progress
    confirmDealDamage = WorkshopSettingReal("Bot Settings", "Initial Deal Damage", 25, 0, 1000, 1);
    confirmDealDamage += roundNo * WorkshopSettingReal("Bot Settings", "Increase Deal Damage Per Round Progress", 1.0, 0, 1000, 2);
    confirmDealDamage *= eachDealtDamageScale;
    // Apply balance multiplier
    confirmDealDamage /= ConvertToBalancedValue(0.7, Team.Team1);     // TAG Bot dealt damage scale
    SetDamageDealt(EventPlayer(), confirmDealDamage);

    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

// TAG Bot/SpawnInterval ----------
playervar define confirmSpawnInterval;

rule: "Bot/SpawnInterval/update"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    portalState == PortalState.Growing
){
    // Shortens Bot spawn interval depending on portal size
    // Portals that have grown significantly over time will spawn more enemies.
    define spawnIntervalScale = (portalSize / maxPortalSize) * eachMaxSpawnInterval;
    confirmSpawnInterval = eachMaxSpawnInterval - spawnIntervalScale;

    confirmSpawnInterval -= (roundNo / 10);
    if(0 > confirmSpawnInterval){
        confirmSpawnInterval = 0;
    }
    
    // set +1 interval for show dead effect
    SetRespawnMaxTime(EventPlayer(), confirmSpawnInterval + deadEffectTime);

    WaitUpdateMediumCycle();
    LoopIf(portalSize < maxPortalSize);
}

rule: "Bot/SpawnInterval/respawnBySucide"
Event.OnDeath
Team.Team2
Player.All
if(
    Attacker() == EventPlayer()
){
    Wait(1, WaitBehavior.AbortWhenFalse);
    Respawn();
}

// TAG Bot/Ability ----------
disabled rule: "Bot/Ability/chargeAbility"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat &&
    HasSpawned()
){
    Wait(1, WaitBehavior.AbortWhenFalse);

    SetAbilityCooldown(ep, Button.Jump, 0);
    SetAbilityCooldown(ep, Button.Crouch, 0);
    SetAbilityCooldown(ep, Button.Ability1, 0);
    SetAbilityCooldown(ep, Button.Ability2, 0);
    SetAbilityCooldown(ep, Button.PrimaryFire, 0);
    SetAbilityCooldown(ep, Button.SecondaryFire, 0);
    SetUltimateCharge (ep, 100);
    LoopIfConditionIsTrue();
}

// TAG Bot/Ultimate ----------
rule: "Bot/Ultimate/chargeUlt"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    HasSpawned() &&
    BotType != BotType.None
){
    WaitConditionConfirmed();
    Wait(eachChargeUltInterval, WaitBehavior.AbortWhenFalse);
    SetUltimateCharge(EventPlayer(), 100);

    LoopIfConditionIsTrue();
}

// TAG Bot/Teleport ----------
playervar define teleportEffectEntity;
playervar define teleportPosition;
define minSpawnAreaSize: 10;
define spawnAreaSizeRate: 1.0;
define spawnAreaSize:
    (portalSize * spawnAreaSizeRate) <= minSpawnAreaSize ?
    minSpawnAreaSize :
    (portalSize * spawnAreaSizeRate);

define teleportPositionClosestPlayer: ClosestPlayerTo(teleportPosition, Team.Team1);
define portalPositionClosestPlayer: ClosestPlayerTo(portalPosition, Team.Team1);

void SetTeleportPositionToPlayerFront()"SetTeleportPositionToPlayerFront"{
    // set teleport position by blind spot from player
    // find place that will be a blind spot up to 10 times
    for(pLoopIndex = 0; pLoopIndex < 10; pLoopIndex++){
        teleportPosition =
            NearestWalkablePosition(
                portalPositionClosestPlayer
                    + 
                (
                    DirectionTowards(
                        portalPositionClosestPlayer,
                        portalPosition
                    )
                        *
                    (DistanceBetween(portalPosition, portalPositionClosestPlayer) * 0.5)
                )
                    +
                RandomPosition(10, 10, 10)
            );

        if(
            DistanceBetween(    // Not too close to player
                teleportPositionClosestPlayer, teleportPosition)
            > 5
        ){
            break;
        }
    }
}

void SetTeleportPositionToPortal()"SetTeleportPositionToPortal"{
    // set teleport position by blind spot from player
    // find place that will be a blind spot up to 10 times
    for(pLoopIndex = 0; pLoopIndex < 10; pLoopIndex++){
        teleportPosition =
            NearestWalkablePosition(
                portalPosition
                    +
                RandomPosition(spawnAreaSize, spawnAreaSize, spawnAreaSize)
            );

        if(
            DistanceBetween(    // Inside portal
                portalPosition, teleportPosition)
            <= (portalSize * spawnAreaSizeRate)
                    &&
            !IsInLineOfSight(   // Blind spot from player 
                teleportPositionClosestPlayer,
                teleportPosition + Up(),
                BarrierLOS.NoBarriersBlock)
        ){
            break;
        }
    }
}

void SetTeleportPositionToPlayer()"SetTeleportPositionToPlayer"{
    // set teleport position by blind spot from player
    // find place that will be a blind spot up to 10 times
    for(pLoopIndex = 0; pLoopIndex < 10; pLoopIndex++){
        teleportPosition =
            NearestWalkablePosition(
                portalPositionClosestPlayer
                    +
                RandomPosition(20, 20, 20)
            );
        
        if(
            DistanceBetween(    // Not too close to player
                teleportPositionClosestPlayer, teleportPosition)
            > 5
                    &&
            !IsInLineOfSight(   // Blind spot from player 
                teleportPositionClosestPlayer,
                teleportPosition + Up(),
                BarrierLOS.NoBarriersBlock)
        ){
            break;
        }
    }
}

void SetTeleportPositionToCamper()"SetTeleportPositionToCamper"{
    // set teleport position by blind spot from player
    // find place that will be a blind spot up to 10 times
    for(pLoopIndex = 0; pLoopIndex < 10; pLoopIndex++){
        teleportPosition = 
            portalPositionClosestPlayer
                +
            RandomPosition(3, 0, 3);
                
        if(
            DistanceBetween(    // Not too close to player
                teleportPositionClosestPlayer, teleportPosition)
            > 1
                    &&
            !IsInViewAngle(    // Out of player field view
                teleportPositionClosestPlayer,
                teleportPosition + Up(),
                90)
                    &&
            IsInLineOfSight(    // Not buried in wall
                teleportPositionClosestPlayer,
                teleportPosition + Up(),
                BarrierLOS.NoBarriersBlock)
        ){
            break;
        }
    }
}

void PlayTeleportEffect()"PlayTeleportEffect"{
    // Play blast effect when Bot teleport
    if(BotType == BotType.Minion){
        PlayEffect(
            AllPlayers(Team.All), PlayEffect.BadExplosion,
            enemyColor, EventPlayer(), 4);
    }
    else if(BotType == BotType.Elite){
        PlayEffect(
            AllPlayers(Team.All), PlayEffect.BadExplosion,
            enemyColor, EventPlayer(), 6);
    }
    else if(BotType == BotType.Boss){
        PlayEffect(
            AllPlayers(Team.All), PlayEffect.BadExplosion,
            enemyColor, EventPlayer(), 10);
    }
    // show effect at root position
    WaitPlayEffect();
}

define deadEffectTime: 1.5;

rule: "Bot/Teleport/teleportToSpawnRoomByPortalDisabled"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    initCompleted &&
    !portalEnable
){
    // Teleport Bot to spawn room when portal disable
    Wait(deadEffectTime, WaitBehavior.AbortWhenFalse);   // wait show dead effect when portal closing
    if(IsAlive()){
        // show pre teleport effect
        PlayTeleportEffect();
    }
    // Teleport to spawn room
    Respawn(AllPlayers(Team.Team2));
    // show teleport effect
    PlayTeleportEffect();
}

rule: "Bot/Teleport/teleportToPortalByPortalEnabled"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    initCompleted &&
    portalEnable
){
    // Teleport Bot to portal when spawn

    // set teleport position
    SetTeleportPositionToPlayerFront();
    // show pre teleport effect
    PlayTeleportEffect();
    // Teleport
    Teleport(EventPlayer(), teleportPosition);
    // show teleport effect
    PlayTeleportEffect();
}

rule: "Bot/Teleport/teleportToPortalBySpawn"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    portalEnable &&
    IsInSpawnRoom()
){
    // Teleport Bot to portal when spawn

    // set teleport position
    if(portalState == PortalState.Suspended)
        SetTeleportPositionToPortal();
    else
        SetTeleportPositionToPlayerFront();
    // show pre teleport effect
    //PlayTeleportEffect();
    // Teleport
    Teleport(EventPlayer(), teleportPosition);
    // show teleport effect
    PlayTeleportEffect();
}

rule: "Bot/Teleport/teleportToPortalByPlayerEntered"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    portalState == PortalState.Suspended &&
    IsAlive(EventPlayer())
){
    WaitConditionConfirmed();
    if(
        DistanceBetween(EventPlayer(), portalPosition) > portalSize &&
        DistanceBetween(EventPlayer(), ClosestPlayerTo(portalPosition, Team.Team1)) >= 15
    ){
        // Teleport Bot to portal when player enter to portal
        // To protect the portal with the Bot

        // set teleport position
        SetTeleportPositionToPortal();
        // show pre teleport effect
        PlayTeleportEffect();
        // Teleport
        Teleport(EventPlayer(), teleportPosition);
        // show teleport effect
        PlayTeleportEffect();
    }
}

rule: "Bot/Teleport/teleportToPortalByCamperDetected"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    IsAlive() &&
    !IsInLineOfSight(EventPlayer(),
            ClosestPlayerTo(portalPosition, Team.Team1),
            BarrierLOS.NoBarriersBlock)
){
    // Teleport an Bot to camping player
    Wait(5 - (roundNo / 5), WaitBehavior.AbortWhenFalse);
    // set teleport position
    if(portalState == PortalState.Suspended)
        SetTeleportPositionToCamper();
    else
        SetTeleportPositionToPlayerFront();
    // show pre teleport effect
    PlayTeleportEffect();
    // Teleport
    Teleport(EventPlayer(), teleportPosition);
    // show pre teleport effect
    PlayTeleportEffect();
    LoopIfConditionIsTrue();
}

// TAG Bot/SetBotInfo ----------
playervar define botInfo = [];
enum BotInfo{
    heroName,
    combatRange,
    combatRangeMin,
    combatRangeMax,
    primaryFireButtonBehaivor,
    primaryFireButtonWaitMin,
    primaryFireButtonWaitMax,
    primaryFireButtonHoldMin,
    primaryFireButtonHoldMax,
    secondaryFireButtonBehaivor,
    secondaryFireButtonWaitMin,
    secondaryFireButtonWaitMax,
    secondaryFireButtonHoldMin,
    secondaryFireButtonHoldMax,
    ability1ButtonWaitMin,
    ability1ButtonWaitMax,
    ability1ButtonHoldMin,
    ability1ButtonHoldMax,
    ability2ButtonWaitMin,
    ability2ButtonWaitMax,
    ability2ButtonHoldMin,
    ability2ButtonHoldMax,
    isRepeating,
    repeatDuringMin,
    repeatDuringMax,
    detectorRoot,
    upperDetector,
    frontDetector,
    underDetector,
    statusText,
    statusText2,
    state,
    tuneDir,
    target,
    targetPos,
    stackPos,
    watchUpdateRate,
    sideStepDir,
    sideStepKeepSecond,
    moveDir
}

define targetPosRange: 8;
define stackPosRange: 2;

rule: "Bot/SetBotInfo"
Event.OngoingPlayer
if(
    HasSpawned() &&
    IsDummyBot()
){
        botInfo[BotInfo.heroName] = "Default";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        botInfo[BotInfo.primaryFireButtonBehaivor] = ButtonBehaivor.HoldOnly;
        botInfo[BotInfo.primaryFireButtonWaitMin] = 0;
        botInfo[BotInfo.primaryFireButtonWaitMax] = 5;
        botInfo[BotInfo.primaryFireButtonHoldMin] = 0;
        botInfo[BotInfo.primaryFireButtonHoldMax] = 5;

        botInfo[BotInfo.secondaryFireButtonBehaivor] = ButtonBehaivor.HoldAndRelease;
        botInfo[BotInfo.secondaryFireButtonWaitMin] = 0;
        botInfo[BotInfo.secondaryFireButtonWaitMax] = 5;
        botInfo[BotInfo.secondaryFireButtonHoldMin] = 0;
        botInfo[BotInfo.secondaryFireButtonHoldMax] = 5;

        botInfo[BotInfo.ability1ButtonWaitMin] = 0;
        botInfo[BotInfo.ability1ButtonWaitMax] = 5;
        botInfo[BotInfo.ability1ButtonHoldMin] = 0;
        botInfo[BotInfo.ability1ButtonHoldMax] = 1;

        botInfo[BotInfo.ability2ButtonWaitMin] = 0;
        botInfo[BotInfo.ability2ButtonWaitMax] = 5;
        botInfo[BotInfo.ability2ButtonHoldMin] = 0;
        botInfo[BotInfo.ability2ButtonHoldMax] = 1;

    switch(HeroOf()){
        case Hero.Ana:
        botInfo[BotInfo.heroName] = "Ana";
        botInfo[BotInfo.combatRange] = CombatRange.Far;
        botInfo[BotInfo.primaryFireButtonBehaivor] = ButtonBehaivor.HoldOnly;
        botInfo[BotInfo.secondaryFireButtonBehaivor] = ButtonBehaivor.HoldAndRelease;
        botInfo[BotInfo.secondaryFireButtonWaitMin] = 0;
        botInfo[BotInfo.secondaryFireButtonWaitMax] = 10;
        botInfo[BotInfo.secondaryFireButtonHoldMin] = 10;
        botInfo[BotInfo.secondaryFireButtonHoldMax] = 10;
        break;

        case Hero.Ashe:
        botInfo[BotInfo.heroName] = "Ashe";
        botInfo[BotInfo.combatRange] = CombatRange.Far;
        botInfo[BotInfo.primaryFireButtonBehaivor] = ButtonBehaivor.Repeat;
        botInfo[BotInfo.secondaryFireButtonBehaivor] = ButtonBehaivor.HoldAndRelease;
        botInfo[BotInfo.secondaryFireButtonWaitMin] = 0;
        botInfo[BotInfo.secondaryFireButtonWaitMax] = 10;
        botInfo[BotInfo.secondaryFireButtonHoldMin] = 10;
        botInfo[BotInfo.secondaryFireButtonHoldMax] = 10;
        break;

        case Hero.Baptiste:
        botInfo[BotInfo.heroName] = "Baptiste";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        break;

        case Hero.Bastion:
        botInfo[BotInfo.heroName] = "Bastion";
        botInfo[BotInfo.combatRange] = CombatRange.Far;
        break;

        case Hero.Brigitte:
        botInfo[BotInfo.heroName] = "Brigitte";
        botInfo[BotInfo.combatRange] = CombatRange.Melee;
        break;

        case Hero.Doomfist:
        botInfo[BotInfo.heroName] = "Doomfist";
        botInfo[BotInfo.combatRange] = CombatRange.Close;
        break;

        case Hero.Dva:
        botInfo[BotInfo.heroName] = "Doomfist";
        botInfo[BotInfo.combatRange] = CombatRange.Close;
        break;

        case Hero.Echo:
        botInfo[BotInfo.heroName] = "Echo";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        break;

        case Hero.Genji:
        botInfo[BotInfo.heroName] = "Genji";
        botInfo[BotInfo.combatRange] = CombatRange.Close;
        break;

        case Hero.Hanzo:
        botInfo[BotInfo.heroName] = "Hanzo";
        botInfo[BotInfo.combatRange] = CombatRange.Far;
        botInfo[BotInfo.primaryFireButtonBehaivor] = ButtonBehaivor.HoldAndRelease;
        botInfo[BotInfo.primaryFireButtonWaitMin] = 0;
        botInfo[BotInfo.primaryFireButtonWaitMax] = 0;
        botInfo[BotInfo.primaryFireButtonHoldMin] = 2;
        botInfo[BotInfo.primaryFireButtonHoldMax] = 2;
        botInfo[BotInfo.secondaryFireButtonBehaivor] = ButtonBehaivor.Non;
        break;

        case Hero.Junkrat:
        botInfo[BotInfo.heroName] = "Junkrat";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        break;

        case Hero.Lucio:
        botInfo[BotInfo.heroName] = "Lucio";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        break;

        case Hero.Mccree:
        botInfo[BotInfo.heroName] = "Mccree";
        botInfo[BotInfo.combatRange] = CombatRange.Close;
        break;

        case Hero.Mei:
        botInfo[BotInfo.heroName] = "Mei";
        botInfo[BotInfo.combatRange] = CombatRange.Close;
        botInfo[BotInfo.primaryFireButtonBehaivor] = ButtonBehaivor.HoldAndRelease;
        break;

        case Hero.Mercy:
        botInfo[BotInfo.heroName] = "Mercy";
        botInfo[BotInfo.combatRange] = CombatRange.Far;
        break;

        case Hero.Moira:
        botInfo[BotInfo.heroName] = "Moira";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        botInfo[BotInfo.primaryFireButtonBehaivor] = ButtonBehaivor.HoldAndRelease;
        botInfo[BotInfo.secondaryFireButtonBehaivor] = ButtonBehaivor.HoldOnly;
        break;

        case Hero.Orisa:
        botInfo[BotInfo.heroName] = "Orisa";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        break;

        case Hero.Pharah:
        botInfo[BotInfo.heroName] = "Pharah";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        break;

        case Hero.Reaper:
        botInfo[BotInfo.heroName] = "Reaper";
        botInfo[BotInfo.combatRange] = CombatRange.Close;
        break;

        case Hero.Reinhardt:
        botInfo[BotInfo.heroName] = "Reinhardt";
        botInfo[BotInfo.combatRange] = CombatRange.Melee;
        break;

        case Hero.Roadhog:
        botInfo[BotInfo.heroName] = "Reaper";
        botInfo[BotInfo.combatRange] = CombatRange.Close;
        break;

        case Hero.Sigma:
        botInfo[BotInfo.heroName] = "Sigma";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        botInfo[BotInfo.secondaryFireButtonWaitMin] = 0;
        botInfo[BotInfo.secondaryFireButtonWaitMax] = 10;
        botInfo[BotInfo.secondaryFireButtonHoldMin] = 0;
        botInfo[BotInfo.secondaryFireButtonHoldMax] = 1;
        break;

        case Hero.Soldier76:
        botInfo[BotInfo.heroName] = "Soldier76";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        break;

        case Hero.Sombra:
        botInfo[BotInfo.heroName] = "Sombra";
        botInfo[BotInfo.combatRange] = CombatRange.Close;
        break;

        case Hero.Symmetra:
        botInfo[BotInfo.heroName] = "Symmetra";
        botInfo[BotInfo.combatRange] = CombatRange.Close;
        botInfo[BotInfo.primaryFireButtonBehaivor] = ButtonBehaivor.HoldAndRelease;
        break;

        case Hero.Torbjorn:
        botInfo[BotInfo.heroName] = "Torbjorn";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        break;

        case Hero.Tracer:
        botInfo[BotInfo.heroName] = "Tracer";
        botInfo[BotInfo.combatRange] = CombatRange.Close;
        break;

        case Hero.Widowmaker:
        botInfo[BotInfo.heroName] = "Widowmaker";
        botInfo[BotInfo.combatRange] = CombatRange.Far;
        botInfo[BotInfo.primaryFireButtonBehaivor] = ButtonBehaivor.HoldAndRelease;
        botInfo[BotInfo.primaryFireButtonWaitMin] = 1;
        botInfo[BotInfo.primaryFireButtonWaitMax] = 2;
        botInfo[BotInfo.primaryFireButtonHoldMin] = 0;
        botInfo[BotInfo.primaryFireButtonHoldMax] = 0;

        botInfo[BotInfo.secondaryFireButtonBehaivor] = ButtonBehaivor.HoldAndRelease;
        botInfo[BotInfo.secondaryFireButtonWaitMin] = 0;
        botInfo[BotInfo.secondaryFireButtonWaitMax] = 0;
        botInfo[BotInfo.secondaryFireButtonHoldMin] = 10;
        botInfo[BotInfo.secondaryFireButtonHoldMax] = 10;
        break;

        case Hero.Winston:
        botInfo[BotInfo.heroName] = "Winston";
        botInfo[BotInfo.combatRange] = CombatRange.Close;
        break;

        case Hero.WreckingBall:
        botInfo[BotInfo.heroName] = "WreckingBall";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        botInfo[BotInfo.primaryFireButtonBehaivor] = ButtonBehaivor.HoldAndRelease;
        botInfo[BotInfo.primaryFireButtonWaitMin] = 5;
        botInfo[BotInfo.primaryFireButtonWaitMax] = 10;
        botInfo[BotInfo.primaryFireButtonHoldMin] = 0;
        botInfo[BotInfo.primaryFireButtonHoldMax] = 10;
        break;

        case Hero.Zarya:
        botInfo[BotInfo.heroName] = "Zarya";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        botInfo[BotInfo.primaryFireButtonBehaivor] = ButtonBehaivor.HoldAndRelease;
        break;

        case Hero.Zenyatta:
        botInfo[BotInfo.heroName] = "Zenyatta";
        botInfo[BotInfo.combatRange] = CombatRange.Far;
        botInfo[BotInfo.primaryFireButtonBehaivor] = ButtonBehaivor.HoldAndRelease;
        break;
    }

    // set combat range
    switch(botInfo[BotInfo.combatRange]){
        case CombatRange.Melee:
            botInfo[BotInfo.combatRangeMin] = 1;
            botInfo[BotInfo.combatRangeMax] = 3;
            break;
        case CombatRange.Close:
            botInfo[BotInfo.combatRangeMin] = 1;
            botInfo[BotInfo.combatRangeMax] = 10;
            break;
        case CombatRange.Middle:
            botInfo[BotInfo.combatRangeMin] = 10;
            botInfo[BotInfo.combatRangeMax] = 18;
            break;
        case CombatRange.Far:
            botInfo[BotInfo.combatRangeMin] = 18;
            botInfo[BotInfo.combatRangeMax] = 26;
            break;
    }
}

enum State{
    Non,
    Wandering,
    Combat,
    Searching,
    Stacked
}

enum CombatRange{
    Non,
    Melee,
    Close,
    Middle,
    Far
}

enum ButtonBehaivor{
    Non,
    HoldOnly,
    HoldAndRelease,
    Repeat
}

enum WeaponbotInfoTarget{
    Non,
    Bot,
    Friend,
    Both
}

// TAG Bot/ObjectDetector ----------

define upperDetectorLength: 4;
define frontDetectorLength: 8;
define underDetectorLength: 6;

enum DetectedObject{
    None,
    Wall,
    Criff,
    DownStair,
    UpStair
}

define isFrontBlocked: IsBlockedBetween(botInfo[BotInfo.detectorRoot], botInfo[BotInfo.frontDetector]);
define isUpperBlocked: IsBlockedBetween(botInfo[BotInfo.detectorRoot], botInfo[BotInfo.upperDetector]);
define isUnderBlocked: IsBlockedBetween(botInfo[BotInfo.frontDetector], botInfo[BotInfo.underDetector]);

Boolean getDetectedObject()"getDetectedObject"{
    DetectedObject detecObj = DetectedObject.None;
    define moveDir = Vector(
        XOf(FacingDirectionOf()),
        0,
        ZOf(FacingDirectionOf())
    );
    moveDir = Normalize(moveDir);
    botInfo[BotInfo.detectorRoot] = EyePosition();
    botInfo[BotInfo.frontDetector] = ShiftedPosition(botInfo[BotInfo.detectorRoot], moveDir, frontDetectorLength);
    botInfo[BotInfo.upperDetector] = ShiftedPosition(botInfo[BotInfo.frontDetector], Up(), upperDetectorLength);
    botInfo[BotInfo.underDetector] = ShiftedPosition(botInfo[BotInfo.frontDetector], Down(), underDetectorLength);

    if(isFrontBlocked){
        if(isUpperBlocked){
            detecObj = DetectedObject.Wall;
        }
        else{
            detecObj = DetectedObject.UpStair;
        }
    }
    else{
        if(isUnderBlocked){
            detecObj = DetectedObject.DownStair;
        }
        else{
            detecObj = DetectedObject.Criff;
        }
    }
    return detecObj;
}

// TAG Bot/ButtonControl ----------
enum ButtonControl{
    button,
    buttonOperation,
    waitDuringMin,
    waitDuringMax,
    holdDuringMin,
    holdDuringMax
}

void StartButtonControl(define buttonControl){
    if(buttonControl[ButtonControl.buttonOperation] == ButtonBehaivor.HoldOnly){
        while(true){
            StartHoldingButton(ep, buttonControl[ButtonControl.button]);
            Wait(RandomReal(buttonControl[ButtonControl.holdDuringMin], buttonControl[ButtonControl.holdDuringMax]), WaitBehavior.AbortWhenFalse);
            StopHoldingButton(ep, buttonControl[ButtonControl.button]);
        }
    }
    else if(buttonControl[ButtonControl.buttonOperation] == ButtonBehaivor.HoldAndRelease){
        while(true){
            Wait(RandomReal(buttonControl[ButtonControl.waitDuringMin], buttonControl[ButtonControl.waitDuringMax]), WaitBehavior.AbortWhenFalse);
            StartHoldingButton(ep, buttonControl[ButtonControl.button]);
            Wait(RandomReal(buttonControl[ButtonControl.holdDuringMin], buttonControl[ButtonControl.holdDuringMax]), WaitBehavior.AbortWhenFalse);
            StopHoldingButton(ep, buttonControl[ButtonControl.button]);
        }
    }
    else if(buttonControl[ButtonControl.buttonOperation] == ButtonBehaivor.Repeat){
        botInfo[BotInfo.repeatDuringMin] = buttonControl[ButtonControl.holdDuringMin];
        botInfo[BotInfo.repeatDuringMax] = buttonControl[ButtonControl.holdDuringMax];
        while(true){
            Wait(RandomReal(buttonControl[ButtonControl.waitDuringMin], buttonControl[ButtonControl.waitDuringMax]), WaitBehavior.AbortWhenFalse);
            botInfo[BotInfo.isRepeating] = true;
            while(botInfo[BotInfo.isRepeating]){
                PressButton(ep, buttonControl[ButtonControl.button]); 
                Wait(0.5, WaitBehavior.AbortWhenFalse);
            }
        }
    }
}

rule: "Bot/ButtonControl/isRepeating"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat &&
    botInfo[BotInfo.isRepeating]
){
    Wait(RandomReal(botInfo[BotInfo.repeatDuringMin], botInfo[BotInfo.repeatDuringMax]), WaitBehavior.AbortWhenFalse);
    botInfo[BotInfo.isRepeating] = false;
}

rule: "Bot/ButtonControl/PrimaryFire/StartButtonControl"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat
){
    StartButtonControl(
        [
            Button.PrimaryFire,
            botInfo[BotInfo.primaryFireButtonBehaivor],
            botInfo[BotInfo.primaryFireButtonWaitMin],
            botInfo[BotInfo.primaryFireButtonWaitMax],
            botInfo[BotInfo.primaryFireButtonHoldMin],
            botInfo[BotInfo.primaryFireButtonHoldMax]
        ]
    );
}

rule: "Bot/ButtonControl/SeconaryFire/StartButtonControl"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat
){
    StartButtonControl(
        [
            Button.SecondaryFire,
            botInfo[BotInfo.secondaryFireButtonBehaivor],
            botInfo[BotInfo.secondaryFireButtonWaitMin],
            botInfo[BotInfo.secondaryFireButtonWaitMax],
            botInfo[BotInfo.secondaryFireButtonHoldMin],
            botInfo[BotInfo.secondaryFireButtonHoldMax]
        ]
    );
}

rule: "Bot/ButtonControl/Ability1/StartButtonControl"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat
){
    StartButtonControl(
        [
            Button.Ability1,
            ButtonBehaivor.HoldAndRelease,
            botInfo[BotInfo.ability1ButtonWaitMin],
            botInfo[BotInfo.ability1ButtonWaitMax],
            botInfo[BotInfo.ability1ButtonHoldMin],
            botInfo[BotInfo.ability1ButtonHoldMax]
        ]
    );
}

rule: "Bot/ButtonControl/Ability2/StartButtonControl"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat
){
    StartButtonControl(
        [
            Button.Ability2,
            ButtonBehaivor.HoldAndRelease,
            botInfo[BotInfo.ability2ButtonWaitMin],
            botInfo[BotInfo.ability2ButtonWaitMax],
            botInfo[BotInfo.ability2ButtonHoldMin],
            botInfo[BotInfo.ability2ButtonHoldMax]
        ]
    );
}

rule: "Bot/ButtonControl/Ultimate/StartButtonControl"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat &&
    UltimateChargePercent() == 100
){
    StartButtonControl(
        [
            Button.Ultimate,
            ButtonBehaivor.HoldAndRelease,
            0,
            5,
            0,
            1
        ]
    );
}

rule: "Bot/ButtonControl/Jump/StartButtonControl"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat
){
    StartButtonControl(
        [
            Button.Jump,
            ButtonBehaivor.HoldAndRelease,
            0,
            10,
            0,
            5
        ]
    );
}

rule: "Bot/ButtonControl/Crouch/StartButtonControl"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat
){
    StartButtonControl(
        [
            Button.Crouch,
            ButtonBehaivor.HoldAndRelease,
            0,
            10,
            0,
            3
        ]
    );
}

rule: "Bot/ButtonControl/Reload/StartButtonControl"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat
){
    StartButtonControl(
        [
            Button.Reload,
            ButtonBehaivor.HoldAndRelease,
            5,
            10,
            0,
            1
        ]
    );
}

rule: "Bot/ButtonControl/WeaponSwitch/StartButtonControl"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat
){
    while(true){
        Wait(RandomReal(0, 30), WaitBehavior.AbortWhenFalse);
        SetWeapon(ep, RandomInteger(0, 1));
    }
}

rule: "Bot/ButtonControl/StopButtonControl"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] != State.Combat
){
    botInfo[BotInfo.statusText2] = <"Not_Combat">;

    StopHoldingButton(ep, Button.PrimaryFire);
    StopHoldingButton(ep, Button.SecondaryFire);
    StopHoldingButton(ep, Button.Ability1);
    StopHoldingButton(ep, Button.Ability2);
    StopHoldingButton(ep, Button.Ultimate);
    StopHoldingButton(ep, Button.Jump);
    StopHoldingButton(ep, Button.Crouch);
}


// TAG Bot/StateControl ----------
define basicUpdateRate: 2.0;

define isStacking:
    SpeedOf() <= 3.0;

define isContactPlayer: 
    HasSpawned(ClosestPlayerTo(ep, OppositeTeamOf(TeamOf()))) &&
    IsAlive(ClosestPlayerTo(ep, OppositeTeamOf(TeamOf()))) &&
    IsInLineOfSight(ep, ClosestPlayerTo(ep, OppositeTeamOf(TeamOf()))) &&
    !(
        HeroOf(botInfo[BotInfo.target]) == Hero.Sombra && IsUsingAbility1(botInfo[BotInfo.target]) &&
        DistanceBetween(ep, ClosestPlayerTo(ep, OppositeTeamOf(TeamOf()))) >= 2
    );

rule: "Bot/State/StateControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    HasSpawned()
){
    if(
        IsDead()
    ){
        // non by dead
        botInfo[BotInfo.state] = State.Non; 
    }
    else if(isContactPlayer){
        // combat by contact player
        botInfo[BotInfo.state] = State.Combat; 
    }
    else
    {
        if(botInfo[BotInfo.targetPos] != 0){
            // start searching at target lost position
            botInfo[BotInfo.state] = State.Searching;
        }
        else{
            // start wardering by target lost
            //botInfo[BotInfo.state] = State.Wandering;
            botInfo[BotInfo.state] = State.Non; 
        }
    }

    Wait(basicUpdateRate, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

// TAG Bot/State/Non ----------
rule: "Bot/State/Non"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Non
){
    botInfo[BotInfo.statusText] = <"Non">;
    botInfo[BotInfo.targetPos] = 0;
    StopMove();
}

// TAG Bot/State/Wandering ----------
define StartMove(define dir):
    StartThrottleInDirection(
        ep, dir, 1,
        Relative.ToPlayer,
        ThrottleBehavior.ReplaceExistingThrottle,
        ThrottleRev.DirectionAndMagnitude);

define StopMove(): StopThrottleInDirection();

rule: "Bot/State/Wandering"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Wandering
){
    botInfo[BotInfo.statusText] = <"Wandering">;

    // set initial status
    botInfo[BotInfo.watchUpdateRate] = basicUpdateRate;
    botInfo[BotInfo.targetPos] = 0;
    StopFacing(ep);

    // action loop
    while(true){
        DetectedObject detectObj = getDetectedObject();
        // blocked by cliff
        if(detectObj == DetectedObject.Criff){
            botInfo[BotInfo.statusText] = <"Wandering/Blocked_By_Cliff">;

            // not set turn direction
            if(botInfo[BotInfo.tuneDir] == 0){
                // set turn direction
                if(RandomInteger(0, 100) <= 50){
                    botInfo[BotInfo.tuneDir] = Right();
                }
                else{
                    botInfo[BotInfo.tuneDir] = Left();
                }
            }
            // set curve to left/right direction
            SetFacing(ep, Forward() + (botInfo[BotInfo.tuneDir] * 2.0), Relative.ToPlayer);
            // shorten watch update rate
            botInfo[BotInfo.watchUpdateRate] = basicUpdateRate / 4;
        }
        // blocked by wall
        else if(detectObj == DetectedObject.Wall){
            botInfo[BotInfo.statusText] = <"Wandering/Blocked_By_Wall">;

            if(botInfo[BotInfo.tuneDir] == 0){
                if(RandomInteger(0, 100) <= 50){
                    botInfo[BotInfo.tuneDir] = Right();
                }
                else{
                    botInfo[BotInfo.tuneDir] = Left();
                }
            }
            SetFacing(ep, Forward() + (botInfo[BotInfo.tuneDir] * 0.5), Relative.ToPlayer);
            botInfo[BotInfo.watchUpdateRate] = basicUpdateRate / 4;
        }
        // not blocked
        else{
            botInfo[BotInfo.statusText] = <"Wandering/Walking">;
            // reset turn direction
            botInfo[BotInfo.tuneDir] = 0;    
            StartMove(Forward());
            // sence near Bot
            if(RandomInteger(0, 100) <= 10){
                SetFacing(
                    ep,
                    DirectionTowards(
                        EyePosition(),
                        ClosestPlayerTo(ep, OppositeTeamOf(TeamOf()))),
                    Relative.ToWorld
                );   
            }
            botInfo[BotInfo.watchUpdateRate] = basicUpdateRate;
        }

        // check stack
        if(isStacking){
            while(RandomInteger(0, 100) <= 40){
                StartHoldingButton(ep, Button.Jump);
                Wait(RandomReal(1, 2), WaitBehavior.AbortWhenFalse);
                StopHoldingButton(ep, Button.Jump);
            }
            if(isStacking){
                botInfo[BotInfo.state] = State.Stacked;
            }
        }

        Wait(botInfo[BotInfo.watchUpdateRate], WaitBehavior.AbortWhenFalse);
    }
}

// TAG Bot/State/Searching ----------
rule: "Bot/State/Searching"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Searching
){
    botInfo[BotInfo.statusText] = <"Searching">;

    // set initial status
    botInfo[BotInfo.watchUpdateRate] = basicUpdateRate;
    StopFacing(ep); 

    if(botInfo[BotInfo.sideStepDir] == 0){
        //botInfo[BotInfo.sideStepDir] = RandomValueInArray([Right(),Left()]);
        botInfo[BotInfo.sideStepDir] = 0;
    }
    else{
        // set reverse side step for find player
        botInfo[BotInfo.sideStepDir] = -botInfo[BotInfo.sideStepDir];
    }
    
    // action loop
    while(true){
        botInfo[BotInfo.targetPos] = BelowPosition(botInfo[BotInfo.targetPos]);
        SetFacing(ep, DirectionTowards(ep, botInfo[BotInfo.targetPos]), Relative.ToWorld);

        // blocked by cliff
        DetectedObject detectObj = getDetectedObject();
        define distToTarget = DistanceBetween(ep, botInfo[BotInfo.target]);
        if(detectObj == DetectedObject.Criff){
            botInfo[BotInfo.moveDir] = 0;
            botInfo[BotInfo.statusText] = <"Searching/Blocked_By_Cliff">;
        }
        else{
            botInfo[BotInfo.moveDir] = Forward();
            botInfo[BotInfo.statusText] = <"Searching/Walking">;
        }

        // set move direction
        if(botInfo[BotInfo.moveDir] != 0 && botInfo[BotInfo.sideStepDir] != 0){
            StartMove(botInfo[BotInfo.moveDir] + botInfo[BotInfo.sideStepDir]);
        }
        else if(botInfo[BotInfo.moveDir] == 0 && botInfo[BotInfo.sideStepDir] != 0){
            StartMove(botInfo[BotInfo.sideStepDir]);
        }
        else if(botInfo[BotInfo.moveDir] != 0 && botInfo[BotInfo.sideStepDir] == 0){
            StartMove(botInfo[BotInfo.moveDir]);
        }
        else{
            StopMove();
        }

        // check stack
        if(isStacking){
            StartMove(-botInfo[BotInfo.sideStepDir] + Forward());
            while(RandomInteger(0, 100) <= 40){
                StartHoldingButton(ep, Button.Jump);
                Wait(RandomReal(1, 2), WaitBehavior.AbortWhenFalse);
                StopHoldingButton(ep, Button.Jump);
            }
            if(isStacking){
                botInfo[BotInfo.state] = State.Stacked;
            }
        }

        // arrival botInfo[BotInfo.target] lost position
        if(DistanceBetween(botInfo[BotInfo.targetPos], ep) <= 5){
            botInfo[BotInfo.statusText] = <"Searching/Canceled">;
            Wait(1, WaitBehavior.IgnoreCondition);
            botInfo[BotInfo.targetPos] = 0;
            botInfo[BotInfo.state] = State.Wandering;
        }
 
        Wait(botInfo[BotInfo.watchUpdateRate], WaitBehavior.AbortWhenFalse);
    }
}

rule: "Bot/State/Searching/Timeout"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Searching
){
    Wait(10, WaitBehavior.AbortWhenFalse);
    botInfo[BotInfo.state] = State.Wandering;
}

// TAG Bot/State/Combat ----------
rule: "Bot/State/Combat"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat
){
    botInfo[BotInfo.statusText] = <"Combat">;

    // set initial status
    botInfo[BotInfo.watchUpdateRate] = basicUpdateRate;
    botInfo[BotInfo.moveDir] = 0;
    botInfo[BotInfo.sideStepDir] = 0;
    StartFacing(
        ep,
        DirectionTowards(
            EyePosition(),
            botInfo[BotInfo.target] + (Up() * 1.0)),
        300,
        Relative.ToWorld, FacingRev.DirectionAndTurnRate
    );   
    
    // action loop
    while(true){
        // set botInfo state
        define target = ClosestPlayerTo(ep, OppositeTeamOf(TeamOf()));
        if(!IsAlive(target)){
            target = RandomValueInArray(AllLivingPlayers(Team.Team1));
        }
        botInfo[BotInfo.target] = target;
        botInfo[BotInfo.targetPos] = PositionOf(botInfo[BotInfo.target]);

        // change combat distance
        DetectedObject object = getDetectedObject();
        define distToTarget = DistanceBetween(ep, botInfo[BotInfo.target]);
        if(object == DetectedObject.Criff){
            botInfo[BotInfo.moveDir] = 0;
            botInfo[BotInfo.statusText] = <"Combat/Blocked_By_Cliff">;
        }
        else if(distToTarget > botInfo[BotInfo.combatRangeMax]){
            botInfo[BotInfo.moveDir] = Forward();
            botInfo[BotInfo.statusText] = <"Combat/Forward">;
        }
        else if(distToTarget < botInfo[BotInfo.combatRangeMin]){
            botInfo[BotInfo.moveDir] = Backward();
            botInfo[BotInfo.statusText] = <"Combat/Backward">;
        }
        else{
            botInfo[BotInfo.moveDir] = 0;
            botInfo[BotInfo.statusText] = <"Combat/Keep_Distance">;
        }

        // change side step
        if(
            botInfo[BotInfo.sideStepKeepSecond] == 0
        ){
            if(RandomInteger(0, 100) <= 70){
                botInfo[BotInfo.sideStepDir] = RandomValueInArray([Right(),Left()]);
                botInfo[BotInfo.sideStepKeepSecond] = RandomInteger(0, 3);
            }
            else{
                botInfo[BotInfo.sideStepDir] = 0;
                botInfo[BotInfo.sideStepKeepSecond] = RandomInteger(0, 1);
            }
        }

        // check stack
        if(isStacking){
            botInfo[BotInfo.sideStepDir] = -botInfo[BotInfo.sideStepDir]; 
        }

        // set move direction
        if(botInfo[BotInfo.moveDir] != 0 && botInfo[BotInfo.sideStepDir] != 0){
            StartMove(botInfo[BotInfo.moveDir] + botInfo[BotInfo.sideStepDir]);
        }
        else if(botInfo[BotInfo.moveDir] == 0 && botInfo[BotInfo.sideStepDir] != 0){
            StartMove(botInfo[BotInfo.sideStepDir]);
        }
        else if(botInfo[BotInfo.moveDir] != 0 && botInfo[BotInfo.sideStepDir] == 0){
            StartMove(botInfo[BotInfo.moveDir]);
        }
        else{
            StopMove();
        }

        Wait(botInfo[BotInfo.watchUpdateRate], WaitBehavior.AbortWhenFalse);
    }
}

rule: "Bot/Bot/State/Combat/sideStepKeepSecond"
Event.OngoingPlayer
if(
    0 < botInfo[BotInfo.sideStepKeepSecond]
){
    while(true){
        Wait(1, WaitBehavior.AbortWhenFalse);
        botInfo[BotInfo.sideStepKeepSecond] --;
    }
}

// TAG Bot/State/Stacked ----------
rule: "Bot/State/Stacked"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Stacked
){
    botInfo[BotInfo.statusText] = <"Stacked">;
    botInfo[BotInfo.stackPos] = PositionOf();
    Wait(1, WaitBehavior.RestartWhenTrue);

    if(DistanceBetween(botInfo[BotInfo.stackPos], ep) <= stackPosRange){
        botInfo[BotInfo.statusText] = <"Stacked/Reset">;
        SetFacing(ep, Backward(), Relative.ToPlayer);
        botInfo[BotInfo.state] = State.Wandering;
    }
}


// Debug -----------------------------------------------
disabled rule: "Debug/ReloadBotAsset"
Event.OngoingPlayer
if(
    ep == HostPlayer() &&
    IsButtonHeld(ep, Button.Interact)
){
    WaitLongPressConfirm();
    isSpawnedBot = false;
    DestroyAllBot();
    CreateAllBotByAsset();
}
