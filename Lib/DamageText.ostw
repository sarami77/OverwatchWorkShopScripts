// Function enable team
// Set team in import destination parent file
globalvar define DamageText_enableTeam;
define DamageText_isEnableTeam:
    DamageText_enableTeam == TeamOf() ||
    DamageText_enableTeam == Team.All;

define minDisplayTime: 0.5;
define maxDisplayTime: 10;
playervar define damageTextEntity;

playervar define prevDamage;

rule: "DamageFloatText/popup"
Event.OnDamageTaken
if(
    DamageText_isEnableTeam &&
    EventDamage() >= 1
)
{
    Wait(0.1, WaitBehavior.RestartWhenTrue);
    DestroyInWorldText(damageTextEntity);
    define damageTextPosition = EyePosition(EventPlayer());
    define damageTextSize = 1 + (EventDamage() * 0.01);
    define damageTextDisplayTime = minDisplayTime + (EventDamage() * 0.01);
    damageTextDisplayTime = damageTextDisplayTime > maxDisplayTime ? maxDisplayTime : damageTextDisplayTime;
    // show red in 200 damage over
    if(200 <= EventDamage()){
        CreateInWorldText(AllPlayers(), RoundToInteger(EventDamage()), damageTextPosition,
            damageTextSize, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            Color.Red, Spectators.DefaultVisibility);
    }
    // show orange in 100 damage over
    else if(100 <= EventDamage()){
        CreateInWorldText(AllPlayers(), RoundToInteger(EventDamage()), damageTextPosition,
            damageTextSize, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            Color.Orange, Spectators.DefaultVisibility);
    }
    // show yellow in 50 damage over
    else if(50 <= EventDamage()){
        CreateInWorldText(AllPlayers(), RoundToInteger(EventDamage()), damageTextPosition,
            damageTextSize, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            Color.Yellow, Spectators.DefaultVisibility);
    }
    // show white in 50 damage under
    else{
        CreateInWorldText(AllPlayers(), RoundToInteger(EventDamage()), damageTextPosition,
            damageTextSize, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            Color.White, Spectators.DefaultVisibility);
    }
    damageTextEntity = LastTextID();
    UpdateEveryFrame(damageTextPosition);

    ChaseVariableOverTime(damageTextPosition, damageTextPosition + (Up() * 10),
        maxDisplayTime, TimeChaseReevaluation.DestinationAndDuration);
    Wait(damageTextDisplayTime, WaitBehavior.RestartWhenTrue);
    DestroyInWorldText(damageTextEntity);
}