import "Utility.del";
import "Debug.del";

// TAG Bot/Spawn ----------
enum BotAsset{
    EnemyType,
    hero,
    count
}

// TAG EnemyType ----------
playervar define enemyType;
enum EnemyType{
    None,
    Minion,
    Elite,
    Boss,
    GiantBoss
}

// TAG BotAsset ----------
define RandomHero: RandomValueInArray(AllHeroes());
define RandomTankHero: RandomValueInArray(AllTankHeroes());
define RandomDamageHero: RandomValueInArray(AllDamageHeroes());
define RandomSupportHero: RandomValueInArray(AllSupportHeroes());

globalvar define botSlot!;

void CreateEnemyBotsByAssetList(define assetList)"CreateEnemyBotsByAssetList"{
    DestroyBots(Team.Team2);

    // create bot by asset
    define asset = ValueInArray(assetList, RandomInteger(0, CountOf(assetList) - 1));
    for(define assetIdx = 0; assetIdx < CountOf(asset); assetIdx++){
        for(define botCount = 0; botCount < asset[assetIdx][BotAsset.count]; botCount++){
            // asign team
            define team = Team.Team2;
            // create bot
            CreateDummyBot(
                asset[assetIdx][BotAsset.hero],
                team,
                botSlot,
                SpawnPoints(team)[0],
                RandomDirection()
            );
            Wait(0.1, WaitBehavior.IgnoreCondition);
                WaitUntil(!isServerOverLoading, 3);
            // set Bot type as enemy type
            define spawnBot = PlayersInSlot(botSlot, team);
            spawnBot.enemyType = asset[assetIdx][BotAsset.EnemyType];

            // next slot
            botSlot ++;
        }
    }
}

void CreateBothBotsByInput(define heroList, define num)"CreateBothBotsByInput"{
    DestroyBots(Team.Team1);
    DestroyBots(Team.Team2);

    // create bot by asset
    for(define slotIdx = 0; slotIdx < num; slotIdx++){
        // asign team
        define team = (slotIdx % 2 == 0) ? Team.Team1 : Team.Team2;
        // try until spawn entity
        while(!HasSpawned(PlayersInSlot(botSlot, team))){
            // create bot
            CreateDummyBot(
                RandomValueInArray(heroList),
                team,
                botSlot,
                SpawnPoints(team)[0],
                RandomDirection()
            );
            Wait(0.1, WaitBehavior.IgnoreCondition);
            WaitUntil(!isServerOverLoading, 3);
        }   
        
        if(team == Team.Team2){
            // next slot
            botSlot ++;
        }
    }
}

void DestroyBots(define team!)"DestroyBots"{
    for(define slotIdx = 0; slotIdx < 6; slotIdx ++){
        // try until despawn entity
        // while(HasSpawned(PlayersInSlot(slotIdx, team))){
            DestroyDummyBot(
                team, slotIdx);
            Wait(0.01, WaitBehavior.IgnoreCondition);
        // }
    }
    botSlot = 0;
}

// TAG Bot/SetBotInfo ----------

playervar define heroName!;

playervar define supportProbability!;
playervar define supportButtons!;

playervar define attackButtons!;

playervar define primaryFireButtonBehaivor!;
playervar define primaryFireButtonReleaseMin!;
playervar define primaryFireButtonReleaseMax!;
playervar define primaryFireButtonPressMin!;
playervar define primaryFireButtonPressMax!;
playervar define secondaryFireButtonBehaivor!;
playervar define secondaryFireButtonReleaseMin!;
playervar define secondaryFireButtonReleaseMax!;
playervar define secondaryFireButtonPressMin!;
playervar define secondaryFireButtonPressMax!;
playervar define ability1ButtonReleaseMin!;
playervar define ability1ButtonReleaseMax!;
playervar define ability1ButtonPressMin!;
playervar define ability1ButtonPressMax!;
playervar define ability2ButtonReleaseMin!;
playervar define ability2ButtonReleaseMax!;
playervar define ability2ButtonPressMin!;
playervar define ability2ButtonPressMax!;


playervar define AttackRange!;
playervar define AttackRangeMin!;
playervar define AttackRangeMax!;

define targetPosRange: 6;

rule: "Bot/SetAttackRoutine"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    HasSpawned()
){
        heroName = "Default";
        supportProbability = 0;
        supportButtons = [];
        attackButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        AttackRange = AttackRange.Middle;

        primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        primaryFireButtonReleaseMin = 0;
        primaryFireButtonReleaseMax = 3;
        primaryFireButtonPressMin = 0;
        primaryFireButtonPressMax = 10;

        secondaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        secondaryFireButtonReleaseMin = 0;
        secondaryFireButtonReleaseMax = 3;
        secondaryFireButtonPressMin = 0;
        secondaryFireButtonPressMax = 10;

        ability1ButtonReleaseMin = 0;
        ability1ButtonReleaseMax = 3;
        ability1ButtonPressMin = 0;
        ability1ButtonPressMax = 5;

        ability2ButtonReleaseMin = 0;
        ability2ButtonReleaseMax = 3;
        ability2ButtonPressMin = 0;
        ability2ButtonPressMax = 5;

    switch(HeroOf()){
        case Hero.Ana:
        heroName = "Ana";
        supportProbability = 100;
        supportButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability2
        ];
        attackButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        AttackRange = AttackRange.Far;
        secondaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        secondaryFireButtonPressMin = 10;
        secondaryFireButtonPressMax = 15;
        break;

        case Hero.Ashe:
        heroName = "Ashe";
        AttackRange = AttackRange.Far;
        primaryFireButtonBehaivor = ButtonBehaivor.ReleaseRepeat;
        secondaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        secondaryFireButtonPressMin = 10;
        secondaryFireButtonPressMax = 10;
        break;

        case Hero.Baptiste:
        heroName = "Baptiste";
        supportProbability = 100;
        supportButtons = [
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.PrimaryFire,
            Button.Ability1
        ];
        AttackRange = AttackRange.Middle;
        break;

        case Hero.Bastion:
        heroName = "Bastion";
        AttackRange = AttackRange.Far;
        secondaryFireButtonReleaseMin = 10;
        secondaryFireButtonReleaseMax = 10;
        ability1ButtonReleaseMin = 10;
        ability1ButtonReleaseMax = 10;
        ability1ButtonPressMin = 0.5;
        ability1ButtonPressMax = 0.5;
        break;

        case Hero.Brigitte:
        heroName = "Brigitte";
        supportProbability = 50;
        supportButtons = [
            Button.Ability2
        ];
        attackButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1
        ];
        AttackRange = AttackRange.Melee;
        break;

        case Hero.Doomfist:
        heroName = "Doomfist";
        AttackRange = AttackRange.Melee;
        secondaryFireButtonPressMin = 2;
        secondaryFireButtonPressMax = 3;
        break;

        case Hero.Dva:
        heroName = "Doomfist";
        AttackRange = AttackRange.Close;
        break;

        case Hero.Echo:
        heroName = "Echo";
        AttackRange = AttackRange.Middle;
        break;

        case Hero.Genji:
        heroName = "Genji";
        AttackRange = AttackRange.Melee;
        break;

        case Hero.Hanzo:
        heroName = "Hanzo";
        AttackRange = AttackRange.Far;
        primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        primaryFireButtonReleaseMax = 1;
        primaryFireButtonPressMin = 1.5;
        primaryFireButtonPressMax = 2;
        secondaryFireButtonBehaivor = ButtonBehaivor.Non;
        break;

        case Hero.Junkrat:
        heroName = "Junkrat";
        AttackRange = AttackRange.Middle;
        break;

        case Hero.Lucio:
        heroName = "Lucio";
        supportProbability = 50;
        supportButtons = [
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        AttackRange = AttackRange.Middle;
        break;

        case Hero.Mccree:
        heroName = "Mccree";
        AttackRange = AttackRange.Close;
        secondaryFireButtonReleaseMax = 10;
        break;

        case Hero.Mei:
        heroName = "Mei";
        AttackRange = AttackRange.Close;
        primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        break;

        case Hero.Mercy:
        heroName = "Mercy";
        supportProbability = 100;
        supportButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        AttackRange = AttackRange.Far;
        primaryFireButtonReleaseMax = 2;
        ability1ButtonReleaseMax = 1;
        ability2ButtonReleaseMax = 1;
        break;

        case Hero.Moira:
        heroName = "Moira";
        supportProbability = 100;
        supportButtons = [
            Button.PrimaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        AttackRange = AttackRange.Close;

        primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        secondaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        break;

        case Hero.Orisa:
        heroName = "Orisa";
        AttackRange = AttackRange.Middle;
        break;

        case Hero.Pharah:
        heroName = "Pharah";
        AttackRange = AttackRange.Middle;
        break;

        case Hero.Reaper:
        heroName = "Reaper";
        AttackRange = AttackRange.Close;
        break;

        case Hero.Reinhardt:
        heroName = "Reinhardt";
        AttackRange = AttackRange.Melee;
        break;

        case Hero.Roadhog:
        heroName = "Reaper";
        AttackRange = AttackRange.Close;
        break;

        case Hero.Sigma:
        heroName = "Sigma";
        AttackRange = AttackRange.Middle;
        secondaryFireButtonReleaseMax = 15;
        secondaryFireButtonPressMax = 1;
        break;

        case Hero.Soldier76:
        heroName = "Soldier76";
        AttackRange = AttackRange.Middle;
        break;

        case Hero.Sombra:
        heroName = "Sombra";
        AttackRange = AttackRange.Close;
        secondaryFireButtonPressMin = 1.5;
        ability1ButtonReleaseMin = 5;
        ability1ButtonReleaseMax = 10;
        break;

        case Hero.Symmetra:
        heroName = "Symmetra";
        AttackRange = AttackRange.Close;
        primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        break;

        case Hero.Torbjorn:
        heroName = "Torbjorn";
        AttackRange = AttackRange.Middle;
        break;

        case Hero.Tracer:
        heroName = "Tracer";
        AttackRange = AttackRange.Close;
        break;

        case Hero.Widowmaker:
        heroName = "Widowmaker";
        AttackRange = AttackRange.Far;
        primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        primaryFireButtonReleaseMin = 1;
        primaryFireButtonReleaseMax = 1.5;
        primaryFireButtonPressMin = 0;
        primaryFireButtonPressMax = 1;
        secondaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        secondaryFireButtonPressMin = 10;
        secondaryFireButtonPressMax = 15;
        ability1ButtonReleaseMin = 10;
        ability1ButtonReleaseMax = 15;
        ability2ButtonReleaseMin = 10;
        ability2ButtonReleaseMax = 15;
        break;

        case Hero.Winston:
        heroName = "Winston";
        AttackRange = AttackRange.Melee;
        break;

        case Hero.WreckingBall:
        heroName = "WreckingBall";
        AttackRange = AttackRange.Middle;
        primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        primaryFireButtonPressMin = 5;
        primaryFireButtonPressMax = 15;
        secondaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        primaryFireButtonPressMin = 10;
        primaryFireButtonPressMax = 15;
        break;

        case Hero.Zarya:
        heroName = "Zarya";
        AttackRange = AttackRange.Middle;
        primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        break;

        case Hero.Zenyatta:
        heroName = "Zenyatta";
        supportProbability = 50;
        supportButtons = [
            Button.Ability2
        ];
        attackButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1
        ];
        AttackRange = AttackRange.Far;
        primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        break;
    }

    // set Attack range
    switch(AttackRange){
        case AttackRange.Melee:
            AttackRangeMin = 1;
            AttackRangeMax = 3;
            break;
        case AttackRange.Close:
            AttackRangeMin = 1;
            AttackRangeMax = 10;
            break;
        case AttackRange.Middle:
            AttackRangeMin = 10;
            AttackRangeMax = 20;
            break;
        case AttackRange.Far:
            AttackRangeMin = 20;
            AttackRangeMax = 30;
            break;
    }
}

enum ActionState{
    Non,
    Attack,
    Support,
    Search
}

enum AttackRange{
    Non,
    Melee,
    Close,
    Middle,
    Far
}

enum ButtonBehaivor{
    Non,
    ReleasePress,
    ReleaseRepeat
}

// TAG Bot/ButtonControl ----------
enum ButtonControl{
    button,
    buttonOperation,
    releaseMin,
    releaseMax,
    pressMin,
    pressMax
}

define noShooting: false;

playervar define isRepeating!;
playervar define repeatMin!;
playervar define repeatMax!;

void StartButtonControl(define bc!){
    AbortIf(noShooting);

    define startButton! = false;
    define fireAndAbilityButtons! = [Button.PrimaryFire, Button.SecondaryFire, Button.Ability1, Button.Ability2];
    // if fire or ability button
    if(
        isMatchButton(bc[ButtonControl.button], fireAndAbilityButtons)
    ){
        // if match attack buttons
        if(
            actionState == ActionState.Attack &&
            isMatchButton(bc[ButtonControl.button], attackButtons)
        ){
            startButton = true;
        }
        // if match Support buttons
        else if(
            actionState == ActionState.Support &&
            isMatchButton(bc[ButtonControl.button], supportButtons)
        ){
            startButton = true;
        }
    }
    else{
        startButton = true;
    }

    // is not start button
    if(!startButton){
        // stop button
        StopHoldingButton(ep, bc[ButtonControl.button]);
    }
    else{
        // swap param if inverse
        define temp! = 0;
        if(bc[ButtonControl.releaseMin] > bc[ButtonControl.releaseMax]){
            temp = bc[ButtonControl.releaseMin];
            bc[ButtonControl.releaseMin] = bc[ButtonControl.releaseMax];
            bc[ButtonControl.releaseMax] = temp;
        }
        if(bc[ButtonControl.pressMin] > bc[ButtonControl.pressMax]){
            temp = bc[ButtonControl.pressMin];
            bc[ButtonControl.pressMin] = bc[ButtonControl.pressMax];
            bc[ButtonControl.pressMax] = temp;
        }

        // start button
        if(bc[ButtonControl.buttonOperation] == ButtonBehaivor.ReleasePress){
            while(true){
                Wait(RandomReal(bc[ButtonControl.releaseMin], bc[ButtonControl.releaseMax]), WaitBehavior.AbortWhenFalse);

                StartHoldingButton(ep, bc[ButtonControl.button]);
                Wait(RandomReal(bc[ButtonControl.pressMin], bc[ButtonControl.pressMax]), WaitBehavior.AbortWhenFalse);

                StopHoldingButton(ep, bc[ButtonControl.button]);
            }
        }
        else if(bc[ButtonControl.buttonOperation] == ButtonBehaivor.ReleaseRepeat){
            repeatMin = bc[ButtonControl.pressMin];
            repeatMax = bc[ButtonControl.pressMax];
            while(true){
                Wait(RandomReal(bc[ButtonControl.releaseMin], bc[ButtonControl.releaseMax]), WaitBehavior.AbortWhenFalse);

                isRepeating = true;
                while(isRepeating){
                    PressButton(ep, bc[ButtonControl.button]); 
                    Wait(0.2, WaitBehavior.AbortWhenFalse);
                }
            }
        }
        // else
    }
}

rule: "Bot/ButtonControl/isRepeating"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    isRepeating
){
    Wait(RandomReal(repeatMin, repeatMax), WaitBehavior.AbortWhenFalse);
    isRepeating = false;
}

Boolean isMatchButton(define matchButton!, define butttons!){
    return IsTrueForAny(butttons, ae == matchButton);
}

// TAG Bot/ButtonControl/PrimaryFire ----------
define enableButtonControlState:
    actionState == ActionState.Attack ||
    actionState == ActionState.Support;

rule: "Bot/ButtonControl/PrimaryFire/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState
){
    StartButtonControl(
        [
            Button.PrimaryFire,
            primaryFireButtonBehaivor,
            primaryFireButtonReleaseMin,
            primaryFireButtonReleaseMax,
            primaryFireButtonPressMin,
            primaryFireButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/SeconaryFire ----------
rule: "Bot/ButtonControl/SeconaryFire/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState
){
    StartButtonControl(
        [
            Button.SecondaryFire,
            secondaryFireButtonBehaivor,
            secondaryFireButtonReleaseMin,
            secondaryFireButtonReleaseMax,
            secondaryFireButtonPressMin,
            secondaryFireButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Ability1 ----------
rule: "Bot/ButtonControl/Ability1/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState
){
    StartButtonControl(
        [
            Button.Ability1,
            ButtonBehaivor.ReleasePress,
            ability1ButtonReleaseMin,
            ability1ButtonReleaseMax,
            ability1ButtonPressMin,
            ability1ButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Ability2 ----------
rule: "Bot/ButtonControl/Ability2/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState
){
    StartButtonControl(
        [
            Button.Ability2,
            ButtonBehaivor.ReleasePress,
            ability2ButtonReleaseMin,
            ability2ButtonReleaseMax,
            ability2ButtonPressMin,
            ability2ButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Ultimate ----------
rule: "Bot/ButtonControl/Ultimate/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState &&
    UltimateChargePercent() >= 100
){
    StartButtonControl(
        [
            Button.Ultimate,
            ButtonBehaivor.ReleasePress,
            0,
            10,
            0,
            1
        ]
    );
}

// TAG Bot/ButtonControl/Jump ----------
rule: "Bot/ButtonControl/Jump/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState
){
    StartButtonControl(
        [
            Button.Jump,
            ButtonBehaivor.ReleasePress,
            0,
            7,
            1,
            5
        ]
    );
}

// TAG Bot/ButtonControl/Crouch ----------
rule: "Bot/ButtonControl/Crouch/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState
){
    StartButtonControl(
        [
            Button.Crouch,
            ButtonBehaivor.ReleasePress,
            5,
            10,
            1,
            2
        ]
    );
}

// TAG Bot/ButtonControl/Reload ----------
rule: "Bot/ButtonControl/Reload/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState
){
    StartButtonControl(
        [
            Button.Reload,
            ButtonBehaivor.ReleasePress,
            5,
            10,
            0,
            1
        ]
    );
}

// TAG Bot/ButtonControl/StopButtonControl ----------
rule: "Bot/ButtonControl/StopButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    !enableButtonControlState
){
    StopHoldingButton(ep, Button.PrimaryFire);
    StopHoldingButton(ep, Button.SecondaryFire);
    StopHoldingButton(ep, Button.Ability1);
    StopHoldingButton(ep, Button.Ability2);
    StopHoldingButton(ep, Button.Ultimate);
    StopHoldingButton(ep, Button.Jump);
    StopHoldingButton(ep, Button.Crouch);
    StopHoldingButton(ep, Button.Reload);

    // reload
    PressButton(ep, Button.Reload);
}


// TAG Bot/ActionState/MainControl ----------
playervar define actionState!;
playervar define prevActionState!;
playervar define statusText!;
playervar define target!;
playervar define targetPos!;
playervar define moveDir!;
playervar define sideStepDir!;
playervar define sideStepSecond!;

define FindAttackTarget():
    FirstOf(
        SortedArray(
            FilteredArray(
                AllPlayers(OppositeTeamOf(TeamOf())),
                (
                    HasSpawned(ae) &&
                    IsInLineOfSight(ep, ae, BarrierLOS.NoBarriersBlock) &&
                    IsAlive(ae) &&
                    !(
                        HeroOf(ae) == Hero.Sombra &&
                        IsUsingAbility1(ae)
                    )
                )
            ),
            DistanceBetween(ae, ep)
        )
    );

define FindSupportTarget():
    FirstOf(
        SortedArray(
            FilteredArray(
                AllPlayers(TeamOf()),
                (
                    ae != ep &&
                    HasSpawned(ae) &&
                    IsInLineOfSight(ep, ae, BarrierLOS.NoBarriersBlock) &&
                    IsAlive(ae) &&
                    NormalizedHealth(ae) <= needHealRate
                )
            ),
            NormalizedHealth(ae)
        )
    );

define needHealRate: 0.75;

define watchUpdateRate:
    isServerOverLoading ? 4 : 2;

rule: "Bot/ActionState/StateControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    HasSpawned()
){
    define targetSighted! =
        (target != 0) &&
        IsAlive(target) &&
        IsInLineOfSight(ep, target);

    // get curent target position
    // target Sighted
    if(targetSighted){
        // get targetPos
        targetPos = PositionOf(target);
    }
    // target dead
    else if(!IsAlive(target)){
        // clear targetPos
        targetPos = 0;
    }
    // else

    // get new target
    if(
        !targetSighted ||       // target not Sighted
        ProbabilityTrue(25) ||  // Probability
        (                        
            actionState == ActionState.Support &&   // support target almost full health
            NormalizedHealth(target) > needHealRate
        )       
    ){
        // set target
        if(
            ProbabilityTrue(supportProbability)    // each support hero Probability
        ){
            // find support target
            target = FindSupportTarget();
            // not found heal target
            if(target == 0){
                // find attack target
                target = FindAttackTarget();
            }
        }
        else{
            // find attack target
            target = FindAttackTarget();
        }
    }

    // get next state
    define nextActionState!;
    // self is dead
    if(IsDead()){
        // Non state by dead
        nextActionState = ActionState.Non; 
    }
    else
    { 
        // has target
        if(target != 0){
            // target is enemy
            if(TeamOf() != TeamOf(target)){
                // Attack state by enemy target
                nextActionState = ActionState.Attack; 
            }
            else{
                // Support state by friend target
                nextActionState = ActionState.Support; 
            }
        }
        // // has not target 
        // else if(targetPos != 0){
        //     // Search state by target lost target 
        //     nextActionState = ActionState.Search;
        // }
        else{
            // Non state by target not found
            nextActionState = ActionState.Non;
        }       
    }

    // if state changed
    if(nextActionState != actionState){
        // next is not Non state
        if(nextActionState != ActionState.Non){
            // temporary set Non state for restart button control
            actionState = ActionState.Non;
            WaitChangeState();
        }
        // set next state
        actionState = nextActionState;
    }

    Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    Wait(RandomReal(0, 1), WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

rule: "Bot/ActionState/GotoAttackStateOnDamageTaken"
Event.OnDamageTaken
if(
    IsDummyBot() &&
    Attacker() != ep &&
    actionState == ActionState.Non
){
    // set attack target
    target = Attacker();
    // set next state
    actionState = ActionState.Attack; 
}

void StopMove()"StopMove"{
    StopThrottleInDirection();
} 

void StartMove()"StartMove"{
    if(moveDir != 0 && sideStepDir != 0){
        StartMoveInDir(moveDir + sideStepDir);
    }
    else if(moveDir == 0 && sideStepDir != 0){
        StartMoveInDir(sideStepDir);
    }
    else if(moveDir != 0 && sideStepDir == 0){
        StartMoveInDir(moveDir);
    }
    else{
        StopMove();
    }
}

define StartMoveInDir(define dir):
    StartThrottleInDirection(
        ep, dir, 1,
        Relative.ToPlayer,
        ThrottleBehavior.ReplaceExistingThrottle,
        ThrottleRev.DirectionAndMagnitude);

define stackRange: 0.75;

playervar define prevPosition;

void checkStackAndBreak()"checkStackAndBreak"{
    if(
        prevPosition != 0 &&
        sideStepDir != 0 &&
        moveDir != 0 &&
        DistanceBetween(PositionOf(), prevPosition) < stackRange
    ){
        statusText = <"checkStackAndBreak <0>", target>;
        
        while(
            DistanceBetween(PositionOf(), prevPosition) < stackRange &&
            ProbabilityTrue(70)
        ){
            // change move direction
            sideStepDir = RandomValueInArray([0, 0, Right(), Left()]);
            moveDir = RandomValueInArray([Forward(), Forward(), Backward()]);
            StartMove();
            // try jump or croch
            define breakStackButton! = RandomValueInArray([Button.Jump, Button.Crouch]);
            StartHoldingButton(ep, breakStackButton);
            Wait(RandomReal(1, 2), WaitBehavior.AbortWhenFalse);
            StopHoldingButton(ep, breakStackButton);
        }
    }
    else{
        prevPosition = PositionOf();
    }
}

// TAG Bot/ActionState/Non ----------
rule: "Bot/ActionState/Non"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    actionState == ActionState.Non
){
    statusText = <"Non">;

    // hero unique action
    HeroUniqueAction();

    moveDir = 0;
    sideStepDir = 0;
    target = 0;
    targetPos = 0;
    StopMove();
    StopFacing();
}

/*
// TAG Bot/ActionState/Searching ----------
rule: "Bot/ActionState/Searching"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    actionState == ActionState.Search
){
    statusText = <"Searching">;

    // hero unique action
    HeroUniqueAction();

    // set initial status
    moveDir = Forward();
    sideStepDir = -sideStepDir;
    StartMove();
    targetPos = BelowPosition(targetPos);   // convert targetpPos to rechable position

    // set face direction to target lost posotion
    StartFacing(
        ep,
        DirectionTowards(
            EyePosition(),
            targetPos),
        300,
        Relative.ToWorld, FacingRev.DirectionAndTurnRate
    );
    
    // action loop
    while(actionState == ActionState.Search){
        // reached target lost position
        if(DistanceBetween(targetPos, ep) <= targetPosRange){
            Wait(1, WaitBehavior.AbortWhenFalse);
            actionState = ActionState.Non;
        }
        
        // check stack
        checkStackAndBreak();

        Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    }
}

rule: "Bot/ActionState/Searching/timeout"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    actionState == ActionState.Search
){
    Wait(5, WaitBehavior.AbortWhenFalse);
    actionState = ActionState.Non;
}
*/

// TAG Bot/ActionState/Attack ----------
define aimDiffusivity: 0.2;
define aimTarget:
    EyePosition(target);

        // (Down() * RandomValueInArray([-0.1, 0, 0.1, 0.2, 0.3, 0.4]));

        // (Down() * 0.3 * aimDiffusivity) +
        // RandomPosition(aimDiffusivity, aimDiffusivity, aimDiffusivity);

define targetDirForward:
    BlockedPositon(
        EyePosition(), 
        ExcludeY(
            DirectionTowards(
                ep,
                aimTarget
            )
        ),
    senserLength);

define targetDirBackward:
    BlockedPositon(
        EyePosition(), 
        ExcludeY(
            -DirectionTowards(
                ep,
                aimTarget
            )
        ),
    senserLength);

rule: "Bot/ActionState/Attack"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    actionState == ActionState.Attack
){
    statusText = <"Attack">;

    // hero unique action
    HeroUniqueAction();

    // set face direction
    StartFacing(
        ep,
        DirectionTowards(
            EyePosition(),
            aimTarget),
        300,
        Relative.ToWorld, FacingRev.DirectionAndTurnRate
    );   
    
    // action loop
    while(actionState == ActionState.Attack){
        // check abyss
        define detectAbyss! = 0;
        if(IsBelowAbyss(targetDirBackward)){
            detectAbyss = Backward();
        }
        else if(IsBelowAbyss(targetDirForward)){
            detectAbyss = Forward();
        }

        // set move direction
        define distToTarget = DistanceBetween(ep, target);
        // target is far
        if(
            distToTarget > AttackRangeMax &&
            detectAbyss != Forward()
        ){
            moveDir = Forward();
        }
        // target is close
        else if(
            distToTarget < AttackRangeMin &&
            detectAbyss != Backward()
        ){
            moveDir = Backward();
        }
        else{
            moveDir = 0;
        }

        // set sidestep direction
        // detect abyss
        if(detectAbyss != 0){
            sideStepDir = 0;
        }
        // non side step
        else if(sideStepSecond == 0){
            if(ProbabilityTrue(50)){
                if(ProbabilityTrue(50)){
                    sideStepDir = Right();
                    sideStepSecond = RandomInteger(0, 3);
                }
                else{
                    sideStepDir = Left();
                    sideStepSecond = RandomInteger(0, 3);
                }
            }
            else{
                sideStepDir = 0;
                sideStepSecond = RandomInteger(0, 3);
            }
        }
        // set move direction
        StartMove();

        // check stack
        checkStackAndBreak();

        Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    }
}

rule: "Bot/ActionState/Attack/sideStepSecond"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    0 < sideStepSecond
){
    Wait(sideStepSecond, WaitBehavior.AbortWhenFalse);
    sideStepSecond = 0;
}

// TAG Bot/ActionState/Support ----------
rule: "Bot/ActionState/Support"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    actionState == ActionState.Support
){
    statusText = <"Support">;

    // hero unique action
    HeroUniqueAction();

    // set face direction
    StartFacing(
        ep,
        DirectionTowards(
            EyePosition(),
            aimTarget),
        300,
        Relative.ToWorld, FacingRev.DirectionAndTurnRate
    );
    
    // action loop
    while(actionState == ActionState.Support){
        // check abyss
        define detectAbyss! = 0;
        if(IsBelowAbyss(targetDirBackward)){
            detectAbyss = Backward();
        }
        else if(IsBelowAbyss(targetDirForward)){
            detectAbyss = Forward();
        }

        // set move direction
        define distToTarget = DistanceBetween(ep, target);
        // target is far
        if(
            distToTarget > AttackRangeMax &&
            detectAbyss != Forward()
        ){
            moveDir = Forward();
        }
        // target is close
        else if(
            distToTarget < AttackRangeMin &&
            detectAbyss != Backward()
        ){
            moveDir = Backward();
        }
        else{
            moveDir = 0;
        }
        // set move direction
        StartMove();
        
        // check stack
        checkStackAndBreak();

        Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    }
}

// TAG Bot/HeroUniqueAction ----------
define MercyStaff: 1;
define MercyPistol: 2;

void HeroUniqueAction(){
    if(HeroOf() == Hero.Mercy){
        if(actionState == ActionState.Attack){
            SetWeapon(ep, MercyPistol);
        }
        else{
            SetWeapon(ep, MercyStaff);
        }
    }
}

// TAG Debug ----------
/*
define maxBotNum: 6;

rule: "Debug/SpawnOneBot"
Event.OngoingPlayer
if(
    ep == HostPlayer() &&
    IsButtonHeld(ep, Button.Interact)
){
    WaitLongPressConfirm();
    define team = botSlot % 2 == 0 ? Team.Team2 : Team.Team1;
    DestroyDummyBot(team, botSlot);
    CreateDummyBot(RandomValueInArray(AllHeroes()), team, botSlot,
        AimingPosition(), FacingDirectionOf()
    );
    if(
        botSlot < maxBotNum &&
        team == Team.Team2
    )
        botSlot ++;
    else
        botSlot = 0;
}

define debugInfoDisplayeTo:
    [HostPlayer(), ep];

rule: "Debug/ShowDebugInfo"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    HasSpawned()
){  
    // show status text
    CreateInWorldText(
        debugInfoDisplayeTo,
        actionState,
        ep + (Up() * 2), 1, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
        Color.White, Spectators.DefaultVisibility);
    // show actionState ring
    CreateEffect(
        ep.actionState != ActionState.Non ? debugInfoDisplayeTo : null,
        Effect.Ring,
            actionState == ActionState.Search ?
                Color.White:
                actionState == ActionState.Attack ?
                    Color.Red :
                    Color.Blue,
        ep, 1, EffectRev.VisibleToPositionRadiusAndColor);
    // show target path beam
    CreateBeamEffect(
        (
            (
                (
                    actionState == ActionState.Attack ||
                    actionState == ActionState.Support
                ) &&
                target != 0
            ) ||                
            (
                actionState == ActionState.Search &&
                targetPos != 0
            )
        )
        ? debugInfoDisplayeTo : null,
        BeamType.BadBeam,
        EyePosition(),
            actionState == ActionState.Attack ||
            actionState == ActionState.Support ?
                target :
                targetPos,
            actionState == ActionState.Search ?
                Color.White:
                actionState == ActionState.Attack ?
                    Color.Red :
                    Color.Blue,
        EffectRev.VisibleToPositionRadiusAndColor);
    // show targetPos ring
    CreateEffect(
        ep.actionState == ActionState.Search ? debugInfoDisplayeTo : null,
        Effect.Ring, Color.White,
        targetPos, targetPosRange, EffectRev.VisibleToPositionRadiusAndColor);
    while(true){
        if(IsBelowAbyss(targetDirBackward)){
            dbgPlyEft(ep);
        }
        Wait(1);
    }
}
*/