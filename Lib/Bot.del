import "Utility.del";
import "Debug.del";

// split actionDistance by Attack Support

globalvar define botEnableTeams = [Team.Team1, Team.Team2];

define isBotEnableTeam: true;

// TAG Bot/Spawn ----------
enum BotAsset{
    EnemyType,
    Hero,
    Count
}

// TAG Bot/EnemyType ----------
playervar define enemyType;
enum EnemyType{
    Non = 0,
    Minion = 1,
    Elite = 2,
    General = 3,
    Boss = 4,
    Zombie = 8
}

// TAG Bot/Asset ----------
void CreateBotsByAsset(define asset!, define team!, define addLimitNum!)"CreateBotsByAsset"{
    if(CountOf(asset) <= 0){
        dbgHudTxt(<"CreateBotsByAsset asset = <0>", CountOf(asset)>);
        return;
    }
    
    define addNum! = 0;
    // run asset items
    for(define assetIdx! = 0; assetIdx < CountOf(asset); assetIdx++){
        // run bot count in asset
        for(define botCount! = 0; botCount < asset[assetIdx][BotAsset.Count]; botCount ++){
            if(addNum >= addLimitNum){
                break;
            }

            if(IsAssemblingHeroes()){
                Wait(RandomReal(0.1, 3), WaitBehavior.IgnoreCondition);
            }

            // get empty slot
            define slot! = GetEmptySlotNo(team);
            for(define tryCount = 10; tryCount > 0 && PlayersInSlot(slot, team) == null; tryCount --){
                // create bot
                CreateDummyBot(
                    asset[assetIdx][BotAsset.Hero],
                    team,
                    slot,
                    SpawnPoints(team)[0],
                    RandomDirection()
                );
                Wait(0.1, WaitBehavior.IgnoreCondition);
                WaitUntilServerFree();
            }
            // set Bot type as enemy type
            define bot! = PlayersInSlot(slot, team);
            bot.enemyType = asset[assetIdx][BotAsset.EnemyType];
            // count up addNum
            addNum ++;
        }
    }
}

void CreateBotsByHeroList(define heroList!, define team!)"CreateBotsByHeroList"{
    // create bot by asset
    for(define listIdx! = 0; listIdx < CountOf(heroList); listIdx++){
        // get empty slot
        define slot! = GetEmptySlotNo(team);
        for(
            define tryCount = 0;
            tryCount <= 10 && PlayersInSlot(slot, team) == null;
            tryCount ++
        ){
            // create bot
            CreateDummyBot(
                heroList[listIdx],
                team,
                slot,
                SpawnPoints(team)[0],
                RandomDirection()
            );
            Wait(0.1, WaitBehavior.IgnoreCondition);
            WaitUntilServerFree();
        }
    }
}

void CreateBotsByHeroInput(define hero!, define num!, define team!)"CreateBotsByHeroInput"{
    // create bot by asset
    for(define listIdx! = 0; listIdx < num; listIdx++){
        // get empty slot
        define slot! = GetEmptySlotNo(team);
        for(
            define tryCount = 0;
            tryCount <= 10 && PlayersInSlot(slot, team) == null;
            tryCount ++
        ){
            // create bot
            CreateDummyBot(
                hero,
                team,
                slot,
                SpawnPoints(team)[0],
                RandomDirection()
            );
            Wait(0.1, WaitBehavior.IgnoreCondition);
            WaitUntilServerFree();
        }
    }
}

void DestroyBots(define team!)"DestroyBots"{
    for(define slotIdx! = 0; slotIdx < builtinMaxSlotNum; slotIdx ++){
        DestroyDummyBot(
            team, slotIdx);
        Wait(0.01, WaitBehavior.IgnoreCondition);
    }
}

// TAG Bot/ButtonControlPropety ----------
playervar define heroName;
playervar define aimScatter;
playervar define supportPrioloty;
playervar define supportButtons;
playervar define attackButtons;
playervar define hasDoubleJumpButtonAbility;
playervar define canFireButtonCombination;

playervar define primaryFireButtonBehaivor;
playervar define primaryFireButtonReleaseMin;
playervar define primaryFireButtonReleaseMax;
playervar define primaryFireButtonPressMin;
playervar define primaryFireButtonPressMax;

playervar define secondaryFireButtonBehaivor;
playervar define secondaryFireButtonReleaseMin;
playervar define secondaryFireButtonReleaseMax;
playervar define secondaryFireButtonPressMin;
playervar define secondaryFireButtonPressMax;

playervar define ability1ButtonReleaseMin;
playervar define ability1ButtonReleaseMax;
playervar define ability1ButtonPressMin;
playervar define ability1ButtonPressMax;

playervar define ability2ButtonReleaseMin;
playervar define ability2ButtonReleaseMax;
playervar define ability2ButtonPressMin;
playervar define ability2ButtonPressMax;

playervar define ultimateButtonReleaseMin;
playervar define ultimateButtonReleaseMax;
playervar define ultimateButtonPressMin;
playervar define ultimateButtonPressMax;

playervar define crouchButtonReleaseMin;
playervar define crouchButtonReleaseMax;
playervar define crouchButtonPressMin;
playervar define crouchButtonPressMax;

playervar define jumpButtonReleaseMin;
playervar define jumpButtonReleaseMax;
playervar define jumpButtonPressMin;
playervar define jumpButtonPressMax;

playervar define actionRangeMin;
playervar define actionRangeMax;

rule: "Bot/SetButtonControlPropetyBySpawned"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    HasSpawned()
){
    SetHeroButtonControlPropety();
}

rule: "Bot/SetButtonControlPropetyByStartDuplicate"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    HeroOf() == Hero.Echo &&
    IsDuplicating(ep)
){
    SetHeroButtonControlPropety();
}

rule: "Bot/SetButtonControlPropetyByEndDuplicate"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    HeroOf() == Hero.Echo &&
    !IsDuplicating(ep)
){
    SetHeroButtonControlPropety();
}

define PreferPolingHeroUniqueAction(): MaxValue();

void SetHeroButtonControlPropety()"SetHeroButtonControlPropety"{
    if(!IsDummyBot()){
        return;
    }

    aimTarget = null;
    heroName = "";

    // basic routine
    aimScatter = 0.5;
    actionRangeMin = ActionRange.Melee;
    actionRangeMax = ActionRange.Melee;

    if(enemyType == EnemyType.Zombie) return;

    canFireButtonCombination = false;
    hasDoubleJumpButtonAbility = false;
    supportPrioloty = 0.0;
    supportButtons = [
        Button.PrimaryFire,
        Button.SecondaryFire,
        Button.Ability1,
        Button.Ability2
    ];
    attackButtons = [
        Button.PrimaryFire,
        Button.SecondaryFire,
        Button.Ability1,
        Button.Ability2
    ];

    primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
    primaryFireButtonReleaseMin = 0;
    primaryFireButtonReleaseMax = 1;
    primaryFireButtonPressMin = 0;
    primaryFireButtonPressMax = 10;

    secondaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
    secondaryFireButtonReleaseMin = 0;
    secondaryFireButtonReleaseMax = 1;
    secondaryFireButtonPressMin = 0;
    secondaryFireButtonPressMax = 10;

    ability1ButtonReleaseMin = 0;
    ability1ButtonReleaseMax = 5;
    ability1ButtonPressMin = 0;
    ability1ButtonPressMax = 1;

    ability2ButtonReleaseMin = 0;
    ability2ButtonReleaseMax = 5;
    ability2ButtonPressMin = 0;
    ability2ButtonPressMax = 1;

    ultimateButtonReleaseMin = 0;
    ultimateButtonReleaseMax = 5;
    ultimateButtonPressMin = 0;
    ultimateButtonPressMax = 1;

    crouchButtonReleaseMin = 0;
    crouchButtonReleaseMax = 10;
    crouchButtonPressMin = 0;
    crouchButtonPressMax = 1;

    jumpButtonReleaseMin = 0;
    jumpButtonReleaseMax = 10;
    jumpButtonPressMin = 0;
    jumpButtonPressMax = 1;

    define hero! = DuplicatingHeroOf();
    if(
        hero == null
    ){
        hero = HeroOf();
    }
    
    switch(hero){
        case Hero.Ana:
        heroName = "Ana";
        aimScatter = 0.3;   // to precision shooting
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        canFireButtonCombination = true;
        supportPrioloty = 1.0;
        secondaryFireButtonPressMin = 30;       // to more use scorp
        secondaryFireButtonPressMax = 40;       // to more use scorp
        jumpButtonReleaseMax = 40;              // to suppress cancel scorp
        ultimateButtonReleaseMax = PreferPolingHeroUniqueAction();          // to suppress over use nano boost (Prefer PolingHeroUniqueAction)
        supportButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability2
        ];
        break;

        case Hero.Ashe:
        heroName = "Ashe";
        aimScatter = 0.3;
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        canFireButtonCombination = true;
        primaryFireButtonBehaivor = ButtonBehaivor.ReleaseRepeat;
        secondaryFireButtonPressMin = 30;       // to more use scorp
        secondaryFireButtonPressMax = 40;       // to more use scorp
        jumpButtonReleaseMax = 40;              // to suppress cancel scorp
        ability1ButtonReleaseMax = PreferPolingHeroUniqueAction();          // to suppress over use corch gun (Prefer PolingHeroUniqueAction)
        break;

        case Hero.Baptiste:
        heroName = "Baptiste";
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        canFireButtonCombination = true;
        supportPrioloty = 1.0;
        ability1ButtonReleaseMax = PreferPolingHeroUniqueAction();          // to suppress over use inmortal field (Prefer PolingHeroUniqueAction)
        jumpButtonReleaseMax = 5;               // to more use exo boots
        crouchButtonReleaseMax = 1;             // to more use exo boots
        crouchButtonPressMax = 20;              // to more use exo boots
        supportButtons = [
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.PrimaryFire,
            Button.Ability1
        ];
        break;

        case Hero.Bastion:
        heroName = "Bastion";
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Far;
        primaryFireButtonReleaseMax = 1;        // to more use primary fire when assault mode
        ability1ButtonReleaseMax = PreferPolingHeroUniqueAction();          // to suppress cancel assault mode (Prefer PolingHeroUniqueAction)
        ultimateButtonReleaseMax = 30;          // to suppress over use artillery
        break;

        case Hero.Brigitte:
        heroName = "Brigitte";
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        canFireButtonCombination = true;
        supportPrioloty = 0.5;
        secondaryFireButtonReleaseMax = 5;      // to suppress over use shield
        ability2ButtonReleaseMax = 1;           // to more use repair pack
        supportButtons = [
            Button.SecondaryFire,
            Button.Ability2
        ];
        break;

        case Hero.Cassidy:
        heroName = "Cassidy";
        aimScatter = 0.3;
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Far;
        secondaryFireButtonReleaseMax = 20;     // to suppress overuse fanning shot
        break;

        case Hero.Doomfist:
        heroName = "Doomfist";
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        ability2ButtonReleaseMin = 3;
        secondaryFireButtonPressMin = 1.3;      // to charge enough rocket punch
        secondaryFireButtonPressMax = 1.5;      // to suppress charge over rocket punch
        break;

        case Hero.Dva:
        heroName = "Dva";
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        ultimateButtonReleaseMax = 40;          // to suppress over use self-destruct / call mech
        break;

        case Hero.Echo:
        heroName = "Echo";
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        break;

        case Hero.Genji:
        heroName = "Genji";
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        hasDoubleJumpButtonAbility = true;
        jumpButtonReleaseMax = 2.5;             // to more use double jump
        jumpButtonPressMax = 3;                 // to more use wall crime
        ability1ButtonReleaseMax = 1;           // to more use swift strike when reset cooldown by kill
        ability1ButtonPressMax = 1;             // to more use swift strike when reset cooldown by kill

        break;

        case Hero.Hanzo:
        heroName = "Hanzo";
        aimScatter = 0.3;
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        hasDoubleJumpButtonAbility = true;
        primaryFireButtonReleaseMax = 1;
        primaryFireButtonPressMin = 0.80;       // to charge enough storm bow
        primaryFireButtonPressMax = 1.30;       // to suppress charge over storm bow
        jumpButtonPressMax = 3;                 // to more use wall crime
        secondaryFireButtonBehaivor = ButtonBehaivor.Non;
        break;

        case Hero.JunkerQueen:
        heroName = "JunkerQueen";
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        break;

        case Hero.Junkrat:
        heroName = "Junkrat";
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Far;
        break;

        case Hero.Kiriko:
        heroName = "Kiriko";
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        supportPrioloty = 1.0;
        jumpButtonPressMax = 3;                 // to more use wall crime
        ability1ButtonPressMax = 1;             // to more use swift step
        ability1ButtonReleaseMax = 1;           // to more use swift step        
        supportButtons = [
            Button.PrimaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.SecondaryFire
        ];
        break;

        case Hero.Lucio:
        heroName = "Lucio";
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        jumpButtonPressMax = 10;
        ability1ButtonReleaseMax = PreferPolingHeroUniqueAction();          // to suppress over use cross fade (Prefer PolingHeroUniqueAction)
        supportPrioloty = 0.5;
        supportButtons = [
            Button.Ability1,
            Button.Ability2
        ];
        break;

        case Hero.Lifeweaver:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        hasDoubleJumpButtonAbility = true;
        supportPrioloty = 1.0;
        jumpButtonReleaseMax = 5;               // to more use life step
        ability2ButtonReleaseMax = PreferPolingHeroUniqueAction();          // to suppress over use life grip (Prefer PolingHeroUniqueAction)
        supportButtons = [
            Button.PrimaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.SecondaryFire,
            Button.Ability1
        ];
        primaryFireButtonPressMin = 0.8;        // to charge enough healing blossom
        primaryFireButtonPressMax = 1.4;        // to suppress charge over healing blossom
        break;

        case Hero.Mei:
        heroName = "Mei";
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        break;

        case Hero.Mercy:
        heroName = "Mercy";
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        supportPrioloty = 1.0;
        secondaryFireButtonReleaseMax = 10;     // to suppress over use damage boost
        ability2ButtonPressMax = 10;            // to more use resuscitation
        ability2ButtonReleaseMax = 0.1;         // to more use resuscitation
        supportButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        break;

        case Hero.Moira:
        heroName = "Moira";
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        supportPrioloty = 0.75;
        supportButtons = [
            Button.PrimaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        break;

        case Hero.Orisa:
        heroName = "Orisa";
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Middle;
        break;

        case Hero.Pharah:
        heroName = "Pharah";
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        jumpButtonReleaseMax = 5;               // to more use hover jet
        jumpButtonPressMax = 5;                 // to more use hover jet
        break;

        case Hero.Ramattra:
        heroName = "Ramattra";
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        secondaryFireButtonReleaseMax = 10;     // to suppress over use guard (on nemesis form)
        secondaryFireButtonPressMin = 2;        // to more keep guard (on nemesis form)
        secondaryFireButtonPressMax = 4;        // to more keep guard (on nemesis form)
        ability1ButtonReleaseMax = PreferPolingHeroUniqueAction();          // to suppress cancel nemesis form (Prefer PolingHeroUniqueAction)
        break;

        case Hero.Reaper:
        heroName = "Reaper";
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        ability2ButtonReleaseMax = PreferPolingHeroUniqueAction();         // to suppress over use shadow step (Prefer PolingHeroUniqueAction)
        break;

        case Hero.Reinhardt:
        heroName = "Reinhardt";
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Melee;
        secondaryFireButtonReleaseMax = 5;     // to suppress over use barrier
        break;

        case Hero.Roadhog:
        heroName = "Roadhog";
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        break;

        case Hero.Sigma:
        heroName = "Sigma";
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        primaryFireButtonReleaseMax = 0;        // to more confirm gravity flax
        secondaryFireButtonReleaseMax = 5;      // to deploy barrier to far distance
        secondaryFireButtonPressMax = 1;        // to deploy barrier to close distance
        break;

        case Hero.Sojourn:
        heroName = "Sojourn";
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Far;
        secondaryFireButtonReleaseMax = 6;      // to suppress over use railgun (charge enough)
        secondaryFireButtonPressMax = 1;        // to suppress over use railgun (charge enough)
        break;
        
        case Hero.Soldier76:
        heroName = "Soldier76";
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        break;

        case Hero.Sombra:
        heroName = "Sombra";
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        secondaryFireButtonPressMin = 1.5;      // to charge enough hack
        ability1ButtonReleaseMax = 10;          // to suppress cancel stealth
        ability2ButtonReleaseMax = 20;          // to suppress over use trans locator (no rapid return)
        break;

        case Hero.Symmetra:
        heroName = "Symmetra";
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        secondaryFireButtonPressMin = 1;        // to charge enough photon bomb
        secondaryFireButtonPressMax = 3;        // to suppress charge over photon bomb
        ability1ButtonReleaseMin = 1;           // to more use turret
        ability1ButtonReleaseMax = 3;           // to more use turret
        ability2ButtonReleaseMax = 30;          // to suppress over use teleporter
        break;

        case Hero.Torbjorn:
        heroName = "Torbjorn";
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        break;

        case Hero.Tracer:
        heroName = "Tracer";
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        break;

        case Hero.Widowmaker:
        heroName = "Widowmaker";
        aimScatter = 0.1;
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        canFireButtonCombination = true;
        primaryFireButtonReleaseMin = 0.8;      // to charge enough sniper rifle
        primaryFireButtonReleaseMax = 1.0;      // to suppress charge over sniper rifle
        primaryFireButtonPressMin = 0;          // to more use sniper rifle
        primaryFireButtonPressMax = 1;          // to more use sniper rifle
        secondaryFireButtonPressMin = 30;       // to more use scorp
        secondaryFireButtonPressMax = 40;       // to more use scorp
        jumpButtonReleaseMax = 40;              // to suppress cancel scorp
        ability1ButtonReleaseMax = PreferPolingHeroUniqueAction();          // to suppress over use grappling hook (Prefer PolingHeroUniqueAction)
        ability2ButtonReleaseMax = 30;          // to suppress over use venom mine
        break;

        case Hero.Winston:
        heroName = "Winston";
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        primaryFireButtonPressMax = 20;
        secondaryFireButtonReleaseMax = 20;
        ultimateButtonReleaseMax = 30;          // to suppress over use primal rage
        break;

        case Hero.WreckingBall:
        heroName = "WreckingBall";
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        primaryFireButtonPressMax = 15;         // to more use quad machine gun
        primaryFireButtonReleaseMax = 10;       // to suppress over use quad machine gun
        secondaryFireButtonReleaseMax = PreferPolingHeroUniqueAction();     // to suppress over use grappling crow (Prefer PolingHeroUniqueAction)
        ability1ButtonReleaseMax = 30;          // to suppress cancel ball form
        crouchButtonPressMax = 4;               // to more use pile driver
        break;

        case Hero.Zarya:
        heroName = "Zarya";
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        attackButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1
        ];
        ability1ButtonReleaseMax = 15;
        ability2ButtonReleaseMax = PreferPolingHeroUniqueAction();          // to suppress over use inmortal field (Prefer PolingHeroUniqueAction)
        break;

        case Hero.Zenyatta:
        heroName = "Zenyatta";
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        supportPrioloty = 0.5;
        supportButtons = [
            Button.Ability1,
            Button.Ability2
        ];
        primaryFireButtonReleaseMin = 1;
        secondaryFireButtonReleaseMin = 1;
        ability1ButtonPressMin = 0.5;           // to more use orb of discord
        ability1ButtonPressMax = 0.5;           // to more use orb of discord
        ability1ButtonReleaseMin = 0.5;         // to more use orb of discord
        ability1ButtonReleaseMax = 0.5;         // to more use orb of discord
        ability2ButtonPressMin = 0.5;           // to more use orb of harmony
        ability2ButtonPressMax = 0.5;           // to more use orb of harmony
        ability2ButtonReleaseMin = 0.5;         // to more use orb of harmony
        ability2ButtonReleaseMax = 0.5;         // to more use orb of harmony
        ultimateButtonReleaseMax = 30;          // to suppress over use transcendence
        break;

        case Hero.Illari:
        heroName = "Illari";
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        supportPrioloty = 1.0;
        supportButtons = [
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.PrimaryFire,
            Button.Ability1
        ];
        primaryFireButtonPressMax = 3;
        primaryFireButtonPressMin = 1.5;
        break;

        default:
        break;
    }    
}

enum ActionState{
    Non,
    Attack,
    Support
}

enum ButtonBehaivor{
    Non,
    ReleasePress,
    ReleaseRepeat
}

// TAG Bot/Moving ----------
playervar define moveDirFB;
playervar define moveDirLR;
playervar define moveTarget;
playervar define enableRetreat = true;

void SetMoveDir() playervar "SetMoveDir"{
    if(enemyType == EnemyType.Zombie){
        // set move to forward
        moveTarget = null;
        moveDirFB = Forward();
        moveDirLR = NoDirection();
        return;
    }

    define distToTarget! = DistanceBetween(ep, aimTarget);
    define objPos! = CurrentObjectOnPosition();

    // move to healer for heal
    if(
        (
            enableRetreat
                ?
            (
                // attack state
                actionState == ActionState.Attack &&
                // lowHealth
                ProbabilityTrue(150 * (1 - NormalizedHealth()))
            )
                :
            false
        )
    
    ){
        define supportPlayers = [];
        define notSupportPlayers = [];
        define livingFriends = AllLivingPlayers(TeamOf());

        // make support player list and not support player
        for(define index! = 0; index < CountOf(livingFriends); index ++){
            if(
                // not self
                ep != livingFriends[index]
            ){
                if(IsSupportHero(HeroOf(livingFriends[index]))){
                    // make support player list
                    supportPlayers[CountOf(supportPlayers)] = livingFriends[index];
                }
                else{
                    // make not support player list
                    notSupportPlayers[CountOf(notSupportPlayers)] = livingFriends[index];
                }
            }
        }

        // find near healer
        define nearHealer = 
            FirstOf(
                SortedArray(
                    supportPlayers,
                    DistanceBetween(ep, ae)
                )
            );

        // find near guard as not support
        define nearGuard = 
            FirstOf(
                SortedArray(
                    notSupportPlayers,
                    DistanceBetween(ep, ae)
                )
            );

        // found support player and far
        if(
            nearHealer != null &&
            DistanceBetween(ep, nearHealer) > ActionRange.Close
        ){
            // set moveTarget by near healer
            moveTarget = nearHealer;
            moveDirFB = NoDirection();
            moveDirLR = NoDirection();
        }
        // found guard player and far
        else if(
            nearGuard != null &&
            DistanceBetween(ep, nearGuard) > ActionRange.Close
        ){
            // set moveTarget by near guard
            moveTarget = nearGuard;
            moveDirFB = NoDirection();
            moveDirLR = NoDirection();
        }
        else{
            // set move to back
            moveTarget = null;
            moveDirFB = Backward();
            moveDirLR = RandomValueInArray([NoDirection(), Right(), Left()]);
        }
    }

    // move to object for secure
    else if(
        // object pos valid
        objPos != null &&
        // payload escort player num is not enough
        (
            (
                (
                    // enemy close win
                    IsCloseWin(EnemyTeamOf(ep)) ||
                    // over time
                    IsOverTime()
                )
                    ?
                // 1/2 players num of team
                NumberOfPlayers(TeamOf()) / 2
                    :
                (IsTeamOnOffense(TeamOf()) ?
                    // 3 is max paylod escort speed
                    3
                        :
                    // 1 is min paylod stop
                    1
                )
            )
                >
            // current on object players num
            NumberOfPlayersOnObjective(TeamOf())
        )
    ){
        // set move to object
        define dirToObject! = LocalVectorOf(DirectionTowards(ep, objPos), ep, Transformation.Rotation);
        moveTarget = null;
        moveDirFB = Vector(0, 0, ZOf(dirToObject));
        moveDirLR = Vector(XOf(dirToObject), 0, 0);
    }
    
    // move to enemy for combat
    else if(actionState != ActionState.Non){
        moveTarget = null;

        // set distRate by actionState
        define distRate! = (actionState == ActionState.Attack) ? 1 : 0.5;

        // target is far and enemy density rate low
        if(
            enableRetreat
                ?
            (
                // target is far
                distToTarget > (actionRangeMax * distRate) &&
                ProbabilityTrue(
                    // by enemy density low
                    (50 * (1 - EnemyDensityRateOfAimTarget(ActionRange.Close))) +
                    // by health high
                    (50 * NormalizedHealth())
                )
            ) 
                :
            distToTarget > (actionRangeMax * distRate)
        ){
            moveDirFB = Forward();
        }
        // target is close
        else if(
            distToTarget < (actionRangeMin * distRate)
        ){
            moveDirFB = Backward();
        }
        else{
            moveDirFB = NoDirection();
        }

        // side step
        // start sidestep by distance close and health less
        if(
            (
                actionState == ActionState.Attack &&                // attack state
                ProbabilityTrue(
                    70 * (1 - NormalizedHealth()) + // by lost health
                    30 * (1 - (distToTarget / ActionRange.Far))  // by target distance clsoe
                )    
            ) ||
            (
                actionState == ActionState.Support &&               // Support state
                ProbabilityTrue(100 * (1 - NormalizedHealth()))      // by lost health
            )
        ){
            if(moveDirLR == NoDirection()){
                moveDirLR = RandomValueInArray([Right(), Left()]);
            }
            else if(ProbabilityTrue(75)){
                // change sidestep to reverse
                moveDirLR = -moveDirLR;
            }
        }
        else{
            // stop sidestep
            moveDirLR = NoDirection();
        }
    }
}

playervar define enableCheckAbyss = true;

void StartMove(define player!) playervar "StartMove"{
    if(noMoving) return;

    define confirmMoveDir = NoDirection();
    define hasMoveTarget;

    if(
        moveDirFB != NoDirection() ||
        moveDirLR != NoDirection()
    ){
        confirmMoveDir = player.moveDirFB + player.moveDirLR;
        hasMoveTarget = false;
    }
    else if(moveTarget != null){
        confirmMoveDir = LocalVectorOf(DirectionTowards(player, moveTarget), ep, Transformation.Rotation);
        hasMoveTarget = true;
    }
    
    // move to position is abyss
    if(
        player.enableCheckAbyss &&
        confirmMoveDir != NoDirection() &&
        IsBelowAbyss(
            BlockedPositonByLocalVector(
                player,
                confirmMoveDir,
                walkMeterPerSec * player.watchUpdateRate
            )
        )
    ){
        StopMove(player);
    }
    else{
        if(
            confirmMoveDir != NoDirection()
        ){
            if(!hasMoveTarget){
                StartThrottleInDirection(
                    player,
                    confirmMoveDir,
                    1,
                    Relative.ToPlayer,
                    ThrottleBehavior.ReplaceExistingThrottle,
                    ThrottleRev.None
                );
            }
            else{
                StartThrottleInDirection(
                    player,
                    DirectionTowards(player, moveTarget),
                    1,
                    Relative.ToWorld,
                    ThrottleBehavior.ReplaceExistingThrottle,
                    ThrottleRev.DirectionAndMagnitude
                );
            }
        }
        else{
            StopMove(player);
        }
    }
}

void StopMove(define player!) playervar "StopMove"{
    if(noMoving) return;
    
    player.moveDirFB = NoDirection();
    player.moveDirLR = NoDirection();
    StopThrottleInDirection(player);
} 

// TAG Bot/Aimming ----------
void StartFacingAimTarget() playervar "StartFacingAimTarget"{
    if(
        aimTarget != null &&
        HasSpawned(aimTarget) &&
        IsAlive(aimTarget)
    ){
        StartFacing(
            ep, DirectionTowards(EyePosition(), aimPosition(aimTarget)),
            facingRate, Relative.ToWorld, FacingRev.DirectionAndTurnRate);
    }
    else{
        StopFacing();
        SetFacing(ep, VectorTowards(ep, ClosestPlayerTo(ep, EnemyTeamOf(ep))));
    }
}

define aimPosition(in define player!): 
    (
        IsInAlternateForm(player) ?
        EyePosition(player) - Vector(0, 0.6, 0)     // body position
            :
        EyePosition(player) + Vector(0, 0.2, 0)     // head position
    )
        +
    RandomPosition(aimScatter, aimScatter, aimScatter)  // aim scatter
        +
    Vector(0, -(aimScatter / 2), 0);    // vertical offset

// TAG Bot/ActionState/StateControl ----------
playervar define watchUpdateRate = 2.0;
playervar define isBotActive;
playervar define actionState;
playervar define aimTarget;

define CanFindRange(in define player!) :
    player != null &&
    DistanceBetween(ep, player) <= ActionRange.CanFind;

define CanFindLine(in define player!) :
    player != null &&
    IsInLineOfSight(EyePosition(ep), EyePosition(player), BarrierLOS.NoBarriersBlock);

define IsSighted(in define player!):
    TeamOf(ep) == TeamOf(player)        ? IsSightedAsFriend(player) :
    TeamOf(ep) == EnemyTeamOf(player)   ? IsSightedAsEnemy(player) :
        false;

define IsSightedAsEnemy(in define player!):
    // valid param
    player != null &&
    // is enemy team
    (TeamOf(ep) == EnemyTeamOf(player)) &&
    // has spawn
    HasSpawned(player) &&
    // alive
    IsAlive(player) &&
    // not in spawn room
    !IsInSpawnRoom(player) &&
    // can find range
    CanFindRange(player) &&
    // can find line
    CanFindLine(player) &&
    // not detection stealth
    !(IsStealth(player) && DistanceBetween(player, ep) >= 4);
    // for debug
    // !(player == hp && IsCrouching(player));

define IsSightedAsFriend(in define player!):
    // valid param
    player != null &&
    // is player team
    (TeamOf(ep) == TeamOf(player)) &&
    // has spawn
    HasSpawned(player) &&
    // alive or can resurrect
    (IsAlive(player) || CanResurrect(ep)) &&
    // not in spawn room
    !IsInSpawnRoom(player) &&
    // can find line
    CanFindRange(player) &&
    // can find line or can swift step
    (CanFindLine(player) || CanSwiftStep(player));
    // for debug
    // !(player == hp && IsCrouching(player));

define FindAttackTarget()"FindAttackTarget"{
    return FirstOf(
        SortedArray(
            FilteredArray(
                AllPlayers(EnemyTeamOf(ep)),
                // sight as enemy
                IsSightedAsEnemy(ae)
            ),
            DistanceBetween(ep, ae)
        )
    );
}

define fullHealthScale: 0.9;

define FindSupportTarget()"FindSupportTarget"{
    return FirstOf(
        SortedArray(
            FilteredArray(
                AllPlayers(TeamOf()),
                // not self
                (ae != ep) &&
                // need heal
                (NormalizedHealth(ae) < fullHealthScale) &&
                // sight as friend
                IsSightedAsFriend(ae)
            ),
            NormalizedHealth(ae)
        )
    );
}

void FindTarget()"FindTarget"{
    define candidateTarget;

    // find aim target
    // but, not set as direct to aimTarget for avoid interrupt invalid facing

    // by supportPrioloty
    if(ProbabilityTrue(100 * supportPrioloty))
    {
        // find support target
        candidateTarget = FindSupportTarget();
        // not found support target
        if(candidateTarget == null){
            // find attack target
            candidateTarget = FindAttackTarget();
        }
    }
    else{
        // find attack target
        candidateTarget = FindAttackTarget();
    }

    if(candidateTarget == null){
        // stop facing before set aimTarget for avoid invalid facing
        StopFacing(ep);
        SetFacing(ep, VectorTowards(ep, ClosestPlayerTo(ep, EnemyTeamOf(ep))));
    }

    // confirm as target
    aimTarget = candidateTarget;

    WaitRandomAfterServerFree();
}

define GetNextActionState()"GetNextActionState"{
    define nextActionState;
    
    if(
        // self alive
        IsAlive() &&
        // has target
        aimTarget != null
    ){
        if(
            // target is friend
            TeamOf() == TeamOf(aimTarget)
        ){
            // Support state
            nextActionState = ActionState.Support;
        }
        else{
            // Attack state
            nextActionState = ActionState.Attack; 
        }
    }
    else{
        // non state
        nextActionState = ActionState.Non;  
    }
    
    return nextActionState;
}

void SetActionState(define player, define nextActionState) "SetActionState"{
    // if state changed
    if(nextActionState != player.actionState){
        // reset for button control reload
        enableButtonControl = false;
        // wait for run disable button control rule
        Wait(0.1, WaitBehavior.IgnoreCondition);
        // set next state
        player.actionState = nextActionState;        
    }
}

rule: "Bot/ActionState/deactivateState"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    !isBotActive
){
    // reset target
    aimTarget = null;
    // apply next state
    SetActionState(ep, GetNextActionState());
    Wait(3, WaitBehavior.IgnoreCondition);
    LoopIfConditionIsTrue();
}

rule: "Bot/ActionState/StateControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    isBotActive
){
    define tryFindTarget = false;

    if(IsAlive()){
        // new target
        if(
            // target not Sighted
            !IsSighted(aimTarget)
        ){
            // get new target
            tryFindTarget = true;
        }
        // check target as support action
        else if(
            // is support role and now supporting
            0 < supportPrioloty &&
            actionState == ActionState.Support
        ){
            if(
                // heal target completed
                NormalizedHealth(aimTarget) >= fullHealthScale ||
                // can not revive dead player
                !(CanResurrect(ep) && !IsAlive(aimTarget))
            ){
                // change target
                tryFindTarget = true;
            }
            else if(
                ProbabilityTrue(
                    // by no support prioloty
                    (50 * (1 - supportPrioloty)) +          
                    // by support target health
                    (50 * NormalizedHealth(aimTarget))      
                )
            ){
                // change target 
                tryFindTarget = true;
            }
            // else{} keep target
        }
        // check target as attack action
        else{
            if(
                // target dead
                !IsAlive(aimTarget)
            ){
                // change target 
                tryFindTarget = true;
            }
            else if(
                ProbabilityTrue(
                    // by attack target health
                    50 * NormalizedHealth(aimTarget) 
                )
            ){
                // change target 
                tryFindTarget = true;
            }
            // else{} keep target
        }

        // get new target
        if(tryFindTarget){
            // find target
            FindTarget();
        }

        // apply next state
        SetActionState(ep, GetNextActionState());
        // action call to near bots
        CallToNearBot();
    }
    else{
        // reset target
        aimTarget = null;
        // apply next state
        SetActionState(ep, GetNextActionState());
    }

    Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    WaitRandomAfterServerFree();
    LoopIfConditionIsTrue();
}

rule: "Bot/ActionState/SetNonStateByDead"
Event.OnDeath
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    Victim() == ep
){
    AbortIf(!isBotActive);

    // reset target
    aimTarget = null;
    // apply next state
    SetActionState(ep, GetNextActionState());
}

rule: "Bot/ActionState/ChangeTargetByTargetDead"
Event.OnElimination
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    IsAlive() &&
    (
        actionState != ActionState.Non &&
        Victim() == aimTarget
    )
){
    AbortIf(!isBotActive);

    // find next target
    FindTarget();
    // apply next state
    SetActionState(ep, GetNextActionState());
}

rule: "Bot/ActionState/ChangeSupportTargetByTargetHealCompleted"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    IsAlive() &&
    (
        actionState == ActionState.Support &&
        NormalizedHealth(aimTarget) >= fullHealthScale
    )
){
    AbortIf(!isBotActive);

    // find next target
    FindTarget();
    // apply next state
    SetActionState(ep, GetNextActionState());
}

rule: "Bot/ActionState/ChangeTargetByDamageTaken"
Event.OnDamageTaken
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    isBotActive &&
    IsAlive() &&
    (
        Attacker() != ep
    )
){
    AbortIf(!isBotActive);
    WaitUntilServerFree();
    
    if(
        // set target in Non
        actionState == ActionState.Non ||
        // change target by target helth
        ProbabilityTrue(50 * NormalizedHealth(aimTarget)) ||
        // can not find aimTarget
        !CanFindLine(aimTarget)
    ){
        // set target by attacker
        aimTarget = Attacker();
        // apply next state
        SetActionState(ep, GetNextActionState());
    }

    // action call to near bots
    CallToNearBot();
    // reduce overrun change target
    Wait(3.0, WaitBehavior.IgnoreCondition);
}

globalvar define isCallAttackCoolingDown1 = false;
globalvar define isCallAttackCoolingDown2 = false;

void CallToNearBot()"CallToNearBot"{
    // check cooldown for reduce overrun
    // if already CoolingDown flag true, ignore action
    if(TeamOf() == Team.Team1){
        if(isCallAttackCoolingDown1){return;}
        isCallAttackCoolingDown1 = true;
    }
    else{
        if(isCallAttackCoolingDown2){return;}
        isCallAttackCoolingDown2 = true;
    }

    if(
        // has aim target
        aimTarget != null
    ){
        // get near idle bot
        define nearFriends = FilteredArray(
            PlayersWithinRadius(ep, 0 + ActionRange.CanFind, TeamOf(), RadiusLOS.Off),
            (
                ae != ep &&
                IsDummyBot(ae) &&
                isBotActive &&
                IsAlive(ae) &&
                (
                    // if support state
                    actionState == ActionState.Support ?
                        // call to near supportable bot for support
                        ae.supportPrioloty > 0 :
                        // call to near idle bot for attack
                        ae.actionState == ActionState.Non
                )
            )
        );

        for(define index = 0; index < CountOf(nearFriends); index ++){
            // set same target
            nearFriends[index].aimTarget = ep.aimTarget;
            // set same state 
            SetActionState(nearFriends[index], ep.actionState);
        }
    }
}

rule: "Bot/ActionState/callAttackCoolDown"
Event.OngoingGlobal
if(
    isCallAttackCoolingDown1 ||
    isCallAttackCoolingDown2
){
    Wait(3.0, WaitBehavior.IgnoreCondition);
    isCallAttackCoolingDown1 = false;
    isCallAttackCoolingDown2 = false;
    Loop();
}

// TAG Bot/ActionState/Non ----------
rule: "Bot/ActionState/Non"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    actionState == ActionState.Non
){
    // stop button
    enableButtonControl = false;

    // stop facing
    StopFacing(ep);
    SetFacing(ep, VectorTowards(ep, ClosestPlayerTo(ep, EnemyTeamOf(ep))));

    // stop move
    StopMove(ep);

    // hero unique action
    PolingHeroUniqueAction();

    Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    WaitRandomAfterServerFree();
    LoopIfConditionIsTrue();
}

// TAG Bot/ActionState/AttackOrSupport ----------
rule: "Bot/ActionState/AttackOrSupport"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    (
        actionState == ActionState.Attack ||
        actionState == ActionState.Support
    )
){
    AbortIf(!isBotActive);

    // start button control
    enableButtonControl = true;

    // start facing
    StartFacingAimTarget();

    // set moveDir for combat
    SetMoveDir();

    // start move by moveDir
    StartMove(ep);

    // hero unique action
    PolingHeroUniqueAction();

    Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    WaitRandomAfterServerFree();
    LoopIfConditionIsTrue();
}

// TAG Bot/HeroUniqueAction ----------
void StartFacingTemporaryWithButton(define target!, define offset!, define aimTime!, define button!, define keepTime!) playervar "StartFacingTemporaryWithButton"{
    if(HasSpawned(target)){
        // is player
        StartFacingPlayer(target);
    }
    else{
        // is position
        StartFacing(
            ep, DirectionTowards(EyePosition(), target + offset),
            facingRate, Relative.ToWorld, FacingRev.DirectionAndTurnRate);
    }

    Wait(aimTime, WaitBehavior.IgnoreCondition);
    StartHoldingButton(ep, button);
    Wait(keepTime, WaitBehavior.IgnoreCondition);
    StopHoldingButton(ep, button);
    StartFacingAimTarget();
}

void PolingHeroUniqueAction() playervar "PolingHeroUniqueAction"{
    // common action
    // reload
    if(
        // in idle
        actionState == ActionState.Non
    ){
        // reload by condition 
        PressButton(ep, Button.Reload);
    }
    else{
        // is out of ammo
        if(
            isOutOfAmmo
        ){
            // reload if out of ammo
            PressButton(ep, Button.Reload);
        }
    }

    if(
        // in combat
        actionState != ActionState.Non
    ){
        // melee
        while(
            aimTarget != null &&
            actionState == ActionState.Attack &&
            DistanceBetween(ep, aimTarget) <= meleeRange &&
            (
                // can kill by melee helath
                Health(aimTarget) <= meleeDamage * 2 ||
                enemyType == EnemyType.Zombie
            )
        ){
            // melee
            PressButton(ep, Button.Melee);
            Wait(0.5, WaitBehavior.AbortWhenFalse);
        }

        if(enemyType == EnemyType.Zombie) return;

        // hero unique action
        // Ana
        if(
            HeroOf() == Hero.Ana
        ){
            if(
                UltimateChargePercent() >= 100
            ){
                // get ultimate ready or ultimate using or low helath player
                define boostTarget! = 
                    RandomValueInArray(
                        FilteredArray(
                            AllLivingPlayers(TeamOf()),
                            (
                                (
                                    // ult ready
                                    UltimateChargePercent(ae) >= 100 ||
                                    // using ult
                                    IsUsingUltimate(ae) ||
                                    // low health
                                    NormalizedHealth(ae) <= 0.25
                                ) &&
                                CanFindLine(ae)
                            )
                        )
                    );

                if(boostTarget != null){
                    StartFacingTemporaryWithButton(boostTarget, null, 0.5, Button.Ultimate, 0);
                }
            }
        }
        // Baptiste
        if(
            HeroOf() == Hero.Baptiste
        ){
            if(
                AbilityCooldown(ep, Button.Ability2) <= 0
            ){
                // get ultimate ready or ultimate using or low helath player
                define protectTarget! = 
                    RandomValueInArray(
                        FilteredArray(
                            AllLivingPlayers(TeamOf()),
                            (
                                (
                                    // low health
                                    NormalizedHealth(ae) <= 0.25
                                ) &&
                                CanFindLine(ae)
                            )
                        )
                    );

                if(protectTarget != null){
                    StartFacingTemporaryWithButton(protectTarget, null, 0.5, Button.Ability2, 0);
                }
            }
        }
        // Zarya
        if(
            HeroOf() == Hero.Zarya
        ){
            if(
                ProbabilityTrue(50) &&
                AbilityCooldown(ep, Button.Ability2) <= 0
            ){
                // get ultimate ready or ultimate using or low helath player
                define protectTarget! = 
                    RandomValueInArray(
                        FilteredArray(
                            AllLivingPlayers(TeamOf()),
                            (
                                (
                                    // low health
                                    NormalizedHealth(ae) <= 0.5
                                ) &&
                                CanFindLine(ae)
                            )
                        )
                    );

                if(protectTarget != null){
                    StartFacingTemporaryWithButton(protectTarget, null, 0.5, Button.Ability2, 0);
                }
            }
        }
        // Mercy
        else if(
            HeroOf() == Hero.Mercy
        ){
            if(
                actionState == ActionState.Support
            ){
                // change to heal arm
                SetWeapon(ep, 1);

                if(
                    // by target health
                    ProbabilityTrue(100 * NormalizedHealth(aimTarget))
                ){
                    // boost aimTarget 
                    StopHoldingButton(ep, Button.PrimaryFire);
                    StartHoldingButton(ep, Button.SecondaryFire);

                    // set boostTarget by ult using player
                    define boostTarget = 
                        RandomValueInArray(
                            FilteredArray(
                                AllLivingPlayers(TeamOf()),
                                (
                                    ae != ep &&
                                    (
                                        // ready ult
                                        100 <= UltimateChargePercent(ae) ||
                                        // using ult
                                        IsUsingUltimate(ae)
                                    ) &&
                                    CanFindLine(ae)
                                )
                            )
                        );

                    if(boostTarget != null){
                        StartFacingTemporaryWithButton(boostTarget, null, 0.5, Button.SecondaryFire, RandomReal(5, 10));
                    }
                }
                else{
                    // heal aimTarget
                    StopHoldingButton(ep, Button.SecondaryFire);
                    StartHoldingButton(ep, Button.PrimaryFire);
                }
            }
            else if(actionState == ActionState.Attack){
                // change to gun
                SetWeapon(ep, 2);
            }
        }
        // Ashe
        else if(
            HeroOf() == Hero.Ashe
        ){
            // fallback by corch gun
            if(
                ProbabilityTrue(50) &&
                DistanceBetween(ep, aimTarget) <= ActionRange.Close
            ){
                if(
                    AbilityCooldown(ep, Button.Ability1) <= 0
                ){
                    // use corch gun
                    PressButton(ep, Button.Ability1);
                }
                else if(ProbabilityTrue(50)){
                    // fallback by non aiming
                    StopHoldingButton(ep, Button.SecondaryFire);
                }
            }

            if(
                isOutOfAmmo ||
                ProbabilityTrue(25 * (1 - (Ammo(ep, 0) / MaxAmmo(ep, 0))))  // by ammo charge
            ){
                // stop buton control for reduce reload cancel by fire
                enableButtonControl = false;
                Wait(0.1, WaitBehavior.IgnoreCondition);
                PressButton(ep, Button.Reload);
                Wait(0.1, WaitBehavior.IgnoreCondition);
                // check reload cancel until full load
                while(IsReloading()){
                    Wait(0.5, WaitBehavior.IgnoreCondition);
                    if(
                        ProbabilityTrue(25 * (Ammo(ep, 0) / MaxAmmo(ep, 0)))  // reload cancel by ammo charge
                    ){
                        break;
                    }
                }
                // restore buton control
                enableButtonControl = true;
            }
        }
        // Sombra
        else if(
            HeroOf() == Hero.Sombra
        ){
            if(
                ProbabilityTrue(50) &&
                AbilityCooldown(ep, Button.Ability2) <= 0 &&
                !IsUsingAbility2()
            ){
                // throw trance locator at backword
                StartFacingPlayerRetreatPosition(aimTarget, 5);
                StopMove(ep);
                Wait(0.5, WaitBehavior.IgnoreCondition);
                PressButton(ep, Button.Ability2);
                Wait(0.1, WaitBehavior.IgnoreCondition);
                // restore facing
                StartFacingAimTarget();
            }

            // use trance locator by low health
            if(
                ProbabilityTrue(100 * (1 - NormalizedHealth())) &&
                IsUsingAbility2()
            ){
                PressButton(ep, Button.Ability2);
            }
        }
        // LifeWeever
        else if(
            HeroOf() == Hero.Lifeweaver
        ){
            // use life grip by aim target low health
            if(
                actionState == ActionState.Support &&
                AbilityCooldown(ep, Button.Ability2) <= 0 &&
                NormalizedHealth(aimTarget) <= 0.5
            ){
                // use life grip
                PressButton(ep, Button.Ability2);
            }

            if(
                ProbabilityTrue(50) &&
                AbilityCooldown(ep, Button.Ability1) <= 0
            ){
                // use lift on own below
                StopMove(ep);
                StartFacingPlayerBetweenBelowPosition(aimTarget, 0.01);
                Wait(0.5, WaitBehavior.IgnoreCondition);
                PressButton(ep, Button.Ability1);
                Wait(0.1, WaitBehavior.IgnoreCondition);
                // restore facing
                StartFacingAimTarget();
            }
        }
        // Widowmaker
        else if(
            HeroOf() == Hero.Widowmaker
        ){
            // using infra sight
            if(
                IsUsingUltimate()
            ){
                // Improve accuracy
                aimScatter = 0.0;
            }
            else{
                aimScatter = 0.1;
            }

            // fallback by graple hook
            if(
                ProbabilityTrue(75) &&
                DistanceBetween(ep, aimTarget) <= ActionRange.Close
            ){
                if(
                    AbilityCooldown(ep, Button.Ability1) <= 0 &&
                    IsBlockedBetween(
                        EyePosition(ep),
                        EyePosition(ep) + (VectorWithOutY(-FacingDirectionOf(ep)) * 16)
                    )
                ){
                    // use graple at backword
                    StopMove(ep);
                    StartFacingPlayerRetreatPosition(aimTarget, RandomReal(2, 5));
                    Wait(0.5, WaitBehavior.IgnoreCondition);
                    PressButton(ep, Button.Ability1);
                    Wait(0.1, WaitBehavior.IgnoreCondition);
                    // restore aiming
                    StartHoldingButton(ep, Button.SecondaryFire);
                    // restore facing
                    StartFacingAimTarget();
                }
                else if(ProbabilityTrue(50)){
                    // fallback by non aiming fire
                    StopHoldingButton(ep, Button.SecondaryFire);
                    StartHoldingButton(ep, Button.PrimaryFire);
                }
            }
        }
        // Lucio
        else if(
            HeroOf() == Hero.Lucio
        ){
            // use cross fade, change mode to heal from speed in support state
            if(
                actionState == ActionState.Support &&
                IsInAlternateForm() &&
                // by aimTarget health low
                ProbabilityTrue(100 * (1 - NormalizedHealth(aimTarget)))
            ){
                PressButton(ep, Button.Ability1);
            }
            // use cross fade, change mode to speed from heal in attack state
            else if(
                actionState == ActionState.Attack &&
                !IsInAlternateForm() &&
                ProbabilityTrue(100 * (NormalizedHealth(ep)))
            ){
                PressButton(ep, Button.Ability1);
            }

            // move forward for heal
            if(
                actionState == ActionState.Support &&
                // by own health high
                ProbabilityTrue(100 * (1 - NormalizedHealth(aimTarget))) 
            ){
                // move foward for melee
                moveDirFB = Forward();
                moveDirLR = NoDirection();
                StartMove(ep);
            }
        }
        // Reaper
        else if(
            HeroOf() == Hero.Reaper
        ){
            // teleport enemy behind with shadow step 
            if(
                ProbabilityTrue(75 * NormalizedHealth()) &&
                AbilityCooldown(ep, Button.Ability2) <= 0 &&
                DistanceBetween(ep, aimTarget) > ActionRange.Close
            ){
                // use shadow step
                PressButton(ep, Button.Ability2);
                Wait(0.1, WaitBehavior.IgnoreCondition);
                PressButton(ep, Button.PrimaryFire);
            }
        }
        // WreckingBall
        else if(
            HeroOf() == Hero.WreckingBall
        ){
            // use graple hook and tackle
            if(
                ProbabilityTrue(75) &&
                AbilityCooldown(ep, Button.SecondaryFire) <= 0 &&
                IsBlockedBetween(
                    EyePosition(ep),
                    EyePosition(ep) + (VectorWithOutY(FacingDirectionOf(ep)) * 20)
                )
            ){
                // stop buton control for reduce ball form cancel by fire
                enableButtonControl = false;
                // use graple at target above
                StartFacingPlayerAbovePosition(aimTarget, 5);
                Wait(0.5, WaitBehavior.IgnoreCondition);
                StartHoldingButton(ep, Button.SecondaryFire);
                Wait(0.1, WaitBehavior.IgnoreCondition);
                // restore facing
                StartFacingAimTarget();
            }
            // use pile driver
            if(
                ProbabilityTrue(75) &&
                AbilityCooldown(ep, Button.Crouch) <= 0
            ){
                if(IsOnGround()){
                    // jump for pile driver
                    ApplyImpulse(ep, Up(),
                        10, Relative.ToWorld, ContraryMotion.Cancel);
                    Wait(RandomReal(0.5, 1), WaitBehavior.IgnoreCondition);
                }
                PressButton(ep, Button.Crouch);
            }
        }
        // Torbjorn
        else if(
            HeroOf() == Hero.Torbjorn
        ){
            if(
                ProbabilityTrue(50) &&
                DistanceBetween(ep, aimTarget) <= ActionRange.Close
            ){
                // change to melee arm
                SetWeapon(ep, 2);

                while(
                    // continue melee mode condition
                    ProbabilityTrue(90) &&
                    DistanceBetween(ep, aimTarget) <= ActionRange.Close
                ){
                    // move foward for melee
                    moveDirFB = Forward();
                    moveDirLR = NoDirection();
                    StartMove(ep);
                    // melee by hammer
                    PressButton(ep, Button.PrimaryFire);
                    Wait(0.5, WaitBehavior.AbortWhenFalse);
                }
            }
            else{
                // change to gun
                SetWeapon(ep, 1);
            }
        }
        // Zenyatta
        else if(
            HeroOf() == Hero.Zenyatta
        ){
            while(
                IsUsingUltimate()
            ){
                define needHealerPlayer! = FindSupportTarget();
                if(needHealerPlayer != null){
                    // move to need heal player for heal
                    define localDir! = LocalVectorOf(DirectionTowards(ep, needHealerPlayer), ep, Transformation.Rotation);
                    moveDirFB = Vector(0, 0, ZOf(localDir));
                    moveDirLR = Vector(XOf(localDir), 0, 0);
                    StartMove(ep);
                }
                Wait(0.5, WaitBehavior.AbortWhenFalse);
            }
        }
        // Illari
        else if(
            HeroOf() == Hero.Illari
        ){
            if(
                ProbabilityTrue(75) &&
                AbilityCooldown(ep, Button.Ability1) <= 0
            ){
                PressButton(ep, Button.Ability1);
                StartHoldingButton(ep, Button.Jump);
                Wait(0.5, WaitBehavior.AbortWhenFalse);
                StopHoldingButton(ep, Button.Jump);
            }
        }
        // Bastion
        else if(
            HeroOf() == Hero.Bastion
        ){
            if(
                ProbabilityTrue(75) &&
                AbilityCooldown(ep, Button.Ability1) <= 0 &&
                !IsUsingAbility1() &&
                !IsUsingUltimate()
            ){
                PressButton(ep, Button.Ability1);
            }
        }
        // Ramattra
        else if(
            HeroOf() == Hero.Ramattra
        ){
            if(
                ProbabilityTrue(75) &&
                AbilityCooldown(ep, Button.Ability1) <= 0 &&
                !IsUsingAbility1() &&
                !IsUsingUltimate()
            ){
                PressButton(ep, Button.Ability1);
            }
        }
    }
}

define DuplicatingHeroOf() "DuplicatingHeroOf"{
    define hero = null;
    if(
        HeroOf() == Hero.Echo &&
        IsDuplicating()
    ){
        hero = HeroBeingDuplicated(ep);
    }
    return hero;
}

rule: "Bot/HeroUniqueAction/positionMoveUltmate"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    IsUsingUltimate()
){
    AbortIf(!isBotActive);
    
    define isPositionMoveUltmate!;
    define waitForStartMove!;
    define moveSpeed!;
    define attackCount!;
    define multiPosAttack!;

    // postion move hero
    if(
        HeroOf() == Hero.Doomfist ||
        DuplicatingHeroOf() == Hero.Doomfist
    ){
        isPositionMoveUltmate = true;
        waitForStartMove = 0.5;
        moveSpeed = 0.06;
        attackCount = 1;
        multiPosAttack = false;
    }
    else if(
        HeroOf() == Hero.Bastion ||
        DuplicatingHeroOf() == Hero.Bastion
    ){
        isPositionMoveUltmate = true;
        waitForStartMove = 1.5;
        moveSpeed = 0.04;
        attackCount = 3;
        multiPosAttack = ProbabilityTrue(0);
    }
    else if(
        HeroOf() == Hero.Junkrat ||
        DuplicatingHeroOf() == Hero.Junkrat
    ){
        isPositionMoveUltmate = true;
        waitForStartMove = 1.5;
        moveSpeed = 0.075;
        attackCount = 1;
        multiPosAttack = false;
    }

    if(isPositionMoveUltmate){
        // stop buton control for reduce cancel
        enableButtonControl = false;
        // stop current moving input
        StopMove(ep);
        // wait for start mode
        Wait(waitForStartMove, WaitBehavior.IgnoreCondition);
        // start move postion selecter to foward
        moveDirFB = Forward();
        moveDirLR = NoDirection();
        StartMove(ep);
        // decrease move speed if multi position attack mode
        if(multiPosAttack) moveSpeed -= 0.01;
        // wait for arrival target
        define dist! = DistanceBetween(ep, aimTarget);
        dist = dist <= 5 ? 5 : dist;
        Wait(dist * (moveSpeed), WaitBehavior.IgnoreCondition);
        // stop move if not multi position attack mode
        if(!multiPosAttack){
            StopMove(ep);
        }
        // trigger attack by attackCount
        for(define tryCount! = 0; tryCount < attackCount; tryCount++){
            PressButton(ep, Button.PrimaryFire);
            if(tryCount < attackCount){
                // button press with random interval
                Wait(RandomReal(0.25, 0.5), WaitBehavior.IgnoreCondition);
            }
        }
        // reduce walking after ult
        StopMove(ep);
        // restore buton control
        enableButtonControl = true;
    }
}

rule: "Bot/HeroUniqueAction/positionAimUltmate"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    UltimateChargePercent() >= DefaultPercentage() &&
    IsButtonHeld(ep, Button.Ultimate)
){
    AbortIf(!isBotActive);

    define isPositionAimUltmate!;
    define isRotateProb!;
    
    // postion aim hero
    if(
        HeroOf() == Hero.Baptiste ||
        DuplicatingHeroOf() == Hero.Baptiste
    ){
        isPositionAimUltmate = true;
        isRotateProb = 10;
    }
    else if(
        HeroOf() == Hero.Symmetra ||
        DuplicatingHeroOf() == Hero.Symmetra
    ){
        isPositionAimUltmate = true;
        isRotateProb = 50;
    }

    if(isPositionAimUltmate){
        // stop buton control for reduce cancel
        enableButtonControl = false;
        // place ult on ground
        StartFacingPlayerBetweenBelowPosition(aimTarget, 0.5);
        Wait(0.5, WaitBehavior.IgnoreCondition);
        if(ProbabilityTrue(isRotateProb)){
            PressButton(ep, Button.Ultimate);
            Wait(0.1, WaitBehavior.IgnoreCondition);
        }
        PressButton(ep, Button.PrimaryFire);
        Wait(0.1, WaitBehavior.IgnoreCondition);
        // restore facing
        StartFacingAimTarget();
        // restore buton control
        enableButtonControl = true;
    }
}

rule: "Bot/HeroUniqueAction/positionAimSecondary"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    AbilityCooldown(ep, Button.SecondaryFire) <= 0 &&
    IsButtonHeld(ep, Button.SecondaryFire)
){
    AbortIf(!isBotActive);

    define isPositionAimSecondary!;

    if(
        HeroOf() == Hero.Ramattra ||
        DuplicatingHeroOf() == Hero.Ramattra
    ){
        if(
            // is omnic form
            !IsNemesisForm(ep)
        ){
            isPositionAimSecondary = true;
        }        
    }

    if(isPositionAimSecondary){
        // stop buton control for reduce cancel
        enableButtonControl = false;
        StopHoldingButton(ep, Button.PrimaryFire);
        // place ability on ground
        StartFacingPlayerBetweenBelowPosition(aimTarget, 0.25);
        Wait(0.5, WaitBehavior.IgnoreCondition);
        PressButton(ep, Button.SecondaryFire);
        Wait(0.1, WaitBehavior.IgnoreCondition);
        // restore facing
        StartFacingAimTarget();
        // restore buton control
        enableButtonControl = true;
    }
}

rule: "Bot/HeroUniqueAction/positionFixSecondary"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    IsFiringSecondary()
){
    AbortIf(!isBotActive);

    define isPositionFixSecondary!;

    if(
        HeroOf() == Hero.WreckingBall ||
        DuplicatingHeroOf() == Hero.WreckingBall
    ){
        if(IsFiringSecondary()){
            isPositionFixSecondary = true;       
        }
    }

    if(isPositionFixSecondary){
        // stop buton control for reduce ball form cancel by fire
        enableButtonControl = false;

        // using graple hook
        while(
            IsFiringSecondary()
        ){
            // accsell for ball tackle
            ApplyImpulse(ep, 
                BallTackleDirection(),
                20, Relative.ToWorld, ContraryMotion.Incorporate);
            
            Wait(0.5, WaitBehavior.IgnoreCondition);
        }

        // try use graple at target above
        for(define tryCount! = 0; tryCount <= 4; tryCount++){
            if(!IsInAlternateForm()){
                break;
            }

            // accsell for ball tackle by inertia movement
            ApplyImpulse(ep, 
                BallTackleDirection(),
                20, Relative.ToWorld, ContraryMotion.Incorporate);

            Wait(0.5, WaitBehavior.IgnoreCondition);
        }

        // restore buton control
        enableButtonControl = true;
    }
}

define BallTackleDirection()"BallTackleDirection"{
    define dir;
    if(
        SpeedOf() >= 10
    ){
        // nearest enemy of grapple crow pos
        dir = DirectionTowards(ep, ClosestPlayerTo(ep, EnemyTeamOf(ep)));
    }
    else{
        dir = -DirectionTowards(ep, ClosestPlayerTo(ep, EnemyTeamOf(ep)));
    }
    return dir;
}

// TAG Bot/ButtonControl ----------
define noShooting: false;   // for debug
define noMoving: false;   // for debug

enum ButtonControl{
    button,
    buttonBehaivor,
    releaseMin,
    releaseMax,
    pressMin,
    pressMax
}

playervar define isRepeatFiring;
playervar define repeatDuring;

Boolean isMatchButton(in define matchButton, in define butttons){
    return IsTrueForAny(butttons, ae == matchButton);
}

define buttonControlPressScale: 1.0;
define buttonControlReleaseScale: 1.0;

define EnemyDensityRateOfAimTarget(in define dist):
    CountOf(PlayersWithinRadius(aimTarget, dist, EnemyTeamOf(ep), RadiusLOS.Off)) /
    NumberOfPlayers(EnemyTeamOf(ep));

// can's implment as function, cuz need control instance each button
void StartButtonControl(in define bc){
    if(noShooting) return;
    if(enemyType == EnemyType.Zombie) return;

    define startButton = false;

    // state dependent buttons
    define stateDependemtButtons = [
        Button.PrimaryFire,
        Button.SecondaryFire,
        Button.Ability1,
        Button.Ability2
    ];
    
    // if state dependent buttons
    if(
        isMatchButton(bc[ButtonControl.button], stateDependemtButtons)
    ){
        // if match attack state buttons
        if(
            actionState == ActionState.Attack &&
            isMatchButton(bc[ButtonControl.button], attackButtons)
        ){
            startButton = true;
        }
        // if match support state buttons
        else if(
            actionState == ActionState.Support &&
            isMatchButton(bc[ButtonControl.button], supportButtons)
        ){
            startButton = true;
        }
    }
    else{
        startButton = true;
    }

    // is not state dependent buttons
    if(!startButton){
        // stop button
        StopHoldingButton(ep, bc[ButtonControl.button]);
    }
    else{
        // not conbination fire
        if(!canFireButtonCombination){
            // if start primary button, release secondary button
            if(
                bc[ButtonControl.button] == Button.PrimaryFire &&
                IsButtonHeld(ep, Button.SecondaryFire)
            ){
                StopHoldingButton(ep, Button.SecondaryFire);
            }
            // if start secondary button, release primary button
            else if(
                bc[ButtonControl.button] == Button.SecondaryFire &&
                IsButtonHeld(ep, Button.PrimaryFire)
            ){
                StopHoldingButton(ep, Button.PrimaryFire);
            }
        }

        // add button bit for debug 
        AddButtonBit(bc[ButtonControl.button]);

        // start button
        // release-press action
        if(bc[ButtonControl.buttonBehaivor] == ButtonBehaivor.ReleasePress){
            while(true){
                // button released during
                Wait(
                    RandomReal(
                        bc[ButtonControl.releaseMin],
                        bc[ButtonControl.releaseMax]
                    ) * buttonControlReleaseScale,
                    WaitBehavior.AbortWhenFalse
                );

                if(
                    bc[ButtonControl.button] == Button.Ultimate &&
                    !ProbabilityTrue(50 * EnemyDensityRateOfAimTarget(ActionRange.Close))
                ){
                    // skip use ultimate whem alive enemies count is low
                    continue;
                }

                StartHoldingButton(ep, bc[ButtonControl.button]);

                if(
                    bc[ButtonControl.button] == Button.Jump &&
                    hasDoubleJumpButtonAbility &&
                    ProbabilityTrue(50)
                ){
                    // use double jump ability
                    Wait(RandomReal(0.1, 0.5), WaitBehavior.AbortWhenFalse);
                    StopHoldingButton(ep, bc[ButtonControl.button]);
                    Wait(RandomReal(0.1, 0.5), WaitBehavior.AbortWhenFalse);
                    StartHoldingButton(ep, bc[ButtonControl.button]);
                }

                // button hold during
                Wait(
                    RandomReal(
                        bc[ButtonControl.pressMin],
                        bc[ButtonControl.pressMax]
                    ) * buttonControlPressScale,
                    WaitBehavior.AbortWhenFalse
                );

                StopHoldingButton(ep, bc[ButtonControl.button]);
            }
        }
        // release-repeat action
        else if(bc[ButtonControl.buttonBehaivor] == ButtonBehaivor.ReleaseRepeat){
            while(true){
                // button released during
                Wait(
                    RandomReal(
                        bc[ButtonControl.releaseMin],
                        bc[ButtonControl.releaseMax]
                    ) * buttonControlReleaseScale,
                    WaitBehavior.AbortWhenFalse
                );

                // set button repeat during
                repeatDuring = 
                    RandomReal(
                        bc[ButtonControl.pressMin],
                        bc[ButtonControl.pressMax]
                    ) * buttonControlPressScale;

                isRepeatFiring = true;
                
                while(
                    isRepeatFiring            
                ){
                    PressButton(ep, bc[ButtonControl.button]);
                    Wait(0.25, WaitBehavior.AbortWhenFalse);
                }
            }
        }
        // else
    }
}

rule: "Bot/ButtonControl/releaseIsRepeatFiring"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    isRepeatFiring
){
    // button repeat during
    Wait(repeatDuring, WaitBehavior.AbortWhenFalse);
    isRepeatFiring = false;
}

// rule: "Bot/ButtonControl/compensateFire"
// Event.OngoingPlayer
// if(
//     isBotEnableTeam &&
//     IsDummyBot() &&
//     actionState != ActionState.Non
// ){
//     if(
//         // has aimTarget
//         aimTarget != null &&
//         // is idling fire
//         !IsFiringPrimary() &&
//         !IsFiringSecondary() &&
//         !IsUsingAbility1() &&
//         !IsUsingAbility2() &&
//         !IsUsingUltimate()
//     ){
//         if(actionState == ActionState.Attack){
//             StopHoldingButton(ep, FirstOf(supportButtons));
//             StartHoldingButton(ep, FirstOf(attackButtons));
//         }
//         else if(actionState == ActionState.Support){
//             StopHoldingButton(ep, FirstOf(attackButtons));
//             StartHoldingButton(ep, FirstOf(supportButtons));
//         }
//     }
//     Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
// }

// TAG Bot/ButtonControl/PrimaryFire ----------
playervar define enableButtonControl;

rule: "Bot/ButtonControl/PrimaryFire/StartButtonControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    enableButtonControl
){
    AbortIf(!isBotActive);

    StartButtonControl(
        [
            Button.PrimaryFire,
            primaryFireButtonBehaivor,
            primaryFireButtonReleaseMin,
            primaryFireButtonReleaseMax,
            primaryFireButtonPressMin,
            primaryFireButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/SecondaryFire ----------
rule: "Bot/ButtonControl/SecondaryFire/StartButtonControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    enableButtonControl
){
    AbortIf(!isBotActive);

    StartButtonControl(
        [
            Button.SecondaryFire,
            secondaryFireButtonBehaivor,
            secondaryFireButtonReleaseMin,
            secondaryFireButtonReleaseMax,
            secondaryFireButtonPressMin,
            secondaryFireButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Ability1 ----------
rule: "Bot/ButtonControl/Ability1/StartButtonControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    enableButtonControl
){
    AbortIf(!isBotActive);

    StartButtonControl(
        [
            Button.Ability1,
            ButtonBehaivor.ReleasePress,
            ability1ButtonReleaseMin,
            ability1ButtonReleaseMax,
            ability1ButtonPressMin,
            ability1ButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Ability2 ----------
rule: "Bot/ButtonControl/Ability2/StartButtonControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    enableButtonControl
){
    AbortIf(!isBotActive);

    StartButtonControl(
        [
            Button.Ability2,
            ButtonBehaivor.ReleasePress,
            ability2ButtonReleaseMin,
            ability2ButtonReleaseMax,
            ability2ButtonPressMin,
            ability2ButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Ultimate ----------
rule: "Bot/ButtonControl/Ultimate/StartButtonControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    enableButtonControl &&
    UltimateChargePercent() >= DefaultPercentage()
){
    AbortIf(!isBotActive);
    
    StartButtonControl(
        [
            Button.Ultimate,
            ButtonBehaivor.ReleasePress,
            ultimateButtonReleaseMin,
            ultimateButtonReleaseMax,
            ultimateButtonPressMin,
            ultimateButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Crouch ----------
rule: "Bot/ButtonControl/Crouch/StartButtonControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    enableButtonControl
){
    AbortIf(!isBotActive);

    StartButtonControl(
        [
            Button.Crouch,
            ButtonBehaivor.ReleasePress,
            crouchButtonReleaseMin,
            crouchButtonReleaseMax,
            crouchButtonPressMin,
            crouchButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Jump ----------
rule: "Bot/ButtonControl/Jump/StartButtonControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    enableButtonControl
){
    AbortIf(!isBotActive);

    StartButtonControl(
        [
            Button.Jump,
            ButtonBehaivor.ReleasePress,
            jumpButtonReleaseMin,
            jumpButtonReleaseMax,
            jumpButtonPressMin,
            jumpButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/StopButtonControl ----------
rule: "Bot/ButtonControl/StopButtonControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    !enableButtonControl
){
    StopHoldingButton(ep, Button.PrimaryFire);
    StopHoldingButton(ep, Button.SecondaryFire);
    StopHoldingButton(ep, Button.Ability1);
    StopHoldingButton(ep, Button.Ability2);
    StopHoldingButton(ep, Button.Ultimate);
    StopHoldingButton(ep, Button.Jump);
    StopHoldingButton(ep, Button.Crouch);
    ClearButtonBit();
}

// TAG Debug ----------

// rule: "Bot/Debug/ShowDebugInfo"
// Event.OngoingPlayer
// if(
//     isBotEnableTeam &&
//     IsDummyBot() &&
//     TeamOf() == enemyTeam &&
//     SlotOf() <= 3
// ){
//     // enable button text
//     CreateInWorldText(
//         AllPlayers(),
//         <"Active = <0>\n\rState = <1>\n\rButton_Control = <2>\n\rButton_Bit = <3>",
//         isBotActive,
//         actionState == ActionState.Non ? "Non" :
//             actionState == ActionState.Attack ? "Attack" :
//             actionState == ActionState.Support ? "Support" :
//             "Err",
//         enableButtonControl,
//         enableButtonBit>,
//         EyePosition(ep) + Vector(0, 1.25, 0),
//         0.8, Clipping.DoNotClip, InworldTextRev.VisibleToPositionStringAndColor,
//         isBotActive ? Color.Yellow : Color.White,
//         Spectators.DefaultVisibility);

//     // while(true){
//     //     // tagret line
//     //     if(
//     //         actionState != ActionState.Non &&
//     //         aimTarget != null
//     //     ){
//     //         dbgPlyBemEft(EyePosition(ep), BodyPosition(aimTarget));
//     //     }
//     //     Wait(1);
//     // }
// }

playervar define enableButtonBit = allButtonBitsNon;   // fomrat is [9PS12U]
define allButtonBitsNon:    900000;
define PrimaryButtonBit:    010000;
define SecondaryButtonBit:  001000;
define Ability1ButtonBit:   000100;
define Ability2ButtonBit:   000010;
define UltimateButtonBit:   000001;

void AddButtonBit(define button) playervar "AddButtonBit"{
    // // add debug text
    // if(button == Button.PrimaryFire){
    //     enableButtonBit += PrimaryButtonBit;
    // }
    // else if(button == Button.SecondaryFire){
    //     enableButtonBit += SecondaryButtonBit;
    // }
    // else if(button == Button.Ability1){
    //     enableButtonBit += Ability1ButtonBit;
    // }
    // else if(button == Button.Ability2){
    //     enableButtonBit += Ability2ButtonBit;
    // }
    // else if(button == Button.Ultimate){
    //     enableButtonBit += UltimateButtonBit;
    // }
}

void ClearButtonBit()"ClearButtonBit"{
    // enableButtonBit = allButtonBitsNon;
}