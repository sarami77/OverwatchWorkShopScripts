import "Utility.del";
import "Debug.del";
import "ServerOverLoadMeasures.del";

// split actionDistance by Attack Support

globalvar define botEnableTeams = [Team.Team1, Team.Team2];

define isBotEnableTeam: true;

// TAG Bot/Spawn ----------
enum BotAsset{
    EnemyType,
    Hero,
    Count
}

// TAG Bot/EnemyType ----------
playervar define enemyType;
enum EnemyType{
    Non,
    Minion,
    Elite,
    SubBoss,
    Boss
}

// TAG Bot/Asset ----------
define createBotInterval : 0.1;
define createBotMaxTryCount: 1;

void CreateBotsByAsset(define asset!, define team!, define addLimitNum!)"CreateBotsByAsset"{
    define addNum! = 0;
    // run asset items
    for(define assetIdx! = 0; assetIdx < CountOf(asset); assetIdx++){
        // run bot count in asset
        for(define botCount! = 0; botCount < asset[assetIdx][BotAsset.Count]; botCount ++){
            if(addNum >= addLimitNum){
                break;
            }

            if(IsAssemblingHeroes()){
                Wait(RandomReal(0.1, 3), WaitBehavior.IgnoreCondition);
            }

            // get empty slot
            define slot! = GetEmptySlotNo(team);
            for(
                define tryCount! = 0;
                tryCount < createBotMaxTryCount && PlayersInSlot(slot, team) == null;
                tryCount ++
            ){
                // create bot
                CreateDummyBot(
                    asset[assetIdx][BotAsset.Hero],
                    team,
                    slot,
                    SpawnPoints(team)[0],
                    RandomDirection()
                );
                Wait(createBotInterval, WaitBehavior.IgnoreCondition);
                WaitReleaseServerLoad(ServerLoadType.BotCreate);
            }
            // set Bot type as enemy type
            define bot! = PlayersInSlot(slot, team);
            bot.enemyType = asset[assetIdx][BotAsset.EnemyType];
            // count up addNum
            addNum ++;
        }
    }
}

void CreateBotsByHeroList(define heroList!, define team!)"CreateBotsByHeroList"{
    // create bot by asset
    for(define listIdx! = 0; listIdx < CountOf(heroList); listIdx++){
        // get empty slot
        define slot! = GetEmptySlotNo(team);
        for(
            define tryCount! = 0;
            tryCount < createBotMaxTryCount && PlayersInSlot(slot, team) == null;
            tryCount ++
        ){
            // create bot
            CreateDummyBot(
                heroList[listIdx],
                team,
                slot,
                SpawnPoints(team)[0],
                RandomDirection()
            );
            Wait(createBotInterval, WaitBehavior.IgnoreCondition);
            WaitReleaseServerLoad(ServerLoadType.BotCreate);
        }
    }
}

void CreateBotsByHeroInput(define hero!, define num!, define team!)"CreateBotsByHeroInput"{
    // create bot by asset
    for(define listIdx! = 0; listIdx < num; listIdx++){
        // get empty slot
        define slot! = GetEmptySlotNo(team);
        for(
            define tryCount! = 0;
            tryCount < createBotMaxTryCount && PlayersInSlot(slot, team) == null;
            tryCount ++
        ){
            // create bot
            CreateDummyBot(
                hero,
                team,
                slot,
                SpawnPoints(team)[0],
                RandomDirection()
            );
            Wait(createBotInterval, WaitBehavior.IgnoreCondition);
            WaitReleaseServerLoad(ServerLoadType.BotCreate);
        }
    }
}

void DestroyBots(define team!)"DestroyBots"{
    for(define slotIdx! = 0; slotIdx < builtinMaxSlotNum; slotIdx ++){
        DestroyDummyBot(team, slotIdx);
        Wait(0.01, WaitBehavior.IgnoreCondition);
    }
}

// TAG Bot/ButtonControlPropety ----------
playervar define actionRangeMin;
playervar define actionRangeMax;

playervar define aimScatter;
playervar define supportPrioloty;
playervar define supportButtons;
playervar define attackButtons;
playervar define hasDoubleJumpButtonAbility;

playervar define primaryFireButtonBehaivor;
playervar define primaryFireButtonReleaseMin;
playervar define primaryFireButtonReleaseMax;
playervar define primaryFireButtonPressMin;
playervar define primaryFireButtonPressMax;

playervar define secondaryFireButtonBehaivor;
playervar define secondaryFireButtonReleaseMin;
playervar define secondaryFireButtonReleaseMax;
playervar define secondaryFireButtonPressMin;
playervar define secondaryFireButtonPressMax;

playervar define ability1ButtonReleaseMin;
playervar define ability1ButtonReleaseMax;
playervar define ability1ButtonPressMin;
playervar define ability1ButtonPressMax;

playervar define ability2ButtonReleaseMin;
playervar define ability2ButtonReleaseMax;
playervar define ability2ButtonPressMin;
playervar define ability2ButtonPressMax;

playervar define ultimateButtonReleaseMin;
playervar define ultimateButtonReleaseMax;
playervar define ultimateButtonPressMin;
playervar define ultimateButtonPressMax;

playervar define crouchButtonReleaseMin;
playervar define crouchButtonReleaseMax;
playervar define crouchButtonPressMin;
playervar define crouchButtonPressMax;

playervar define jumpButtonReleaseMin;
playervar define jumpButtonReleaseMax;
playervar define jumpButtonPressMin;
playervar define jumpButtonPressMax;

define disabledControl: MaxValue();

void SetHeroButtonControlPropety()"SetHeroButtonControlPropety"{
    // wait hero change
    Wait(0.1, WaitBehavior.IgnoreCondition);
    
    if(!IsDummyBot()){
        return;
    }

    // basic routine
    aimScatter = 0.5;
    actionRangeMin = ActionRange.Melee;
    actionRangeMax = ActionRange.Melee;

    hasDoubleJumpButtonAbility = false;
    supportPrioloty = 0.0;
    supportButtons = [
        Button.PrimaryFire,
        Button.SecondaryFire,
        Button.Ability1,
        Button.Ability2
    ];
    attackButtons = [
        Button.PrimaryFire,
        Button.SecondaryFire,
        Button.Ability1,
        Button.Ability2
    ];

    primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
    primaryFireButtonReleaseMin = 0;
    primaryFireButtonReleaseMax = 1;
    primaryFireButtonPressMin = 0;
    primaryFireButtonPressMax = 10;

    secondaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
    secondaryFireButtonReleaseMin = 0;
    secondaryFireButtonReleaseMax = 1;
    secondaryFireButtonPressMin = 0;
    secondaryFireButtonPressMax = 10;

    ability1ButtonReleaseMin = 0;
    ability1ButtonReleaseMax = 5;
    ability1ButtonPressMin = 0;
    ability1ButtonPressMax = 1;

    ability2ButtonReleaseMin = 0;
    ability2ButtonReleaseMax = 5;
    ability2ButtonPressMin = 0;
    ability2ButtonPressMax = 1;

    ultimateButtonReleaseMin = 0;
    ultimateButtonReleaseMax = 5;
    ultimateButtonPressMin = 0;
    ultimateButtonPressMax = 1;

    crouchButtonReleaseMin = 0;
    crouchButtonReleaseMax = 10;
    crouchButtonPressMin = 0;
    crouchButtonPressMax = 1;

    jumpButtonReleaseMin = 0;
    jumpButtonReleaseMax = 5;
    jumpButtonPressMin = 0;
    jumpButtonPressMax = 1;

    define hero! = DuplicatingHeroOf();
    if(
        hero == null
    ){
        hero = HeroOf();
    }
    
    switch(hero){
        case Hero.Ana:
        aimScatter = 0.3;   // to precision shooting
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        supportPrioloty = 1.0;
        secondaryFireButtonPressMin = 30;       // to more use scorp
        secondaryFireButtonPressMax = 40;       // to more use scorp
        jumpButtonReleaseMax = 40;              // to suppress cancel scorp
        ultimateButtonReleaseMax = disabledControl;          // to suppress over use nano boost (Prefer PolingHeroUniqueAction)
        supportButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability2
        ];
        break;

        case Hero.Ashe:
        aimScatter = 0.3;
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        primaryFireButtonBehaivor = ButtonBehaivor.ReleaseRepeat;
        secondaryFireButtonPressMin = 30;       // to more use scorp
        secondaryFireButtonPressMax = 40;       // to more use scorp
        jumpButtonReleaseMax = 40;              // to suppress cancel scorp
        ability1ButtonReleaseMax = disabledControl;          // to suppress over use corch gun (Prefer PolingHeroUniqueAction)
        break;

        case Hero.Baptiste:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        supportPrioloty = 1.0;
        ability1ButtonReleaseMax = disabledControl;          // to suppress over use inmortal field (Prefer PolingHeroUniqueAction)
        jumpButtonReleaseMax = 5;               // to more use exo boots
        crouchButtonReleaseMax = 1;             // to more use exo boots
        crouchButtonPressMax = 20;              // to more use exo boots
        supportButtons = [
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.PrimaryFire,
            Button.Ability1
        ];
        break;

        case Hero.Bastion:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        primaryFireButtonReleaseMax = 1;        // to more use primary fire when assault mode
        primaryFireButtonPressMax = 20;        // to more use primary fire when assault mode
        ability1ButtonReleaseMax = disabledControl;          // to suppress cancel assault mode (Prefer PolingHeroUniqueAction)
        ultimateButtonReleaseMax = 30;          // to suppress over use artillery
        break;

        case Hero.Brigitte:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        supportPrioloty = 0.5;
        primaryFireButtonPressMax = 20;
        secondaryFireButtonReleaseMax = 5;      // to suppress over use shield
        ability2ButtonReleaseMax = 1;           // to more use repair pack
        supportButtons = [
            Button.SecondaryFire,
            Button.Ability2
        ];
        break;

        case Hero.Cassidy:
        aimScatter = 0.3;
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Middle;
        secondaryFireButtonReleaseMax = 40;     // to suppress overuse fanning shot
        break;

        case Hero.Doomfist:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        ability2ButtonReleaseMin = 3;
        secondaryFireButtonPressMin = 1.3;      // to charge enough rocket punch
        secondaryFireButtonPressMax = 1.5;      // to suppress charge over rocket punch
        jumpButtonReleaseMax = 10;              // to to suppress cancel rocket punch
        break;

        case Hero.Dva:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        ultimateButtonReleaseMax = 40;          // to suppress over use self-destruct / call mech
        break;

        case Hero.Echo:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        jumpButtonReleaseMax = 5;               // to more use float
        jumpButtonPressMax = 5;                 // to more use float
        break;

        case Hero.Genji:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        hasDoubleJumpButtonAbility = true;
        jumpButtonReleaseMax = 2.5;             // to more use double jump
        jumpButtonPressMax = 3;                 // to more use wall crime
        ability1ButtonReleaseMax = 1;           // to more use swift strike when reset cooldown by kill
        ability1ButtonPressMax = 1;             // to more use swift strike when reset cooldown by kill
        break;

        case Hero.Hanzo:
        aimScatter = 0.3;
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        hasDoubleJumpButtonAbility = true;
        primaryFireButtonReleaseMin = 0;
        primaryFireButtonReleaseMax = 1.0;
        primaryFireButtonPressMin = 0.75;       // to charge enough storm bow
        primaryFireButtonPressMax = 0.75;       // to suppress charge over storm bow
        jumpButtonPressMax = 3;                 // to more use wall crime
        secondaryFireButtonBehaivor = ButtonBehaivor.Non;
        break;

        case Hero.JunkerQueen:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        break;

        case Hero.Junkrat:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        break;

        case Hero.Kiriko:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        supportPrioloty = 1.0;
        jumpButtonPressMax = 3;                 // to more use wall crime
        ability1ButtonPressMax = 1;             // to more use swift step
        ability1ButtonReleaseMax = 1;           // to more use swift step        
        supportButtons = [
            Button.PrimaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.SecondaryFire
        ];
        break;

        case Hero.Lucio:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        jumpButtonPressMax = 10;
        ability1ButtonReleaseMax = disabledControl;          // to suppress over use cross fade (Prefer PolingHeroUniqueAction)
        supportPrioloty = 0.75;
        supportButtons = [
            Button.Ability1,
            Button.Ability2
        ];
        break;

        case Hero.Lifeweaver:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        hasDoubleJumpButtonAbility = true;
        supportPrioloty = 1.0;
        jumpButtonReleaseMax = 5;               // to more use life step
        ability2ButtonReleaseMax = disabledControl;          // to suppress over use life grip (Prefer PolingHeroUniqueAction)
        supportButtons = [
            Button.PrimaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.SecondaryFire,
            Button.Ability1
        ];
        primaryFireButtonPressMin = 0.8;        // to charge enough healing blossom
        primaryFireButtonPressMax = 1.4;        // to suppress charge over healing blossom
        break;

        case Hero.Mei:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        break;

        case Hero.Mercy:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        supportPrioloty = 1.0;
        secondaryFireButtonReleaseMax = 10;     // to suppress over use damage boost
        ability2ButtonPressMax = 10;            // to more use resuscitation
        ability2ButtonReleaseMax = 0.1;         // to more use resuscitation
        supportButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        break;

        case Hero.Moira:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        supportPrioloty = 0.75;
        supportButtons = [
            Button.PrimaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        break;

        case Hero.Orisa:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Middle;
        break;

        case Hero.Pharah:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        jumpButtonReleaseMax = 5;               // to more use hover jet
        jumpButtonPressMax = 5;                 // to more use hover jet
        break;

        case Hero.Ramattra:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        secondaryFireButtonReleaseMax = 10;     // to suppress over use guard (on nemesis form)
        secondaryFireButtonPressMin = 2;        // to more keep guard (on nemesis form)
        secondaryFireButtonPressMax = 4;        // to more keep guard (on nemesis form)
        ability1ButtonReleaseMax = disabledControl;          // to suppress cancel nemesis form (Prefer PolingHeroUniqueAction)
        break;

        case Hero.Reaper:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        ability2ButtonReleaseMax = disabledControl;         // to suppress over use shadow step (Prefer PolingHeroUniqueAction)
        break;

        case Hero.Reinhardt:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        primaryFireButtonPressMax = 20;
        secondaryFireButtonReleaseMax = 5;     // to suppress over use barrier
        break;

        case Hero.Roadhog:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Middle;
        break;

        case Hero.Sigma:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        primaryFireButtonReleaseMax = 0;        // to more confirm gravity flax
        secondaryFireButtonReleaseMax = 3;      // to deploy barrier to far distance
        secondaryFireButtonPressMin = 0.1;        // to deploy barrier to close distance
        secondaryFireButtonPressMax = 1.0;        // to deploy barrier to close distance
        break;

        case Hero.Sojourn:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        secondaryFireButtonReleaseMax = 6;      // to suppress over use railgun (charge enough)
        secondaryFireButtonPressMax = 1;        // to suppress over use railgun (charge enough)
        break;
        
        case Hero.Soldier76:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        break;

        case Hero.Sombra:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        secondaryFireButtonPressMin = 1.5;      // to charge enough hack
        ability2ButtonReleaseMax = 15;          // to suppress over use trans locator
        break;

        case Hero.Symmetra:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        secondaryFireButtonPressMin = 1;        // to charge enough photon bomb
        secondaryFireButtonPressMax = 3;        // to suppress charge over photon bomb
        ability1ButtonReleaseMin = 1;           // to more use turret
        ability1ButtonReleaseMax = 3;           // to more use turret
        ability2ButtonReleaseMax = 15;          // to suppress over use teleporter
        break;

        case Hero.Torbjorn:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        break;

        case Hero.Tracer:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        break;

        case Hero.Widowmaker:
        aimScatter = 0.1;
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        primaryFireButtonReleaseMin = 1.4;      // to charge enough sniper rifle 1.4s
        primaryFireButtonReleaseMax = 1.4;      // to suppress charge over sniper rifle
        primaryFireButtonPressMin = 0;          // to more use sniper rifle
        primaryFireButtonPressMax = 1.0;        // to more use sniper rifle
        secondaryFireButtonPressMin = 30;       // to more use scorp
        secondaryFireButtonPressMax = 40;       // to more use scorp
        jumpButtonReleaseMax = 40;              // to suppress cancel scorp
        ability1ButtonReleaseMax = disabledControl;          // to suppress over use grappling hook (Prefer PolingHeroUniqueAction)
        ability2ButtonReleaseMax = 30;          // to suppress over use venom mine
        break;

        case Hero.Winston:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        primaryFireButtonPressMax = 20;
        secondaryFireButtonReleaseMax = 20;
        ultimateButtonReleaseMax = 30;          // to suppress over use primal rage
        break;

        case Hero.WreckingBall:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        primaryFireButtonPressMax = 15;         // to more use quad machine gun
        primaryFireButtonReleaseMax = 10;       // to suppress over use quad machine gun
        secondaryFireButtonReleaseMax = disabledControl;     // to suppress over use grappling crow (Prefer PolingHeroUniqueAction)
        ability1ButtonReleaseMax = 30;          // to suppress cancel ball form
        crouchButtonPressMax = 4;               // to more use pile driver
        break;

        case Hero.Zarya:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        attackButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1
        ];
        ability1ButtonReleaseMax = 15;
        ability2ButtonReleaseMax = disabledControl;          // to suppress over use inmortal field (Prefer PolingHeroUniqueAction)
        break;

        case Hero.Zenyatta:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        supportPrioloty = 0.5;
        supportButtons = [
            Button.Ability1,
            Button.Ability2
        ];
        primaryFireButtonReleaseMin = 1;
        secondaryFireButtonReleaseMin = 1;
        ability1ButtonPressMin = 0.5;           // to more use orb of discord
        ability1ButtonPressMax = 0.5;           // to more use orb of discord
        ability1ButtonReleaseMin = 0.5;         // to more use orb of discord
        ability1ButtonReleaseMax = 0.5;         // to more use orb of discord
        ability2ButtonPressMin = 0.5;           // to more use orb of harmony
        ability2ButtonPressMax = 0.5;           // to more use orb of harmony
        ability2ButtonReleaseMin = 0.5;         // to more use orb of harmony
        ability2ButtonReleaseMax = 0.5;         // to more use orb of harmony
        ultimateButtonReleaseMax = 30;          // to suppress over use transcendence
        break;

        case Hero.Illari:
        aimScatter = 0.3;
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        supportPrioloty = 1.0;
        supportButtons = [
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.PrimaryFire,
            Button.Ability1
        ];
        primaryFireButtonReleaseMin = 0.2;      // to charge enough sorar rifle
        primaryFireButtonReleaseMax = 0.5;      // to suppress charge over sorar rifle
        primaryFireButtonPressMin = 0;          // to more use sorar rifle
        primaryFireButtonPressMax = 1.0;          // to more use sorar rifle
        break;

        case Hero.Mauga:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Middle;
        break;

        default:
        break;
    }

    // if already button control enabled
    if(enableButtonControl){
        // restart button control by param changed
        enableButtonControl = false;
        Wait(0.1, WaitBehavior.IgnoreCondition);
        enableButtonControl = true;
    }
}

enum ActionState{
    Non,
    Attack,
    Support
}

enum ButtonBehaivor{
    Non,
    ReleasePress,
    ReleaseRepeat
}

// TAG Bot/Moving ----------
playervar define moveDirFB;
playervar define moveDirLR;
playervar define moveTarget;
playervar define enableRetreat! = true;

void SetMoveDir() playervar "SetMoveDir"{
    define distToTarget! = DistanceBetween(ep, aimTarget);
    define objPos! = CurrentObjectOnPosition();

    // move to healer for heal
    if(
        (
            enableRetreat
                ?
            (
                // attack state
                actionState == ActionState.Attack &&
                // lowHealth
                IsProbabilityTrue(150 * (1 - NormalizedHealth()))
            )
                :
            false
        )
    
    ){
        define supportPlayers = [];
        define notSupportPlayers = [];
        define livingFriends = AllLivingPlayers(TeamOf());

        // make support player list and not support player
        for(define index! = 0; index < CountOf(livingFriends); index ++){
            if(
                // not self
                ep != livingFriends[index]
            ){
                if(IsSupportHero(HeroOf(livingFriends[index]))){
                    // make support player list
                    supportPlayers[CountOf(supportPlayers)] = livingFriends[index];
                }
                else{
                    // make not support player list
                    notSupportPlayers[CountOf(notSupportPlayers)] = livingFriends[index];
                }
            }
        }

        // find near healer
        define nearHealer = 
            FirstOf(
                SortedArray(
                    supportPlayers,
                    DistanceBetween(ep, ae)
                )
            );

        // found support player and far
        if(
            nearHealer != null &&
            DistanceBetween(ep, nearHealer) > ActionRange.Close
        ){
            // set moveTarget by near healer
            moveTarget = nearHealer;
            moveDirFB = NoDirection();
            moveDirLR = NoDirection();
        }
        
        else{
            // find near guard as not support
            define nearGuard = 
                FirstOf(
                    SortedArray(
                        notSupportPlayers,
                        DistanceBetween(ep, ae)
                    )
                );

            // found guard player and far
            if(
                nearGuard != null &&
                DistanceBetween(ep, nearGuard) > ActionRange.Close
            ){
                // set moveTarget by near guard
                moveTarget = nearGuard;
                moveDirFB = NoDirection();
                moveDirLR = NoDirection();
            }
            else{
                // set move to back
                moveTarget = null;
                moveDirFB = Backward();
                moveDirLR = RandomValueInArray([NoDirection(), Right(), Left()]);
            }
        } 
    }
    // move to object for secure
    else if(
        // object pos valid
        objPos != null &&
        // payload escort player num is not enough
        (
            // current on object players num
            NumberOfPlayersOnObjective(TeamOf())
                <
            (
                // enemy close win
                IsCloseWin(EnemyTeamOf(ep))
                ?
                    // 1/2 players num of team
                    NumberOfPlayers(TeamOf()) / 2
                :
                    (
                        // offense team
                        IsTeamOnOffense(TeamOf())
                        ?
                            // 3 is max num of payload escort speed
                            3
                        :
                            (
                                // enemy on object
                                NumberOfPlayersOnObjective(EnemyTeamOf(ep)) > 0
                                ?
                                    // 1 is min num of payload stop
                                    1
                                :
                                    0
                            )
                    )
            )
        )
    ){
        // set move to object
        define dirToObject! = LocalVectorOf(DirectionTowards(ep, objPos), ep, Transformation.Rotation);
        moveTarget = null;
        moveDirFB = Vector(0, 0, ZOf(dirToObject));
        moveDirLR = Vector(XOf(dirToObject), 0, 0);
    }
    // move to enemy for combat
    else if(actionState != ActionState.Non){
        moveTarget = null;

        // set distRate by actionState
        define distRate! = (actionState == ActionState.Attack) ? 1 : 0.5;
        // get enemy density
        define enemyDensity! = EnemyDensityRateOfAimTargetNear(ActionRange.Close);

        if(
            // target is close
            distToTarget < (actionRangeMin * distRate)
        ){
            moveDirFB = Backward();
        }
        else if(
            // target is far
            distToTarget > (actionRangeMax * distRate) &&
            // by few enemy count in close
            IsProbabilityTrue(100 * (1 - enemyDensity))
        ){
            moveDirFB = Forward();
        }
        
        else{
            moveDirFB = NoDirection();
        }

        // side step
        if(
            IsProbabilityTrue(
                actionState == ActionState.Attack ? 
                    // by target distance
                    50 * (1 - (distToTarget / ActionRange.Far)) :
                    // non prob
                    0
                        +
                // by lost health
                (50 * (1 - NormalizedHealth()))
            )
        ){
            if(
                 // by few enemy count in close range
                IsProbabilityTrue(50 * (1 - enemyDensity))
            ){
                // start sidestep
                if(
                    moveDirLR == NoDirection()
                ){
                    // set sidestep
                    moveDirLR = RandomValueInArray([Right(), Left()]);
                }
                else if(IsProbabilityTrue(75)){
                    // change to reverse
                    moveDirLR = -moveDirLR;
                }
            }
            else{
                // stop sidestep
                moveDirLR = NoDirection();
            }
        }
        else{
            // stop sidestep
            moveDirLR = NoDirection();
        }
    }
}

playervar define enableCheckAbyss! = true;

void StartMove(define player!) playervar "StartMove"{
    if(noMoving) return;

    define confirmMoveDir = NoDirection();
    define hasMoveTarget;

    if(
        moveDirFB != NoDirection() ||
        moveDirLR != NoDirection()
    ){
        confirmMoveDir = player.moveDirFB + player.moveDirLR;
        hasMoveTarget = false;
    }
    else if(moveTarget != null){
        confirmMoveDir = LocalVectorOf(DirectionTowards(player, moveTarget), ep, Transformation.Rotation);
        hasMoveTarget = true;
    }
    
    // move to position is abyss
    if(
        confirmMoveDir != NoDirection() &&
        (
            player.enableCheckAbyss &&
            IsBelowAbyss(
                BlockedPositonByLocalVector(
                    player,
                    confirmMoveDir,
                    walkMeterPerSec * player.watchUpdateRate
                )
            )
        )
    ){
        StopMove(player);
    }
    else{
        if(
            confirmMoveDir != NoDirection()
        ){
            if(!hasMoveTarget){
                StartThrottleInDirection(
                    player,
                    confirmMoveDir,
                    1,
                    Relative.ToPlayer,
                    ThrottleBehavior.ReplaceExistingThrottle,
                    ThrottleRev.None
                );
            }
            else{
                StartThrottleInDirection(
                    player,
                    DirectionTowards(player, moveTarget),
                    1,
                    Relative.ToWorld,
                    ThrottleBehavior.ReplaceExistingThrottle,
                    ThrottleRev.DirectionAndMagnitude
                );
            }
        }
        else{
            StopMove(player);
        }
    }
}

void StopMove(define player!) playervar "StopMove"{
    if(noMoving) return;
    
    player.moveDirFB = NoDirection();
    player.moveDirLR = NoDirection();
    StopThrottleInDirection(player);
} 

// TAG Bot/Aimming ----------
define facingRate:
    actionRangeMax == ActionRange.Melee ?   300 :
    actionRangeMax == ActionRange.Close ?   250 :
    actionRangeMax == ActionRange.Middle ?  200 :
    actionRangeMax == ActionRange.Far ?     150 :
    100;

void StartFacingAimTarget() playervar "StartFacingAimTarget"{
    if(
        aimTarget != null &&
        HasSpawned(aimTarget) &&
        IsAlive(aimTarget)
    ){
        StartFacing(
            ep, DirectionTowards(EyePosition(), aimPosition(aimTarget)),
            facingRate, Relative.ToWorld, FacingRev.DirectionAndTurnRate);
    }
    else{
        StopFacing();
    }
}

define aimPosition(in define player!): 
    (
        IsInAlternateForm(player) ?
        EyePosition(player) - Vector(0, 0.6, 0)     // body position
            :
        EyePosition(player) + Vector(0, 0.2, 0)     // head position
    )
        +
    RandomPosition(aimScatter, aimScatter, aimScatter)  // aim scatter
        +
    Vector(0, -(aimScatter / 2), 0);    // vertical offset

// TAG Bot/ActionState/StateControl ----------
playervar define watchUpdateRate = 2.0;
playervar define isBotActive;
playervar define actionState;
playervar define aimTarget;

define CanFindRange(in define player!) :
    player != null &&
    DistanceBetween(ep, player) <= ActionRange.CanFind;

define CanFindLine(in define player!) :
    player != null &&
    IsInLineOfSight(EyePosition(ep), EyePosition(player), BarrierLOS.NoBarriersBlock);

define IsSighted(in define player!):
    TeamOf(ep) == TeamOf(player)        ? IsSightedAsFriend(player) :
    TeamOf(ep) == EnemyTeamOf(player)   ? IsSightedAsEnemy(player) :
        false;

define IsSightedAsEnemy(in define player!):
    // valid param
    player != null &&
    // is enemy team
    (TeamOf(ep) == EnemyTeamOf(player)) &&
    // has spawn
    HasSpawned(player) &&
    // alive
    IsAlive(player) &&
    // not in spawn room
    !IsInSpawnRoom(player) &&
    // can find range
    CanFindRange(player) &&
    // can find line
    CanFindLine(player) &&
    // not detection stealth
    !(IsStealth(player) && DistanceBetween(player, ep) >= 4);

define IsSightedAsFriend(in define player!):
    // valid param
    player != null &&
    // is player team
    (TeamOf(ep) == TeamOf(player)) &&
    // has spawn
    HasSpawned(player) &&
    // alive or can resurrect
    (IsAlive(player) || CanResurrect(ep)) &&
    // not in spawn room
    !IsInSpawnRoom(player) &&
    // can find line
    CanFindRange(player) &&
    // can find line or can swift step
    (CanFindLine(player) || CanSwiftStep(player));

define FindAttackTarget()"FindAttackTarget"{
    return FirstOf(
        SortedArray(
            FilteredArray(
                AllPlayers(EnemyTeamOf(ep)),
                // sight as enemy
                IsSightedAsEnemy(ae)
            ),
            DistanceBetween(ep, ae)
        )
    );
}

define neadHealHealthScale: 0.9;

define FindSupportTarget()"FindSupportTarget"{
    return FirstOf(
        SortedArray(
            FilteredArray(
                AllPlayers(TeamOf()),
                // not self
                (ae != ep) &&
                // need heal
                (NormalizedHealth(ae) < neadHealHealthScale) &&
                // sight as friend
                IsSightedAsFriend(ae)
            ),
            NormalizedHealth(ae)
        )
    );
}

void FindTarget()"FindTarget"{
    define candidateTarget;

    // find aim target
    // but, not set as direct to aimTarget for avoid interrupt invalid facing

    // by supportPrioloty
    if(IsProbabilityTrue(100 * supportPrioloty))
    {
        // find support target
        candidateTarget = FindSupportTarget();
        // not found support target
        if(candidateTarget == null){
            // find attack target
            candidateTarget = FindAttackTarget();
        }
    }
    else{
        // find attack target
        candidateTarget = FindAttackTarget();
    }

    if(candidateTarget == null){
        // stop facing before set aimTarget for avoid invalid facing
        StopFacing(ep);
    }

    // confirm as target
    aimTarget = candidateTarget;

}

define GetNextActionState()"GetNextActionState"{
    define nextActionState;
    
    if(
        // self alive
        IsAlive() &&
        // has target
        aimTarget != null
    ){
        if(
            // target is friend
            TeamOf() == TeamOf(aimTarget)
        ){
            // Support state
            nextActionState = ActionState.Support;
        }
        else{
            // Attack state
            nextActionState = ActionState.Attack; 
        }
    }
    else{
        // non state
        nextActionState = ActionState.Non;  
    }
    
    return nextActionState;
}

void SetActionState(define player, define nextActionState) "SetActionState"{
    // if state changed
    if(nextActionState != player.actionState){
        // set next state
        player.actionState = nextActionState;
    }
}

rule: "Bot/ActionState/deactivateState"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    !isBotActive
){
    // reset target
    aimTarget = null;
    // apply next state
    SetActionState(ep, ActionState.Non);
}

rule: "Bot/ActionState/StateControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    isBotActive
){
    SetHeroButtonControlPropety();

    while(true){
        define tryFindTarget = false;

        if(IsAlive()){
            // new target
            if(
                // target not Sighted
                !IsSighted(aimTarget)
            ){
                // get new target
                tryFindTarget = true;
            }
            // check target as support action
            else if(
                // is support role and now supporting
                0 < supportPrioloty &&
                actionState == ActionState.Support
            ){
                if(
                    // heal target completed
                    NormalizedHealth(aimTarget) >= neadHealHealthScale ||
                    // can not revive dead player
                    !(CanResurrect(ep) && !IsAlive(aimTarget))
                ){
                    // change target
                    tryFindTarget = true;
                }
                else if(
                    IsProbabilityTrue(
                        // by no support prioloty
                        (50 * (1 - supportPrioloty)) +          
                        // by support target health
                        (50 * NormalizedHealth(aimTarget))      
                    )
                ){
                    // change target 
                    tryFindTarget = true;
                }
                // else{} keep target
            }
            // check target as attack action
            else{
                if(
                    // target dead
                    !IsAlive(aimTarget)
                ){
                    // change target 
                    tryFindTarget = true;
                }
                else if(
                    IsProbabilityTrue(
                        // by attack target health
                        50 * NormalizedHealth(aimTarget) 
                    )
                ){
                    // change target 
                    tryFindTarget = true;
                }
                // else{} keep target
            }

            // get new target
            if(tryFindTarget){
                // find target
                FindTarget();
            }

            // apply next state
            SetActionState(ep, GetNextActionState());
            // action call to near bots
            CallToNearBot();
        }
        else{
            // reset target
            aimTarget = null;
            // apply next state
            SetActionState(ep, GetNextActionState());
        }

        WaitReleaseServerLoad(actionState == ActionState.Non ? ServerLoadType.BotMustAction : ServerLoadType.BotAction);
        Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    }
}

rule: "Bot/ActionState/SetNonStateByDead"
Event.OnDeath
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    Victim() == ep
){
    AbortIf(!isBotActive);

    // reset target
    aimTarget = null;
    // apply next state
    SetActionState(ep, GetNextActionState());
}

rule: "Bot/ActionState/ChangeTargetByTargetDead"
Event.OnElimination
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    IsAlive() &&
    (
        actionState != ActionState.Non &&
        Victim() == aimTarget
    )
){
    AbortIf(!isBotActive);
    WaitReleaseServerLoad(actionState == ActionState.Non ? ServerLoadType.BotMustAction : ServerLoadType.BotAction);

    // find next target
    FindTarget();
    // apply next state
    SetActionState(ep, GetNextActionState());
}

rule: "Bot/ActionState/ChangeSupportTargetByTargetHealCompleted"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    IsAlive() &&
    (
        actionState == ActionState.Support &&
        NormalizedHealth(aimTarget) >= neadHealHealthScale
    )
){
    AbortIf(!isBotActive);
    WaitReleaseServerLoad(actionState == ActionState.Non ? ServerLoadType.BotMustAction : ServerLoadType.BotAction);

    // find next target
    FindTarget();
    // apply next state
    SetActionState(ep, GetNextActionState());
}

rule: "Bot/ActionState/ChangeTargetByDamageTaken"
Event.OnDamageTaken
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    IsAlive() &&
    (
        Attacker() != ep
    )
){
    AbortIf(!isBotActive);
    WaitReleaseServerLoad(actionState == ActionState.Non ? ServerLoadType.BotMustAction : ServerLoadType.BotAction);

    if(
        // set target in Non
        actionState == ActionState.Non ||
        // change target by target helth
        IsProbabilityTrue(50 * NormalizedHealth(aimTarget)) ||
        // can not find aimTarget
        !CanFindLine(aimTarget)
    ){
        // set target by attacker
        aimTarget = Attacker();
        // apply next state
        SetActionState(ep, GetNextActionState());
    }

    // action call to near bots
    CallToNearBot();

    // reduce overrun change target
    Wait(3.0, WaitBehavior.IgnoreCondition);
}

globalvar define isCallAttackCoolingDown1 = false;
globalvar define isCallAttackCoolingDown2 = false;

void CallToNearBot()"CallToNearBot"{
    // check cooldown for reduce overrun
    // if already CoolingDown flag true, ignore action
    if(TeamOf() == Team.Team1){
        if(isCallAttackCoolingDown1){
            return;
        }
        isCallAttackCoolingDown1 = true;
    }
    else if(TeamOf() == Team.Team2){
        if(isCallAttackCoolingDown2){
            return;
        }
        isCallAttackCoolingDown2 = true;
    }

    if(
        // has aim target
        aimTarget != null
    ){
        // get near idle bot
        define nearFriends = FilteredArray(
            PlayersWithinRadius(ep, 0 + ActionRange.CanFind, TeamOf(), RadiusLOS.Off),
            (
                ae != ep &&
                IsDummyBot(ae) &&
                ae.isBotActive &&
                IsAlive(ae) &&
                (
                    // if support state
                    actionState == ActionState.Support ?
                        // call to near supportable bot for support
                        ae.supportPrioloty > 0 :
                        // call to near idle bot for attack
                        ae.actionState == ActionState.Non
                )
            )
        );

        for(define index = 0; index < CountOf(nearFriends); index ++){
            // set same target
            nearFriends[index].aimTarget = ep.aimTarget;
            // set same state 
            SetActionState(nearFriends[index], ep.actionState);
        }
    }
}

rule: "Bot/ActionState/releaseIsCallAttackCoolingDown"
Event.OngoingGlobal
if(
    isCallAttackCoolingDown1 ||
    isCallAttackCoolingDown2
){
    Wait(3.0, WaitBehavior.IgnoreCondition);
    isCallAttackCoolingDown1 = false;
    isCallAttackCoolingDown2 = false;
    Loop();
    // LoopIfConditionIsTrue();
}

// TAG Bot/ActionState/Non ----------
rule: "Bot/ActionState/Non"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    actionState == ActionState.Non
){
    // reset button control
    enableButtonControl = false;
    Wait(0.1, WaitBehavior.IgnoreCondition);

    // stop facing
    StopFacing(ep);
    // stop move
    StopMove(ep);

    while(true){
        // hero unique action
        PolingHeroUniqueAction();
        
        WaitReleaseServerLoad(actionState == ActionState.Non ? ServerLoadType.BotMustAction : ServerLoadType.BotAction);
        Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    }
}

// TAG Bot/ActionState/Attack ----------
rule: "Bot/ActionState/Attack"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    actionState == ActionState.Attack
){
    AbortIf(!isBotActive);

    // reset button control for change depending state button set
    enableButtonControl = false;
    Wait(0.1, WaitBehavior.IgnoreCondition);

    while(true){
        // start button control
        enableButtonControl = true;
        // start facing
        StartFacingAimTarget();
        // set moveDir for combat
        SetMoveDir();
        // start move by moveDir
        StartMove(ep);
        // hero unique action
        PolingHeroUniqueAction();

        WaitReleaseServerLoad(actionState == ActionState.Non ? ServerLoadType.BotMustAction : ServerLoadType.BotAction);
        Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    }
}

// TAG Bot/ActionState/Support ----------
rule: "Bot/ActionState/Support"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    actionState == ActionState.Support
){
    AbortIf(!isBotActive);

    // reset button control for change depending state button set
    enableButtonControl = false;
    Wait(0.1, WaitBehavior.IgnoreCondition);

    while(true){
        // start button control
        enableButtonControl = true;
        // start facing
        StartFacingAimTarget();
        // set moveDir for combat
        SetMoveDir();
        // start move by moveDir
        StartMove(ep);
        // hero unique action
        PolingHeroUniqueAction();

        WaitReleaseServerLoad(actionState == ActionState.Non ? ServerLoadType.BotMustAction : ServerLoadType.BotAction);
        Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    }
}

// TAG Bot/HeroUniqueAction ----------
void StartFacingTemporaryTargetWithButton(define target!, define offset!, define aimTime!, define button!, define keepTime!) playervar "StartFacingTemporaryTargetWithButton"{
    // is player
    if(HasSpawned(target)){
        
        StartFacingPlayer(target, facingRate);
    }
    // is position
    else{
        StartFacing(
            ep, DirectionTowards(EyePosition(), target + offset),
            facingRate, Relative.ToWorld, FacingRev.DirectionAndTurnRate);
    }

    Wait(aimTime, WaitBehavior.IgnoreCondition);
    StartHoldingButton(ep, button);
    Wait(keepTime, WaitBehavior.IgnoreCondition);
    StopHoldingButton(ep, button);
    StartFacingAimTarget();
}

void PolingHeroUniqueAction() playervar "PolingHeroUniqueAction"{
    // common action
    // reload
    if(
        // in idle
        actionState == ActionState.Non
    ){
        // wait  
        Wait(3, WaitBehavior.AbortWhenFalse);
        // reload by condition 
        PressButton(ep, Button.Reload);
    }
    else{
        // is out of ammo
        if(
            isOutOfAmmo
        ){
            // reload
            PressButton(ep, Button.Reload);
        }
    }

    if(
        // in combat
        actionState != ActionState.Non
    ){
        // melee
        while(
            aimTarget != null &&
            actionState == ActionState.Attack &&
            DistanceBetween(ep, aimTarget) <= meleeRange &&
            (
                // can kill by melee helath
                Health(aimTarget) <= meleeDamage * 2
            )
        ){
            // melee
            PressButton(ep, Button.Melee);
            Wait(0.5, WaitBehavior.AbortWhenFalse);
        }

        // hero unique action
        // Ana
        if(
            HeroOf() == Hero.Ana
        ){
            if(
                UltimateChargePercent() >= 100
            ){
                // get ultimate ready or ultimate using or low helath player
                define boostTarget! = 
                    RandomValueInArray(
                        FilteredArray(
                            AllLivingPlayers(TeamOf()),
                            (
                                (
                                    // ult ready
                                    UltimateChargePercent(ae) >= 100 ||
                                    // using ult
                                    IsUsingUltimate(ae) ||
                                    // low health
                                    NormalizedHealth(ae) <= 0.25
                                ) &&
                                CanFindLine(ae)
                            )
                        )
                    );

                if(boostTarget != null){
                    StartFacingTemporaryTargetWithButton(boostTarget, null, 0.5, Button.Ultimate, 0);
                }
            }
        }
        // Baptiste
        if(
            HeroOf() == Hero.Baptiste
        ){
            if(
                AbilityCooldown(ep, Button.Ability2) <= 0
            ){
                // get ultimate ready or ultimate using or low helath player
                define protectTarget! = 
                    RandomValueInArray(
                        FilteredArray(
                            AllLivingPlayers(TeamOf()),
                            (
                                (
                                    // low health
                                    NormalizedHealth(ae) <= 0.25
                                ) &&
                                CanFindLine(ae)
                            )
                        )
                    );

                if(protectTarget != null){
                    StartFacingTemporaryTargetWithButton(protectTarget, null, 0.5, Button.Ability2, 0);
                }
            }
        }
        // Zarya
        if(
            HeroOf() == Hero.Zarya
        ){
            if(
                IsProbabilityTrue(50) &&
                AbilityCooldown(ep, Button.Ability2) <= 0
            ){
                // get ultimate ready or ultimate using or low helath player
                define protectTarget! = 
                    RandomValueInArray(
                        FilteredArray(
                            AllLivingPlayers(TeamOf()),
                            (
                                (
                                    // low health
                                    NormalizedHealth(ae) <= 0.5
                                ) &&
                                CanFindLine(ae)
                            )
                        )
                    );

                if(protectTarget != null){
                    StartFacingTemporaryTargetWithButton(protectTarget, null, 0.5, Button.Ability2, 0);
                }
            }
        }
        // Mercy
        else if(
            HeroOf() == Hero.Mercy
        ){
            if(
                actionState == ActionState.Support
            ){
                // change to heal arm
                SetWeapon(ep, 1);

                if(
                    // by target health
                    IsProbabilityTrue(70 * NormalizedHealth(aimTarget))
                ){
                    // boost aimTarget 
                    StopHoldingButton(ep, Button.PrimaryFire);
                    StartHoldingButton(ep, Button.SecondaryFire);

                    // set boostTarget by ult using player
                    define boostTarget = 
                        RandomValueInArray(
                            FilteredArray(
                                AllLivingPlayers(TeamOf()),
                                (
                                    ae != ep &&
                                    (
                                        // ready ult
                                        100 <= UltimateChargePercent(ae) ||
                                        // using ult
                                        IsUsingUltimate(ae)
                                    ) &&
                                    CanFindLine(ae)
                                )
                            )
                        );

                    if(boostTarget != null){
                        StartFacingTemporaryTargetWithButton(boostTarget, null, 0.5, Button.SecondaryFire, RandomReal(3, 6));
                    }
                }
                else{
                    // heal aimTarget
                    StopHoldingButton(ep, Button.SecondaryFire);
                    StartHoldingButton(ep, Button.PrimaryFire);
                }
            }
            else if(actionState == ActionState.Attack){
                // change to gun
                SetWeapon(ep, 2);
            }
        }
        // Cassidy
        else if(
            HeroOf() == Hero.Cassidy
        ){
            if(
                IsProbabilityTrue(50) &&
                DistanceBetween(ep, aimTarget) <= ActionRange.Close &&
                !IsUsingUltimate()  // for not ult cancel
            ){
                // use faning shot
                StopHoldingButton(ep, Button.PrimaryFire);
                PressButton(ep, Button.SecondaryFire);
                Wait(0.7, WaitBehavior.IgnoreCondition);
                if(
                    AbilityCooldown(ep, Button.Ability1) <= 0 &&
                    IsAlive(aimTarget)
                ){
                    PressButton(ep, Button.Ability1);
                    Wait(0.5, WaitBehavior.IgnoreCondition);
                    PressButton(ep, Button.SecondaryFire);
                }
            }
        }
        // Ashe
        else if(
            HeroOf() == Hero.Ashe
        ){
            // fallback by corch gun
            if(
                IsProbabilityTrue(50) &&
                DistanceBetween(ep, aimTarget) <= ActionRange.Close
            ){
                if(
                    AbilityCooldown(ep, Button.Ability1) <= 0
                ){
                    // use corch gun
                    PressButton(ep, Button.Ability1);
                }
                else if(IsProbabilityTrue(50)){
                    // fallback by non aiming
                    StopHoldingButton(ep, Button.SecondaryFire);
                }
            }

            if(
                isOutOfAmmo ||
                IsProbabilityTrue(25 * (1 - (Ammo(ep, 0) / MaxAmmo(ep, 0))))  // by ammo charge
            ){
                // stop buton control for reduce reload cancel by fire
                enableButtonControl = false;
                Wait(0.1, WaitBehavior.IgnoreCondition);
                PressButton(ep, Button.Reload);
                Wait(0.1, WaitBehavior.IgnoreCondition);
                // check reload cancel until full load
                while(IsReloading()){
                    Wait(0.5, WaitBehavior.IgnoreCondition);
                    if(
                        IsProbabilityTrue(25 * (Ammo(ep, 0) / MaxAmmo(ep, 0)))  // reload cancel by ammo charge
                    ){
                        break;
                    }
                }
                // restore buton control
                enableButtonControl = true;
            }
        }
        // Sombra
        else if(
            HeroOf() == Hero.Sombra
        ){
            if(
                AbilityCooldown(ep, Button.Ability2) <= 0 &&
                // by own health low
                IsProbabilityTrue(100 * (1 - NormalizedHealth()))
            ){
                // throw trance locator at backword
                StartFacingPlayerRetreatPosition(aimTarget, 5);
                StopMove(ep);
                Wait(0.5, WaitBehavior.IgnoreCondition);
                PressButton(ep, Button.Ability2);
                Wait(0.1, WaitBehavior.IgnoreCondition);
                // restore facing
                StartFacingAimTarget();
            }
            else if(
                AbilityCooldown(ep, Button.Ability2) <= 0 &&
                // by own health high
                IsProbabilityTrue(50 * NormalizedHealth())
            ){
                // throw trance locator at forward
                PressButton(ep, Button.Ability2);
            }
        }
        // LifeWeever
        else if(
            HeroOf() == Hero.Lifeweaver
        ){
            // use life grip by aim target low health
            if(
                AbilityCooldown(ep, Button.Ability2) <= 0 &&
                actionState == ActionState.Support &&
                (
                    NormalizedHealth(aimTarget) <= 0.5
                )
            ){
                // use life grip
                PressButton(ep, Button.Ability2);
            }

            if(
                AbilityCooldown(ep, Button.Ability1) <= 0 &&
                !IsUsingAbility1(ep) &&
                (
                    IsProbabilityTrue(25) ||
                    NormalizedHealth() <= 0.5
                )
            ){
                // use lift on own below
                StopMove(ep);
                StartFacingPlayerBetweenBelowPosition(aimTarget, 0.01);
                Wait(0.5, WaitBehavior.IgnoreCondition);
                PressButton(ep, Button.Ability1);
                Wait(0.1, WaitBehavior.IgnoreCondition);
                // restore facing
                StartFacingAimTarget();
            }
        }
        // Hanzo
        else if(
            HeroOf() == Hero.Hanzo
        ){
            // fallback by double jump
            if(
                IsProbabilityTrue(75) &&
                DistanceBetween(ep, aimTarget) <= ActionRange.Close
            ){
                // move backward for combat
                moveDirFB = Backward();
                StartMove(ep);
                
                if(
                    AbilityCooldown(ep, Button.Jump) <= 0
                ){
                    // use double jump at backword
                    PressButton(ep, Button.Jump);
                    Wait(0.5, WaitBehavior.IgnoreCondition);
                    PressButton(ep, Button.Jump);
                }
            }
        }
        // Widowmaker
        else if(
            HeroOf() == Hero.Widowmaker
        ){
            // using infra sight
            if(
                IsUsingUltimate()
            ){
                // Improve accuracy
                aimScatter = 0.0;
            }
            else{
                aimScatter = 0.1;
            }

            if(
                DistanceBetween(ep, aimTarget) <= ActionRange.Close
            ){
                // fallback by graple hook
                if(
                    IsProbabilityTrue(((1 - NormalizedHealth()) * 75)) &&
                    AbilityCooldown(ep, Button.Ability1) <= 0 &&
                    IsBlockedBetween(
                        EyePosition(ep),
                        EyePosition(ep) + (VectorWithOutY(-FacingDirectionOf(ep)) * 16)
                    )
                ){
                    StopMove(ep);
                    StopHoldingButton(ep, Button.SecondaryFire);
                    StartFacingPlayerRetreatPosition(aimTarget, RandomReal(2, 5));
                    Wait(0.75, WaitBehavior.IgnoreCondition);
                    PressButton(ep, Button.Ability1);
                    Wait(0.1, WaitBehavior.IgnoreCondition);
                    // restore aiming
                    StartHoldingButton(ep, Button.SecondaryFire);
                    // restore facing
                    StartFacingAimTarget();
                }
                // fallback with hip fire
                else if(
                    IsProbabilityTrue((1 - NormalizedHealth()) * 25) &&
                    IsButtonHeld(ep, Button.SecondaryFire)
                ){
                    StopHoldingButton(ep, Button.SecondaryFire);
                    Wait(RandomReal(1.0, 3.0), WaitBehavior.IgnoreCondition);
                    // restore aiming
                    StartHoldingButton(ep, Button.SecondaryFire);
                }
            }
        }
        // Lucio
        else if(
            HeroOf() == Hero.Lucio
        ){
            if(
                IsProbabilityTrue(NormalizedHealth() * 75)
            ){
                // move to teammate for heal
                define healTarget! = FindSupportTarget();
                if(healTarget != null){
                    // move to player for heal
                    define localDir! = LocalVectorOf(DirectionTowards(ep, healTarget), ep, Transformation.Rotation);
                    moveDirFB = Vector(0, 0, ZOf(localDir));
                    moveDirLR = Vector(XOf(localDir), 0, 0);
                    StartMove(ep);
                }
            }

            if(
                AbilityCooldown(ep, Button.Ability2) <= 0 &&
                NormalizedHealth(aimTarget) < 
                    actionState == ActionState.Support ?
                    0.5 :
                    0.25
            ){
                PressButton(ep, Button.Ability2);
                // keep curent form
                Wait(RandomReal(0.1, 1.5), WaitBehavior.IgnoreCondition);
            }

            // tune form
            if(
                actionState == ActionState.Support &&
                // speed form
                IsInAlternateForm()
            ){
                // change mode to heal
                PressButton(ep, Button.Ability1);
            }
            else if(
                actionState == ActionState.Attack &&
                // heal form
                !IsInAlternateForm()
            ){
                // change mode to speed
                PressButton(ep, Button.Ability1);
            }
        }
        // Reaper
        else if(
            HeroOf() == Hero.Reaper
        ){
            // teleport enemy behind with shadow step 
            if(
                IsProbabilityTrue(75 * NormalizedHealth()) &&
                AbilityCooldown(ep, Button.Ability2) <= 0 &&
                DistanceBetween(ep, aimTarget) > ActionRange.Close
            ){
                // use shadow step
                PressButton(ep, Button.Ability2);
                Wait(0.1, WaitBehavior.IgnoreCondition);
                PressButton(ep, Button.PrimaryFire);
            }
        }
        // Sojourn
        else if(
            HeroOf() == Hero.Sojourn
        ){
            // fire charged railgun 
            if(
                IsUsingUltimate()
            ){
                Wait(RandomReal(0.1, 2.5), WaitBehavior.IgnoreCondition);
                // use charged railgun
                PressButton(ep, Button.SecondaryFire);
            }
        }
        // WreckingBall
        else if(
            HeroOf() == Hero.WreckingBall
        ){
            // use graple hook and tackle
            if(
                IsProbabilityTrue(75) &&
                AbilityCooldown(ep, Button.SecondaryFire) <= 0 &&
                IsBlockedBetween(
                    EyePosition(ep),
                    EyePosition(ep) + (VectorWithOutY(FacingDirectionOf(ep)) * 20)
                )
            ){
                // stop buton control for reduce ball form cancel by fire
                enableButtonControl = false;
                // use graple at target above
                StartFacingPlayerAbovePosition(aimTarget, 5);
                Wait(0.5, WaitBehavior.IgnoreCondition);
                StartHoldingButton(ep, Button.SecondaryFire);
                Wait(0.1, WaitBehavior.IgnoreCondition);
                // restore facing
                StartFacingAimTarget();
            }
            // use pile driver
            if(
                IsProbabilityTrue(75) &&
                AbilityCooldown(ep, Button.Crouch) <= 0
            ){
                if(IsOnGround()){
                    // jump for pile driver
                    ApplyImpulse(ep, Up(),
                        10, Relative.ToWorld, ContraryMotion.Cancel);
                    Wait(RandomReal(0.5, 1), WaitBehavior.IgnoreCondition);
                }
                PressButton(ep, Button.Crouch);
            }
        }
        // Torbjorn
        else if(
            HeroOf() == Hero.Torbjorn
        ){
            if(
                IsProbabilityTrue(50) &&
                DistanceBetween(ep, aimTarget) <= ActionRange.Close
            ){
                // change to melee arm
                SetWeapon(ep, 2);

                while(
                    // continue melee mode condition
                    IsProbabilityTrue(90) &&
                    IsAlive() &&
                    DistanceBetween(ep, aimTarget) <= ActionRange.Close
                ){
                    // move foward for melee
                    moveDirFB = Forward();
                    moveDirLR = NoDirection();
                    StartMove(ep);
                    // melee by hammer
                    PressButton(ep, Button.PrimaryFire);
                    Wait(0.3, WaitBehavior.IgnoreCondition);
                }
            }
            else{
                // change to gun
                SetWeapon(ep, 1);
            }
        }
        // Zenyatta
        else if(
            HeroOf() == Hero.Zenyatta
        ){
            while(
                IsUsingUltimate()
            ){
                define healTarget! = FindSupportTarget();
                if(healTarget != null){
                    // move to player for heal
                    define localDir! = LocalVectorOf(DirectionTowards(ep, healTarget), ep, Transformation.Rotation);
                    moveDirFB = Vector(0, 0, ZOf(localDir));
                    moveDirLR = Vector(XOf(localDir), 0, 0);
                    StartMove(ep);
                }
                Wait(0.5, WaitBehavior.IgnoreCondition);
            }
        }
        // Illari
        else if(
            HeroOf() == Hero.Illari
        ){
            if(
                IsProbabilityTrue(75) &&
                AbilityCooldown(ep, Button.Ability1) <= 0
            ){
                PressButton(ep, Button.Ability1);
                StartHoldingButton(ep, Button.Jump);
                Wait(0.5, WaitBehavior.IgnoreCondition);
                StopHoldingButton(ep, Button.Jump);
            }
        }
        // Bastion
        else if(
            HeroOf() == Hero.Bastion
        ){
            if(
                IsProbabilityTrue(75) &&
                AbilityCooldown(ep, Button.Ability1) <= 0 &&
                !IsUsingAbility1() &&
                !IsUsingUltimate()
            ){
                PressButton(ep, Button.Ability1);
            }
        }
        // Ramattra
        else if(
            HeroOf() == Hero.Ramattra
        ){
            if(
                IsProbabilityTrue(75) &&
                AbilityCooldown(ep, Button.Ability1) <= 0 &&
                !IsUsingAbility1() &&
                !IsUsingUltimate()
            ){
                PressButton(ep, Button.Ability1);
            }
        }
    }
}

rule: "Bot/HeroUniqueAction/setButonPropertyDuplicateStart"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    HeroOf() == Hero.Echo &&
    IsDuplicating(ep)
){
    SetHeroButtonControlPropety();
}

rule: "Bot/HeroUniqueAction/setButonPropertyDuplicateEnd"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    HeroOf() == Hero.Echo &&
    !IsDuplicating(ep)
){
    SetHeroButtonControlPropety();
}

define DuplicatingHeroOf() "DuplicatingHeroOf"{
    define hero = null;
    if(
        HeroOf() == Hero.Echo &&
        IsDuplicating()
    ){
        hero = HeroBeingDuplicated(ep);
    }
    return hero;
}

rule: "Bot/HeroUniqueAction/positionMoveUltmate"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    IsUsingUltimate()
){
    AbortIf(!isBotActive);
    
    define isPositionMoveUltmate!;
    define waitForStartMove!;
    define moveSpeed!;
    define attackCount!;
    define multiPosAttack!;

    // postion move hero
    if(
        HeroOf() == Hero.Doomfist ||
        DuplicatingHeroOf() == Hero.Doomfist
    ){
        isPositionMoveUltmate = true;
        waitForStartMove = 0.5;
        moveSpeed = 0.06;
        attackCount = 1;
        multiPosAttack = false;
    }
    else if(
        HeroOf() == Hero.Bastion ||
        DuplicatingHeroOf() == Hero.Bastion
    ){
        isPositionMoveUltmate = true;
        waitForStartMove = 1.5;
        moveSpeed = 0.04;
        attackCount = 3;
        multiPosAttack = IsProbabilityTrue(0);
    }
    else if(
        HeroOf() == Hero.Junkrat ||
        DuplicatingHeroOf() == Hero.Junkrat
    ){
        isPositionMoveUltmate = true;
        waitForStartMove = 1.5;
        moveSpeed = 0.075;
        attackCount = 1;
        multiPosAttack = false;
    }

    if(isPositionMoveUltmate){
        // stop buton control for reduce cancel
        enableButtonControl = false;
        // stop current moving input
        StopMove(ep);
        // wait for start mode
        Wait(waitForStartMove, WaitBehavior.AbortWhenFalse);
        // start move postion selecter to foward
        moveDirFB = Forward();
        moveDirLR = NoDirection();
        StartMove(ep);
        // decrease move speed if multi position attack mode
        if(multiPosAttack) moveSpeed -= 0.01;
        // wait for arrival target
        define dist! = DistanceBetween(ep, aimTarget);
        dist = dist <= 5 ? 5 : dist;
        Wait(dist * (moveSpeed), WaitBehavior.AbortWhenFalse);
        // stop move if not multi position attack mode
        if(!multiPosAttack){
            StopMove(ep);
        }
        // trigger attack by attackCount
        for(define tryCount! = 0; tryCount < attackCount; tryCount++){
            PressButton(ep, Button.PrimaryFire);
            if(tryCount < attackCount){
                // button press with random interval
                Wait(RandomReal(0.25, 0.5), WaitBehavior.AbortWhenFalse);
            }
        }
        // reduce walking after ult
        StopMove(ep);
        // restore buton control
        enableButtonControl = true;
    }
}

rule: "Bot/HeroUniqueAction/positionAimUltmate"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    UltimateChargePercent() >= DefaultPercentage() &&
    IsButtonHeld(ep, Button.Ultimate)
){
    AbortIf(!isBotActive);

    define isPositionAimUltmate!;
    define isRotateProb!;
    
    // postion aim hero
    if(
        HeroOf() == Hero.Baptiste ||
        DuplicatingHeroOf() == Hero.Baptiste
    ){
        isPositionAimUltmate = true;
        isRotateProb = 10;
    }
    else if(
        HeroOf() == Hero.Symmetra ||
        DuplicatingHeroOf() == Hero.Symmetra
    ){
        isPositionAimUltmate = true;
        isRotateProb = 50;
    }

    if(isPositionAimUltmate){
        // stop buton control for reduce cancel
        enableButtonControl = false;
        // place ult on ground
        StartFacingPlayerBetweenBelowPosition(aimTarget, 0.5);
        Wait(0.5, WaitBehavior.AbortWhenFalse);
        if(IsProbabilityTrue(isRotateProb)){
            PressButton(ep, Button.Ultimate);
            Wait(0.1, WaitBehavior.AbortWhenFalse);
        }
        PressButton(ep, Button.PrimaryFire);
        Wait(0.1, WaitBehavior.AbortWhenFalse);
        // restore facing
        StartFacingAimTarget();
        // restore buton control
        enableButtonControl = true;
    }
}

rule: "Bot/HeroUniqueAction/positionAimSecondary"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    AbilityCooldown(ep, Button.SecondaryFire) <= 0 &&
    IsButtonHeld(ep, Button.SecondaryFire)
){
    AbortIf(!isBotActive);

    define isPositionAimSecondary!;

    if(
        HeroOf() == Hero.Ramattra ||
        DuplicatingHeroOf() == Hero.Ramattra
    ){
        if(
            // is omnic form
            !IsNemesisForm(ep)
        ){
            isPositionAimSecondary = true;
        }        
    }

    if(isPositionAimSecondary){
        // stop buton control for reduce cancel
        enableButtonControl = false;
        StopHoldingButton(ep, Button.PrimaryFire);
        // place ability on ground
        StartFacingPlayerBetweenBelowPosition(aimTarget, 0.25);
        Wait(0.5, WaitBehavior.AbortWhenFalse);
        PressButton(ep, Button.SecondaryFire);
        Wait(0.1, WaitBehavior.AbortWhenFalse);
        // restore facing
        StartFacingAimTarget();
        // restore buton control
        enableButtonControl = true;
    }
}

rule: "Bot/HeroUniqueAction/positionFixSecondary"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    IsFiringSecondary()
){
    AbortIf(!isBotActive);

    define isPositionFixSecondary!;

    if(
        HeroOf() == Hero.WreckingBall ||
        DuplicatingHeroOf() == Hero.WreckingBall
    ){
        if(IsFiringSecondary()){
            isPositionFixSecondary = true;       
        }
    }

    if(isPositionFixSecondary){
        // stop buton control for reduce ball form cancel by fire
        enableButtonControl = false;

        // using graple hook
        while(
            IsFiringSecondary()
        ){
            // accsell for ball tackle
            ApplyImpulse(ep, 
                BallTackleDirection(),
                20, Relative.ToWorld, ContraryMotion.Incorporate);
            
            Wait(0.5, WaitBehavior.AbortWhenFalse);
        }

        // try use graple at target above
        for(define tryCount! = 0; tryCount <= 4; tryCount++){
            if(!IsInAlternateForm()){
                break;
            }

            // accsell for ball tackle by inertia movement
            ApplyImpulse(ep, 
                BallTackleDirection(),
                20, Relative.ToWorld, ContraryMotion.Incorporate);

            Wait(0.5, WaitBehavior.AbortWhenFalse);
        }

        // restore buton control
        enableButtonControl = true;
    }
}

define BallTackleDirection()"BallTackleDirection"{
    define dir;
    if(
        SpeedOf() >= 10
    ){
        // nearest enemy of grapple crow pos
        dir = DirectionTowards(ep, ClosestPlayerTo(ep, EnemyTeamOf(ep)));
    }
    else{
        dir = -1 * DirectionTowards(ep, ClosestPlayerTo(ep, EnemyTeamOf(ep)));
    }
    return dir;
}

// TAG Bot/ButtonControl ----------
define noShooting: false;   // for debug
define noMoving: false;   // for debug

playervar define enableButtonControl;

// TAG Bot/ButtonControl/StartButtonControl ----------
rule: "Bot/ButtonControl/StartButtonControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    enableButtonControl
){
    async StartButtonControlOfPrimaryFire();
    async StartButtonControlOfSecondaryFire();
    async StartButtonControlOfAbility1();
    async StartButtonControlOfAbility2();
    async StartButtonControlOfUltimate();
    async StartButtonControlOfJump();
    async StartButtonControlOfCrouch();
}

// implment as function, cuz parallel running by async call
void StartButtonControlOfPrimaryFire()"StartButtonControlOfPrimaryFire"{
    StartButtonControl(
        Button.PrimaryFire,
        primaryFireButtonBehaivor,
        primaryFireButtonReleaseMin,
        primaryFireButtonReleaseMax,
        primaryFireButtonPressMin,
        primaryFireButtonPressMax
    );
    StopHoldingButton(ep, Button.PrimaryFire);
}

void StartButtonControlOfSecondaryFire()"StartButtonControlOfSecondaryFire"{
    StartButtonControl(
        Button.SecondaryFire,
        secondaryFireButtonBehaivor,
        secondaryFireButtonReleaseMin,
        secondaryFireButtonReleaseMax,
        secondaryFireButtonPressMin,
        secondaryFireButtonPressMax
    );
    StopHoldingButton(ep, Button.SecondaryFire);
}

void StartButtonControlOfAbility1()"StartButtonControlOfAbility1"{
    StartButtonControl(
        Button.Ability1,
        ButtonBehaivor.ReleasePress,
        ability1ButtonReleaseMin,
        ability1ButtonReleaseMax,
        ability1ButtonPressMin,
        ability1ButtonPressMax
    );
    StopHoldingButton(ep, Button.Ability1);
}

void StartButtonControlOfAbility2()"StartButtonControlOfAbility2"{
    StartButtonControl(
        Button.Ability2,
        ButtonBehaivor.ReleasePress,
        ability1ButtonReleaseMin,
        ability1ButtonReleaseMax,
        ability1ButtonPressMin,
        ability1ButtonPressMax
    );
    StopHoldingButton(ep, Button.Ability2);
}

void StartButtonControlOfUltimate()"StartButtonControlOfUltimate"{
    StartButtonControl(
        Button.Ultimate,
        ButtonBehaivor.ReleasePress,
        ultimateButtonReleaseMin,
        ultimateButtonReleaseMax,
        ultimateButtonPressMin,
        ultimateButtonPressMax
    );
    StopHoldingButton(ep, Button.Ultimate);
}

void StartButtonControlOfJump()"StartButtonControlOfJump"{
    StartButtonControl(
        Button.Jump,
        ButtonBehaivor.ReleasePress,
        jumpButtonReleaseMin,
        jumpButtonReleaseMax,
        jumpButtonPressMin,
        jumpButtonPressMax
    );
    StopHoldingButton(ep, Button.Jump);
}

void StartButtonControlOfCrouch()"StartButtonControlOfCrouch"{
    StartButtonControl(
        Button.Crouch,
        ButtonBehaivor.ReleasePress,
        ultimateButtonReleaseMin,
        ultimateButtonReleaseMax,
        ultimateButtonPressMin,
        ultimateButtonPressMax
    );
    StopHoldingButton(ep, Button.Crouch);
}

// TAG Bot/ButtonControl/StopButtonControl ----------
rule: "Bot/ButtonControl/StopButtonControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    !enableButtonControl
){
    StopHoldingButton(ep, Button.PrimaryFire);
    StopHoldingButton(ep, Button.SecondaryFire);
    StopHoldingButton(ep, Button.Ability1);
    StopHoldingButton(ep, Button.Ability2);
    StopHoldingButton(ep, Button.Ultimate);
    StopHoldingButton(ep, Button.Jump);
    StopHoldingButton(ep, Button.Crouch);
    // ClearButtonBit();
}

// TAG Bot/ButtonControl/Action ----------
playervar define isRepeatFiring;
playervar define repeatDuring;

// can's implment as function, cuz need control instance each button
Boolean isMatchButton(in define matchButton, in define butttons){
    return IsTrueForAny(butttons, ae == matchButton);
}

define minWaitTime: 0.1;

// can's implment as function, cuz need control instance each button
void StartButtonControl(in define button, define buttonBehaivor!, define releaseMin, define releaseMax, define pressMin, define pressMax){
    if(noShooting) return;

    define startButton = false;

    // if state dependent buttons
    if(
        isMatchButton(
            button, [
                Button.PrimaryFire,
                Button.SecondaryFire,
                Button.Ability1,
                Button.Ability2
            ])
    ){
        // if attack state dependent buttons
        if(
            actionState == ActionState.Attack &&
            isMatchButton(button, attackButtons)
        ){
            startButton = true;
        }
        // if support state dependent buttons
        else if(
            actionState == ActionState.Support &&
            isMatchButton(button, supportButtons)
        ){
            startButton = true;
        }
    }
    else{
        startButton = true;
    }

    if(!startButton){
        // stop button
        StopHoldingButton(ep, button);
    }
    else{
        // start button
        
        // release-press action
        if(buttonBehaivor == ButtonBehaivor.ReleasePress){
            while(enableButtonControl){
                // button release during
                WaitUntil(
                    !enableButtonControl,
                    RandomReal(releaseMin < minWaitTime ? minWaitTime : releaseMin, releaseMax)
                );
                if(!enableButtonControl){ return; }

                // start hold button
                if(
                    button == Button.Jump &&
                    hasDoubleJumpButtonAbility &&
                    IsProbabilityTrue(50)
                ){
                    // use double jump ability
                    StartHoldingButton(ep, button);
                    Wait(RandomReal(0.1, 0.5), WaitBehavior.IgnoreCondition);
                    StopHoldingButton(ep, button);
                    Wait(RandomReal(0.1, 0.5), WaitBehavior.IgnoreCondition);                    
                    StartHoldingButton(ep, button);
                }
                else if(
                    button == Button.Ultimate &&
                    (
                        // is using ult already
                        IsUsingUltimate() ||
                        // alive enemies count is low
                        IsProbabilityTrue(50 * (1 - EnemyDensityRateOfAimTargetNear(ActionRange.Close)))
                    )                
                ){
                    // skip press ultimate button 
                    Wait(0.1, WaitBehavior.IgnoreCondition);
                }
                else{
                    StartHoldingButton(ep, button);     // SetButtonBit(button, true);
                }
                        

                // button hold during
                WaitUntil(
                    !enableButtonControl,
                    RandomReal(pressMin < minWaitTime ? minWaitTime : pressMin, pressMax)
                );
                if(!enableButtonControl){ return; }

                // stop hold button
                StopHoldingButton(ep, button);          // SetButtonBit(button, false);
            }
        }
        // release-repeat action
        else if(buttonBehaivor == ButtonBehaivor.ReleaseRepeat){
            while(enableButtonControl){
                // button release during
                WaitUntil(
                    !enableButtonControl,
                    RandomReal(releaseMin < minWaitTime ? minWaitTime : releaseMin, releaseMax));
                if(!enableButtonControl){ return; }

                // set button repeat during
                repeatDuring = RandomReal(pressMin < minWaitTime ? minWaitTime : pressMin, pressMax);
                
                // start repeat button
                isRepeatFiring = true;                  // SetButtonBit(button, true);
                while(
                    isRepeatFiring            
                ){
                    PressButton(ep, button);
                    WaitUntil(
                        !enableButtonControl,
                        0.25
                    );
                    if(!enableButtonControl){ return; }
                }
                // stop repeat button
                                                        // SetButtonBit(button, false);
            }
        }
    }
}

rule: "Bot/ButtonControl/releaseIsRepeatFiring"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    isRepeatFiring
){
    // button repeat during
    Wait(repeatDuring, WaitBehavior.AbortWhenFalse);
    isRepeatFiring = false;
}

// TAG Debug ----------

// rule: "Bot/Debug/ShowDebugInfo"
// Event.OngoingPlayer
// if(
//     isBotEnableTeam &&
//     IsDummyBot()
// ){
//     // enable button text
//     CreateInWorldText(
//         AllPlayers(),
//         <"Bot_Active = <0>\n\rAction_State = <1>\n\rButton_CONTROL = <2>\n\rButton_Flag = <3>",
//             isBotActive ? "true" : "false",
//                 actionState == ActionState.Non ?        "Non" :
//                 actionState == ActionState.Attack ?     "Attack" :
//                 actionState == ActionState.Support ?    "Support" :
//                                                         "???",
//                     enableButtonControl,
//                         buttonFlagText
//         >,
//         EyePosition(ep) + Vector(0, 1.25, 0),
//         0.8, Clipping.DoNotClip, InworldTextRev.VisibleToPositionStringAndColor,
//         enableButtonControl ? Color.Yellow : Color.White,
//         Spectators.DefaultVisibility);

//     // while(true){
//     //     // tagret line
//     //     if(
//     //         actionState != ActionState.Non &&
//     //         aimTarget != null
//     //     ){
//     //         dbgPlyBemEft(EyePosition(ep), BodyPosition(aimTarget));
//     //     }
//     //     Wait(1);
//     // }
// }

// define initialButtonFlag: [false, false, false, false, false, false, false];
// playervar define buttonFlag = initialButtonFlag;

// void SetButtonBit(define button, define state)"SetButtonBit"{
//     switch(button){
//         case Button.PrimaryFire:    if(state) buttonFlag[0] = true;    else buttonFlag[0] = false; break;
//         case Button.SecondaryFire:  if(state) buttonFlag[1] = true;    else buttonFlag[1] = false; break;
//         case Button.Ability1:       if(state) buttonFlag[2] = true;    else buttonFlag[2] = false; break;
//         case Button.Ability2:       if(state) buttonFlag[3] = true;    else buttonFlag[3] = false; break;
//         case Button.Ultimate:       if(state) buttonFlag[4] = true;    else buttonFlag[4] = false; break;
//         case Button.Jump:           if(state) buttonFlag[5] = true;    else buttonFlag[5] = false; break;
//         case Button.Crouch:         if(state) buttonFlag[6] = true;    else buttonFlag[6] = false; break;
//     }
//     UpdateButtonFlagText();
// }

// void ClearButtonBit()"SetButtonBit"{
//     buttonFlag = initialButtonFlag;
//     UpdateButtonFlagText();
// }

// playervar define buttonFlagText;

// void UpdateButtonFlagText()"UpdateButtonFlagText"{
//     buttonFlagText = "";
//     for (define index = 0; index < CountOf(buttonFlag); index++)
//     {
//         if(buttonFlag[index]){
//             buttonFlagText = <"<0><1>", buttonFlagText, "1">;
//         }
//         else{
//             buttonFlagText = <"<0><1>", buttonFlagText, "0">;
//         }
//     }
// }