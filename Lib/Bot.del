import "Utility.del";
import "Debug.del";

// TODO
// bot nead healing state

// TAG public property
globalvar define botAimScat = WorkshopSettingReal("Enemy Bot Settings", "Aim Scattering (0 is head shot)",              0.1, 0, 1000, 3);

// TAG Bot/Spawn ----------
enum BotAsset{
    EnemyType,
    Hero,
    Count
}

// TAG EnemyType ----------
playervar define enemyType;
enum EnemyType{
    None,
    Minion,
    Elite,
    General,
    Boss
}

// TAG BotAsset ----------
void CreateBotsByAssetList(define assetList, define team, define addLimitNum)"CreateBotsByAssetList"{
    // select asset in assetList
    define asset! = ValueInArray(assetList, RandomInteger(0, CountOf(assetList) - 1));
    // make bot by asset
    CreateBotsByAsset(asset, team, addLimitNum);
}

void CreateBotsByAsset(define asset, define team, define addLimitNum)"CreateBotsByAsset"{
    define addNum! = 0;
    // run asset items
    for(define assetIdx! = 0; assetIdx < CountOf(asset); assetIdx++){
        // run bot count in asset
        for(define botCount! = 0; botCount < asset[assetIdx][BotAsset.Count]; botCount ++){
            if(addNum >= addLimitNum){
                break;
            }

            if(IsAssemblingHeroes()){
                Wait(RandomReal(0, 3), WaitBehavior.IgnoreCondition);
            }

            // get empty slot
            define slot! = getEmptySlotNo(team);
            // while(
            //     PlayersInSlot(slot, team) == null
            // ){
                // create bot
                CreateDummyBot(
                    asset[assetIdx][BotAsset.Hero],
                    team,
                    slot,
                    SpawnPoints(team)[0],
                    RandomDirection()
                );
                Wait(0.1, WaitBehavior.IgnoreCondition);
            // }
            // set Bot type as enemy type
            define bot! = PlayersInSlot(slot, team);
            bot.enemyType = asset[assetIdx][BotAsset.EnemyType];
            // count up addNum
            addNum ++;
        }
    }
}

void CreateBotsByHeroList(define heroList, define num, define team)"CreateBotsByHeroList"{
    // create bot by asset
    for(define slotIdx! = 0; slotIdx < num; slotIdx++){
        // get empty slot
        define slot! = getEmptySlotNo(team);
        // while(
        //     PlayersInSlot(slot, team) == null
        // ){
            // create bot
            CreateDummyBot(
                RandomValueInArray(heroList),
                team,
                slot,
                SpawnPoints(team)[0],
                RandomDirection()
            );
            Wait(0.1, WaitBehavior.IgnoreCondition);
        // }
    }
}

void CreateBotsByHeroInput(define hero, define num, define team)"CreateBotsByHeroInput"{
    // create bot by asset
    for(define slotIdx! = 0; slotIdx < num; slotIdx++){
        // get empty slot
        define slot! = getEmptySlotNo(team);
        // while(
        //     PlayersInSlot(slot, team) == null
        // ){
            // create bot
            CreateDummyBot(
                hero,
                team,
                slot,
                SpawnPoints(team)[0],
                RandomDirection()
            );
            Wait(0.1, WaitBehavior.IgnoreCondition);
        // }
    }
}

void DestroyBots(define team!)"DestroyBots"{
    for(define slotIdx! = 0; slotIdx < builtinMaxSlotNum; slotIdx ++){
        DestroyDummyBot(
            team, slotIdx);
        Wait(0.01, WaitBehavior.IgnoreCondition);
    }
}

Number getEmptySlotNo(define team!)"getEmptySlotNo"{
    for(define slotNo! = 0; slotNo < builtinMaxSlotNum; slotNo++){
        if(PlayersInSlot(slotNo, team) == null) {
            return slotNo;
        }
    }
    errLog("getEmptySlotNo not found empty slot");
    return -1;
}

// TAG Bot/SetBotInfo ----------

playervar define heroName;
playervar define supportPrioloty;
playervar define supportButtons;
playervar define attackButtons;
playervar define canFireButtonCombination;

playervar define primaryFireButtonBehaivor;
playervar define primaryFireButtonReleaseMin;
playervar define primaryFireButtonReleaseMax;
playervar define primaryFireButtonPressMin;
playervar define primaryFireButtonPressMax;

playervar define secondaryFireButtonBehaivor;
playervar define secondaryFireButtonReleaseMin;
playervar define secondaryFireButtonReleaseMax;
playervar define secondaryFireButtonPressMin;
playervar define secondaryFireButtonPressMax;

playervar define ability1ButtonReleaseMin;
playervar define ability1ButtonReleaseMax;
playervar define ability1ButtonPressMin;
playervar define ability1ButtonPressMax;

playervar define ability2ButtonReleaseMin;
playervar define ability2ButtonReleaseMax;
playervar define ability2ButtonPressMin;
playervar define ability2ButtonPressMax;

playervar define ultimateButtonReleaseMin;
playervar define ultimateButtonReleaseMax;
playervar define ultimateButtonPressMin;
playervar define ultimateButtonPressMax;

playervar define crouchButtonReleaseMin;
playervar define crouchButtonReleaseMax;
playervar define crouchButtonPressMin;
playervar define crouchButtonPressMax;

playervar define jumpButtonReleaseMin;
playervar define jumpButtonReleaseMax;
playervar define jumpButtonPressMin;
playervar define jumpButtonPressMax;

define ActionRange_Melee: 0;
define ActionRange_Close: 10;
define ActionRange_Middle: 20;
define ActionRange_Far: 30;

playervar define actionRangeMin!;
playervar define actionRangeMax!;

rule: "Bot/SetActionRoutineBySpawned"
Event.OngoingPlayer
if(
    // IsDummyBot() &&
    HasSpawned()
){
    SetHeroActionRoutine();
}

rule: "Bot/SetActionRoutineByStartDuplicate"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    HeroOf() == Hero.Echo &&
    IsDuplicating(ep)
){
    SetHeroActionRoutine();
    // dbgHudTxt(<"<0> is change routin to <1>", ep, heroName>);
}

rule: "Bot/SetActionRoutineByEndDuplicate"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    HeroOf() == Hero.Echo &&
    !IsDuplicating(ep)
){
    SetHeroActionRoutine();
    // dbgHudTxt(<"<0> is change routin to <1>", ep, heroName>);
}

void SetHeroActionRoutine()"SetHeroActionRoutine"{
        target = 0;
        
        heroName = "";
        actionRangeMin = ActionRange_Melee;
        actionRangeMax = ActionRange_Far;
        canFireButtonCombination = false;

        primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        primaryFireButtonReleaseMin = 0;
        primaryFireButtonReleaseMax = 5;
        primaryFireButtonPressMin = 0;
        primaryFireButtonPressMax = 10;

        secondaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        secondaryFireButtonReleaseMin = 0;
        secondaryFireButtonReleaseMax = 5;
        secondaryFireButtonPressMin = 0;
        secondaryFireButtonPressMax = 10;

        ability1ButtonReleaseMin = 0;
        ability1ButtonReleaseMax = 5;
        ability1ButtonPressMin = 0;
        ability1ButtonPressMax = 1;

        ability2ButtonReleaseMin = 0;
        ability2ButtonReleaseMax = 5;
        ability2ButtonPressMin = 0;
        ability2ButtonPressMax = 1;

        ultimateButtonReleaseMin = 0;
        ultimateButtonReleaseMax = 5;
        ultimateButtonPressMin = 0;
        ultimateButtonPressMax = 1;

        crouchButtonReleaseMin = 0;
        crouchButtonReleaseMax = 5;
        crouchButtonPressMin = 0;
        crouchButtonPressMax = 1;

        jumpButtonReleaseMin = 0;
        jumpButtonReleaseMax = 5;
        jumpButtonPressMin = 0;
        jumpButtonPressMax = 1;

        supportPrioloty = 0;
        supportButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];

    define hero! = HeroOf();
    if(
        hero == Hero.Echo &&
        IsDuplicating()
    ){
        hero = HeroBeingDuplicated();
    }
    
    switch(hero){
        case Hero.Ana:
        heroName = "Ana";
        actionRangeMin = ActionRange_Middle;
        actionRangeMax = ActionRange_Far;
        canFireButtonCombination = true;
        secondaryFireButtonPressMin = 20;
        secondaryFireButtonPressMax = 40;
        supportPrioloty = 1;
        supportButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability2
        ];
        break;

        case Hero.Ashe:
        heroName = "Ashe";
        actionRangeMin = ActionRange_Middle;
        actionRangeMax = ActionRange_Far;
        canFireButtonCombination = true;
        primaryFireButtonBehaivor = ButtonBehaivor.ReleaseRepeat;
        secondaryFireButtonPressMin = 30;
        secondaryFireButtonPressMax = 60;
        break;

        case Hero.Baptiste:
        heroName = "Baptiste";
        actionRangeMin = ActionRange_Middle;
        actionRangeMax = ActionRange_Far;
        canFireButtonCombination = true;
        crouchButtonReleaseMax = 1;
        crouchButtonPressMax = 30;
        supportPrioloty = 1;
        supportButtons = [
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.PrimaryFire,
            Button.Ability1
        ];
        break;

        case Hero.Bastion:
        heroName = "Bastion";
        actionRangeMin = ActionRange_Close;
        actionRangeMax = ActionRange_Far;
        primaryFireButtonReleaseMax = 1;
        ability1ButtonReleaseMin = 8;
        ability1ButtonReleaseMax = 8;
        ultimateButtonReleaseMax = 30;
        break;

        case Hero.Brigitte:
        heroName = "Brigitte";
        actionRangeMin = ActionRange_Melee;
        actionRangeMax = ActionRange_Melee;
        canFireButtonCombination = true;
        secondaryFireButtonReleaseMax = 15;
        secondaryFireButtonPressMin = 3;
        secondaryFireButtonPressMax = 6;
        ability2ButtonReleaseMax = 1;
        ultimateButtonReleaseMax = 30;
        supportPrioloty = 0.75;
        supportButtons = [
            Button.SecondaryFire,
            Button.Ability2
        ];
        break;

        case Hero.Cassidy:
        heroName = "Cassidy";
        actionRangeMin = ActionRange_Melee;
        actionRangeMax = ActionRange_Far;
        secondaryFireButtonReleaseMax = 20;
        break;

        case Hero.Doomfist:
        heroName = "Doomfist";
        actionRangeMin = ActionRange_Melee;
        actionRangeMax = ActionRange_Close;
        ability2ButtonReleaseMin = 3;
        secondaryFireButtonPressMin = 1.3;
        secondaryFireButtonPressMax = 1.5;
        break;

        case Hero.Dva:
        heroName = "Dva";
        actionRangeMin = ActionRange_Melee;
        actionRangeMax = ActionRange_Close;
        ultimateButtonReleaseMax = 40;
        break;

        case Hero.Echo:
        heroName = "Echo";
        actionRangeMin = ActionRange_Close;
        actionRangeMax = ActionRange_Middle;
        break;

        case Hero.Genji:
        heroName = "Genji";
        actionRangeMin = ActionRange_Melee;
        actionRangeMax = ActionRange_Close;
        ability1ButtonReleaseMax = 0.5; 
        ability1ButtonPressMax = 0.5; 
        break;

        case Hero.Hanzo:
        heroName = "Hanzo";
        actionRangeMin = ActionRange_Middle;
        actionRangeMax = ActionRange_Far;
        primaryFireButtonReleaseMax = 1;
        primaryFireButtonPressMin = 0.75;
        primaryFireButtonPressMax = 1.25;
        secondaryFireButtonBehaivor = ButtonBehaivor.Non;
        break;

        case Hero.JunkerQueen:
        heroName = "JunkerQueen";
        actionRangeMin = ActionRange_Melee;
        actionRangeMax = ActionRange_Melee;
        break;

        case Hero.Junkrat:
        heroName = "Junkrat";
        actionRangeMin = ActionRange_Close;
        actionRangeMax = ActionRange_Far;
        break;

        case Hero.Kiriko:
        heroName = "Kiriko";
        actionRangeMin = ActionRange_Middle;
        actionRangeMax = ActionRange_Far;
        primaryFireButtonReleaseMax = 1;
        ability1ButtonPressMax = 1;
        ability1ButtonReleaseMax = 1;
        supportPrioloty = 1;
        supportButtons = [
            Button.PrimaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.SecondaryFire
        ];
        break;

        case Hero.Lucio:
        heroName = "Lucio";
        actionRangeMin = ActionRange_Close;
        actionRangeMax = ActionRange_Middle;
        ultimateButtonReleaseMax = 15;
        supportPrioloty = 0.5;
        supportButtons = [
            Button.Ability1,
            Button.Ability2
        ];
        break;

        case Hero.Mei:
        heroName = "Mei";
        actionRangeMin = ActionRange_Melee;
        actionRangeMax = ActionRange_Close;
        ultimateButtonReleaseMax = 30;
        break;

        case Hero.Mercy:
        heroName = "Mercy";
        actionRangeMin = ActionRange_Middle;
        actionRangeMax = ActionRange_Far;
        primaryFireButtonReleaseMax = 1;
        secondaryFireButtonReleaseMax = 10;
        ability2ButtonPressMax = 10;
        ability2ButtonReleaseMax = 0.1;
        supportPrioloty = 1;
        supportButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        break;

        case Hero.Moira:
        heroName = "Moira";
        actionRangeMin = ActionRange_Close;
        actionRangeMax = ActionRange_Middle;
        supportPrioloty = 1;
        supportButtons = [
            Button.PrimaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        break;

        case Hero.Orisa:
        heroName = "Orisa";
        actionRangeMin = ActionRange_Melee;
        actionRangeMax = ActionRange_Middle;
        primaryFireButtonPressMax = 15;        
        break;

        case Hero.Pharah:
        heroName = "Pharah";
        actionRangeMin = ActionRange_Close;
        actionRangeMax = ActionRange_Middle;
        break;

        case Hero.Reaper:
        heroName = "Reaper";
        actionRangeMin = ActionRange_Melee;
        actionRangeMax = ActionRange_Close;
        primaryFireButtonPressMax = 20;
        ability2ButtonReleaseMax = 20;
        break;

        case Hero.Reinhardt:
        heroName = "Reinhardt";
        actionRangeMin = ActionRange_Melee;
        actionRangeMax = ActionRange_Melee;
        secondaryFireButtonReleaseMax = 15;
        secondaryFireButtonPressMin = 3;
        secondaryFireButtonPressMax = 6;
        primaryFireButtonPressMax = 20;
        primaryFireButtonReleaseMax = 1;
        break;

        case Hero.Roadhog:
        heroName = "Roadhog";
        actionRangeMin = ActionRange_Melee;
        actionRangeMax = ActionRange_Close;
        primaryFireButtonPressMax = 10;
        break;

        case Hero.Sigma:
        heroName = "Sigma";
        actionRangeMin = ActionRange_Close;
        actionRangeMax = ActionRange_Middle;
        primaryFireButtonReleaseMax = 0;
        secondaryFireButtonReleaseMax = 5;
        secondaryFireButtonPressMax = 1;
        ultimateButtonReleaseMax = 15;
        break;

        case Hero.Sojourn:
        heroName = "Sojourn";
        actionRangeMin = ActionRange_Close;
        actionRangeMax = ActionRange_Far;
        secondaryFireButtonReleaseMax = 10;
        break;
        
        case Hero.Soldier76:
        heroName = "Soldier76";
        actionRangeMin = ActionRange_Close;
        actionRangeMax = ActionRange_Far;
        break;

        case Hero.Sombra:
        heroName = "Sombra";
        actionRangeMin = ActionRange_Close;
        actionRangeMax = ActionRange_Middle;
        secondaryFireButtonPressMin = 1.5;
        ability2ButtonReleaseMax = 10;
        ability2ButtonPressMax = 0.5;
        break;

        case Hero.Symmetra:
        heroName = "Symmetra";
        actionRangeMin = ActionRange_Melee;
        actionRangeMax = ActionRange_Close;
        secondaryFireButtonPressMin = 1;
        secondaryFireButtonPressMax = 3;
        ability1ButtonReleaseMin = 1;
        ability1ButtonReleaseMax = 3;
        ability2ButtonReleaseMax = 30;
        break;

        case Hero.Torbjorn:
        heroName = "Torbjorn";
        actionRangeMin = ActionRange_Close;
        actionRangeMax = ActionRange_Middle;
        break;

        case Hero.Tracer:
        heroName = "Tracer";
        actionRangeMin = ActionRange_Close;
        actionRangeMax = ActionRange_Middle;
        ultimateButtonReleaseMin = 1;
        ultimateButtonReleaseMax = 1;
        break;

        case Hero.Widowmaker:
        heroName = "Widowmaker";
        actionRangeMin = ActionRange_Middle;
        actionRangeMax = ActionRange_Far;
        canFireButtonCombination = true;
        primaryFireButtonReleaseMin = 0.9;
        primaryFireButtonReleaseMax = 1.1;
        primaryFireButtonPressMin = 0;
        primaryFireButtonPressMax = 1;
        secondaryFireButtonPressMin = 30;
        secondaryFireButtonPressMax = 60;
        ability1ButtonReleaseMax = 30;
        ability2ButtonReleaseMax = 30;
        jumpButtonReleaseMax = 30;
        break;

        case Hero.Winston:
        heroName = "Winston";
        actionRangeMin = ActionRange_Melee;
        actionRangeMax = ActionRange_Close;
        ultimateButtonReleaseMax = 40;
        break;

        case Hero.WreckingBall:
        heroName = "WreckingBall";
        actionRangeMin = ActionRange_Melee;
        actionRangeMax = ActionRange_Middle;
        primaryFireButtonReleaseMax = 15;
        primaryFireButtonPressMax = 20;
        secondaryFireButtonPressMin = 6;
        secondaryFireButtonPressMax = 15;
        ability1ButtonReleaseMin = 5;
        ability1ButtonReleaseMax = 10;
        break;

        case Hero.Zarya:
        heroName = "Zarya";
        actionRangeMin = ActionRange_Close;
        actionRangeMax = ActionRange_Middle;
        ability1ButtonReleaseMax = 10;
        ability1ButtonPressMax = 0.5;
        ability2ButtonReleaseMax = 0.5;
        ability2ButtonPressMax = 0.5;
        supportPrioloty = 0.5;
        supportButtons = [
            Button.Ability2
        ];
        attackButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1
        ];
        break;

        case Hero.Zenyatta:
        heroName = "Zenyatta";
        actionRangeMin = ActionRange_Middle;
        actionRangeMax = ActionRange_Far;
        primaryFireButtonReleaseMin = 1;
        secondaryFireButtonReleaseMin = 1;
        ability1ButtonPressMin = 0.5;
        ability1ButtonPressMax = 0.5;
        ability1ButtonReleaseMin = 0.5;
        ability1ButtonReleaseMax = 0.5;
        ability2ButtonPressMin = 0.5;
        ability2ButtonPressMax = 0.5;
        ability2ButtonReleaseMin = 0.5;
        ability2ButtonReleaseMax = 0.5;
        ultimateButtonReleaseMax = 30;
        supportPrioloty = 0.5;
        supportButtons = [
            Button.Ability1,
            Button.Ability2
        ];
        break;

        case Hero.Ramattra:
        heroName = "Ramattra";
        actionRangeMin = ActionRange_Melee;
        actionRangeMax = ActionRange_Close;
        ability1ButtonReleaseMin = 12;
        ability1ButtonReleaseMax = 16;
        ability1ButtonPressMin = 1;
        ability1ButtonPressMax = 1;
        secondaryFireButtonReleaseMax = 10;
        secondaryFireButtonPressMin = 2;
        secondaryFireButtonPressMax = 4;
        break;

        default:
    }
}

enum ActionState{
    Non,
    Changing,
    Attack,
    Support
}

enum ActionRange{
    Non,
    Melee,
    Close,
    Middle,
    Far
}

enum ButtonBehaivor{
    Non,
    ReleasePress,
    ReleaseRepeat
}

// TAG Bot/ActionState/StateControl ----------
playervar define watchUpdateRate = 1;
playervar define actionState;
playervar define target;

define FindAttackTarget()"FindAttackTarget"{
    return FirstOf(
        SortedArray(
            FilteredArray(
                AllLivingPlayers(EnemyTeamOf()),
                (
                    IsInLineOfSight(EyePosition(ep), EyePosition(ae), BarrierLOS.NoBarriersBlock) &&
                    !(
                        IsStealth(ae) &&
                        DistanceBetween(ae, ep) >= 4
                    )
                )
            ),
            DistanceBetween(ep, ae)
        )
    );
}

define FindSupportTarget()"FindSupportTarget"{
    return FirstOf(
        SortedArray(
            FilteredArray(
                (
                    CanResurrect(ep) ?
                        AllPlayers(TeamOf()) :
                        AllLivingPlayers(TeamOf())),
                (
                    ae != ep &&
                    (
                        CanPhantom(ep) ?
                        true :
                        IsInLineOfSight(EyePosition(ep), EyePosition(ae), BarrierLOS.NoBarriersBlock)
                    ) &&
                    NormalizedHealth(ae) < 1
                )
            ),
            NormalizedHealth(ae)
        )
    );
}

void ApplyNextActionState(define player!, define nextActionState!) playervar "ApplyNextActionState"{
    // if state changed
    if(nextActionState != player.actionState){
        // next state is not Non state
        if(nextActionState != ActionState.Non){
            // set Non state for restart button control
            player.actionState = ActionState.Changing;
            WaitChangeState();
        }       
        // set next state
        player.actionState = nextActionState;        
    }
}

rule: "Bot/ActionState/StateControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    HasSpawned() &&
    IsAlive()
){
    WaitRandomForDistributeServerLoad();

    // get next state
    define nextActionState!;
    // is alive
    if(
        
        !IsInSpawnRoom()
    ){ 
        // get targetSighted
        define targetSighted! =
            target != 0 &&          // targe valid
            target != ep &&         // not own
            IsAlive(target) &&      // target alive
            IsInLineOfSight(ep, target, BarrierLOS.NoBarriersBlock) &&  // in line            
            !(
                TeamOf() != TeamOf(target) &&
                IsStealth(target) &&
                DistanceBetween(target, ep) >= 4
            );

        define tryGetTarget! = false;
        
        // target not Sighted
        if(!targetSighted){
            tryGetTarget = true;
        }
        // is support role hero and do support
        else if(
            0 < supportPrioloty &&
            actionState == ActionState.Support
        ){
            // heal completed or target dead
            if(
                NormalizedHealth(target) >= 1 ||
                IsDead(target)
            ){
                tryGetTarget = true;
            }
            // change target dependent on support target health
            else if(
                ProbabilityTrue(100 * NormalizedHealth(target))
            ){
                tryGetTarget = true;
            }
        }
        // is not support role hero
        else{
            // change target dependent on attack target helth & attack prob
            if(
                ProbabilityTrue(50 * NormalizedHealth(target))
            ){
                tryGetTarget = true;
            }
        }

        // get new target
        if(tryGetTarget){
            // is support role hero
            if(ProbabilityTrue(100 * supportPrioloty))
            {
                // find support target
                target = FindSupportTarget();

                // not found heal target
                if(target == 0){
                    // find attack target
                    target = FindAttackTarget();
                }
            }
            else{
                // find attack target
                target = FindAttackTarget();
            }
        }

        // has target
        if(
            HasSpawned(target)
        ){
            // target is enemy
            if(TeamOf() != TeamOf(target)){
                // Attack state
                nextActionState = ActionState.Attack;
            }
            else{
                // Support state
                nextActionState = ActionState.Support; 
            }
        }
        else{
            // Non state by target not found
            nextActionState = ActionState.Non;
        }       
    }
    else{
        // Non state by dead
        nextActionState = ActionState.Non; 
    }

    if(
        actionState != ActionState.Attack &&
        nextActionState == ActionState.Attack
    ){
        // call attack by trans to attack state
        CallAttackNearBot(target);
    }

    // apply next state
    ApplyNextActionState(ep, nextActionState);

    Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

rule: "Bot/ActionState/SetNonStateByDead"
Event.OnDeath
if(
    IsDummyBot() &&
    Victim() == ep &&
    actionState != ActionState.Non
){
    // apply next state
    ApplyNextActionState(ep, ActionState.Non);
}

rule: "Bot/ActionState/ChangeTargetByTargetDead"
Event.OnElimination
if(
    IsDummyBot() &&
    Victim() == target &&
    actionState != ActionState.Non
){
    // is support role hero
    if(ProbabilityTrue(100 * supportPrioloty))
    {
        // find support target
        target = FindSupportTarget();
        // not found heal target
        if(target == 0){
            // find attack target
            target = FindAttackTarget();
        }
    }
    else{
        // find attack target
        target = FindAttackTarget();
    }
}

rule: "Bot/ActionState/ChangeTargetByDamageTaken"
Event.OnDamageTaken
if(
    IsDummyBot() &&
    actionState == ActionState.Attack
){
    // change target dependent on attack target helth & attack prob
    if(
        ProbabilityTrue(50 * NormalizedHealth(target))
    ){
        // set attacker to target
        target = Attacker();
    }
    Wait(3.0, WaitBehavior.IgnoreCondition);
}

rule: "Bot/ActionState/CallAttackByDamageTaken"
Event.OnDamageTaken
if(
    IsDummyBot() &&
    Attacker() != ep
){
    // call attack by damage taken
    CallAttackNearBot(Attacker());
}

globalvar define isCallAttackCoolingDown! = false;

void CallAttackNearBot(define attackTarget!)"CallAttackNearBot"{
    AbortIf(isCallAttackCoolingDown);
    isCallAttackCoolingDown = true;
    define nearFriends = FilteredArray(
        PlayersWithinRadius(
            ep, 30, TeamOf(ep), RadiusLOS.Off
        ),
        (
            // ae != ep &&
            IsDummyBot() &&
            IsAlive(ae) &&
            ae.actionState == ActionState.Non
        )
    );

    // dbgHudTxt(<"CallAttackNearBot <0>", CountOf(nearFriends)>);
    
    for(define nearFriendsIndex! = 0; nearFriendsIndex < CountOf(nearFriends); nearFriendsIndex ++){
        WaitRandomForDistributeServerLoad();
        // set target
        nearFriends[nearFriendsIndex].target = attackTarget;
        // set attack 
        ApplyNextActionState(nearFriends[nearFriendsIndex], ActionState.Attack);
        Wait(0.1, WaitBehavior.AbortWhenFalse);
    }
}

rule: "Bot/ActionState/callAttackCoolDown"
Event.OngoingGlobal
if(
    isCallAttackCoolingDown
){
    Wait(1.0, WaitBehavior.IgnoreCondition);
    isCallAttackCoolingDown = false;
    Loop();
}

playervar define statusText;
playervar define moveDirFB;
playervar define moveDirLR;

playervar define enableHealingMove = true;

void setMoveDir() playervar "setMoveDir"{
    // need healing
    if(
        enableHealingMove &&
        NormalizedHealth() < 0.5
    ){
        WaitRandomForDistributeServerLoad();
        // move to healer for heal

        // set to near healer
        define moveToPlayer! = 
            FirstOf(
                SortedArray(
                    FilteredArray(
                        AllLivingPlayers(TeamOf()),
                        (
                            ae != ep &&
                            0 < ae.supportPrioloty &&
                            IsInLineOfSight(ae, ep)
                        )
                    ),
                    DistanceBetween(ae, ep)
                )
            );
        
        // no near healer
        if(moveToPlayer == null){
            // set to any role teammate
            moveToPlayer = ClosestPlayerTo(ep, TeamOf());
        }

        define dir! = LocalVectorOf(DirectionTowards(ep, moveToPlayer), ep, Transformation.Rotation);
        moveDirFB = Vector(0, 0, ZOf(dir));
        moveDirLR = Vector(XOf(dir), 0, 0);
    }
    // not need healing
    else{
        // move to target for combat

        // set move dir front/back
        define distToTarget! = DistanceBetween(ep, target);
        define distRate! = actionState == ActionState.Attack ? 1 : 0.7;
        // target is far
        if(
            distToTarget > (actionRangeMax * distRate)
        ){
            moveDirFB = Forward();
        }
        // target is close
        else if(
            distToTarget < (actionRangeMin * distRate)
        ){
            moveDirFB = Backward();
        }
        else{
            // no moveDir
            moveDirFB = NoDirection();
        }

        // set move dir left/right
        if(actionState == ActionState.Attack){
            define distanceToTarget! = DistanceBetween(ep, target);
            // start sidestep by distance to target
            if(
                ProbabilityTrue(
                    25 +
                    (
                        100 *
                        (1 - NormalizedHealth()) *      // by health
                        (1 - (distanceToTarget / 30))   // by target distance
                    )
                )
            ){
                // start sidestep
                // already has sidestep
                if(moveDirLR != NoDirection()){
                    if(
                        ProbabilityTrue(
                            25 +
                            (
                                100 *
                                (1 - NormalizedHealth()) *      // by health
                                (1 - (distanceToTarget / 30))   // by target distance
                            )
                        )
                    ){
                        // reverse sidestep
                        moveDirLR = -moveDirLR;
                    }
                    else{
                        // stop sidestep
                        moveDirLR = NoDirection();
                    }
                }
                else{
                    if(ProbabilityTrue(50)){
                        // right sidestep
                        moveDirLR = Right();
                    }
                    else{
                        // left sidestep
                        moveDirLR = Left();
                    }
                }
            }
            else{
                // stop sidestep
                moveDirLR = NoDirection();
            }
        }
        else{
            moveDirLR = NoDirection();
        }
    }
}

define noMoving: false;   // for debug

playervar define enableCheckAbyss! = true;

void StartMove() playervar "StartMove"{
    AbortIf(noMoving);

    define confirmMoveDir! = moveDirFB + moveDirLR;
    // move to position is abyss
    if(
        enableCheckAbyss &&
        IsBelowAbyss(
            BlockedPositonByLocalVector(
                confirmMoveDir,
                walkMeterPerSec * watchUpdateRate
            )
        )
        // false
    ){
        StopMove();
    }
    else{
        if(
            confirmMoveDir != NoDirection()
        ){
            StartThrottleInDirection(
                ep,
                confirmMoveDir,
                1,
                Relative.ToPlayer,
                ThrottleBehavior.ReplaceExistingThrottle,
                ThrottleRev.DirectionAndMagnitude
            );
        }
        else{
            StopMove();
        }
    }
}

void StopMove()"StopMove"{
    StopThrottleInDirection();
} 

define aimingPosition:
    IsInAlternateForm(target) ?
        EyePosition(target) - Vector(0, 0.6, 0)     // body position
    :
        EyePosition(target) + Vector(0, 0.2, 0)     // head position
            +
    RandomPosition(botAimScat, botAimScat, botAimScat)  // aim scattet
            +
    Vector(0, -(botAimScat / 2), 0);    // vertical offset

void StartFacingTarget()"StartFacingTarget"{
    if(
        target != 0 &&
        target != null &&
        IsAlive(target)
    ){
        StartFacing(
            ep, DirectionTowards(EyePosition(), aimingPosition),
            300, Relative.ToWorld, FacingRev.DirectionAndTurnRate);
    }
}

// TAG Bot/ActionState/Non ----------
rule: "Bot/ActionState/Non"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    actionState == ActionState.Non
){
    statusText = <"Non">;

    moveDirFB = NoDirection();
    moveDirLR = NoDirection();
    target = 0;
    StopMove();
    Wait(0.1, WaitBehavior.AbortWhenFalse);

    // hero unique action
    polingHeroUniqueAction();

    // action loop
    while(actionState == ActionState.Non){
        WaitRandomForDistributeServerLoad();
        if(IsAlive()){
            define nearEnemy! = ClosestPlayerTo(ep, EnemyTeamOf());
            if(
                nearEnemy != null &&
                DistanceBetween(ep, nearEnemy) <= 30
            ){
                // set facing to near enemy
                StartFacing(
                    ep, DirectionTowards(ep, nearEnemy),
                    300, Relative.ToWorld, FacingRev.DirectionAndTurnRate);
            }
            else{
                // stop facing
                StopFacing();
            }
        }
        else{
            StopFacing();
        }
        Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    }
}

// TAG Bot/ActionState/AttackOrSupport ----------
rule: "Bot/ActionState/AttackOrSupport"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    (
        actionState == ActionState.Attack ||
        actionState == ActionState.Support
    )
){
    // start facing direction
    StartFacingTarget();
    Wait(0.1, WaitBehavior.AbortWhenFalse);

    // action loop
    while(
        actionState == ActionState.Attack ||
        actionState == ActionState.Support
    ){
        WaitRandomForDistributeServerLoad();

        // hero unique action
        polingHeroUniqueAction();

        // set moveDir direction
        setMoveDir();

        // start move by moveDir and sideStepDir
        StartMove();

        Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    }
}

// TAG Bot/HeroUniqueAction ----------
define MercyStaff: 1;
define MercyPistol: 2;

void polingHeroUniqueAction() playervar "polingHeroUniqueAction"{
    // common action
    // melee
    while(
        actionState == ActionState.Attack &&
        IsAlive(target) &&
        Health(target) <= (25 * 2) &&
        DistanceBetween(ep, target) <= 2.5
    ){
        PressButton(ep, Button.Melee);
        Wait(0.5, WaitBehavior.AbortWhenFalse);
    }

    // reload
    if(
        actionState == ActionState.Non ||
        (MaxAmmo(ep, 0) > 0 && Ammo(ep, 0) <= 0) ||
        (MaxAmmo(ep, 1) > 0 && Ammo(ep, 1) <= 0)
    ){
        PressButton(ep, Button.Reload);
    }

    // hero unique action
    else if(
        actionState != ActionState.Non
    ){
        // ashe
        if(HeroOf() == Hero.Ashe){
            // reduce fire when reloading
            if(
                Ammo(ep, 0) <= MaxAmmo(ep, 0) / 2 ||
                IsReloading()
            ){
                    StopHoldingButton(ep, Button.PrimaryFire);
                    StopHoldingButton(ep, Button.SecondaryFire);
                    StopHoldingButton(ep, Button.Ability1);
                    StopHoldingButton(ep, Button.Ability2);
                    Wait(0.1, WaitBehavior.AbortWhenFalse);
                    PressButton(ep, Button.Reload);
            }
        }
        // Mercy
        else if(HeroOf() == Hero.Mercy){
            // change weapon
            if(actionState == ActionState.Attack){
                SetWeapon(ep, MercyPistol);
            }
            else{
                SetWeapon(ep, MercyStaff);
                if(
                    TeamOf() == TeamOf(target)
                ){
                    if(
                        ProbabilityTrue(100 * NormalizedHealth(target))
                    ){
                        // damage boost
                        StopHoldingButton(ep, Button.PrimaryFire);
                        StartHoldingButton(ep, Button.SecondaryFire);
                    }
                    else{
                        // heal
                        StopHoldingButton(ep, Button.SecondaryFire);
                        StartHoldingButton(ep, Button.PrimaryFire);
                    }
                }
            }
        }
        // WreckingBall
        else if(HeroOf() == Hero.WreckingBall){
            // jump for pile driver
            if(
                AbilityCooldown(ep, Button.Crouch) <= 0 &&
                IsButtonHeld(ep, Button.Crouch)
            ){
                ApplyImpulse(ep, Up(),
                    10, Relative.ToWorld, ContraryMotion.Cancel);
            }
            // accsell for ball tackle
            while(IsFiringSecondary(ep)){
                // for ball charge
                define boostDir! = RandomValueInArray([Right(), Right(), Left(), Left(), Forward(), Backward()]);
                ApplyImpulse(ep, boostDir,
                    30, Relative.ToWorld, ContraryMotion.Cancel);
                Wait(0.5, WaitBehavior.AbortWhenFalse);
            }
        }
    }
}

define AbortIfNotDepEcho()"AbortIfNotDepEcho"{
    if(HeroOf() == Hero.Echo){
        AbortIf(!IsDuplicating());
    }
}

rule: "Bot/HeroUniqueAction/positionMoveUltmate"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    IsUsingUltimate()
){
    AbortIfNotDepEcho();

    define isPositionMoveUltmate;
    define waitForStartMove!;
    define moveSpeed!;
    define attackCount!;
    define multiPosAttack!;

    // postion move hero
    if(
        HeroOf() == Hero.Doomfist ||
        HeroBeingDuplicated() == Hero.Doomfist
    ){
        isPositionMoveUltmate = true;
        waitForStartMove = 0.5;
        moveSpeed = 0.06;
        attackCount = 1;
        multiPosAttack = false;
    }
    else if(
        HeroOf() == Hero.Bastion ||
        HeroBeingDuplicated() == Hero.Bastion
    ){
        isPositionMoveUltmate = true;
        waitForStartMove = 1.0;
        moveSpeed = 0.05;
        attackCount = 3;
        multiPosAttack = ProbabilityTrue(50);
    }
    else if(
        HeroOf() == Hero.Junkrat ||
        HeroBeingDuplicated() == Hero.Junkrat
    ){
        isPositionMoveUltmate = true;
        waitForStartMove = 1.5;
        moveSpeed = 0.075;
        attackCount = 1;
        multiPosAttack = false;
    }

    if(isPositionMoveUltmate){
        // stop current moving input
        StopMove();
        StopHoldingButton(ep, Button.PrimaryFire);
        StopHoldingButton(ep, Button.SecondaryFire);
        // wait for start mode
        Wait(waitForStartMove, WaitBehavior.AbortWhenFalse);
        // start move postion selecter to foward
        moveDirFB = Forward();
        moveDirLR = NoDirection();
        StartMove();
        // decrease move speed if multi position attack mode
        if(multiPosAttack) moveSpeed -= 0.01;
        // wait for arrival target
        define dist! = DistanceBetween(ep, target);
        dist = dist <= 5 ? 5 : dist;
        Wait(dist * (moveSpeed), WaitBehavior.AbortWhenFalse);
        // stop move if not multi position attack mode
        if(!multiPosAttack) StopMove();
        // trigger attack by attackCount
        for(; 0 < attackCount; attackCount--){
            PressButton(ep, Button.PrimaryFire);
            if(0 < attackCount){
                // button press with random interval
                Wait(RandomReal(0.2, 0.5), WaitBehavior.IgnoreCondition);
            }
        }
        // reduce walking after ult
        StopMove();
    }
}

define FacingTargetBetweenPosition(define distRate!)"FacingTargetBetweenPosition"{
        StartFacing(
        ep, DirectionTowards(
                EyePosition(),
                PositionOf(ep) +
                DirectionTowards(ep, target) *
                DistanceBetween(ep, target) * distRate
            ),
            300, Relative.ToWorld, FacingRev.DirectionAndTurnRate
        );
        Wait(0.5, WaitBehavior.IgnoreCondition);
}

rule: "Bot/HeroUniqueAction/positionAimUltmate"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    UltimateChargePercent() >= DefaultPercentage() &&
    IsButtonHeld(ep, Button.Ultimate)
){
    AbortIfNotDepEcho();

    define isPositionAimUltmate;
    
    // postion aim hero
    if(
        HeroOf() == Hero.Baptiste ||
        HeroBeingDuplicated() == Hero.Baptiste
    ){
        isPositionAimUltmate = true;
    }
    else if(
        HeroOf() == Hero.Symmetra ||
        HeroBeingDuplicated() == Hero.Symmetra
    ){
        isPositionAimUltmate = true;
    }

    if(isPositionAimUltmate){
        StopHoldingButton(ep, Button.PrimaryFire);
        StopHoldingButton(ep, Button.SecondaryFire);
        for(define tryCount!; tryCount < 6; tryCount++){
            FacingTargetBetweenPosition(0.5);
            PressButton(ep, Button.PrimaryFire);
            if(UltimateChargePercent() < DefaultPercentage()){
                break;
            }
        }
        StartFacingTarget();
    }
}

rule: "Bot/HeroUniqueAction/positionAimSecondary"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    !IsUsingAbility1() &&
    AbilityCooldown(ep, Button.SecondaryFire) <= 0 &&
    IsButtonHeld(ep, Button.SecondaryFire)
){
    AbortIfNotDepEcho();

    define isPositionAimSecondary;

    if(
        HeroOf() == Hero.Ramattra ||
        HeroBeingDuplicated() == Hero.Ramattra
    ){
        isPositionAimSecondary = true;
    }

    if(isPositionAimSecondary){
        StopHoldingButton(ep, Button.PrimaryFire);
        StopHoldingButton(ep, Button.SecondaryFire);
        for(define tryCount!; tryCount < 6; tryCount++){
            FacingTargetBetweenPosition(0.3);
            PressButton(ep, Button.SecondaryFire);
            if(AbilityCooldown(ep, Button.SecondaryFire) > 0){
                break;
            }
        }
        StartFacingTarget();
    }
}

// TAG Bot/ButtonControl ----------
enum ButtonControl{
    button,
    buttonBehaivor,
    releaseMin,
    releaseMax,
    pressMin,
    pressMax
}

playervar define isRepeaFiring;
playervar define repeatDuring;


Boolean isMatchButton(define matchButton!, define butttons!){
    return IsTrueForAny(butttons, ae == matchButton);
}

define buttonControlPressScale: 1.0;
define buttonControlReleaseScale: 1.0;
define noShooting: false;   // for debug

void StartButtonControl(define bc){
    AbortIf(noShooting);

    define startButton! = false;
    define fireAndAbilityButtons! = [Button.PrimaryFire, Button.SecondaryFire, Button.Ability1, Button.Ability2];
    // if fire or ability button
    if(
        isMatchButton(bc[ButtonControl.button], fireAndAbilityButtons)
    ){
        // if match attack buttons
        if(
            actionState == ActionState.Attack &&
            isMatchButton(bc[ButtonControl.button], attackButtons)
        ){
            startButton = true;
        }
        // if match Support buttons
        else if(
            actionState == ActionState.Support &&
            isMatchButton(bc[ButtonControl.button], supportButtons)
        ){
            startButton = true;
        }
    }
    else{
        startButton = true;
    }

    // is not start button
    if(!startButton){
        // stop button
        StopHoldingButton(ep, bc[ButtonControl.button]);
    }
    else{
        // start button

        // not conbination fire
        if(!canFireButtonCombination){
            // if start primary button, release secondary button
            if(
                bc[ButtonControl.button] == Button.PrimaryFire &&
                IsButtonHeld(ep, Button.SecondaryFire)
            ){
                StopHoldingButton(ep, Button.SecondaryFire);
            }
            // if start secondary button, release primary button
            else if(
                bc[ButtonControl.button] == Button.SecondaryFire &&
                IsButtonHeld(ep, Button.PrimaryFire)
            ){
                StopHoldingButton(ep, Button.PrimaryFire);
            }
        }

        // ajust max to min when over
        if(bc[ButtonControl.releaseMax] < bc[ButtonControl.releaseMin]){
            bc[ButtonControl.releaseMax] = bc[ButtonControl.releaseMin];
        }
        if(bc[ButtonControl.pressMax] < bc[ButtonControl.pressMin]){
            bc[ButtonControl.pressMax] = bc[ButtonControl.pressMin];
        }

        // release-press action
        if(bc[ButtonControl.buttonBehaivor] == ButtonBehaivor.ReleasePress){
            while(true){
                Wait(
                    RandomReal(
                        bc[ButtonControl.releaseMin],
                        bc[ButtonControl.releaseMax]
                    ) * buttonControlReleaseScale,
                    WaitBehavior.AbortWhenFalse
                );

                StartHoldingButton(ep, bc[ButtonControl.button]);
                Wait(
                    RandomReal(
                        bc[ButtonControl.pressMin],
                        bc[ButtonControl.pressMax]
                    ) * buttonControlPressScale,
                    WaitBehavior.AbortWhenFalse
                );

                StopHoldingButton(ep, bc[ButtonControl.button]);
                PressFirstButtonWhenIdle();
            }
        }
        // release-repeat action
        else if(bc[ButtonControl.buttonBehaivor] == ButtonBehaivor.ReleaseRepeat){
            while(true){
                Wait(
                    RandomReal(
                        bc[ButtonControl.releaseMin],
                        bc[ButtonControl.releaseMax]
                    ) * buttonControlReleaseScale,
                    WaitBehavior.AbortWhenFalse
                );

                repeatDuring = 
                    RandomReal(
                        bc[ButtonControl.pressMin],
                        bc[ButtonControl.pressMax]
                    ) * buttonControlPressScale;
                isRepeaFiring = true;

                while(isRepeaFiring){
                    PressButton(ep, bc[ButtonControl.button]);
                    Wait(0.2, WaitBehavior.AbortWhenFalse);
                }

                PressFirstButtonWhenIdle();
            }
        }
        // else
    }
}

rule: "Bot/ButtonControl/releaseIsRepeaFiring"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    isRepeaFiring
){
    Wait(repeatDuring, WaitBehavior.AbortWhenFalse);
    isRepeaFiring = false;
}

void PressFirstButtonWhenIdle()"PressFirstButtonWhenIdle"{
    Wait(0.1, WaitBehavior.AbortWhenFalse);
    if(
        !IsFiringPrimary() &&
        !IsFiringSecondary() &&
        !IsUsingAbility1() &&
        !IsUsingAbility2()
    ){
        define button!;
        if(actionState == ActionState.Attack){
            StartHoldingButton(ep, FirstOf(attackButtons));
        }
        else if(actionState == ActionState.Support){
            StartHoldingButton(ep, FirstOf(supportButtons));
        }
    }

}

// TAG Bot/ButtonControl/PrimaryFire ----------
define enableButtonControlState:
    actionState == ActionState.Attack ||
    actionState == ActionState.Support;

rule: "Bot/ButtonControl/PrimaryFire/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState
){
    StartButtonControl(
        [
            Button.PrimaryFire,
            primaryFireButtonBehaivor,
            primaryFireButtonReleaseMin,
            primaryFireButtonReleaseMax,
            primaryFireButtonPressMin,
            primaryFireButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/SecondaryFire ----------
rule: "Bot/ButtonControl/SecondaryFire/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState
){
    StartButtonControl(
        [
            Button.SecondaryFire,
            secondaryFireButtonBehaivor,
            secondaryFireButtonReleaseMin,
            secondaryFireButtonReleaseMax,
            secondaryFireButtonPressMin,
            secondaryFireButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Ability1 ----------
rule: "Bot/ButtonControl/Ability1/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState
){
    StartButtonControl(
        [
            Button.Ability1,
            ButtonBehaivor.ReleasePress,
            ability1ButtonReleaseMin,
            ability1ButtonReleaseMax,
            ability1ButtonPressMin,
            ability1ButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Ability2 ----------
rule: "Bot/ButtonControl/Ability2/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState
){
    StartButtonControl(
        [
            Button.Ability2,
            ButtonBehaivor.ReleasePress,
            ability2ButtonReleaseMin,
            ability2ButtonReleaseMax,
            ability2ButtonPressMin,
            ability2ButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Ultimate ----------
rule: "Bot/ButtonControl/Ultimate/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState &&
    UltimateChargePercent() >= DefaultPercentage()
){
    StartButtonControl(
        [
            Button.Ultimate,
            ButtonBehaivor.ReleasePress,
            ultimateButtonReleaseMin,
            ultimateButtonReleaseMax,
            ultimateButtonPressMin,
            ultimateButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Crouch ----------
rule: "Bot/ButtonControl/Crouch/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState
){
    StartButtonControl(
        [
            Button.Crouch,
            ButtonBehaivor.ReleasePress,
            crouchButtonReleaseMin,
            crouchButtonReleaseMax,
            crouchButtonPressMin,
            crouchButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Jump ----------
rule: "Bot/ButtonControl/Jump/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState
){
    StartButtonControl(
        [
            Button.Jump,
            ButtonBehaivor.ReleasePress,
            jumpButtonReleaseMin,
            jumpButtonReleaseMax,
            jumpButtonPressMin,
            jumpButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Reload ----------
/*
disabled rule: "Bot/ButtonControl/Reload/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState
){
    StartButtonControl(
        [
            Button.Reload,
            ButtonBehaivor.ReleasePress,
            5,
            15,
            0,
            1
        ]
    );
}
*/

// TAG Bot/ButtonControl/StopButtonControl ----------
rule: "Bot/ButtonControl/StopButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    !enableButtonControlState
){
    StopHoldingButton(ep, Button.PrimaryFire);
    StopHoldingButton(ep, Button.SecondaryFire);
    StopHoldingButton(ep, Button.Ability1);
    StopHoldingButton(ep, Button.Ability2);
    StopHoldingButton(ep, Button.Ultimate);
    StopHoldingButton(ep, Button.Jump);
    StopHoldingButton(ep, Button.Crouch);
    // StopHoldingButton(ep, Button.Reload);
}

// TAG Debug ----------
