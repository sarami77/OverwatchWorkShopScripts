import "Utility.del";
import "Debug.del";

// TAG public property
globalvar define botAimScat = WorkshopSettingReal("Enemy Bot Settings", "Aim Scattering (0 is head shot)",              0.2, 0, 1000, 3);

// TAG Bot/Spawn ----------
enum BotAsset{
    EnemyType,
    hero,
    count
}

// TAG EnemyType ----------
playervar define enemyType;
enum EnemyType{
    None,
    Minion,
    Elite,
    Boss,
    GiantBoss
}

// TAG BotAsset ----------
define RandomHero: RandomValueInArray(AllHeroes());
define RandomTankHero: RandomValueInArray(AllTankHeroes());
define RandomDamageHero: RandomValueInArray(AllDamageHeroes());
define RandomSupportHero: RandomValueInArray(AllSupportHeroes());

globalvar define botSlot1!;
globalvar define botSlot2!;
globalvar define enemyTeamName!;

void CreateBotsByAssetList(define assetList, define team)"CreateBotsByAssetList"{
    DestroyBots(team);
    define asset = ValueInArray(assetList, RandomInteger(0, CountOf(assetList) - 1));
    // set team name
    enemyTeamName = asset[0];
    // create bot by asset
    for(define assetIdx! = 1; assetIdx < CountOf(asset); assetIdx++){
        for(define botCount! = 0; botCount < asset[assetIdx][BotAsset.count]; botCount++){
            // create bot
            CreateDummyBot(
                asset[assetIdx][BotAsset.hero],
                team,
                team == Team.Team1 ? botSlot1 : botSlot2,
                SpawnPoints(team)[0],
                RandomDirection()
            );
            Wait(0.1, WaitBehavior.IgnoreCondition);
                WaitUntil(!isServerOverLoading, 3);
            // set Bot type as enemy type
            define bot! = PlayersInSlot(team == Team.Team1 ? botSlot1 : botSlot2, team);
            bot.enemyType = asset[assetIdx][BotAsset.EnemyType];

            // next slot
            if(team == Team.Team1)
                botSlot1++;
            else
                botSlot2++;
        }
    }
}

void CreateBotsByHeroList(define heroList, define num, define team)"CreateBotsByHeroList"{
    DestroyBots(team);
    Wait(0.1, WaitBehavior.IgnoreCondition);

    // create bot by asset
    for(define slotIdx = 0; slotIdx < num; slotIdx++){
        // try until spawn entity
        while(
            !HasSpawned(PlayersInSlot(team == Team.Team1 ? botSlot1 : botSlot2, team))
        ){
            // create bot
            CreateDummyBot(
                RandomValueInArray(heroList),
                team,
                team == Team.Team1 ? botSlot1 : botSlot2,
                SpawnPoints(team)[0],
                RandomDirection()
            );
            Wait(0.1, WaitBehavior.IgnoreCondition);
            WaitUntil(!isServerOverLoading, 3);
        }   
        
        // next slot
        if(team == Team.Team1)
            botSlot1++;
        else
            botSlot2++;
    }
}

void CreateBotsByHeroInput(define hero, define num, define team)"CreateBotsByHeroInput"{
    DestroyBots(team);
    Wait(0.1, WaitBehavior.IgnoreCondition);

    // create bot by asset
    for(define slotIdx = 0; slotIdx < num; slotIdx++){
        // try until spawn entity
        while(
            !HasSpawned(PlayersInSlot(team == Team.Team1 ? botSlot1 : botSlot2, team))
        ){
            // create bot
            CreateDummyBot(
                hero,
                team,
                team == Team.Team1 ? botSlot1 : botSlot2,
                SpawnPoints(team)[0],
                RandomDirection()
            );
            Wait(0.1, WaitBehavior.IgnoreCondition);
            WaitUntil(!isServerOverLoading, 3);
        }   
        
        // next slot
        if(team == Team.Team1)
            botSlot1++;
        else
            botSlot2++;
    }
}

void DestroyBots(define team)"DestroyBots"{
    for(define slotIdx = 0; slotIdx < 24; slotIdx ++){
        // try until despawn entity
        // while(HasSpawned(PlayersInSlot(slotIdx, team))){
            DestroyDummyBot(
                team, slotIdx);
            Wait(0.01, WaitBehavior.IgnoreCondition);
        // }
    }

    // clear slot
    if(team == Team.Team1)
        botSlot1 = 0;
    else
        botSlot2 = 0;
}

// TAG Bot/SetBotInfo ----------

playervar define heroName!;
playervar define supportPriorityProbability!;
playervar define supportButtons!;
playervar define attackButtons!;

playervar define primaryFireButtonBehaivor;
playervar define primaryFireButtonReleaseMin;
playervar define primaryFireButtonReleaseMax;
playervar define primaryFireButtonPressMin;
playervar define primaryFireButtonPressMax;
playervar define secondaryFireButtonBehaivor;
playervar define secondaryFireButtonReleaseMin;
playervar define secondaryFireButtonReleaseMax;
playervar define secondaryFireButtonPressMin;
playervar define secondaryFireButtonPressMax;
playervar define ability1ButtonReleaseMin;
playervar define ability1ButtonReleaseMax;
playervar define ability1ButtonPressMin;
playervar define ability1ButtonPressMax;
playervar define ability2ButtonReleaseMin;
playervar define ability2ButtonReleaseMax;
playervar define ability2ButtonPressMin;
playervar define ability2ButtonPressMax;
playervar define ultimateButtonReleaseMin;
playervar define ultimateButtonReleaseMax;
playervar define ultimateButtonPressMin;
playervar define ultimateButtonPressMax;

playervar define actionRange!;
playervar define actionRangeMin!;
playervar define actionRangeMax!;

rule: "Bot/SetActionRoutine"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    HasSpawned()
){
        actionRange = ActionRange.Middle;
        heroName = "Default";
        supportPriorityProbability = 0;
        supportButtons = [];
        attackButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];

        primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        primaryFireButtonReleaseMin = 0;
        primaryFireButtonReleaseMax = 2.5;
        primaryFireButtonPressMin = 0;
        primaryFireButtonPressMax = 5;

        secondaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        secondaryFireButtonReleaseMin = 0;
        secondaryFireButtonReleaseMax = 2.5;
        secondaryFireButtonPressMin = 0;
        secondaryFireButtonPressMax = 5;

        ability1ButtonReleaseMin = 0;
        ability1ButtonReleaseMax = 2.5;
        ability1ButtonPressMin = 0;
        ability1ButtonPressMax = 5;

        ability2ButtonReleaseMin = 0;
        ability2ButtonReleaseMax = 2.5;
        ability2ButtonPressMin = 0;
        ability2ButtonPressMax = 5;

        ultimateButtonReleaseMin = 0;
        ultimateButtonReleaseMax = 2.5;
        ultimateButtonPressMin = 0;
        ultimateButtonPressMax = 5;

    switch(HeroOf()){
        case Hero.Ana:
        heroName = "Ana";
        actionRange = ActionRange.Far;
        secondaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        secondaryFireButtonPressMin = 10;
        secondaryFireButtonPressMax = 15;
        supportPriorityProbability = 100;
        supportButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability2
        ];
        break;

        case Hero.Ashe:
        heroName = "Ashe";
        actionRange = ActionRange.Far;
        primaryFireButtonBehaivor = ButtonBehaivor.ReleaseRepeat;
        secondaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        secondaryFireButtonPressMin = 10;
        secondaryFireButtonPressMax = 10;
        break;

        case Hero.Baptiste:
        heroName = "Baptiste";
        actionRange = ActionRange.Far;
        supportPriorityProbability = 100;
        supportButtons = [
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.PrimaryFire,
            Button.Ability1
        ];
        break;

        case Hero.Bastion:
        heroName = "Bastion";
        actionRange = ActionRange.Far;
        secondaryFireButtonReleaseMin = 10;
        secondaryFireButtonReleaseMax = 15;
        ability1ButtonReleaseMin = 5;
        ability1ButtonReleaseMax = 20;
        ability1ButtonPressMin = 0.5;
        ability1ButtonPressMax = 0.5;
        ultimateButtonReleaseMax = 40;
        break;

        case Hero.Brigitte:
        heroName = "Brigitte";
        actionRange = ActionRange.Melee;
        secondaryFireButtonReleaseMax = 6;
        primaryFireButtonPressMax = 15;
        ability2ButtonPressMax = 1;
        ability2ButtonReleaseMax = 1;
        ultimateButtonReleaseMax = 30;
        supportPriorityProbability = 75;
        supportButtons = [
            Button.SecondaryFire,
            Button.Ability2
        ];
        break;

        case Hero.Doomfist:
        heroName = "Doomfist";
        actionRange = ActionRange.Melee;
        primaryFireButtonReleaseMax = 3;
        secondaryFireButtonPressMin = 2;
        secondaryFireButtonPressMax = 3;
        break;

        case Hero.Dva:
        heroName = "Dva";
        actionRange = ActionRange.Close;
        ultimateButtonReleaseMax = 30;
        break;

        case Hero.Echo:
        heroName = "Echo";
        actionRange = ActionRange.Middle;
        break;

        case Hero.Genji:
        heroName = "Genji";
        actionRange = ActionRange.Melee;
        break;

        case Hero.Hanzo:
        heroName = "Hanzo";
        actionRange = ActionRange.Far;
        primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        primaryFireButtonReleaseMax = 1;
        primaryFireButtonPressMin = 1.5;
        primaryFireButtonPressMax = 2;
        secondaryFireButtonBehaivor = ButtonBehaivor.Non;
        break;

        case Hero.Junkrat:
        heroName = "Junkrat";
        actionRange = ActionRange.Middle;
        break;

        case Hero.Lucio:
        heroName = "Lucio";
        actionRange = ActionRange.Middle;
        ultimateButtonReleaseMax = 15;
        supportPriorityProbability = 25;
        supportButtons = [
            Button.Ability1,
            Button.Ability2
        ];
        break;

        case Hero.Cassidy:
        heroName = "Cassidy";
        actionRange = ActionRange.Close;
        primaryFireButtonReleaseMin = 0;
        primaryFireButtonReleaseMax = 2;
        secondaryFireButtonReleaseMax = 20;
        break;

        case Hero.Mei:
        heroName = "Mei";
        actionRange = ActionRange.Close;
        primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        ultimateButtonReleaseMax = 30;
        break;

        case Hero.Mercy:
        heroName = "Mercy";
        actionRange = ActionRange.Far;
        secondaryFireButtonReleaseMax = 10;
        ability1ButtonReleaseMin = 1;
        ability1ButtonReleaseMax = 2;
        ability2ButtonReleaseMin = 1;
        ability2ButtonReleaseMax = 2;
        supportPriorityProbability = 100;
        supportButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        break;

        case Hero.Moira:
        heroName = "Moira";
        actionRange = ActionRange.Middle;
        supportPriorityProbability = 100;
        supportButtons = [
            Button.PrimaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        secondaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        break;

        case Hero.Orisa:
        heroName = "Orisa";
        actionRange = ActionRange.Far;
        break;

        case Hero.Pharah:
        heroName = "Pharah";
        actionRange = ActionRange.Middle;
        break;

        case Hero.Reaper:
        heroName = "Reaper";
        actionRange = ActionRange.Close;
        break;

        case Hero.Reinhardt:
        heroName = "Reinhardt";
        actionRange = ActionRange.Melee;
        secondaryFireButtonReleaseMax = 10;
        primaryFireButtonPressMax = 20;
        break;

        case Hero.Roadhog:
        heroName = "Reaper";
        actionRange = ActionRange.Close;
        break;

        case Hero.Sigma:
        heroName = "Sigma";
        actionRange = ActionRange.Middle;
        secondaryFireButtonReleaseMax = 15;
        secondaryFireButtonPressMax = 1;
        ultimateButtonReleaseMax = 25;
        break;

        case Hero.Soldier76:
        heroName = "Soldier76";
        actionRange = ActionRange.Middle;
        break;

        case Hero.Sombra:
        heroName = "Sombra";
        actionRange = ActionRange.Close;
        secondaryFireButtonPressMin = 1.5;
        ability2ButtonReleaseMax = 10;
        ability2ButtonPressMax = 0.5;
        break;

        case Hero.Symmetra:
        heroName = "Symmetra";
        actionRange = ActionRange.Middle;
        primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        secondaryFireButtonPressMin = 1;
        secondaryFireButtonPressMax = 3;
        ability1ButtonReleaseMin = 1;
        ability1ButtonReleaseMax = 3;
        ability2ButtonReleaseMax = 15;
        break;

        case Hero.Torbjorn:
        heroName = "Torbjorn";
        actionRange = ActionRange.Middle;
        break;

        case Hero.Tracer:
        heroName = "Tracer";
        actionRange = ActionRange.Close;
        break;

        case Hero.Widowmaker:
        heroName = "Widowmaker";
        actionRange = ActionRange.Far;
        primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        primaryFireButtonReleaseMin = 1;
        primaryFireButtonReleaseMax = 1.5;
        primaryFireButtonPressMin = 0;
        primaryFireButtonPressMax = 1;
        secondaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        secondaryFireButtonPressMin = 15;
        secondaryFireButtonPressMax = 20;
        ability1ButtonReleaseMin = 10;
        ability1ButtonReleaseMax = 15;
        ability2ButtonReleaseMin = 10;
        ability2ButtonReleaseMax = 15;
        break;

        case Hero.Winston:
        heroName = "Winston";
        actionRange = ActionRange.Melee;
        ultimateButtonReleaseMax = 30;
        break;

        case Hero.WreckingBall:
        heroName = "WreckingBall";
        actionRange = ActionRange.Close;
        primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        primaryFireButtonReleaseMax = 15;
        primaryFireButtonPressMax = 20;
        secondaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        secondaryFireButtonPressMin = 6;
        secondaryFireButtonPressMax = 15;
        ability1ButtonReleaseMin = 5;
        ability1ButtonReleaseMax = 10;
        break;

        case Hero.Zarya:
        heroName = "Zarya";
        actionRange = ActionRange.Middle;
        primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        ability2ButtonReleaseMin = 1;
        ability2ButtonReleaseMax = 1;
        break;

        case Hero.Zenyatta:
        heroName = "Zenyatta";
        actionRange = ActionRange.Far;
        primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
        primaryFireButtonReleaseMin = 1;
        secondaryFireButtonReleaseMin = 1;
        ability1ButtonReleaseMin = 1;
        ability1ButtonReleaseMax = 1;
        ability1ButtonPressMin = 1;
        ability1ButtonPressMax = 1;
        ability2ButtonReleaseMin = 1;
        ability2ButtonReleaseMax = 1;
        ability2ButtonPressMin = 1;
        ability2ButtonPressMax = 1;
        ultimateButtonReleaseMax = 30;
        supportPriorityProbability = 50;
        supportButtons = [
            Button.Ability1,
            Button.Ability2
        ];
        break;
    }

    // set Attack range
    switch(actionRange){
        case ActionRange.Melee:
            actionRangeMin = 0;
            actionRangeMax = 4;
            break;
        case ActionRange.Close:
            actionRangeMin = 0;
            actionRangeMax = 8;
            break;
        case ActionRange.Middle:
            actionRangeMin = 8;
            actionRangeMax = 16;
            break;
        case ActionRange.Far:
            actionRangeMin = 16;
            actionRangeMax = 32;
            break;
    }
}

enum ActionState{
    Non,
    Staring,
    Attack,
    Support
}

enum ActionRange{
    Non,
    Melee,
    Close,
    Middle,
    Far
}

enum ButtonBehaivor{
    Non,
    ReleasePress,
    ReleaseRepeat
}

// TAG Bot/ActionState/StateControl ----------
define needHealRate: 0.75;

define watchUpdateRate:
    isServerOverLoading ? 4 : 2;

define FindAttackTarget():
    FirstOf(
        SortedArray(
            FilteredArray(
                AllPlayers(OppositeTeamOf(TeamOf())),
                (
                    HasSpawned(ae) &&
                    IsInLineOfSight(ep, ae, BarrierLOS.NoBarriersBlock) &&
                    IsAlive(ae) &&
                    !(
                        IsStealth(ae) &&
                        DistanceBetween(ae, ep) >= 3
                    )
                )
            ),
            DistanceBetween(ae, ep)
        )
    );

define FindSupportTarget():
    FirstOf(
        SortedArray(
            FilteredArray(
                AllPlayers(TeamOf()),
                (
                    ae != ep &&
                    HasSpawned(ae) &&
                    IsInLineOfSight(ep, ae, BarrierLOS.NoBarriersBlock) &&
                    IsAlive(ae) &&
                    NormalizedHealth(ae) < needHealRate
                )
            ),
            Health(ae) - MaxHealth(ae)
        )
    );

rule: "Bot/ActionState/StateControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    HasSpawned()
){
    // if(target != 0)
    //     dbgPlyBemEft(EyePosition(), EyePosition(target) - PositionOffset());

    // get next state
    define nextActionState!;
    // is dead
    if(IsDead()){
        // Non state by dead
        nextActionState = ActionState.Non; 
    }
    else
    { 
        // get targetSighted
        define targetSighted! =
            target != 0 &&
            HasSpawned(target) &&
            IsAlive(target) &&
            IsInLineOfSight(ep, target, BarrierLOS.NoBarriersBlock) &&
            !(
                IsStealth(target) &&
                DistanceBetween(target, ep) >= 3
            );

        define tryGetTarget! = false;
        // target not Sighted
        if(!targetSighted){
            tryGetTarget = true;
        }
        // is support enable
        else if(0 < supportPriorityProbability){
            if(actionState == ActionState.Attack){
                if(
                    ProbabilityTrue(supportPriorityProbability)
                ){
                    tryGetTarget = true;
                }
            }
            else if(actionState == ActionState.Support){
                if(
                    ProbabilityTrue(NormalizedHealth(target) * 75)
                ){
                    tryGetTarget = true;
                }
                else if(NormalizedHealth(target) >= needHealRate){
                    tryGetTarget = true;
                }
            }
        }
        // is support disable
        else{
            if(
                ProbabilityTrue(NormalizedHealth(target) * 75)
            ){
                tryGetTarget = true;
            }
        }

        // get new target
        if(tryGetTarget){
            // set target
            if(
                ProbabilityTrue(supportPriorityProbability)
            ){
                // find support target
                target = FindSupportTarget();
                // not found heal target
                if(target == 0){
                    // find attack target
                    target = FindAttackTarget();
                }
            }
            else{
                // find attack target
                target = FindAttackTarget();
            }
        }

        // has target
        if(
            target != 0 && target != null
        ){
            // target is enemy
            if(TeamOf() != TeamOf(target)){
                // Attack state
                nextActionState = ActionState.Attack; 
            }
            else{
                // Support state
                nextActionState = ActionState.Support; 
            }
        }
        else{
            // Non state by target not found
            nextActionState = ActionState.Non;
        }       
    }

    // state changed
    if(nextActionState != actionState){
        // next state is not Non state
        if(nextActionState != ActionState.Non){
            // set Non state for restart button control
            actionState = ActionState.Staring;
            WaitChangeState();
        }
        // set next state
        actionState = nextActionState;
    }
    // wait check cycle
    Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);

    // for distribute load
    if(isServerOverLoading){
        
        Wait(RandomInteger(0, 0.5), WaitBehavior.AbortWhenFalse);
    }
    WaitUntil(!isServerOverLoading, 10);
    LoopIfConditionIsTrue();
}

rule: "Bot/ActionState/GotoAttackStateOnDamageTaken"
Event.OnDamageTaken
if(
    IsDummyBot() &&
    actionState == ActionState.Non &&
    Attacker() != ep
){
    // set attack target
    target = Attacker();
    // temporary set Non state for restart button control
    actionState = ActionState.Non;
    WaitChangeState();
    actionState = ActionState.Attack;
}

playervar define actionState;
playervar define prevActionState;
playervar define statusText;
playervar define target;
playervar define moveDir;
playervar define sideStepDir;

void StopMove()"StopMove"{
    StopThrottleInDirection();
} 

void StartMove()"StartMove"{
    if(moveDir != 0 && sideStepDir != 0){
        StartMoveInDir(moveDir + sideStepDir);
    }
    else if(moveDir == 0 && sideStepDir != 0){
        StartMoveInDir(sideStepDir);
    }
    else if(moveDir != 0 && sideStepDir == 0){
        StartMoveInDir(moveDir);
    }
    else{
        StopMove();
    }
}

void StartMoveInDir(define dir){
    StartThrottleInDirection(
        ep, dir, 1,
        Relative.ToPlayer,
        ThrottleBehavior.ReplaceExistingThrottle,
        ThrottleRev.DirectionAndMagnitude
    );
}

define stuckRange: 0.25;

playervar define prevPosition;

playervar define isInStuck;

void checkAndBreakStuck()"checkAndBreakStuck"{
    if(
        (   // has move
            sideStepDir != 0 ||
            moveDir != 0
        ) &&
        prevPosition != 0 &&
        DistanceBetween(ep, prevPosition) <= stuckRange    // not moved from prevPosition
    ){
        statusText = <"checkAndBreakStuck">;
        while(
            // keep try break stuck prob
            ProbabilityTrue(75) &&
            // not moved from prevPosition yet
            DistanceBetween(ep, prevPosition) <= stuckRange
        ){
            isInStuck = true;
            //dbgPlyEft(ep);
            // try jump or croch
            define breakStuckButton! = RandomValueInArray([Button.Jump, Button.Crouch]);
            StartHoldingButton(ep, breakStuckButton);
            Wait(RandomReal(0.5, 1.0), WaitBehavior.IgnoreCondition);   // keep hold button
            StopHoldingButton(ep, breakStuckButton);
        }
    }
    else{
        isInStuck = false;
        prevPosition = PositionOf();
    }
}

void setMoveDir(define forwardIsAbyss!, define backwardIsAbyss!)"setMoveDir"{
    // set move direction
    define distToTarget! = DistanceBetween(ep, target);

    // select dir
    // attack state
    if(actionState == ActionState.Attack){
        // target is far
        if(
            distToTarget > actionRangeMax
        ){
            moveDir = Forward();
        }
        // target is close
        else if(
            distToTarget < actionRangeMin
        ){
            moveDir = Backward();
        }
        else{
            // no moveDir
            moveDir = 0;
        }
    }
    // support state
    else if(actionState == ActionState.Support){
        // target is far
        if(
            distToTarget > (actionRangeMax * 0.75)
        ){
            moveDir = Forward();
        }
        // target is close
        else if(
            distToTarget < (actionRangeMin * 0.75)
        ){
            moveDir = Backward();
        }
        else{
            // no moveDir
            moveDir = 0;
        }
    }

    // check abyss
    // can't forward
    if(forwardIsAbyss && moveDir == Forward()){
        moveDir = 0;
    }
    // can't backward
    else if(backwardIsAbyss && moveDir == Backward()){
        moveDir = 0;
    }
}

void setSideStep(define rightIsAbyss!, define leftIsAbyss!)"setSideStep"{
    define distToTarget! = DistanceBetween(ep, target);
    define isMyRange! =
        distToTarget >= actionRangeMin &&
        distToTarget <= actionRangeMax;
    // now my range or prob
    if(isMyRange || ProbabilityTrue(50)){
        // select dir
        if(ProbabilityTrue(10)){
            // no sidestep
            sideStepDir = 0;
        }
        else{
            // has sidestep
            if(sideStepDir != 0){
                // set side step
                if(ProbabilityTrue(40)){
                    // reverse sidestep
                    sideStepDir = -sideStepDir;
                }
                //else
            }
            else{
                // set side step
                if(ProbabilityTrue(50)){
                    // right sidestep
                    sideStepDir = Right();
                }
                else{
                    // left sidestep
                    sideStepDir = Left();
                }
            }
        }

        // check abyss
        // first check right prob
        if(ProbabilityTrue(50)){
            // can't right
            if(rightIsAbyss && sideStepDir == Right()){
                sideStepDir = Left();
            }
            // can't left too
            if(leftIsAbyss && sideStepDir == Left()){
                sideStepDir = 0;
            }
        }
        else{
            // can't left
            if(leftIsAbyss && sideStepDir == Left()){
                sideStepDir = Right();
            }
            // can't right too
            if(rightIsAbyss && sideStepDir == Right()){
                sideStepDir = 0;
            }
        }
    }
    else{
        sideStepDir = 0;
    }
    // else
}

void StartFacingTarget(){
    if(
        target != 0 &&
        target != null &&
        IsAlive(target)
    ){
        StartFacing(
            ep,
            DirectionTowards(
                EyePosition(),
                EyePosition(target) + RandomPosition(botAimScat, botAimScat, botAimScat)
            ),
            250,
            Relative.ToWorld, FacingRev.DirectionAndTurnRate
        );
    }
}

// TAG Bot/ActionState/Non ----------
rule: "Bot/ActionState/Non"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    actionState == ActionState.Non
){
    statusText = <"Non">;

    // hero unique action
    heroAction();

    moveDir = 0;
    sideStepDir = 0;
    target = 0;

    StopMove();
    StopFacing();
    Wait(0.1, WaitBehavior.AbortWhenFalse);

    while(actionState == ActionState.Non){
        // set initial face direction
        SetFacing(
            ep,
            DirectionTowards(ep, ClosestPlayerTo(ep, EnemyTeamOf())),
            Relative.ToWorld);

        Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
        WaitUntil(!isServerOverLoading, 10);
    }    // action loop
}

// TAG Bot/ActionState/Attack ----------
rule: "Bot/ActionState/Attack"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    actionState == ActionState.Attack
){
    statusText = <"Attack">;

    // start facing direction
    StartFacingTarget();
    Wait(0.1, WaitBehavior.AbortWhenFalse);
    
    while(actionState == ActionState.Attack){
        // hero unique action
        heroAction();

        // check abyss
        define distance! = moveMeterPerSec * watchUpdateRate;
        define fCheckPos! = BlockedPositonByLocalVector(Forward(), distance);
        define fAbyss! = IsBelowAbyss(fCheckPos);
        define bCheckPos! = BlockedPositonByLocalVector(Backward(), distance);
        define bAbyss! = IsBelowAbyss(bCheckPos);

        // set moveDir direction
        setMoveDir(fAbyss, bAbyss);

        // check abyss
        define rCheckPos! = BlockedPositonByLocalVector(Right(), distance);
        define rAbyss! = IsBelowAbyss(rCheckPos);
        define lCheckPos! = BlockedPositonByLocalVector(Left(), distance);
        define lAbyss! = IsBelowAbyss(lCheckPos);

        // set sidestep direction
        setSideStep(rAbyss, lAbyss);

        // start move by moveDir and sideStepDir
        StartMove();

        // check stuck
        checkAndBreakStuck();

        Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
        WaitUntil(!isServerOverLoading, 10);
    }    // action loop

}

// TAG Bot/ActionState/Support ----------
rule: "Bot/ActionState/Support"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    actionState == ActionState.Support
){
    statusText = <"Support">;

    // start facing direction
    StartFacingTarget();
    Wait(0.1, WaitBehavior.AbortWhenFalse);

    // action loop
    while(actionState == ActionState.Support){
        // hero unique action
        heroAction();
    
        // check abyss
        define distance! = moveMeterPerSec * watchUpdateRate;
        define fCheckPos! = BlockedPositonByLocalVector(Forward(), distance);
        define fAbyss! = IsBelowAbyss(fCheckPos);
        define bCheckPos! = BlockedPositonByLocalVector(Backward(), distance);
        define bAbyss! = IsBelowAbyss(bCheckPos);
    
        // set moveDir direction
        setMoveDir(fAbyss, bAbyss);

        // no sidestepDir
        sideStepDir = 0;

        // start move by moveDir and sideStepDir
        StartMove();
        
        // check stuck
        checkAndBreakStuck();

        Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
        WaitUntil(!isServerOverLoading, 10);
    }
}

// TAG Bot/HeroUniqueAction ----------
define canMeleeKill:
    DistanceBetween(ep, target) <= 2.5 &&
    Health(target) <= 30;
define MercyStaff: 1;
define MercyPistol: 2;

void heroAction(){
    // common action
    // melee
    while(
        actionState != ActionState.Non &&
        canMeleeKill
    ){
        PressButton(ep, Button.Melee);
        Wait(0.5, WaitBehavior.AbortWhenFalse);
    }

    // reload
    if(
        actionState == ActionState.Non ||
        (MaxAmmo(ep, 0) > 0 && Ammo(ep, 0) <= 0 ) ||
        (MaxAmmo(ep, 1) > 0 && Ammo(ep, 1) <= 0 )
    ){
        PressButton(ep, Button.Reload);
    }

    // hero unique action
    else if(
        actionState != ActionState.Non
    ){
        // Mercy's change weapon
        if(HeroOf() == Hero.Mercy){
            if(actionState == ActionState.Attack){
                SetWeapon(ep, MercyPistol);
            }
            else{
                SetWeapon(ep, MercyStaff);
            }
        }
        // WreckingBall's jump for pile driver
        else if(HeroOf() == Hero.WreckingBall){
            if(
                AbilityCooldown(ep, Button.Crouch) <= 0 &&
                IsButtonHeld(ep, Button.Crouch) &&
                IsOnGround(ep)
            ){
                ApplyImpulse(ep, Up(),
                    10, Relative.ToWorld, ContraryMotion.Cancel);
            }

        // WreckingBall's accel for ball tackle
            while(IsFiringSecondary(ep)){
                // for ball charge
                define boostDir! = RandomValueInArray([Right(), Forward(), Backward(), Left()]);
                ApplyImpulse(ep, boostDir,
                    30, Relative.ToWorld, ContraryMotion.Cancel);
                Wait(0.5, WaitBehavior.AbortWhenFalse);
            }
        }
    }
}


// TAG Bot/ButtonControl ----------
enum ButtonControl{
    button,
    buttonOperation,
    releaseMin,
    releaseMax,
    pressMin,
    pressMax
}

define noShooting: false;   // for debug

playervar define isRepeating;
playervar define repeatMin;
playervar define repeatMax;

Boolean isMatchButton(define matchButton!, define butttons!){
    return IsTrueForAny(butttons, ae == matchButton);
}

define buttonControlTimeScale: 1;

void StartButtonControl(define bc){
    AbortIf(
        noShooting &&
        (
            bc[ButtonControl.button] == Button.PrimaryFire ||   
            bc[ButtonControl.button] == Button.SecondaryFire ||
            bc[ButtonControl.button] == Button.Ability1 ||
            bc[ButtonControl.button] == Button.Ability2 ||
            bc[ButtonControl.button] == Button.Ultimate
        )
    );

    define startButton = false;
    define fireAndAbilityButtons = [Button.PrimaryFire, Button.SecondaryFire, Button.Ability1, Button.Ability2];
    // if fire or ability button
    if(
        isMatchButton(bc[ButtonControl.button], fireAndAbilityButtons)
    ){
        // if match attack buttons
        if(
            actionState == ActionState.Attack &&
            isMatchButton(bc[ButtonControl.button], attackButtons)
        ){
            startButton = true;
        }
        // if match Support buttons
        else if(
            actionState == ActionState.Support &&
            isMatchButton(bc[ButtonControl.button], supportButtons)
        ){
            startButton = true;
        }
    }
    else{
        startButton = true;
    }

    // is not start button
    if(!startButton){
        // stop button
        StopHoldingButton(ep, bc[ButtonControl.button]);
    }
    else{
        /*
        // role value to low if inverse value
        if(bc[ButtonControl.releaseMin] > bc[ButtonControl.releaseMax]){
            bc[ButtonControl.releaseMin] = bc[ButtonControl.releaseMax];
        }
        if(bc[ButtonControl.pressMin] > bc[ButtonControl.pressMax]){
            bc[ButtonControl.pressMin] = bc[ButtonControl.pressMax];
        }
        */

        // start button
        if(bc[ButtonControl.buttonOperation] == ButtonBehaivor.ReleasePress){
            while(true){
                Wait(buttonControlTimeScale * RandomReal(bc[ButtonControl.releaseMin], bc[ButtonControl.releaseMax]), WaitBehavior.AbortWhenFalse);

                StartHoldingButton(ep, bc[ButtonControl.button]);
                Wait(buttonControlTimeScale * RandomReal(bc[ButtonControl.pressMin], bc[ButtonControl.pressMax]), WaitBehavior.AbortWhenFalse);

                StopHoldingButton(ep, bc[ButtonControl.button]);
            }
        }
        else if(bc[ButtonControl.buttonOperation] == ButtonBehaivor.ReleaseRepeat){
            repeatMin = bc[ButtonControl.pressMin];
            repeatMax = bc[ButtonControl.pressMax];
            while(true){
                Wait(buttonControlTimeScale * RandomReal(bc[ButtonControl.releaseMin], bc[ButtonControl.releaseMax]), WaitBehavior.AbortWhenFalse);

                isRepeating = true;
                while(isRepeating){
                    PressButton(ep, bc[ButtonControl.button]); 
                    Wait(0.2, WaitBehavior.AbortWhenFalse);
                }
            }
        }
        // else
    }
}

rule: "Bot/ButtonControl/releaseIsRepeating"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    isRepeating
){
    Wait(RandomReal(repeatMin, repeatMax), WaitBehavior.AbortWhenFalse);
    isRepeating = false;
}

// TAG Bot/ButtonControl/PrimaryFire ----------
define enableButtonControlState:
    actionState == ActionState.Attack ||
    actionState == ActionState.Support;

rule: "Bot/ButtonControl/PrimaryFire/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState
){
    StartButtonControl(
        [
            Button.PrimaryFire,
            primaryFireButtonBehaivor,
            primaryFireButtonReleaseMin,
            primaryFireButtonReleaseMax,
            primaryFireButtonPressMin,
            primaryFireButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/SeconaryFire ----------
rule: "Bot/ButtonControl/SeconaryFire/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState
){
    StartButtonControl(
        [
            Button.SecondaryFire,
            secondaryFireButtonBehaivor,
            secondaryFireButtonReleaseMin,
            secondaryFireButtonReleaseMax,
            secondaryFireButtonPressMin,
            secondaryFireButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Ability1 ----------
rule: "Bot/ButtonControl/Ability1/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState
){
    StartButtonControl(
        [
            Button.Ability1,
            ButtonBehaivor.ReleasePress,
            ability1ButtonReleaseMin,
            ability1ButtonReleaseMax,
            ability1ButtonPressMin,
            ability1ButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Ability2 ----------
rule: "Bot/ButtonControl/Ability2/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState
){
    StartButtonControl(
        [
            Button.Ability2,
            ButtonBehaivor.ReleasePress,
            ability2ButtonReleaseMin,
            ability2ButtonReleaseMax,
            ability2ButtonPressMin,
            ability2ButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Ultimate ----------
rule: "Bot/ButtonControl/Ultimate/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState &&
    UltimateChargePercent() >= 100
){
    StartButtonControl(
        [
            Button.Ultimate,
            ButtonBehaivor.ReleasePress,
            ultimateButtonReleaseMin,
            ultimateButtonReleaseMax,
            ultimateButtonPressMin,
            ultimateButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Jump ----------
rule: "Bot/ButtonControl/Jump/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState
){
    StartButtonControl(
        [
            Button.Jump,
            ButtonBehaivor.ReleasePress,
            0,
            5,
            0,
            5
        ]
    );
}

// TAG Bot/ButtonControl/Crouch ----------
rule: "Bot/ButtonControl/Crouch/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState
){
    StartButtonControl(
        [
            Button.Crouch,
            ButtonBehaivor.ReleasePress,
            5,
            10,
            0,
            2.5
        ]
    );
}

// TAG Bot/ButtonControl/Reload ----------
disabled rule: "Bot/ButtonControl/Reload/StartButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    enableButtonControlState
){
    StartButtonControl(
        [
            Button.Reload,
            ButtonBehaivor.ReleasePress,
            5,
            15,
            0,
            1
        ]
    );
}

// TAG Bot/ButtonControl/StopButtonControl ----------
rule: "Bot/ButtonControl/StopButtonControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    !enableButtonControlState
){
    StopHoldingButton(ep, Button.PrimaryFire);
    StopHoldingButton(ep, Button.SecondaryFire);
    StopHoldingButton(ep, Button.Ability1);
    StopHoldingButton(ep, Button.Ability2);
    StopHoldingButton(ep, Button.Ultimate);
    StopHoldingButton(ep, Button.Jump);
    StopHoldingButton(ep, Button.Crouch);
    // StopHoldingButton(ep, Button.Reload);
}

// TAG Debug ----------
/*
rule: "Debug/Init"
Event.OngoingPlayer
if(
    ep == HostPlayer() &&
    HasSpawned(ep)
){
    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "Server Load", ServerLoad()>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);

    CreateHudText(ep,
        null, <"hold Interact button <0> to toggle all bots",
            ButtonGuide(Button.Interact)>, null,
        Location.Left, 0,
        Color.Yellow, Color.Yellow, Color.Yellow,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);

    CreateHudText(ep,
        null, <"press Interact button <0> to spawn one enemy bot",
            ButtonGuide(Button.Interact)>, null,
        Location.Left, 0,
        Color.Yellow, Color.Yellow, Color.Yellow,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);
    
    CreateIcon(spawnPos != 0 ? HostPlayer() : null, spawnPos, Icon.ArrowDown,
            IconRev.VisibleToAndPosition, Color.White, true);

}

globalvar define spawnPos;

define dummyBots:
        FilteredArray(
            AllPlayers(),
            (
                IsDummyBot(ae)
            )
        );

rule: "Debug/TeleportAllStandbyBots"
Event.OngoingPlayer
if(
    HostPlayer() == ep &&
    0 < CountOf(dummyBots)
){
    Teleport(
        FilteredArray(
            AllPlayers(),
            (
                ae.actionState == ActionState.Non &&
                IsDummyBot(ae)
            )
        ),
        NearestWalkablePosition(spawnPos + RandomPosition(5, 0, 5)));
    Wait(2, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}


define maxBotNum: 24;

rule: "Debug/ToggleSpawnAllBots"
Event.OngoingPlayer
if(
    ep == HostPlayer() &&
    IsButtonHeld(ep, Button.Interact)

){
    WaitLongPressConfirm();

    if(0 == CountOf(dummyBots)){
        spawnPos = NearestWalkablePosition(AimingPosition());
        define botNum = WorkshopSettingInteger("Enemy Bot Settings", "Bot Count", 24, 0, 24, 2);
        CreateBotsByHeroList(AllHeroes(), botNum);
    }
    else{
        DestroyBots(Team.Team1);
        DestroyBots(Team.Team2);
    }
}

rule: "Debug/SpawnOneEnemyBots"
Event.OngoingPlayer
if(
    ep == HostPlayer() &&
    IsButtonHeld(ep, Button.Interact)

){
    WaitUntil(!IsButtonHeld(ep, Button.Interact), 0.4);
    AbortIf(IsButtonHeld(ep, Button.Interact));

    spawnPos = NearestWalkablePosition(AimingPosition());
    CreateDummyBot(
        RandomValueInArray(AllHeroes()),
        OppositeTeamOf(TeamOf()),
        botSlot,
        NearestWalkablePosition(AimingPosition()),
        RandomDirection()
    );
    botSlot ++;
}
*/

/*
define debugInfoDisplayeTo:
    [HostPlayer(), ep];

rule: "Debug/ShowDebugInfo"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    HasSpawned()
){  
    // show status text
    CreateInWorldText(
        debugInfoDisplayeTo,
        actionState,
        ep + (Up() * 2), 1, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
        Color.White, Spectators.DefaultVisibility);
    // show actionState ring
    CreateEffect(
        ep.actionState != ActionState.Non ? debugInfoDisplayeTo : null,
        Effect.Ring,
            actionState == ActionState.Search ?
                Color.White:
                actionState == ActionState.Attack ?
                    Color.Red :
                    Color.Blue,
        ep, 1, EffectRev.VisibleToPositionRadiusAndColor);
    // show target path beam
    CreateBeamEffect(
        (
            (
                (
                    actionState == ActionState.Attack ||
                    actionState == ActionState.Support
                ) &&
                target != 0
            ) ||                
            (
                actionState == ActionState.Search
            )
        )
        ? debugInfoDisplayeTo : null,
        BeamType.BadBeam,
        EyePosition(),
            actionState == ActionState.Attack ||
            target,
            actionState == ActionState.Search ?
                Color.White:
                actionState == ActionState.Attack ?
                    Color.Red :
                    Color.Blue,
        EffectRev.VisibleToPositionRadiusAndColor);
    while(true){
        if(IsBelowAbyss(targetDirBackward)){
            dbgPlyEft(ep);
        }
        Wait(1);
    }
}
*/