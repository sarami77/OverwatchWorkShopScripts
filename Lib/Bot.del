import "Utility.del";
import "Debug.del";
import "ServerOverloadMeasures.del";

// split actionDistance by Attack Support

globalvar define botEnableTeams = [Team.Team1, Team.Team2];

define isBotEnableTeam: true;

// TAG Bot/Spawn ----------
enum BotAsset{
    EnemyType,
    Hero,
    Count
}

// TAG Bot/EnemyType ----------
playervar define enemyType;
enum EnemyType{
    Non,
    Minion,
    Elite,
    SubBoss,
    Boss
}

// TAG Bot/Asset ----------
define createBotInterval : 0.1;
define createBotMaxTryCount: 1;

void CreateBotsByAsset(define asset!, define team!, define addLimitNum!)"CreateBotsByAsset"{
    define addNum! = 0;
    // run asset items
    for(define assetIdx! = 0; assetIdx < CountOf(asset); assetIdx++){
        // run bot count in asset
        asset[assetIdx][BotAsset.Count] = RoundToInteger(asset[assetIdx][BotAsset.Count], Rounding.Up);
        for(define botCount! = 0; botCount < asset[assetIdx][BotAsset.Count]; botCount ++){
            if(addNum >= addLimitNum){
                break;
            }

            // if(IsAssemblingHeroes()){
            //     Wait(RandomReal(0.1, 3), WaitBehavior.IgnoreCondition);
            // }

            // get empty slot
            define slot! = GetEmptySlotNo(team);
            for(
                define tryCount! = 0;
                tryCount < createBotMaxTryCount && PlayersInSlot(slot, team) == null;
                tryCount ++
            ){
                // create bot
                CreateDummyBot(
                    asset[assetIdx][BotAsset.Hero],
                    team,
                    slot,
                    SpawnPoints(team)[0],
                    RandomDirection()
                );
                Wait(createBotInterval, WaitBehavior.IgnoreCondition);
            }
            // set Bot type as enemy type
            define bot! = PlayersInSlot(slot, team);
            bot.enemyType = asset[assetIdx][BotAsset.EnemyType];
            // count up addNum
            addNum ++;
        }
    }
}

// void CreateBotsByHeroList(define heroList!, define team!)"CreateBotsByHeroList"{
//     // create bot by asset
//     for(define listIdx! = 0; listIdx < CountOf(heroList); listIdx++){
//         // get empty slot
//         define slot! = GetEmptySlotNo(team);
//         for(
//             define tryCount! = 0;
//             tryCount < createBotMaxTryCount && PlayersInSlot(slot, team) == null;
//             tryCount ++
//         ){
//             // create bot
//             CreateDummyBot(
//                 heroList[listIdx],
//                 team,
//                 slot,
//                 SpawnPoints(team)[0],
//                 RandomDirection()
//             );
//             Wait(createBotInterval, WaitBehavior.IgnoreCondition);
//         }
//     }
// }

// void CreateBotsByHeroInput(define hero!, define num!, define team!)"CreateBotsByHeroInput"{
//     // create bot by asset
//     for(define listIdx! = 0; listIdx < num; listIdx++){
//         // get empty slot
//         define slot! = GetEmptySlotNo(team);
//         for(
//             define tryCount! = 0;
//             tryCount < createBotMaxTryCount && PlayersInSlot(slot, team) == null;
//             tryCount ++
//         ){
//             // create bot
//             CreateDummyBot(
//                 hero,
//                 team,
//                 slot,
//                 SpawnPoints(team)[0],
//                 RandomDirection()
//             );
//             Wait(createBotInterval, WaitBehavior.IgnoreCondition);
//         }
//     }
// }

void DestroyBots(define team!)"DestroyBots"{
    for(define slotIdx! = 0; slotIdx < builtinMaxSlotNum; slotIdx ++){
        DestroyDummyBot(team, slotIdx);
        Wait(0.01, WaitBehavior.IgnoreCondition);
    }
}

// TAG Bot/Move ----------
define noMoving: false;   // for debug

playervar define moveDirFB;
playervar define moveDirLR;
playervar define moveTarget;
playervar define enableRetreat! = true;
playervar define enableFollowObject! = true;

void SetMoveDir() playervar "SetMoveDir"{
    if(noMoving) return;

    define distToTarget! = DistanceBetween(ep, aimTarget);
    define objPos! = CurrentObjectOnPosition();
    define nearEnemy! = ClosestPlayerTo(ep, EnemyTeamOf(ep));

    if(
        enableRetreat
        ?
            (
                // not using ult
                !IsUsingUltimate() &&
                // by low health
                IsTrueProbability(150 * (1 - NormalizedHealth()))
            )
        :
            false
    ){
        // dbgHudTxt(<"move for heal = <0>", SlotOf()>);

        define supportPlayers = [];
        define notSupportPlayers = [];
        define livingFriends = AllLivingPlayers(TeamOf());

        // make support player list and not support player
        for(define index! = 0; index < CountOf(livingFriends); index ++){
            if(
                // not self
                ep != livingFriends[index]
            ){
                if(livingFriends[index].supportPrioloty > 0){
                    // add to support player list
                    supportPlayers[CountOf(supportPlayers)] = livingFriends[index];
                }
                else{
                    // add to not support player list
                    notSupportPlayers[CountOf(notSupportPlayers)] = livingFriends[index];
                }
            }
        }

        // find near healer from support player list
        define nearHealer = 
            FirstOf(
                SortedArray(
                    supportPlayers,
                    DistanceBetween(ep, ae)
                )
            );

        // found healer and not near
        if(
            nearHealer != null &&
            DistanceBetween(ep, nearHealer) > (ActionRange.Close / 2)
        ){
            // move to healer
            moveTarget = PositionOf(nearHealer) + (FacingDirectionOf(nearHealer) * 3);
            moveDirFB = NoDirection();
            moveDirLR = NoDirection();
        }
        else{
            // find near guard from not support player list
            define nearGuard = 
                FirstOf(
                    SortedArray(
                        notSupportPlayers,
                        DistanceBetween(ep, ae)
                    )
                );

            // found guard and not near
            if(
                nearGuard != null &&
                DistanceBetween(ep, nearGuard) > (ActionRange.Close / 2)
            ){
                // move to guard
                moveTarget = PositionOf(nearGuard) + (FacingDirectionOf(nearGuard) * 3);
                moveDirFB = NoDirection();
                moveDirLR = NoDirection();
            }
            else{
                // move to back
                moveTarget = null;
                moveDirFB = Backward();
                moveDirLR = RandomValueInArray([NoDirection(), Right(), Left()]);
            }
        } 
    }
    // move to object for secure
    else if(
        enableFollowObject &&
        // object pos valid
        objPos != null &&
        (
            // not on object
            !IsTeamOnObject(TeamOf(ep)) ||
            // enemy close win
            IsCloseWin(EnemyTeamOf(ep))
        )
    ){
        // dbgHudTxt(<"move for object = <0>", SlotOf()>);

        // move to object
        define dirToObject! = LocalVectorOf(DirectionTowards(ep, objPos), ep, Transformation.Rotation);
        moveTarget = null;
        moveDirFB = Vector(0, 0, ZOf(dirToObject));
        moveDirLR = Vector(XOf(dirToObject), 0, 0);
    }
    // move to target for attack or support
    else if(actionState != ActionState.Non){
        // dbgHudTxt(<"move for combat = <0>", SlotOf()>);

        moveTarget = null;
        // get distRate by actionState
        define distRate! = (actionState == ActionState.Attack) ? 1 : 0.5;
        // get enemy density
        define enemyDensity! = EnemyDensity(aimTarget, ActionRange.Close);

        // front/back
        if(
            // target is close
            distToTarget < (actionRangeMin * distRate)
        ){
            moveDirFB = Backward();
        }
        else if(
            // target is far
            distToTarget > (actionRangeMax * distRate) &&
            // by enemy density low
            IsTrueProbability(DefaultPercentage() * (1 - enemyDensity))
        ){
            moveDirFB = Forward();
        }
        else{
            // stop move by own action range
            moveDirFB = NoDirection();
        }

        // right/left
        if(
            IsTrueProbability(
                DefaultPercentage() *
                (
                    // by health low
                    (1 - NormalizedHealth()) +

                    actionState == ActionState.Attack
                    ? 
                        // by enemy density low
                        (1 - enemyDensity)

                    :
                        0
                )
            )
        ){
            // start side step for dodge attack
            if(
                // no side step
                moveDirLR == NoDirection()
            ){
                // start left/right step
                moveDirLR = RandomValueInArray([Right(), Left()]);
            }
            else if(IsTrueProbability(50)){
                // change side step to reverse
                moveDirLR = -moveDirLR;
            }
        }
        else{
            // stop side step by not close and not low helth
            moveDirLR = NoDirection();
        }
    }
}

playervar define enableCheckAbyss! = true;

void StartMove(define player!, define ignoreAbyss! = false) playervar "StartMove"{
    if(noMoving) return;

    define confirmMoveDir = NoDirection();
    define hasMoveTarget;

    if(
        moveDirFB != NoDirection() ||
        moveDirLR != NoDirection()
    ){
        confirmMoveDir = player.moveDirFB + player.moveDirLR;
        hasMoveTarget = false;
    }
    else if(moveTarget != null){
        confirmMoveDir = LocalVectorOf(DirectionTowards(player, moveTarget), ep, Transformation.Rotation);
        hasMoveTarget = true;
    }
    
    if(
        confirmMoveDir != NoDirection()
    ){
        // move to position is abyss
        if(
            !ignoreAbyss &&
            player.enableCheckAbyss &&
            IsBelowAbyss(
                BlockedPositonByLocalVector(
                    player,
                    confirmMoveDir,
                    walkMeterPerSec * player.watchUpdateRate
                )
            )
        ){
            StopMove(player);
        }
        else{
            if(
                !hasMoveTarget
            ){
                // move by fix vector
                StartThrottleInDirection(
                    player,
                    confirmMoveDir,
                    1,
                    Relative.ToPlayer,
                    ThrottleBehavior.ReplaceExistingThrottle,
                    ThrottleRev.None
                );
            }
            else{
                // move by dynamic target
                StartThrottleInDirection(
                    player,
                    DirectionTowards(player, moveTarget),
                    1,
                    Relative.ToWorld,
                    ThrottleBehavior.ReplaceExistingThrottle,
                    ThrottleRev.DirectionAndMagnitude
                );
            }
        }
    }
}

void StopMove(define player!) playervar "StopMove"{
    player.moveDirFB = NoDirection();
    player.moveDirLR = NoDirection();
    StopThrottleInDirection(player);
} 

// TAG Bot/Aim ----------
define facingSpeedRate:
    actionRangeMax == ActionRange.Melee ?   400 :
    actionRangeMax == ActionRange.Close ?   350 :
    actionRangeMax == ActionRange.Middle ?  300 :
    actionRangeMax == ActionRange.Far ?     250 :
    DefaultPercentage();

define facingUpdateInterval:
    watchUpdateRate * 0.1;

playervar define aimmingPosition;

void StartFacingAimTarget() playervar "StartFacingAimTarget"{
    while(
        HasSpawned(aimTarget) &&
        IsAlive(aimTarget)
    ){
        StartFacing(
            ep, 
            IsAlive(aimTarget) ?
                DirectionTowards(EyePosition(), aimmingPosition) :
                FacingDirectionOf()
            ,
            facingSpeedRate, Relative.ToWorld, FacingRev.DirectionAndTurnRate);
        Wait(1.0, WaitBehavior.IgnoreCondition);

        if(
            IsInViewAngle(ep, aimTarget, 30)
        ){
            break;
        }

        StopFacing();
        Wait(0.1, WaitBehavior.IgnoreCondition);
    }
}

rule: "EnemyBot/Aim/updateAimmingPosition"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    actionState != ActionState.Non
){
    if(HasSpawned(aimTarget)){
        aimmingPosition =
            (
                IsInAlternateForm() ?
                EyePosition(aimTarget) - Vector(0, 0.6, 0)     // body position
                    :
                EyePosition(aimTarget) + Vector(0, 0.2, 0)     // head position
            )
                +
            RandomPosition(aimScatter, aimScatter, aimScatter)  // aim scatter
                +
            Vector(0, -(aimScatter / 2), 0);
    }

    Wait(facingUpdateInterval, WaitBehavior.IgnoreCondition);
    LoopIfConditionIsTrue();
}

// TAG Bot/PolingAction ----------
void StartFacingTemporaryWithButton(define target!, define button!, define keepTime! = 0.1, define angle! = 30) playervar "StartFacingTemporaryWithButton"{
    // target is player
    if(HasSpawned(target)){
        StartFacingPlayer(target, facingSpeedRate);
    }
    // target is position
    else{
        StartFacing(
            ep, DirectionTowards(EyePosition(), target),
            facingSpeedRate, Relative.ToWorld, FacingRev.DirectionAndTurnRate);
    }

    define tryTime! = 3.0;
    define tryInterval! = 0.2;
    define maxTryCount! = tryTime * tryInterval;
    for(define tryCount! = 0; tryCount < maxTryCount; tryCount++){
        Wait(tryInterval, WaitBehavior.IgnoreCondition);
        if(IsInViewAngle(ep, target, angle)){
            break;
        }
    }
    
    Wait(0.1, WaitBehavior.IgnoreCondition);
    StartHoldingButton(ep, button);
    Wait(keepTime, WaitBehavior.IgnoreCondition);
    StopHoldingButton(ep, button);
    StartFacingAimTarget();
}

define IsInCombat(): actionState != ActionState.Non;

void PolingAction() playervar "PolingAction"{
    // hero unique action
    define hero = HeroOfWithDuplicate();

    // common action
    // melee
    while(
        actionState == ActionState.Attack &&
        HasSpawned(aimTarget) &&
        IsAlive(aimTarget) &&
        (
            Health(aimTarget) <=
            (
                HeroOf() == Hero.Reinhardt ?    meleeDamage * 4 :
                HeroOf() == Hero.Brigitte ?     meleeDamage * 4 :
                HeroOf() == Hero.Venture ?      meleeDamage * 4 :
                                                meleeDamage * 2
            )
        ) &&
        (
            DistanceBetween(ep, aimTarget) <=
            (
                HeroOf() == Hero.Reinhardt ?    meleeRange * 2 :
                HeroOf() == Hero.Brigitte ?     meleeRange * 2 :
                                                meleeRange
            )
        )
    ){
        // melee
        PressButton(ep, Button.Melee);
        Wait(0.5, WaitBehavior.AbortWhenFalse);
    }

    // reload
    if(
        (
            !IsInCombat() &&
            IsCanFillAmmo()
        ) ||
        (
            IsInCombat() &&
            IsOutOfAmmo()
        )
    ){
        PressButton(ep, Button.Reload);
    }

    // hero action
    // Ana
    if(hero == Hero.Ana){
        if(
            IsInCombat() &&
            UltimateChargePercent() >= DefaultPercentage()
        ){
            // get ultimate ready or ultimate using or low helath player
            define boostTarget! = 
                RandomValueInArray(
                    FilteredArray(
                        AllLivingPlayers(TeamOf()),
                        (
                            ae != ep &&
                            (
                                // ult ready
                                UltimateChargePercent(ae) >= DefaultPercentage() ||
                                // using ult
                                IsUsingUltimate(ae) ||
                                // low health
                                NormalizedHealth(ae) <= criticalDamageHealthScale
                            ) &&
                            CanFindLine(ae)
                        )
                    )
                );

            if(boostTarget != null){
                StartFacingTemporaryWithButton(boostTarget, Button.Ultimate, 0.1);
            }
        }
    }
    // Brigitte
    else if(hero == Hero.Brigitte){
        if(
            AbilityCooldown(ep, Button.Ability2) <= 0 &&
            IsTrueProbability(50)
        ){
            define healTarget! = 
                RandomValueInArray(
                    FilteredArray(
                        AllLivingPlayers(TeamOf()),
                        (
                            ae != ep &&
                            NormalizedHealth(ae) <= canHealHealthScale &&
                            CanFindLine(ae)
                        )
                    )
                );

            if(healTarget != null){
                StartFacingTemporaryWithButton(healTarget, Button.Ability2, 0.1);
            }
        }
    }
    // Mercy
    else if(hero == Hero.Mercy){
       // resurrect
        if(
            AbilityCooldown(ep, Button.Ability2) <= 0
        ){
            define resurrectTarget! = 
                RandomValueInArray(
                    FilteredArray(
                        AllDeadPlayers(TeamOf()),
                        (
                            ae != ep &&
                            CanFindLine(ae)
                        )
                    )
                );

            if(resurrectTarget != null){
                while(
                    IsDead(resurrectTarget) &&
                    AbilityCooldown(ep, Button.Ability2) <= 0
                ){
                    StartFacingTemporaryWithButton(resurrectTarget, Button.Ability1, 1.0);
                    if(DistanceBetween(ep, resurrectTarget) >= 3){
                        moveDirFB = Forward();
                        moveDirLR = NoDirection();
                        StartMove(ep);
                    }
                    else{
                        StopMove(ep);
                    }
                    StartHoldingButton(ep, Button.Ability2);
                }
            }
        }

        //  boost to ult player
        if(
            IsTrueProbability(DefaultPercentage() * NormalizedHealth(aimTarget))
        ){
            define boostTarget! = 
                RandomValueInArray(
                    FilteredArray(
                        AllLivingPlayers(TeamOf()),
                        (
                            ae != ep &&
                            (
                                // ready ult
                                DefaultPercentage() <= UltimateChargePercent(ae) ||
                                // using ult
                                IsUsingUltimate(ae)
                            ) &&
                            CanFindLine(ae)
                        )
                    )
                );

            if(boostTarget != null){
                if(Weapon() == 2){
                    // change to heal arm
                    SetWeapon(ep, 1);
                }
                StopHoldingButton(ep, Button.PrimaryFire);
                StartFacingTemporaryWithButton(boostTarget, Button.SecondaryFire, RandomReal(3, 6));
            }
        }

        // change weapon
        if(actionState == ActionState.Support){
            if(Weapon() == 2){
                // change to heal arm
                SetWeapon(ep, 1);
            }
        }
        else if(actionState == ActionState.Attack){
            if(Weapon() == 1){
                // change to gun
                SetWeapon(ep, 2);
            }
        }

        // change beam
        if(Weapon() == 1){
            if(
                // by target health high
                IsTrueProbability(50 * NormalizedHealth(aimTarget))
            ){
                // boost aimTarget 
                StopHoldingButton(ep, Button.PrimaryFire);
                StartHoldingButton(ep, Button.SecondaryFire);

            }
            else{
                // heal aimTarget
                StopHoldingButton(ep, Button.SecondaryFire);
                StartHoldingButton(ep, Button.PrimaryFire);
            }
        }
    }
    // Baptiste
    else if(hero == Hero.Baptiste){
        if(
            AbilityCooldown(ep, Button.Ability2) <= 0
        ){
            // get ultimate ready or ultimate using or low helath player
            define protectTarget! = 
                RandomValueInArray(
                    FilteredArray(
                        AllLivingPlayers(TeamOf()),
                        (
                            ae != ep &&
                            NormalizedHealth(ae) <= criticalDamageHealthScale &&
                            CanFindLine(ae)
                        )
                    )
                );

            if(protectTarget != null){
                protectTarget = BelowPosition(protectTarget);
                StartFacingTemporaryWithButton(protectTarget, Button.Ability2, 0.1);
            }
        }
    }
    // Dva
    else if(hero == Hero.Dva){
        if(
            // mech mode
            !IsInAlternateForm() &&
            AbilityCooldown(ep, Button.Ability1) <= 0 &&
            UltimateChargePercent(ep) >= DefaultPercentage() &&
            // enemy density high
            IsTrueProbability(50 * EnemyDensity(aimTarget, ActionRange.Close))
        ){
            PressButton(ep, Button.Ability1);
            Wait(RandomReal(0, 1.5), WaitBehavior.IgnoreCondition);
            PressButton(ep, Button.Ultimate);
        }
    }
    // Zarya
    else if(hero == Hero.Zarya){
        if(
            IsTrueProbability(50) &&
            AbilityCooldown(ep, Button.Ability2) <= 0
        ){
            // get ultimate ready or ultimate using or low helath player
            define protectTarget! = 
                RandomValueInArray(
                    FilteredArray(
                        AllLivingPlayers(TeamOf()),
                        (
                            ae != ep &&
                            NormalizedHealth(ae) <= criticalDamageHealthScale &&
                            CanFindLine(ae)
                        )
                    )
                );

            if(protectTarget != null){
                StartFacingTemporaryWithButton(protectTarget, Button.Ability2, 0.1);
            }
        }
    }
    // Kiriko
    else if(hero == Hero.Kiriko){
        if(
            actionState == ActionState.Support &&
            AbilityCooldown(ep, Button.Ability2) <= 0 &&
            NormalizedHealth(aimTarget) <= criticalDamageHealthScale
        ){
            PressButton(ep, Button.Ability2);
        }

        if(
            AbilityCooldown(ep, Button.Ability1) <= 0
        ){
            define protectTarget! = 
                RandomValueInArray(
                    FilteredArray(
                        AllLivingPlayers(TeamOf()),
                        (
                            ae != ep &&
                            NormalizedHealth(ae) <= canHealHealthScale
                        )
                    )
                );

            if(protectTarget != null){
                StartFacingTemporaryWithButton(protectTarget, Button.Ability1, 3.0);
                StopMove(ep);
            }
        }
    }
    // LifeWeever
    else if(hero == Hero.Lifeweaver){
        // use petal platform
        if(
            IsInCombat() &&
            AbilityCooldown(ep, Button.Ability1) <= 0 &&
            !IsUsingAbility1(ep)
        ){
            // for self
            if(
                IsTrueProbability(50 + (DefaultPercentage() * (1 - NormalizedHealth()))) &&
                !IsAboveCeiling(ep)
            ){
                StopMove(ep);
                Wait(0.5, WaitBehavior.IgnoreCondition);
                // aim to own step
                StartFacingTemporaryWithButton(BelowPosition(ep), Button.Ability1, 0.1);
                Wait(1, WaitBehavior.IgnoreCondition);
                PressButton(ep, Button.Jump);
                SetStatus(ep, null, Status.Rooted, RandomReal(3.0, 6.0));
            }
            // for friend
            else if(IsTrueProbability(50)){
                define assistTarget! = 
                    RandomValueInArray(
                        FilteredArray(
                            AllLivingPlayers(TeamOf()),
                            (
                                ae != ep &&
                                ae.actionRangeMax == ActionRange.Far &&
                                IsStanding(ae) &&
                                DistanceBetween(ep, ae) <= ActionRange.Middle &&
                                CanFindLine(ae)
                            )
                        )
                    );

                if(
                    assistTarget != null &&
                    !IsAboveCeiling(assistTarget)
                ){
                    StartFacingTemporaryWithButton(BelowPosition(assistTarget) + Vector(0, 0.1, 0), Button.Ability1, 0.1);
                }
            }
        }

        // use life grip
        if(
            AbilityCooldown(ep, Button.Ability2) <= 0
        ){
            // get ultimate ready or ultimate using or low helath player
            define protectTarget! = 
                RandomValueInArray(
                    FilteredArray(
                        AllLivingPlayers(TeamOf()),
                        (
                            ae != ep &&
                            NormalizedHealth(ae) <= criticalDamageHealthScale &&
                            DistanceBetween(ep, ae) >= ActionRange.Close &&
                            CanFindLine(ae)
                        )
                    )
                );

            if(protectTarget != null){
                StartFacingTemporaryWithButton(protectTarget, Button.Ability2, 0.1);
            }
        }
    }
    // Tracer
    else if(hero == Hero.Tracer){
        if(
            // by own health low
            IsTrueProbability(150 * (1 - NormalizedHealth())) &&
            AbilityCooldown(ep, Button.Ability2) <= 0
        ){
            PressButton(ep, Button.Ability2);
        }
    }
    // Zenyatta
    else if(hero == Hero.Zenyatta){
        if(!IsFiringSecondary()){
            if(
                IsTrueProbability(IsUsingAbility1() ? 50 : 100)
            ){
                define protectTarget! = 
                    RandomValueInArray(
                        FilteredArray(
                            AllLivingPlayers(TeamOf()),
                            (
                                ae != ep &&
                                NormalizedHealth(ae) <= canHealHealthScale &&
                                CanFindLine(ae)
                            )
                        )
                    );

                if(protectTarget != null){
                    StartFacingTemporaryWithButton(protectTarget, Button.Ability1, 0.1);
                }
            }

            if(
                IsTrueProbability(IsUsingAbility2() ? 50 : 100)
            ){
                define attackTarget! = 
                    RandomValueInArray(
                        FilteredArray(
                            AllLivingPlayers(EnemyTeamOf(ep)),
                            (
                                ae != ep &&
                                NormalizedHealth(ae) > criticalDamageHealthScale &&
                                CanFindLine(ae)
                            )
                        )
                    );

                if(attackTarget != null){
                    StartFacingTemporaryWithButton(attackTarget, Button.Ability2, 0.1);
                }
            }
        }

        // close to friend for heal
        while(
            IsUsingUltimate()
        ){
            define healTarget! = 
                FirstOf(
                    FilteredArray(
                        AllLivingPlayers(TeamOf()),
                        (
                            ae != ep &&
                            NormalizedHealth(ae) <= canHealHealthScale &&
                            CanFindLine(ae)
                        )
                    ),
                );

            if(healTarget != null){
                define localDir! = LocalVectorOf(DirectionTowards(ep, healTarget), ep, Transformation.Rotation);
                moveDirFB = Vector(0, 0, ZOf(localDir));
                moveDirLR = Vector(XOf(localDir), 0, 0);
                StartMove(ep);
            }
            Wait(0.5, WaitBehavior.IgnoreCondition);
        }
    }
    // Ashe
    else if(hero == Hero.Ashe){
        // fallback by corch gun
        if(
            IsInCombat() &&
            IsTrueProbability(50) &&
            DistanceBetween(ep, aimTarget) <= ActionRange.Close
        ){
            if(
                AbilityCooldown(ep, Button.Ability1) <= 0
            ){
                // use corch gun
                PressButton(ep, Button.Ability1);
            }
            else if(IsTrueProbability(50)){
                // fallback by non aiming
                StopHoldingButton(ep, Button.SecondaryFire);
            }
        }

        if(
            IsOutOfAmmo() ||
            IsTrueProbability(25 * (1 - (Ammo(ep, 0) / MaxAmmo(ep, 0))))  // by ammo charge
        ){
            // stop buton control for reduce reload cancel by fire
            enableButtonControl = false;
            Wait(0.1, WaitBehavior.IgnoreCondition);
            PressButton(ep, Button.Reload);
            Wait(0.1, WaitBehavior.IgnoreCondition);
            // check reload cancel until full load
            while(IsReloading()){
                Wait(0.5, WaitBehavior.IgnoreCondition);
                if(
                    IsTrueProbability(25 * (Ammo(ep, 0) / MaxAmmo(ep, 0)))  // reload cancel by ammo charge
                ){
                    break;
                }
            }
            // restore buton control
            enableButtonControl = true;
        }
    }
    // Bastion
    else if(hero == Hero.Bastion){
        if(
            IsInCombat() &&
            IsTrueProbability(75) &&
            AbilityCooldown(ep, Button.Ability1) <= 0 &&
            !IsUsingAbility1() &&
            !IsUsingUltimate()
        ){
            PressButton(ep, Button.Ability1);
        }
    }
    // Cassidy
    else if(hero == Hero.Cassidy){
        if(
            IsInCombat() &&
            IsTrueProbability(50) &&
            DistanceBetween(ep, aimTarget) <= ActionRange.Close &&
            !IsUsingUltimate()  // for not ult cancel
        ){
            // use faning shot
            StopHoldingButton(ep, Button.PrimaryFire);
            PressButton(ep, Button.SecondaryFire);
            Wait(0.7, WaitBehavior.IgnoreCondition);
            if(
                AbilityCooldown(ep, Button.Ability1) <= 0 &&
                IsAlive(aimTarget)
            ){
                PressButton(ep, Button.Ability1);
                Wait(0.5, WaitBehavior.IgnoreCondition);
                PressButton(ep, Button.SecondaryFire);
            }
        }
    }
    // Hanzo
    else if(hero == Hero.Hanzo){
        // fallback by double jump
        if(
            IsInCombat() &&
            IsTrueProbability(75) &&
            DistanceBetween(ep, aimTarget) <= ActionRange.Close
        ){
            // move backward for combat
            moveDirFB = Backward();
            StartMove(ep);
            
            if(
                AbilityCooldown(ep, Button.Jump) <= 0
            ){
                // use double jump at backword
                PressButton(ep, Button.Jump);
                Wait(0.5, WaitBehavior.IgnoreCondition);
                PressButton(ep, Button.Jump);
            }
        }
    }
    // Hazard
    else if(hero == Hero.Hazard){
        if(
            IsInCombat() &&
            IsTrueProbability(75) &&
            AbilityCooldown(ep, Button.Ability1) <= 0
        ){
            PressButton(ep, Button.Ability1);
            if(DistanceBetween(ep, aimTarget) <= ActionRange.Middle){
                define dist = DistanceBetween(ep, aimTarget);
                Wait(dist * 0.04, WaitBehavior.IgnoreCondition);
                PressButton(ep, Button.Ability1);
            }
        }
    }
    // Illari
    else if(hero == Hero.Illari){
        if(
            IsInCombat() &&
            IsTrueProbability(75) &&
            AbilityCooldown(ep, Button.Ability1) <= 0
        ){
            PressButton(ep, Button.Ability1);
            StartHoldingButton(ep, Button.Jump);
            Wait(0.5, WaitBehavior.IgnoreCondition);
            StopHoldingButton(ep, Button.Jump);
        }
    }
    // Ramattra
    else if(hero == Hero.Ramattra){
        if(
            IsInCombat() &&
            IsTrueProbability(50) &&
            AbilityCooldown(ep, Button.SecondaryFire) <= 0 &&
            !IsNemesisForm(ep)
        ){
            StartHoldingButton(ep, Button.SecondaryFire);
        }

        if(
            IsTrueProbability(25) &&
            AbilityCooldown(ep, Button.Ability1) <= 0 &&
            !IsNemesisForm(ep)
        ){
            PressButton(ep, Button.Ability1);
        }
    }
    // Reinhardt
    else if(hero == Hero.Reinhardt){
        if(
            IsInCombat() &&
            // by own health low
            IsTrueProbability(100 * (1 - NormalizedHealth()))
        ){
            StartHoldingButton(ep, Button.SecondaryFire);
        }
    }
    // Sombra
    else if(hero == Hero.Sombra){
        if(
            IsInCombat() &&
            AbilityCooldown(ep, Button.Ability2) <= 0 &&
            // by own health low
            IsTrueProbability(150 * (1 - NormalizedHealth()))
        ){
            // aim to backword
            define aimPosition! = 
                ep +
                (VectorWithOutY(-FacingDirectionOf()) * 5) + 
                Vector(0, 5, 0) +
                RandomPosition(2.5, 2.5, 2.5);
            
            StartFacingTemporaryWithButton(aimPosition, Button.Ability2, 0.1);
        }
        else if(
            AbilityCooldown(ep, Button.Ability2) <= 0 &&
            // by own health high
            IsTrueProbability(50 * NormalizedHealth())
        ){
            // throw trance locator at forward
            PressButton(ep, Button.Ability2);
        }
    }
    // Lucio
    else if(hero == Hero.Lucio){
        // boost heal/speed
        if(
            AbilityCooldown(ep, Button.Ability2) <= 0 &&
            NormalizedHealth(aimTarget) <= 0.25
        ){
            PressButton(ep, Button.Ability2);
            Wait(RandomReal(0, 2), WaitBehavior.IgnoreCondition);
        }

        // close to friend for heal
        if(
            IsTrueProbability(50)
        ){
            define healTarget! = 
                RandomValueInArray(
                    FilteredArray(
                        AllLivingPlayers(TeamOf()),
                        (
                            ae != ep &&
                            NormalizedHealth(ae) <= canHealHealthScale &&
                            CanFindLine(ae)
                        )
                    )
                );

            if(healTarget != null){
                define localDir! = LocalVectorOf(DirectionTowards(ep, healTarget), ep, Transformation.Rotation);
                moveDirFB = Vector(0, 0, ZOf(localDir));
                moveDirLR = Vector(XOf(localDir), 0, 0);
                StartMove(ep);
            }
        }

        // change form
        if(
            (
                actionState == ActionState.Support ||
                // low health
                NormalizedHealth() <= 0.5
            )&&
            // speed form
            IsInAlternateForm()
        ){
            // change mode to heal
            PressButton(ep, Button.Ability1);
        }
        else if(
            actionState != ActionState.Support &&
            // heal form
            !IsInAlternateForm()
        ){
            // change mode to speed
            PressButton(ep, Button.Ability1);
        }
    }
    // Mei
    else if(hero == Hero.Mei){
        // use ice wall for defend self
        if(
            IsInCombat() &&
            IsTrueProbability(DefaultPercentage() * (1 - NormalizedHealth()))  &&
            AbilityCooldown(ep, Button.Ability2) <= 0
        ){
            define aimPosition! = 
                BelowPosition(
                    ShiftedPosition(
                        ep,
                        VectorTowards(ep, aimTarget),
                        3
                    )
                );
            StartFacingTemporaryWithButton(aimPosition, Button.Ability2, 0.1);
            PressButton(ep, Button.PrimaryFire);
        }

        // use ice wall for split enemy
        if(
            IsInCombat() &&
            IsTrueProbability(50)  &&
            AbilityCooldown(ep, Button.Ability2) <= 0
        ){
            // aim between on ground
            define aimPosition! = 
                BelowPosition(
                    ShiftedPosition(
                        aimTarget,
                        VectorTowards(ep, aimTarget),
                        3
                    )
                );
            StartFacingTemporaryWithButton(aimPosition, Button.Ability2, 0.1);
            PressButton(ep, Button.PrimaryFire);
        }

        // use cyro freez
        if(
            IsTrueProbability(DefaultPercentage() * (1 - NormalizedHealth()))  &&
            AbilityCooldown(ep, Button.Ability1) <= 0
        ){
            PressButton(ep, Button.Ability1);
        }
    }
    // Reaper
    else if(hero == Hero.Reaper){
        // teleport enemy behind with shadow step 
        if(
            IsInCombat() &&
            IsTrueProbability(100 * NormalizedHealth()) &&
            AbilityCooldown(ep, Button.Ability2) <= 0 &&
            DistanceBetween(ep, aimTarget) > ActionRange.Close
        ){
            define aimPosition!;

            while(
                aimPosition == null ||
                DistanceBetween(ep, aimPosition) > ActionRange.CanFind
            ){
                // aim target behind
                aimPosition = 
                    BelowPosition(
                        ShiftedPosition(
                            aimTarget,
                            VectorTowards(ep, aimTarget),
                            5
                        ) +
                        RandomPosition(5, 0, 5)
                    );
                Wait(0.2, WaitBehavior.IgnoreCondition);
            }

            StartFacingTemporaryWithButton(aimPosition, Button.Ability2, 0.5);
            PressButton(ep, Button.PrimaryFire);
        }
    }
    // Sojourn
    else if(hero == Hero.Sojourn){
        // fire charged railgun 
        if(
            IsInCombat() &&
            IsUsingUltimate()
        ){
            Wait(RandomReal(0.1, 2.5), WaitBehavior.IgnoreCondition);
            // use charged railgun
            PressButton(ep, Button.SecondaryFire);
        }
    }
    // Torbjorn
    else if(hero == Hero.Torbjorn){
        if(
            IsInCombat() &&
            IsTrueProbability(50) &&
            DistanceBetween(ep, aimTarget) <= ActionRange.Close
        ){
            // change to melee arm
            SetWeapon(ep, 2);

            while(
                // continue melee mode condition
                IsTrueProbability(90) &&
                IsAlive() &&
                DistanceBetween(ep, aimTarget) <= ActionRange.Close
            ){
                // move foward for melee
                moveDirFB = Forward();
                moveDirLR = NoDirection();
                StartMove(ep);
                // melee by hammer
                PressButton(ep, Button.PrimaryFire);
                Wait(0.3, WaitBehavior.IgnoreCondition);
            }
        }
        else{
            // change to gun
            SetWeapon(ep, 1);
        }
    }
    // Venture
    else if(hero == Hero.Venture){
        // teleport enemy behind with shadow step 
        if(
            IsInCombat() &&
            AbilityCooldown(ep, Button.Ability1) <= 0 &&
            DistanceBetween(ep, aimTarget) > ActionRange.Close
        ){
            enableButtonControl = false;
            StartMove(ep);
            StopHoldingButton(ep, Button.PrimaryFire);
            StopHoldingButton(ep, Button.SecondaryFire);
            PressButton(ep, Button.Ability1);
            Wait(0.7, WaitBehavior.IgnoreCondition);
            StopHoldingButton(ep, Button.PrimaryFire);
            if(AbilityCooldown(ep, Button.SecondaryFire) <= 0){
                PressButton(ep, Button.SecondaryFire);
            }
            // move foward for melee
            moveDirFB = Forward();
            moveDirLR = NoDirection();
            Wait(RandomReal(1.0, 5.0), WaitBehavior.IgnoreCondition);
            StartHoldingButton(ep, Button.PrimaryFire);
            Wait(RandomReal(1.0, 2.0), WaitBehavior.IgnoreCondition);
            enableButtonControl = true;
        }
    }
    // WreckingBall
    else if(hero == Hero.WreckingBall){
        // use graple hook and tackle
        if(
            IsInCombat() &&
            IsTrueProbability(75) &&
            AbilityCooldown(ep, Button.SecondaryFire) <= 0
        ){
            define detectDist! = 21;
            define hasWallDir! = GetWallDirection(ep, detectDist, [Forward(), Left(), Right(), Backward()]);
            if(hasWallDir != null){
                // stop buton control for reduce ball form cancel by fire
                enableButtonControl = false;
                define aimPosition! = GetGrapplePosition(hasWallDir, detectDist);
                StartFacingTemporaryWithButton(aimPosition, Button.SecondaryFire, RandomReal(3.0, 9.0));
            }
        }

        // use pile driver
        if(
            IsInCombat() &&
            IsTrueProbability(75) &&
            AbilityCooldown(ep, Button.Crouch) <= 0
        ){
            if(IsOnGround()){
                // jump for pile driver
                ApplyImpulse(ep, Up(),
                    10, Relative.ToWorld, ContraryMotion.Cancel);
                Wait(RandomReal(0.5, 1), WaitBehavior.IgnoreCondition);
            }
            PressButton(ep, Button.Crouch);
        }
    }
    // Widowmaker
    else if(hero == Hero.Widowmaker){
        // using infra sight
        if(
            IsUsingUltimate()
        ){
            // Improve accuracy
            aimScatter = 0.0;
        }
        else{
            aimScatter = 0.1;
        }

        if(
            IsInCombat() &&
            DistanceBetween(ep, aimTarget) <= ActionRange.Close
        ){
            // fallback by graple hook
            if(
                AbilityCooldown(ep, Button.Ability1) <= 0
            ){
                define detectDist! = 20;
                define hasWallDir! = GetWallDirection(ep, detectDist, [Backward(), Left(), Right(), Forward()]);
                if(hasWallDir != null){
                    StopMove(ep);
                    StopHoldingButton(ep, Button.SecondaryFire);
                    define aimPosition! = GetGrapplePosition(hasWallDir, detectDist);
                    StartFacingTemporaryWithButton(aimPosition, Button.Ability1, 0.1);
                    StartHoldingButton(ep, Button.SecondaryFire);
                }
            }
            // fallback without aiming
            else{
                StopHoldingButton(ep, Button.SecondaryFire);
                StartHoldingButton(ep, Button.PrimaryFire);
                Wait(RandomReal(3.0, 5.0), WaitBehavior.IgnoreCondition);
                // restore aiming
                StartHoldingButton(ep, Button.SecondaryFire);
            }
        }
    }
}

define HeroOfWithDuplicate() "HeroOfWithDuplicate"{
    define hero! = HeroOf();
    if(
        hero == Hero.Echo &&
        IsDuplicating()
    ){
        hero = HeroBeingDuplicated();
    }
    return hero;
}


// TAG Bot/TriggerAction ----------
playervar define enableMoveUltimate!;
playervar define isInMoveUltimateState!;

rule: "Bot/TriggerAction/moveUltmate"
Event.OngoingPlayer
if(
    enableMoveUltimate &&
    IsAlive() &&
    IsUsingUltimate()
){
    AbortIf(!isBotActive);
    
    define isCanAction!;
    define waitForStartMove!;
    define moveSpeed!;
    define countPressButton!;
    define isMultiPosAttack!;

    define hero! = HeroOfWithDuplicate();
    if(
        hero == Hero.Doomfist
    ){
        isCanAction = true;
        waitForStartMove = 0.25;
        moveSpeed = 0.07;
        countPressButton = 1;
        isMultiPosAttack = false;
    }
    else if(
        hero == Hero.Bastion
    ){
        isCanAction = true;
        waitForStartMove = 0.5;
        moveSpeed = 0.065;
        countPressButton = 4;
        isMultiPosAttack = IsTrueProbability(40);
    }
    else if(
        hero == Hero.Junkrat
    ){
        isCanAction = true;
        waitForStartMove = 1.0;
        moveSpeed = 0.085;
        countPressButton = 1;
        isMultiPosAttack = false;
    }

    // move ultmate
    if(isCanAction){
        // start move ult state for stop interrupt poling action
        isInMoveUltimateState = true;
        // stop buton control
        enableButtonControl = false;
        // stop current input
        StopMove(ep);
        StopHoldingButton(ep, Button.PrimaryFire);
        // wait for start mode
        Wait(waitForStartMove, WaitBehavior.IgnoreCondition);

        // start move postion selecter to foward
        moveDirFB = Forward();
        moveDirLR = NoDirection();
        StartMove(ep, true);
        // decrease move speed if multi position attack mode
        if(isMultiPosAttack) moveSpeed -= 0.01;
        // wait for arrival target
        define dist! = DistanceBetween(ep, aimTarget);
        dist = dist <= 5 ? 5 : dist;
        Wait((dist * moveSpeed), WaitBehavior.IgnoreCondition);

        // stop move if not multi position attack mode
        if(!isMultiPosAttack){
            StopMove(ep);
        }
        // repeat press button by pressButtonInterval
        for(define tryCount! = 0; tryCount < countPressButton; tryCount++){
            PressButton(ep, Button.PrimaryFire);
            Wait(RandomReal(0.25, 0.5), WaitBehavior.IgnoreCondition);
        }
        // reduce walking after ult
        StopMove(ep);
        // restore buton control and poling action
        enableButtonControl = true;
        // stop ult positioning
        isInMoveUltimateState = false;
    }
}

playervar define enablePlaceUltimate!;

rule: "Bot/TriggerAction/placeUltmate"
Event.OngoingPlayer
if(
    enablePlaceUltimate &&
    IsAlive() &&
    UltimateChargePercent() >= DefaultPercentage() &&
    IsButtonHeld(ep, Button.Ultimate)
){
    AbortIf(!isBotActive);

    define isCanAction!;
    define rotateProb!;

    define hero! = HeroOfWithDuplicate();
    if(
        hero == Hero.Baptiste
    ){
        isCanAction = true;
        rotateProb = 10;
    }
    else if(
        hero == Hero.Symmetra
    ){
        isCanAction = true;
        rotateProb = 50;
    }
    else if(
        hero == Hero.Lifeweaver
    ){
        isCanAction = true;
    }

    // place ultmate
    if(isCanAction){
        // stop buton control for reduce cancel
        enableButtonControl = false;
        // rotate
        if(IsTrueProbability(rotateProb)){
            PressButton(ep, Button.Ultimate);
            Wait(0.1, WaitBehavior.IgnoreCondition);
        }
        // aim ground on between
        define aimPosition! = 
            BelowPosition(
                ShiftedPosition(
                    ep,
                    VectorTowards(ep, aimTarget),
                    DistanceBetween(ep, aimTarget) * 0.5
                )
            );
        StartFacingTemporaryWithButton(aimPosition, Button.PrimaryFire, 0.1);
        PressButton(ep, Button.PrimaryFire);
        // restore buton control
        enableButtonControl = true;
    }
}

playervar define enablePlaceSecondary!;

rule: "Bot/TriggerAction/placeSecondary"
Event.OngoingPlayer
if(
    enablePlaceSecondary &&
    IsAlive() &&
    AbilityCooldown(ep, Button.SecondaryFire) <= 0 &&
    IsButtonHeld(ep, Button.SecondaryFire)
){
    AbortIf(!isBotActive);

    define isCanAction!;

    define hero! = HeroOfWithDuplicate();
    if(
        hero == Hero.Ramattra
    ){
        if(
            // is omnic form
            !IsNemesisForm(ep)
        ){
            isCanAction = true;
        }        
    }

    // place secondary
    if(isCanAction){
        // stop buton control for reduce cancel
        enableButtonControl = false;
        // cancel hold SecondaryFire
        CancelPrimaryAction();
        StopHoldingButton(ep, Button.PrimaryFire);
        // aim ground on 1/4
        define aimPosition! = 
            BelowPosition(
                ShiftedPosition(
                    ep,
                    VectorTowards(ep, aimTarget),
                    DistanceBetween(ep, aimTarget) * 0.25
                )
            );
        StartFacingTemporaryWithButton(aimPosition, Button.SecondaryFire, 0.1);
        // restore buton control
        enableButtonControl = true;
    }
}

playervar define enableHoldSecondary!;

rule: "Bot/TriggerAction/holdSecondary"
Event.OngoingPlayer
if(
    enableHoldSecondary &&
    IsAlive() &&
    IsFiringSecondary()
){
    AbortIf(!isBotActive);

    define isHoldSecondary!;

    define hero! = HeroOfWithDuplicate();
    // postion fix hero
    if(
        hero == Hero.WreckingBall
    ){
        if(IsFiringSecondary()){
            isHoldSecondary = true;       
        }
    }

    if(isHoldSecondary){
        // stop buton control for reduce ball form cancel by fire
        enableButtonControl = false;

        // using graple hook
        while(
            IsFiringSecondary()
        ){
            // accsell for ball tackle
            BallTackle();
            Wait(0.5, WaitBehavior.IgnoreCondition);
        }

        // restore buton control
        enableButtonControl = true;
    }
}

void BallTackle() playervar "BallTackle"{
    define dir!;
    if(
        SpeedOf() <= 10
    ){
        dir = 1;
    }
    else{
        dir = -1;
    }
    ApplyImpulse(ep, 
        dir * DirectionTowards(ep, ClosestPlayerTo(ep, EnemyTeamOf(ep))),
        25, Relative.ToWorld, ContraryMotion.Incorporate);
}

// TAG Bot/ActionState/StateControl ----------
playervar define watchUpdateRate = 2.0;
playervar define isBotActive;
playervar define actionState;
playervar define aimTarget;

enum ActionState{
    Non,
    Attack,
    Support
}

define IsSighted(in define player!):
    HasSpawned(player) &&
    // alive
    IsAlive(player) &&
    // not in spawn room
    !IsInSpawnRoom(player) &&
    // can find range
    CanFindRange(player) &&
    // can find line
    CanFindLine(player);

define CanFindRange(in define player!) :
    HasSpawned(player) &&
    DistanceBetween(ep, player) <= ActionRange.CanFind;

define CanFindLine(in define player!) :
    HasSpawned(player) &&
    IsInLineOfSight(EyePosition(ep), EyePosition(player), BarrierLOS.NoBarriersBlock);

void FindTarget()"FindTarget"{
    define candidateTarget;

    // by supportPrioloty
    if(IsTrueProbability(DefaultPercentage() * supportPrioloty))
    {
        // find support target
        candidateTarget = FindSupportTarget();
        // not found support target
        if(candidateTarget == null){
            // find attack target
            candidateTarget = FindAttackTarget();
        }
    }
    else{
        // find attack target
        candidateTarget = FindAttackTarget();
    }

    // confirm as target
    aimTarget = candidateTarget;
}

define FindAttackTarget()"FindAttackTarget"{
    define target;
    define targets = 
        FilteredArray(
            AllPlayers(EnemyTeamOf(ep)),
            (
                ae != ep &&
                IsSighted(ae)
            )
        );

    if(!isServerOverload()){
        target = SortedArray(targets, NormalizedHealth(ae));
        // target = SortedArray(targets, DistanceBetween(ep, ae));
    }
    else{
        target = RandomValueInArray(targets);
    }

    return target;
}

define canHealHealthScale: 0.9;
define criticalDamageHealthScale: 0.5;

define FindSupportTarget()"FindSupportTarget"{
    define target;
    define targets = 
        FilteredArray(
            AllPlayers(TeamOf()),
            (
                ae != ep &&
                NormalizedHealth(ae) <= canHealHealthScale &&
                IsSighted(ae)
            )
        );

    if(!isServerOverload()){
        target = SortedArray(targets, NormalizedHealth(ae));
    }
    else{
        target = RandomValueInArray(targets);
    }

    return target;
}

define GetNextActionState()"GetNextActionState"{
    define nextActionState;
    
    if(
        // self alive
        IsAlive() &&
        // has target
        HasSpawned(aimTarget)
    ){
        if(
            // target is friend
            TeamOf() == TeamOf(aimTarget)
        ){
            // Support state
            nextActionState = ActionState.Support;
        }
        else{
            // Attack state
            nextActionState = ActionState.Attack; 
        }
    }
    else{
        // non state
        nextActionState = ActionState.Non;  
    }
    
    return nextActionState;
}

void SetActionState(define player, define nextActionState) "SetActionState"{
    // if state changed
    if(nextActionState != player.actionState){
        // set next state
        player.actionState = nextActionState;
    }
}

rule: "Bot/ActionState/deactivateState"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    !isBotActive
){
    // reset target
    aimTarget = null;
    // apply next state
    SetActionState(ep, ActionState.Non);
}

rule: "Bot/ActionState/StateControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    isBotActive
){
    while(true){
        if(IsAlive()){
            define tryFindTarget = false;

            // has not target
            if(
                // target not Sighted
                !IsSighted(aimTarget)
            ){
                // get new target
                tryFindTarget = true;
            }
            // has target
            else{
                // check change tagrget condition as attack state
                if(
                    actionState == ActionState.Attack
                ){
                    if(
                        // change target by target helth amd support prioloty 
                        IsTrueProbability(50 * NormalizedHealth(aimTarget) * supportPrioloty)
                    ){
                        // change target
                        tryFindTarget = true;
                    }
                }
                // check change tagrget condition as support state
                else{
                    if(
                        // by not support Prioloty
                        IsTrueProbability(50 * NormalizedHealth(aimTarget) * (1 - supportPrioloty)) ||
                        // target heal almost completed
                        NormalizedHealth(aimTarget) >= canHealHealthScale
                    ){
                        // change target 
                        tryFindTarget = true;
                    }
                }
            }

            // get new target
            if(tryFindTarget){
                // find target
                FindTarget();
            }

            // apply next state
            SetActionState(ep, GetNextActionState());
            // action call to near bots
            CallToNearBot();
        }
        else{
            // reset target
            aimTarget = null;
            // apply next state
            SetActionState(ep, GetNextActionState());
        }

        Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
        WaitUntilServerLoadLimitRelease(watchUpdateRate);
    }
}

rule: "Bot/ActionState/SetNonStateByDead"
Event.OnDeath
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    Victim() == ep
){
    AbortIf(!isBotActive);

    // reset target
    aimTarget = null;
    // apply next state
    SetActionState(ep, GetNextActionState());
}

rule: "Bot/ActionState/ChangeTargetByTargetDead"
Event.OnElimination
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    IsAlive() &&
    (
        actionState != ActionState.Non &&
        Victim() == aimTarget
    )
){
    AbortIf(!isBotActive);
    WaitUntilServerLoadLimitRelease(watchUpdateRate);

    // find next target
    FindTarget();
    // apply next state
    SetActionState(ep, GetNextActionState());
}

rule: "Bot/ActionState/ChangeTargetByTargetHealCompleted"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    IsAlive() &&
    (
        actionState == ActionState.Support &&
        NormalizedHealth(aimTarget) >= canHealHealthScale
    )
){
    AbortIf(!isBotActive);
    WaitUntilServerLoadLimitRelease(watchUpdateRate);

    // find next target
    FindTarget();
    // apply next state
    SetActionState(ep, GetNextActionState());

    // action call to near bots
    CallToNearBot();
}

rule: "Bot/ActionState/ChangeTargetFromAttackerByDamageTaken"
Event.OnDamageTaken
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    IsAlive() &&
    (
        Attacker() != ep
    )
){
    AbortIf(!isBotActive);
    WaitUntilServerLoadLimitRelease(watchUpdateRate);

    define tryFindTarget = false;

    // has not target
    if(
        // target not Sighted
        !IsSighted(aimTarget)
    ){
        // change target
        tryFindTarget = true;
    }
    // check change tagrget condition as attack state
    else if(
        actionState == ActionState.Attack
    ){
        if(
            // change target by target helth amd support prioloty 
            IsTrueProbability(50 * NormalizedHealth(aimTarget) * supportPrioloty)
        ){
            // change target
            tryFindTarget = true;
        }
    }
    // check change tagrget condition as support state
    else if(
        actionState == ActionState.Support
    ){
        if(
            // by not support Prioloty
            IsTrueProbability(50 * NormalizedHealth(aimTarget) * (1 - supportPrioloty))
        ){
            // change target 
            tryFindTarget = true;
        }
    }

    if(
        // find target
        tryFindTarget
    ){
        // set target by attacker
        aimTarget = Attacker();
        // apply next state
        SetActionState(ep, GetNextActionState());
    }

    // action call to near bots
    CallToNearBot();

    // reduce overrun
    Wait(3.0, WaitBehavior.IgnoreCondition);
}

globalvar define isCallAttackCoolingDown1 = false;
globalvar define isCallAttackCoolingDown2 = false;

void CallToNearBot()"CallToNearBot"{
    // check cooldown for reduce overrun
    // if already CoolingDown flag true, ignore action
    if(TeamOf() == Team.Team1){
        if(isCallAttackCoolingDown1) return;
        isCallAttackCoolingDown1 = true;
    }
    else if(TeamOf() == Team.Team2){
        if(isCallAttackCoolingDown2) return;
        isCallAttackCoolingDown2 = true;
    }

    if(
        // has aim target
        HasSpawned(aimTarget)
    ){
        // get near idle bot
        define nearFriends = FilteredArray(
            AllLivingPlayers(TeamOf()),
            (
                ae != ep &&
                IsDummyBot(ae) &&
                ae.isBotActive &&
                (
                    // if support state
                    actionState == ActionState.Support ?
                        // call to near supportable bot for support
                        ae.supportPrioloty > 0 :
                        // call to near idle bot for attack
                        ae.actionState == ActionState.Non
                ) &&
                CanFindRange(ae)
            )
        );

        for(define index = 0; index < CountOf(nearFriends); index ++){
            // set same target
            nearFriends[index].aimTarget = ep.aimTarget;
            // set same state 
            SetActionState(nearFriends[index], ep.actionState);

            Wait(0.1, WaitBehavior.IgnoreCondition);
        }
    }
}

rule: "Bot/ActionState/releaseIsCallAttackCoolingDown"
Event.OngoingGlobal
if(
    isCallAttackCoolingDown1 ||
    isCallAttackCoolingDown2
){
    // reduce overrun
    Wait(3.0, WaitBehavior.IgnoreCondition);
    isCallAttackCoolingDown1 = false;
    isCallAttackCoolingDown2 = false;
    Loop();
    // LoopIfConditionIsTrue();
}

// TAG Bot/ActionState/Non ----------
rule: "Bot/ActionState/Non"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    actionState == ActionState.Non
){
    // reset button control
    enableButtonControl = false;
    Wait(0.1, WaitBehavior.IgnoreCondition);

    // stop facing
    StopFacing(ep);
    // stop move
    StopMove(ep);

    while(true){
        // not in ult positioning
        if(!isInMoveUltimateState){
            // poling action
            PolingAction(); 
        }
        
        Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
        WaitUntilServerLoadLimitRelease(watchUpdateRate);
    }
}

// TAG Bot/ActionState/Attack ----------
rule: "Bot/ActionState/Attack"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    actionState == ActionState.Attack
){
    AbortIf(!isBotActive);

    // reset button control for change depending state button set
    enableButtonControl = false;
    Wait(0.1, WaitBehavior.IgnoreCondition);

    while(true){
        // not in ult positioning
        if(!isInMoveUltimateState){
            // start button control
            enableButtonControl = true;
            // start facing
            StartFacingAimTarget();
            // set moveDir
            SetMoveDir();
            // start move by moveDir
            StartMove(ep);
            // poling action
            PolingAction(); 
        }

        Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
        WaitUntilServerLoadLimitRelease(watchUpdateRate);
    }
}

// TAG Bot/ActionState/Support ----------
rule: "Bot/ActionState/Support"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    actionState == ActionState.Support
){
    AbortIf(!isBotActive);

    // reset button control for change depending state button set
    enableButtonControl = false;
    Wait(0.1, WaitBehavior.IgnoreCondition);

    while(true){
        // not in ult positioning
        if(!isInMoveUltimateState){
            // start button control
            enableButtonControl = true;
            // start facing
            StartFacingAimTarget();
            // set moveDir
            SetMoveDir();
            // start move by moveDir
            StartMove(ep);
            // poling action
            PolingAction(); 
        }

        Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
        WaitUntilServerLoadLimitRelease(watchUpdateRate);
    }
}

// TAG Bot/ButtonControl/Propety ----------
rule: "Bot/ButtonControl/Propety/setBySpawned"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    HasSpawned()
){
    SetButtonControlPropety();
}

rule: "Bot/ButtonControl/Propety/setByDuplicateStart"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    HeroOf() == Hero.Echo &&
    IsDuplicating(ep)
){
    // wait hero change
    Wait(0.5, WaitBehavior.IgnoreCondition);
    SetButtonControlPropety();
}

rule: "Bot/ButtonControl/Propety/setByDuplicateEnd"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    HeroOf() == Hero.Echo &&
    !IsDuplicating(ep)
){
    // wait hero change
    Wait(0.5, WaitBehavior.IgnoreCondition);
    SetButtonControlPropety();
}

playervar define hasButtonControlPropety! = false;

playervar define actionRangeMin!;
playervar define actionRangeMax!;

playervar define aimScatter;
playervar define supportPrioloty!;
playervar define supportButtons;
playervar define attackButtons;
playervar define enableDoubleJump!;

playervar define primaryFireButtonBehaivor!;
playervar define primaryFireButtonReleaseMin!;
playervar define primaryFireButtonReleaseMax!;
playervar define primaryFireButtonPressMin!;
playervar define primaryFireButtonPressMax!;

playervar define secondaryFireButtonBehaivor!;
playervar define secondaryFireButtonReleaseMin!;
playervar define secondaryFireButtonReleaseMax!;
playervar define secondaryFireButtonPressMin!;
playervar define secondaryFireButtonPressMax!;

playervar define ability1ButtonBehaivor!;
playervar define ability1ButtonReleaseMin!;
playervar define ability1ButtonReleaseMax!;
playervar define ability1ButtonPressMin!;
playervar define ability1ButtonPressMax!;

playervar define ability2ButtonBehaivor!;
playervar define ability2ButtonReleaseMin!;
playervar define ability2ButtonReleaseMax!;
playervar define ability2ButtonPressMin!;
playervar define ability2ButtonPressMax!;

playervar define ultimateButtonBehaivor!;
playervar define ultimateButtonReleaseMin!;
playervar define ultimateButtonReleaseMax!;
playervar define ultimateButtonPressMin!;
playervar define ultimateButtonPressMax!;

playervar define crouchButtonReleaseMin!;
playervar define crouchButtonReleaseMax!;
playervar define crouchButtonPressMin!;
playervar define crouchButtonPressMax!;

playervar define jumpButtonReleaseMin!;
playervar define jumpButtonReleaseMax!;
playervar define jumpButtonPressMin!;
playervar define jumpButtonPressMax!;

// TAG Bot/ButtonControl/SetButtonControlPropety ----------
void SetButtonControlPropety()"SetButtonControlPropety"{
    // basic routine
    aimScatter = 0.5;
    actionRangeMin = ActionRange.Melee;
    actionRangeMax = ActionRange.Melee;

    enableDoubleJump = false;
    supportPrioloty = 0.0;
    supportButtons = [
        Button.PrimaryFire,
        Button.SecondaryFire,
        Button.Ability1,
        Button.Ability2
    ];
    attackButtons = [
        Button.PrimaryFire,
        Button.SecondaryFire,
        Button.Ability1,
        Button.Ability2
    ];

    primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
    primaryFireButtonReleaseMin = 0;
    primaryFireButtonReleaseMax = 1;
    primaryFireButtonPressMin = 0;
    primaryFireButtonPressMax = 10;

    secondaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
    secondaryFireButtonReleaseMin = 0;
    secondaryFireButtonReleaseMax = 1;
    secondaryFireButtonPressMin = 0;
    secondaryFireButtonPressMax = 10;

    ability1ButtonBehaivor = ButtonBehaivor.ReleasePress;
    ability1ButtonReleaseMin = 0;
    ability1ButtonReleaseMax = 5;
    ability1ButtonPressMin = 0;
    ability1ButtonPressMax = 1;

    ability2ButtonBehaivor = ButtonBehaivor.ReleasePress;
    ability2ButtonReleaseMin = 0;
    ability2ButtonReleaseMax = 5;
    ability2ButtonPressMin = 0;
    ability2ButtonPressMax = 1;

    ultimateButtonBehaivor = ButtonBehaivor.ReleasePress;
    ultimateButtonReleaseMin = 0;
    ultimateButtonReleaseMax = 5;
    ultimateButtonPressMin = 0;
    ultimateButtonPressMax = 1;

    jumpButtonReleaseMin = 0;
    jumpButtonReleaseMax = 5;
    jumpButtonPressMin = 0;
    jumpButtonPressMax = 1;

    crouchButtonReleaseMin = 0;
    crouchButtonReleaseMax = 10;
    crouchButtonPressMin = 0;
    crouchButtonPressMax = 1;

    enableMoveUltimate = false;
    enablePlaceUltimate = false;
    enablePlaceSecondary = false;
    enableHoldSecondary = false;

    define hero! = HeroOfWithDuplicate();
    
    switch(hero){
        case Hero.Ana:
        aimScatter = 0.3;   // to precision shooting
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        supportPrioloty = 1.0;
        secondaryFireButtonPressMin = 30;       // to more use scorp
        secondaryFireButtonPressMax = 40;       // to more use scorp
        jumpButtonReleaseMax = 40;              // to suppress cancel scorp
        ultimateButtonBehaivor = ButtonBehaivor.Non;          // to suppress over use nano boost (Prefer PolingAction
        supportButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability2
        ];
        break;

        case Hero.Ashe:
        aimScatter = 0.3;
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        primaryFireButtonBehaivor = ButtonBehaivor.ReleaseRepeat;
        secondaryFireButtonPressMin = 30;       // to more use scorp
        secondaryFireButtonPressMax = 40;       // to more use scorp
        jumpButtonReleaseMax = 40;              // to suppress cancel scorp
        ability1ButtonBehaivor = ButtonBehaivor.Non;          // to suppress over use corch gun (Prefer PolingAction
        break;

        case Hero.Baptiste:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        supportPrioloty = 1.0;
        ability2ButtonBehaivor = ButtonBehaivor.Non;          // to suppress over use inmortal field (Prefer PolingAction
        jumpButtonReleaseMax = 5;               // to more use exo boots
        crouchButtonReleaseMax = 1;             // to more use exo boots
        crouchButtonPressMax = 20;              // to more use exo boots
        supportButtons = [
            Button.SecondaryFire,
            Button.Ability1
        ];
        attackButtons = [
            Button.PrimaryFire,
            Button.Ability1
        ];
        enablePlaceUltimate = true;
        break;

        case Hero.Bastion:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        primaryFireButtonReleaseMax = 1;        // to more use primary fire when assault mode
        primaryFireButtonPressMax = 20;        // to more use primary fire when assault mode
        secondaryFireButtonReleaseMax = 5;        // to more use primary fire when assault mode
        ability1ButtonBehaivor = ButtonBehaivor.Non;          // to suppress cancel assault mode (Prefer PolingAction
        ultimateButtonReleaseMax = 30;          // to suppress over use artillery
        enableMoveUltimate = true;
        break;

        case Hero.Brigitte:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        supportPrioloty = 0.5;
        primaryFireButtonPressMax = 20;
        secondaryFireButtonReleaseMax = rva([5, 30]);      // to suppress over use shield
        ability2ButtonBehaivor = ButtonBehaivor.Non;           // to more use repair pack
        supportButtons = [
            Button.SecondaryFire
        ];
        break;

        case Hero.Cassidy:
        aimScatter = 0.3;
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Middle;
        secondaryFireButtonReleaseMax = 40;     // to suppress overuse fanning shot
        break;

        case Hero.Doomfist:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        ability2ButtonReleaseMin = 3;
        secondaryFireButtonPressMin = 1.3;      // to charge enough rocket punch
        secondaryFireButtonPressMax = 1.5;      // to suppress charge over rocket punch
        jumpButtonReleaseMax = 10;              // to to suppress cancel rocket punch
        enableMoveUltimate = true;
        break;

        case Hero.Dva:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        ultimateButtonReleaseMax = 40;          // to suppress over use self-destruct / call mech
        break;

        case Hero.Echo:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        jumpButtonReleaseMax = 5;               // to more use float
        jumpButtonPressMax = 5;                 // to more use float
        ultimateButtonReleaseMax = 40;
        break;

        case Hero.Genji:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        jumpButtonReleaseMax = 2.5;             // to more use double jump
        jumpButtonPressMax = 5;                 // to more use wall crime
        ability1ButtonReleaseMax = 1;           // to more use swift strike when reset cooldown by kill
        ability1ButtonPressMax = 1;             // to more use swift strike when reset cooldown by kill
        enableDoubleJump = true;
        break;

        case Hero.Hanzo:
        aimScatter = 0.3;
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        primaryFireButtonReleaseMin = 0;
        primaryFireButtonReleaseMax = 1.0;
        primaryFireButtonPressMin = 0.6;       // to charge enough storm bow  0.7s
        primaryFireButtonPressMax = 0.8;       // to suppress charge over storm bow
        jumpButtonPressMax = 5;                 // to more use wall crime
        secondaryFireButtonBehaivor = ButtonBehaivor.Non;
        enableDoubleJump = true;
        break;

        case Hero.Hazard:
        ability1ButtonBehaivor = ButtonBehaivor.Non;
        secondaryFireButtonReleaseMax = 10;
        jumpButtonPressMax = 5;                 // to more use wall crime
        break;

        case Hero.Illari:
        aimScatter = 0.3;
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        supportPrioloty = 1.0;
        supportButtons = [
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.PrimaryFire,
            Button.Ability1
        ];
        primaryFireButtonReleaseMin = 0.2;      // to charge enough sorar rifle
        primaryFireButtonReleaseMax = 0.8;      // to suppress charge over sorar rifle
        primaryFireButtonPressMin = 0;          // to more use sorar rifle
        primaryFireButtonPressMax = 1.0;          // to more use sorar rifle
        break;

        case Hero.JunkerQueen:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        break;

        case Hero.Junkrat:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        enableMoveUltimate = true;
        break;

        case Hero.Kiriko:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        supportPrioloty = 1.0;
        jumpButtonPressMax = 5;                 // to more use wall crime
        ability1ButtonBehaivor = ButtonBehaivor.Non;
        ability2ButtonBehaivor = ButtonBehaivor.Non;
        supportButtons = [
            Button.PrimaryFire
        ];
        attackButtons = [
            Button.SecondaryFire
        ];
        break;

        case Hero.Lucio:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        jumpButtonPressMax = 10;
        ability1ButtonBehaivor = ButtonBehaivor.Non;          // to suppress over use cross fade (Prefer PolingAction
        supportPrioloty = 0.75;
        supportButtons = [
            Button.Ability2
        ];
        break;

        case Hero.Lifeweaver:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        supportPrioloty = 1.0;
        jumpButtonReleaseMax = 5;               // to more use life step
        ability1ButtonBehaivor = ButtonBehaivor.Non;          // to suppress over use petal platform (Prefer PolingAction
        ability2ButtonBehaivor = ButtonBehaivor.Non;          // to suppress over use life grip (Prefer PolingAction
        supportButtons = [
            Button.PrimaryFire
        ];
        attackButtons = [
            Button.SecondaryFire
        ];
        primaryFireButtonPressMin = 0.8;        // to charge enough healing blossom
        primaryFireButtonPressMax = 1.4;        // to suppress charge over healing blossom
        enableDoubleJump = true;
        enablePlaceUltimate = true;
        break;

        case Hero.Mauga:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Middle;
        break;

        case Hero.Mei:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        ability1ButtonBehaivor = ButtonBehaivor.Non;         // to suppress over use cyro freeze (Prefer PolingAction
        ability2ButtonBehaivor = ButtonBehaivor.Non;         // to suppress over use ice wall (Prefer PolingAction
        break;

        case Hero.Mercy:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        supportPrioloty = 1.0;
        secondaryFireButtonReleaseMax = 10;     // to suppress over use damage boost
        ability1ButtonPressMin = 0;
        ability1ButtonPressMax = 2;
        ability1ButtonPressMin = 0;
        ability1ButtonPressMax = 2;
        ability2ButtonPressMax = 10;            // to more use resuscitation
        ability2ButtonReleaseMax = 0.1;         // to more use resuscitation
        supportButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        break;

        case Hero.Moira:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        supportPrioloty = 0.75;
        supportButtons = [
            Button.PrimaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        break;

        case Hero.Orisa:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Middle;
        break;

        case Hero.Pharah:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        jumpButtonPressMax = 5;                 // to more use hover jet
        break;

        case Hero.Ramattra:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        secondaryFireButtonReleaseMax = rva([5, 30]);      // to suppress over use guard (on nemesis form)
        secondaryFireButtonPressMin = 2;        // to more keep guard (on nemesis form)
        secondaryFireButtonPressMax = 4;        // to more keep guard (on nemesis form)
        ability1ButtonBehaivor = ButtonBehaivor.Non;          // control Prefer PolingAction
        ultimateButtonReleaseMax = 40;          // to suppress over use inhillation
        enablePlaceSecondary = true;
        break;

        case Hero.Reaper:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        ability2ButtonBehaivor = ButtonBehaivor.Non;         // to suppress over use shadow step (Prefer PolingAction
        break;

        case Hero.Reinhardt:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        primaryFireButtonPressMax = 20;
        secondaryFireButtonReleaseMax = rva([5, 30]);     // to suppress over use barrier
        break;

        case Hero.Roadhog:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Middle;
        secondaryFireButtonPressMin = 2;        // to deploy barrier to close distance
        secondaryFireButtonReleaseMax = 15;        // to deploy barrier to close distance
        break;

        case Hero.Sigma:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        primaryFireButtonReleaseMax = 0;        // to more confirm gravity flax
        secondaryFireButtonReleaseMax = 3;      // to deploy barrier to far distance
        secondaryFireButtonPressMin = 0.1;        // to deploy barrier to close distance
        secondaryFireButtonPressMax = 0.5;        // to deploy barrier to close distance
        break;

        case Hero.Sojourn:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        secondaryFireButtonReleaseMax = 6;      // to suppress over use railgun (charge enough)
        secondaryFireButtonPressMax = 1;        // to suppress over use railgun (charge enough)
        break;
        
        case Hero.Soldier76:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        break;

        case Hero.Sombra:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        secondaryFireButtonPressMin = 1.5;      // to charge enough hack
        ability2ButtonReleaseMax = 15;          // to suppress over use trans locator
        break;

        case Hero.Symmetra:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        secondaryFireButtonPressMin = 1;        // to charge enough photon bomb
        secondaryFireButtonPressMax = 3;        // to suppress charge over photon bomb
        ability1ButtonReleaseMin = 1;           // to more use turret
        ability1ButtonReleaseMax = 3;           // to more use turret
        ability2ButtonReleaseMax = 15;          // to suppress over use teleporter
        enablePlaceUltimate = true;
        break;

        case Hero.Torbjorn:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        break;

        case Hero.Tracer:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        ability2ButtonBehaivor = ButtonBehaivor.Non;         // control Prefer PolingAction
        break;

        case Hero.Juno:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        supportPrioloty = 1.0;
        enableDoubleJump = true;
        break;

        case Hero.Venture:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        break;

        case Hero.Widowmaker:
        aimScatter = 0.1;
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        primaryFireButtonReleaseMin = 1.3;      // to charge enough sniper rifle 1.4s
        primaryFireButtonReleaseMax = 1.5;      // to suppress charge over sniper rifle
        primaryFireButtonPressMin = 0;          // to more use sniper rifle
        primaryFireButtonPressMax = 1.0;        // to more use sniper rifle
        secondaryFireButtonPressMin = 30;       // to more use scorp
        secondaryFireButtonPressMax = 40;       // to more use scorp
        jumpButtonReleaseMax = 40;              // to suppress cancel scorp
        ability1ButtonBehaivor = ButtonBehaivor.Non;          // control Prefer PolingAction
        ability2ButtonReleaseMax = 30;          // to suppress over use venom mine
        break;

        case Hero.Winston:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        primaryFireButtonPressMax = 20;
        secondaryFireButtonReleaseMax = 20;
        ultimateButtonReleaseMax = 40;          // to suppress over use primal rage
        break;

        case Hero.WreckingBall:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        primaryFireButtonPressMax = 15;         // to more use quad machine gun
        primaryFireButtonReleaseMax = 10;       // to suppress over use quad machine gun
        secondaryFireButtonBehaivor = ButtonBehaivor.Non;     // control Prefer PolingAction
        ability1ButtonReleaseMax = 30;          // to suppress cancel ball form
        crouchButtonPressMax = 4;               // to more use pile driver
        enableHoldSecondary = true;
        break;

        case Hero.Zarya:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        attackButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1
        ];
        ability1ButtonReleaseMax = 10;
        ability2ButtonBehaivor = ButtonBehaivor.Non;          // control Prefer PolingAction
        break;

        case Hero.Zenyatta:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        supportPrioloty = 0.5;
        supportButtons = [
            Button.Ability1,
            Button.Ability2
        ];
        primaryFireButtonReleaseMin = 1;
        secondaryFireButtonReleaseMin = 1;
        ability1ButtonBehaivor = ButtonBehaivor.Non;        // control by Prefer PolingAction
        ability2ButtonBehaivor = ButtonBehaivor.Non;        // control by Prefer PolingAction
        ultimateButtonReleaseMax = 30;          // to suppress over use transcendence
        break;

        default:
        break;
    }

    // if already button control enabled
    if(enableButtonControl){
        // restart button control by param changed
        enableButtonControl = false;
        Wait(0.1, WaitBehavior.IgnoreCondition);
        enableButtonControl = true;
    }

    hasButtonControlPropety = true;
}

enum ButtonBehaivor{
    Non,
    ReleasePress,
    ReleaseRepeat
}

// TAG Bot/ButtonControl/StartButtonControl ----------
define noButtonControl: false;   // for debug

playervar define enableButtonControl;

rule: "Bot/ButtonControl/StartButtonControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    hasButtonControlPropety &&
    enableButtonControl
){
    async StartButtonControlOfPrimaryFire();
    async StartButtonControlOfSecondaryFire();
    async StartButtonControlOfAbility1();
    async StartButtonControlOfAbility2();
    async StartButtonControlOfUltimate();
    async StartButtonControlOfJump();
    async StartButtonControlOfCrouch();
}

// implment as function, cuz parallel running by async call
void StartButtonControlOfPrimaryFire()"StartButtonControlOfPrimaryFire"{
    StartButtonControl(
        Button.PrimaryFire,
        primaryFireButtonBehaivor,
        primaryFireButtonReleaseMin,
        primaryFireButtonReleaseMax,
        primaryFireButtonPressMin,
        primaryFireButtonPressMax,
        true
    );
}

void StartButtonControlOfSecondaryFire()"StartButtonControlOfSecondaryFire"{
    StartButtonControl(
        Button.SecondaryFire,
        secondaryFireButtonBehaivor,
        secondaryFireButtonReleaseMin,
        secondaryFireButtonReleaseMax,
        secondaryFireButtonPressMin,
        secondaryFireButtonPressMax,
        true
    );
}

void StartButtonControlOfAbility1()"StartButtonControlOfAbility1"{
    StartButtonControl(
        Button.Ability1,
        ability1ButtonBehaivor,
        ability1ButtonReleaseMin,
        ability1ButtonReleaseMax,
        ability1ButtonPressMin,
        ability1ButtonPressMax,
        true
    );
}

void StartButtonControlOfAbility2()"StartButtonControlOfAbility2"{
    StartButtonControl(
        Button.Ability2,
        ability2ButtonBehaivor,
        ability2ButtonReleaseMin,
        ability2ButtonReleaseMax,
        ability2ButtonPressMin,
        ability2ButtonPressMax,
        true
    );
}

void StartButtonControlOfUltimate()"StartButtonControlOfUltimate"{
    StartButtonControl(
        Button.Ultimate,
        ultimateButtonBehaivor,
        ultimateButtonReleaseMin,
        ultimateButtonReleaseMax,
        ultimateButtonPressMin,
        ultimateButtonPressMax,
        false
    );
}

void StartButtonControlOfJump()"StartButtonControlOfJump"{
    StartButtonControl(
        Button.Jump,
        ButtonBehaivor.ReleasePress,
        jumpButtonReleaseMin,
        jumpButtonReleaseMax,
        jumpButtonPressMin,
        jumpButtonPressMax,
        false
    );
}

void StartButtonControlOfCrouch()"StartButtonControlOfCrouch"{
    StartButtonControl(
        Button.Crouch,
        ButtonBehaivor.ReleasePress,
        ultimateButtonReleaseMin,
        ultimateButtonReleaseMax,
        ultimateButtonPressMin,
        ultimateButtonPressMax,
        false
    );
}

// TAG Bot/ButtonControl/StopButtonControl ----------
rule: "Bot/ButtonControl/StopButtonControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    hasButtonControlPropety &&
    !enableButtonControl
){
    StopHoldingButton(ep, Button.PrimaryFire);
    StopHoldingButton(ep, Button.SecondaryFire);
    StopHoldingButton(ep, Button.Ability1);
    StopHoldingButton(ep, Button.Ability2);
    StopHoldingButton(ep, Button.Ultimate);
    StopHoldingButton(ep, Button.Jump);
    StopHoldingButton(ep, Button.Crouch);
    // ClearButtonBit();
}

// TAG Bot/ButtonControl/Action ----------
playervar define isRepeatFiring;
playervar define repeatDuring;

// can's implment as function, cuz need control instance each button
Boolean isMatchButton(in define matchButton, in define butttons){
    return IsTrueForAny(butttons, ae == matchButton);
}

// can's implment as function, cuz need control instance each button
void StartButtonControl(in define button, in define buttonBehaivor, in define releaseMin, in define releaseMax, in define pressMin, in define pressMax, in define isDependingState){
    if(noButtonControl) return;
    if(buttonBehaivor == ButtonBehaivor.Non) return;

    define startButton = false;

    // if state dependent buttons
    if(
        isDependingState
    ){
        // if attack state dependent buttons
        if(
            actionState == ActionState.Attack &&
            isMatchButton(button, attackButtons)
        ){
            startButton = true;
        }
        // if support state dependent buttons
        else if(
            actionState == ActionState.Support &&
            isMatchButton(button, supportButtons)
        ){
            startButton = true;
        }
        // else
    }
    else{
        startButton = true;
    }

    if(!startButton){
        // stop button
        StopHoldingButton(ep, button);
    }
    else{
        // release action at first  by prob
        if(IsTrueProbability(50)){
            // button release during
            Wait(RandomReal(releaseMin, releaseMax), WaitBehavior.IgnoreCondition);
            if(!enableButtonControl){ return; }
        }

        // start button
        while(enableButtonControl){
            WaitUntilServerLoadLimitRelease(watchUpdateRate);
            if(!enableButtonControl){ return; }
            
            // release-press action
            if(buttonBehaivor == ButtonBehaivor.ReleasePress){
                // start hold button
                if(
                    button == Button.Ultimate &&
                    (
                        // is using ult already
                        IsUsingUltimate() ||
                        // enemy density low
                        IsTrueProbability(50 * (1 - EnemyDensity(aimTarget, ActionRange.Close)))
                    )                
                ){
                    // wait only, skip hold ultimate button 
                    Wait(0.1, WaitBehavior.IgnoreCondition);
                }
                else if(
                    button == Button.Jump &&
                    enableDoubleJump &&
                    IsTrueProbability(50)
                ){
                    // use double jump ability
                    StartHoldingButton(ep, button);
                    Wait(RandomReal(0.1, 0.5), WaitBehavior.IgnoreCondition);
                    StopHoldingButton(ep, button);
                    Wait(RandomReal(0.1, 0.5), WaitBehavior.IgnoreCondition);                    
                    StartHoldingButton(ep, button);
                }
                else{
                    StartHoldingButton(ep, button);     // SetButtonBit(button, true);
                }
                
                // button hold during
                Wait(RandomReal(pressMin, pressMax), WaitBehavior.IgnoreCondition);
                if(!enableButtonControl){ return; }

                // stop hold button
                StopHoldingButton(ep, button);          // SetButtonBit(button, false);
            }
            // release-repeat action
            else if(buttonBehaivor == ButtonBehaivor.ReleaseRepeat){
                // set button repeat during
                repeatDuring = RandomReal(pressMin, pressMax);
                
                // start repeat button
                isRepeatFiring = true;                  // SetButtonBit(button, true);
                while(
                    isRepeatFiring            
                ){
                    // button repeat during
                    PressButton(ep, button);
                    Wait(0.25, WaitBehavior.IgnoreCondition);
                    if(!enableButtonControl){ return; }
                }
                
                // stop repeat button
                                                        // SetButtonBit(button, false);
            }
            
            // button release during
            Wait(RandomReal(releaseMin, releaseMax), WaitBehavior.IgnoreCondition);
            if(!enableButtonControl){ return; }
        }
    }
}

rule: "Bot/ButtonControl/releaseIsRepeatFiring"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    isRepeatFiring
){
    // button repeat during
    Wait(repeatDuring, WaitBehavior.AbortWhenFalse);
    isRepeatFiring = false;
}

// TAG Debug ----------

// rule: "Bot/Debug/ShowDebugInfo"
// Event.OngoingPlayer
// if(
//     isBotEnableTeam &&
//     IsDummyBot()
// ){
//     // enable button text
//     CreateInWorldText(
//         AllPlayers(),
//         <"Bot_Active = <0>\n\rAction_State = <1>\n\rButton_CONTROL = <2>\n\rButton_Flag = <3>",
//             isBotActive ? "true" : "false",
//                 actionState == ActionState.Non ?        "Non" :
//                 actionState == ActionState.Attack ?     "Attack" :
//                 actionState == ActionState.Support ?    "Support" :
//                                                         "???",
//                     enableButtonControl,
//                         buttonFlagText
//         >,
//         EyePosition(ep) + Vector(0, 1.25, 0),
//         0.8, Clipping.DoNotClip, InworldTextRev.VisibleToPositionStringAndColor,
//         enableButtonControl ? Color.Yellow : Color.White,
//         Spectators.DefaultVisibility);
//     // while(true){
//     //     // tagret line
//     //     if(
//     //         actionState != ActionState.Non &&
//     //         HasSpawned(aimTarget)
//     //     ){
//     //         dbgPlyBemEft(EyePosition(ep), BodyPosition(aimTarget));
//     //     }
//     //     Wait(1);
//     // }
// }

// define initialButtonFlag: [false, false, false, false, false, false, false];
// playervar define buttonFlag = initialButtonFlag;

// void SetButtonBit(define button, define state)"SetButtonBit"{
//     switch(button){
//         case Button.PrimaryFire:    if(state) buttonFlag[0] = true;    else buttonFlag[0] = false; break;
//         case Button.SecondaryFire:  if(state) buttonFlag[1] = true;    else buttonFlag[1] = false; break;
//         case Button.Ability1:       if(state) buttonFlag[2] = true;    else buttonFlag[2] = false; break;
//         case Button.Ability2:       if(state) buttonFlag[3] = true;    else buttonFlag[3] = false; break;
//         case Button.Ultimate:       if(state) buttonFlag[4] = true;    else buttonFlag[4] = false; break;
//         case Button.Jump:           if(state) buttonFlag[5] = true;    else buttonFlag[5] = false; break;
//         case Button.Crouch:         if(state) buttonFlag[6] = true;    else buttonFlag[6] = false; break;
//     }
//     UpdateButtonFlagText();
// }

// void ClearButtonBit()"SetButtonBit"{
//     buttonFlag = initialButtonFlag;
//     UpdateButtonFlagText();
// }

// playervar define buttonFlagText;

// void UpdateButtonFlagText()"UpdateButtonFlagText"{
//     buttonFlagText = "";
//     for (define index = 0; index < CountOf(buttonFlag); index++)
//     {
//         if(buttonFlag[index]){
//             buttonFlagText = <"<0><1>", buttonFlagText, "1">;
//         }
//         else{
//             buttonFlagText = <"<0><1>", buttonFlagText, "0">;
//         }
//     }
// }