import "Utility.del";
import "Debug.del";

globalvar define botEnableTeams! = [Team.Team1, Team.Team2];
// define isBotEnableTeam: IsTrueForAny(botEnableTeams, TeamOf(ep) == ae);
define isBotEnableTeam: true;

// TAG Bot/Spawn ----------
enum BotAsset{
    EnemyType,
    Hero,
    Count
}

// TAG EnemyType ----------
playervar define enemyType;
enum EnemyType{
    Non = 0,
    Minion = 1,
    Elite = 2,
    General = 3,
    Boss = 4,
    Zombie = 8
}

// TAG BotAsset ----------
void CreateBotsByAssetList(define assetList, define team, define addLimitNum)"CreateBotsByAssetList"{
    // select asset in assetList
    define asset! = ValueInArray(assetList, RandomInteger(0, CountOf(assetList) - 1));
    // make bot by asset
    CreateBotsByAsset(asset, team, addLimitNum);
}

void CreateBotsByAsset(define asset, define team, define addLimitNum)"CreateBotsByAsset"{
    define addNum! = 0;
    // run asset items
    for(define assetIdx! = 0; assetIdx < CountOf(asset); assetIdx++){
        // run bot count in asset
        for(define botCount! = 0; botCount < asset[assetIdx][BotAsset.Count]; botCount ++){
            if(addNum >= addLimitNum){
                break;
            }

            if(IsAssemblingHeroes()){
                Wait(RandomReal(0, 3), WaitBehavior.IgnoreCondition);
            }

            // get empty slot
            define slot! = GetEmptySlotNo(team);
            for(
                define tryCount = 10;
                tryCount > 0 && PlayersInSlot(slot, team) == null;
                tryCount --
            ){
                // create bot
                CreateDummyBot(
                    asset[assetIdx][BotAsset.Hero],
                    team,
                    slot,
                    SpawnPoints(team)[0],
                    RandomDirection()
                );
                Wait(0.1, WaitBehavior.IgnoreCondition);
            }
            // set Bot type as enemy type
            define bot! = PlayersInSlot(slot, team);
            bot.enemyType = asset[assetIdx][BotAsset.EnemyType];
            // count up addNum
            addNum ++;
        }
    }
}

void CreateBotsByHeroList(define heroList, define team)"CreateBotsByHeroList"{
    // create bot by asset
    for(define listIdx! = 0; listIdx < CountOf(heroList); listIdx++){
        // get empty slot
        define slot! = GetEmptySlotNo(team);
        for(
            define tryCount = 0;
            tryCount <= 10 && PlayersInSlot(slot, team) == null;
            tryCount ++
        ){
            // create bot
            CreateDummyBot(
                heroList[listIdx],
                team,
                slot,
                SpawnPoints(team)[0],
                RandomDirection()
            );
            Wait(0.1, WaitBehavior.IgnoreCondition);
        }
    }
}

void CreateBotsByHeroRandomList(define heroList, define num, define team)"CreateBotsByHeroRandomList"{
    // create bot by asset
    for(define listIdx! = 0; listIdx < num; listIdx++){
        // get empty slot
        define slot! = GetEmptySlotNo(team);
        for(
            define tryCount = 0;
            tryCount <= 10 && PlayersInSlot(slot, team) == null;
            tryCount ++
        ){
            // create bot
            CreateDummyBot(
                RandomValueInArray(heroList),
                team,
                slot,
                SpawnPoints(team)[0],
                RandomDirection()
            );
            Wait(0.1, WaitBehavior.IgnoreCondition);
        }
    }
}

void CreateBotsByHeroInput(define hero, define num, define team)"CreateBotsByHeroInput"{
    // create bot by asset
    for(define listIdx! = 0; listIdx < num; listIdx++){
        // get empty slot
        define slot! = GetEmptySlotNo(team);
        for(
            define tryCount = 0;
            tryCount <= 10 && PlayersInSlot(slot, team) == null;
            tryCount ++
        ){
            // create bot
            CreateDummyBot(
                hero,
                team,
                slot,
                SpawnPoints(team)[0],
                RandomDirection()
            );
            Wait(0.1, WaitBehavior.IgnoreCondition);
        }
    }
}

void DestroyBots(define team!)"DestroyBots"{
    for(define slotIdx! = 0; slotIdx < builtinMaxSlotNum; slotIdx ++){
        DestroyDummyBot(
            team, slotIdx);
        Wait(0.01, WaitBehavior.IgnoreCondition);
    }
}

// TAG Bot/SetBotInfo ----------
playervar define heroName;
playervar define aimScatter;
playervar define supportPrioloty;
playervar define supportButtons;
playervar define attackButtons;
playervar define hasDoubleJumpButtonAbility;
playervar define canFireButtonCombination;

playervar define primaryFireButtonBehaivor;
playervar define primaryFireButtonReleaseMin;
playervar define primaryFireButtonReleaseMax;
playervar define primaryFireButtonPressMin;
playervar define primaryFireButtonPressMax;

playervar define secondaryFireButtonBehaivor;
playervar define secondaryFireButtonReleaseMin;
playervar define secondaryFireButtonReleaseMax;
playervar define secondaryFireButtonPressMin;
playervar define secondaryFireButtonPressMax;

playervar define ability1ButtonReleaseMin;
playervar define ability1ButtonReleaseMax;
playervar define ability1ButtonPressMin;
playervar define ability1ButtonPressMax;

playervar define ability2ButtonReleaseMin;
playervar define ability2ButtonReleaseMax;
playervar define ability2ButtonPressMin;
playervar define ability2ButtonPressMax;

playervar define ultimateButtonReleaseMin;
playervar define ultimateButtonReleaseMax;
playervar define ultimateButtonPressMin;
playervar define ultimateButtonPressMax;

playervar define crouchButtonReleaseMin;
playervar define crouchButtonReleaseMax;
playervar define crouchButtonPressMin;
playervar define crouchButtonPressMax;

playervar define jumpButtonReleaseMin;
playervar define jumpButtonReleaseMax;
playervar define jumpButtonPressMin;
playervar define jumpButtonPressMax;

define Bot_ActionRange_Melee: 0;
define Bot_ActionRange_Close: 10;
define Bot_ActionRange_Middle: 20;
define Bot_ActionRange_Far: 30;
define Bot_ActionRange_CanFind: 40;

playervar define actionRangeMin!;
playervar define actionRangeMax!;
playervar define routineInitCompleted!;

rule: "Bot/SetActionRoutineBySpawned"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    HasSpawned()
){
    SetHeroActionRoutine();
    // start StateControl
    routineInitCompleted = true;
}

rule: "Bot/SetActionRoutineByStartDuplicate"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    HeroOf() == Hero.Echo &&
    IsDuplicating(ep)
){
    SetHeroActionRoutine();
}

rule: "Bot/SetActionRoutineByEndDuplicate"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    HeroOf() == Hero.Echo &&
    !IsDuplicating(ep)
){
    SetHeroActionRoutine();
}

playervar define isLifeWeever;

void SetHeroActionRoutine()"SetHeroActionRoutine"{
    target = 0;
    heroName = "";

    if(enemyType == EnemyType.Zombie){
        actionRangeMin = Bot_ActionRange_Melee;
        actionRangeMax = Bot_ActionRange_Melee;
        return;
    }

    // default routine
    aimScatter = 0.5;
    actionRangeMin = Bot_ActionRange_Melee;
    actionRangeMax = Bot_ActionRange_Melee;
    canFireButtonCombination = false;
    hasDoubleJumpButtonAbility = false;
    supportPrioloty = 0.0;
    supportButtons = [
        Button.PrimaryFire,
        Button.SecondaryFire,
        Button.Ability1,
        Button.Ability2
    ];
    attackButtons = [
        Button.PrimaryFire,
        Button.SecondaryFire,
        Button.Ability1,
        Button.Ability2
    ];

    primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
    primaryFireButtonReleaseMin = 0;
    primaryFireButtonReleaseMax = 1;
    primaryFireButtonPressMin = 0;
    primaryFireButtonPressMax = 10;

    secondaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
    secondaryFireButtonReleaseMin = 0;
    secondaryFireButtonReleaseMax = 1;
    secondaryFireButtonPressMin = 0;
    secondaryFireButtonPressMax = 10;

    ability1ButtonReleaseMin = 0;
    ability1ButtonReleaseMax = 5;
    ability1ButtonPressMin = 0;
    ability1ButtonPressMax = 1;

    ability2ButtonReleaseMin = 0;
    ability2ButtonReleaseMax = 5;
    ability2ButtonPressMin = 0;
    ability2ButtonPressMax = 1;

    ultimateButtonReleaseMin = 0;
    ultimateButtonReleaseMax = 10;
    ultimateButtonPressMin = 0;
    ultimateButtonPressMax = 1;

    crouchButtonReleaseMin = 0;
    crouchButtonReleaseMax = 10;
    crouchButtonPressMin = 0;
    crouchButtonPressMax = 1;

    jumpButtonReleaseMin = 0;
    jumpButtonReleaseMax = 10;
    jumpButtonPressMin = 0;
    jumpButtonPressMax = 1;

    define hero! = HeroOf();
    if(
        hero == Hero.Echo &&
        IsDuplicating()
    ){
        hero = HeroBeingDuplicated();
    }
    
    switch(hero){
        case Hero.Ana:
        heroName = "Ana";
        aimScatter = 0.4;
        actionRangeMin = Bot_ActionRange_Middle;
        actionRangeMax = Bot_ActionRange_Far;
        canFireButtonCombination = true;
        supportPrioloty = 1.0;
        secondaryFireButtonPressMin = 30;
        secondaryFireButtonPressMax = 40;
        jumpButtonReleaseMax = 40;
        supportButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability2
        ];
        break;

        case Hero.Ashe:
        heroName = "Ashe";
        aimScatter = 0.3;
        actionRangeMin = Bot_ActionRange_Middle;
        actionRangeMax = Bot_ActionRange_Far;
        canFireButtonCombination = true;
        primaryFireButtonBehaivor = ButtonBehaivor.ReleaseRepeat;
        secondaryFireButtonPressMin = 30;
        secondaryFireButtonPressMax = 40;
        jumpButtonReleaseMax = 40;
        break;

        case Hero.Baptiste:
        heroName = "Baptiste";
        actionRangeMin = Bot_ActionRange_Middle;
        actionRangeMax = Bot_ActionRange_Far;
        canFireButtonCombination = true;
        supportPrioloty = 1.0;
        jumpButtonReleaseMax = 5;
        crouchButtonReleaseMax = 1;
        crouchButtonPressMax = 20;
        supportButtons = [
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.PrimaryFire,
            Button.Ability1
        ];
        break;

        case Hero.Bastion:
        heroName = "Bastion";
        actionRangeMin = Bot_ActionRange_Close;
        actionRangeMax = Bot_ActionRange_Far;
        primaryFireButtonReleaseMax = 1;
        ability1ButtonReleaseMin = 8;
        ability1ButtonReleaseMax = 10;
        ultimateButtonReleaseMax = 30;
        break;

        case Hero.Brigitte:
        heroName = "Brigitte";
        actionRangeMin = Bot_ActionRange_Melee;
        actionRangeMax = Bot_ActionRange_Melee;
        canFireButtonCombination = true;
        supportPrioloty = 0.75;
        secondaryFireButtonReleaseMax = 20;
        secondaryFireButtonPressMin = 3;
        secondaryFireButtonPressMax = 6;
        ability2ButtonReleaseMax = 1;
        supportButtons = [
            Button.SecondaryFire,
            Button.Ability2
        ];
        break;

        case Hero.Cassidy:
        heroName = "Cassidy";
        aimScatter = 0.3;
        actionRangeMin = Bot_ActionRange_Melee;
        actionRangeMax = Bot_ActionRange_Far;
        secondaryFireButtonReleaseMax = 20;
        break;

        case Hero.Doomfist:
        heroName = "Doomfist";
        actionRangeMin = Bot_ActionRange_Melee;
        actionRangeMax = Bot_ActionRange_Close;
        ability2ButtonReleaseMin = 3;
        secondaryFireButtonPressMin = 1.3;
        secondaryFireButtonPressMax = 1.5;
        break;

        case Hero.Dva:
        heroName = "Dva";
        actionRangeMin = Bot_ActionRange_Melee;
        actionRangeMax = Bot_ActionRange_Close;
        ultimateButtonReleaseMax = 30;
        break;

        case Hero.Echo:
        heroName = "Echo";
        actionRangeMin = Bot_ActionRange_Close;
        actionRangeMax = Bot_ActionRange_Middle;
        break;

        case Hero.Genji:
        heroName = "Genji";
        actionRangeMin = Bot_ActionRange_Melee;
        actionRangeMax = Bot_ActionRange_Close;
        hasDoubleJumpButtonAbility = true;
        ability1ButtonReleaseMax = 0.5; 
        ability1ButtonPressMax = 0.5; 
        jumpButtonReleaseMax = 2.5;
        jumpButtonPressMax = 2;
        break;

        case Hero.Hanzo:
        heroName = "Hanzo";
        aimScatter = 0.3;
        actionRangeMin = Bot_ActionRange_Middle;
        actionRangeMax = Bot_ActionRange_Far;
        hasDoubleJumpButtonAbility = true;
        primaryFireButtonReleaseMax = 1;
        primaryFireButtonPressMin = 0.80;
        primaryFireButtonPressMax = 1.30;
        secondaryFireButtonBehaivor = ButtonBehaivor.Non;
        break;

        case Hero.JunkerQueen:
        heroName = "JunkerQueen";
        actionRangeMin = Bot_ActionRange_Melee;
        actionRangeMax = Bot_ActionRange_Melee;
        break;

        case Hero.Junkrat:
        heroName = "Junkrat";
        actionRangeMin = Bot_ActionRange_Close;
        actionRangeMax = Bot_ActionRange_Far;
        break;

        case Hero.Kiriko:
        heroName = "Kiriko";
        actionRangeMin = Bot_ActionRange_Middle;
        actionRangeMax = Bot_ActionRange_Far;
        supportPrioloty = 1.0;
        ability1ButtonPressMax = 1;
        ability1ButtonReleaseMax = 1;
        supportButtons = [
            Button.PrimaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.SecondaryFire
        ];
        break;

        case Hero.Lucio:
        heroName = "Lucio";
        actionRangeMin = Bot_ActionRange_Close;
        actionRangeMax = Bot_ActionRange_Middle;
        supportPrioloty = 0.5;
        supportButtons = [
            Button.Ability1,
            Button.Ability2
        ];
        break;

        case Hero.Mei:
        heroName = "Mei";
        actionRangeMin = Bot_ActionRange_Melee;
        actionRangeMax = Bot_ActionRange_Close;
        break;

        case Hero.Mercy:
        heroName = "Mercy";
        actionRangeMin = Bot_ActionRange_Middle;
        actionRangeMax = Bot_ActionRange_Far;
        supportPrioloty = 1.0;
        secondaryFireButtonReleaseMax = 10;
        ability2ButtonPressMax = 10;
        ability2ButtonReleaseMax = 0.1;
        supportButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        break;

        case Hero.Moira:
        heroName = "Moira";
        actionRangeMin = Bot_ActionRange_Close;
        actionRangeMax = Bot_ActionRange_Middle;
        supportPrioloty = 0.75;
        supportButtons = [
            Button.PrimaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        break;

        case Hero.Orisa:
        heroName = "Orisa";
        actionRangeMin = Bot_ActionRange_Melee;
        actionRangeMax = Bot_ActionRange_Middle;
        break;

        case Hero.Pharah:
        heroName = "Pharah";
        actionRangeMin = Bot_ActionRange_Close;
        actionRangeMax = Bot_ActionRange_Middle;
        jumpButtonReleaseMax = 5;
        jumpButtonPressMax = 5;
        break;

        case Hero.Reaper:
        heroName = "Reaper";
        actionRangeMin = Bot_ActionRange_Melee;
        actionRangeMax = Bot_ActionRange_Close;
        ability2ButtonReleaseMax = 20;
        break;

        case Hero.Reinhardt:
        heroName = "Reinhardt";
        actionRangeMin = Bot_ActionRange_Melee;
        actionRangeMax = Bot_ActionRange_Melee;
        secondaryFireButtonReleaseMax = 30;
        break;

        case Hero.Roadhog:
        heroName = "Roadhog";
        actionRangeMin = Bot_ActionRange_Melee;
        actionRangeMax = Bot_ActionRange_Close;
        break;

        case Hero.Sigma:
        heroName = "Sigma";
        actionRangeMin = Bot_ActionRange_Close;
        actionRangeMax = Bot_ActionRange_Middle;
        primaryFireButtonReleaseMax = 0;
        secondaryFireButtonReleaseMax = 5;
        secondaryFireButtonPressMax = 1;
        break;

        case Hero.Sojourn:
        heroName = "Sojourn";
        actionRangeMin = Bot_ActionRange_Close;
        actionRangeMax = Bot_ActionRange_Far;
        secondaryFireButtonReleaseMax = 10;
        break;
        
        case Hero.Soldier76:
        heroName = "Soldier76";
        actionRangeMin = Bot_ActionRange_Close;
        actionRangeMax = Bot_ActionRange_Far;
        break;

        case Hero.Sombra:
        heroName = "Sombra";
        actionRangeMin = Bot_ActionRange_Close;
        actionRangeMax = Bot_ActionRange_Middle;
        secondaryFireButtonPressMin = 1.5;
        ability2ButtonReleaseMax = 10;
        ability2ButtonPressMax = 0.5;
        break;

        case Hero.Symmetra:
        heroName = "Symmetra";
        actionRangeMin = Bot_ActionRange_Melee;
        actionRangeMax = Bot_ActionRange_Close;
        secondaryFireButtonPressMin = 1;
        secondaryFireButtonPressMax = 3;
        ability1ButtonReleaseMin = 1;
        ability1ButtonReleaseMax = 3;
        ability2ButtonReleaseMax = 30;
        break;

        case Hero.Torbjorn:
        heroName = "Torbjorn";
        actionRangeMin = Bot_ActionRange_Close;
        actionRangeMax = Bot_ActionRange_Middle;
        break;

        case Hero.Tracer:
        heroName = "Tracer";
        actionRangeMin = Bot_ActionRange_Melee;
        actionRangeMax = Bot_ActionRange_Close;
        break;

        case Hero.Widowmaker:
        heroName = "Widowmaker";
        aimScatter = 0.1;
        actionRangeMin = Bot_ActionRange_Middle;
        actionRangeMax = Bot_ActionRange_Far;
        canFireButtonCombination = true;
        primaryFireButtonReleaseMin = 0.8;
        primaryFireButtonReleaseMax = 1.0;
        primaryFireButtonPressMin = 0;
        primaryFireButtonPressMax = 1;
        secondaryFireButtonPressMin = 30;
        secondaryFireButtonPressMax = 40;
        jumpButtonReleaseMax = 40;
        ability1ButtonReleaseMax = 40;
        ability2ButtonReleaseMax = 40;
        break;

        case Hero.Winston:
        heroName = "Winston";
        actionRangeMin = Bot_ActionRange_Melee;
        actionRangeMax = Bot_ActionRange_Close;
        ultimateButtonReleaseMax = 30;
        break;

        case Hero.WreckingBall:
        heroName = "WreckingBall";
        actionRangeMin = Bot_ActionRange_Melee;
        actionRangeMax = Bot_ActionRange_Middle;
        primaryFireButtonReleaseMax = 15;
        secondaryFireButtonReleaseMin = 1;
        secondaryFireButtonReleaseMax = 1;
        secondaryFireButtonPressMin = 1;
        secondaryFireButtonPressMax = 6;
        ability1ButtonReleaseMax = 20;
        crouchButtonPressMax = 2;
        break;

        case Hero.Zarya:
        heroName = "Zarya";
        actionRangeMin = Bot_ActionRange_Close;
        actionRangeMax = Bot_ActionRange_Middle;
        supportPrioloty = 0.25;
        supportButtons = [
            Button.Ability2
        ];
        attackButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1
        ];        ability1ButtonReleaseMax = 10;
        ability1ButtonPressMax = 0.5;
        ability2ButtonReleaseMax = 0.5;
        ability2ButtonPressMax = 0.5;
        break;

        case Hero.Zenyatta:
        heroName = "Zenyatta";
        actionRangeMin = Bot_ActionRange_Middle;
        actionRangeMax = Bot_ActionRange_Far;
        supportPrioloty = 0.5;
        supportButtons = [
            Button.Ability1,
            Button.Ability2
        ];        primaryFireButtonReleaseMin = 1;
        secondaryFireButtonReleaseMin = 1;
        ability1ButtonPressMin = 0.5;
        ability1ButtonPressMax = 0.5;
        ability1ButtonReleaseMin = 0.5;
        ability1ButtonReleaseMax = 0.5;
        ability2ButtonPressMin = 0.5;
        ability2ButtonPressMax = 0.5;
        ability2ButtonReleaseMin = 0.5;
        ability2ButtonReleaseMax = 0.5;
        ultimateButtonReleaseMax = 30;
        break;

        case Hero.Ramattra:
        heroName = "Ramattra";
        actionRangeMin = Bot_ActionRange_Melee;
        actionRangeMax = Bot_ActionRange_Close;
        ability1ButtonReleaseMin = 8;
        ability1ButtonReleaseMax = 16;
        secondaryFireButtonReleaseMax = 10;
        secondaryFireButtonPressMin = 2;
        secondaryFireButtonPressMax = 4;
        break;

        default:
        isLifeWeever = true;
        actionRangeMin = Bot_ActionRange_Middle;
        actionRangeMax = Bot_ActionRange_Far;
        hasDoubleJumpButtonAbility = true;
        supportPrioloty = 1.0;
        supportButtons = [
            Button.PrimaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.SecondaryFire,
            Button.Ability1
        ];
        primaryFireButtonPressMin = 0.8;
        primaryFireButtonPressMax = 1.4;
    }    
}

enum ActionState{
    Non,
    Attack,
    Support
}

enum ActionRange{
    Non,
    Melee,
    Close,
    Middle,
    Far
}

enum ButtonBehaivor{
    Non,
    ReleasePress,
    ReleaseRepeat
}

// TAG Bot/ActionState/StateControl ----------
playervar define watchUpdateRate = 2.0;
playervar define actionState;
playervar define target;

define CanFindRange(define player) :
    DistanceBetween(ep, player) <= Bot_ActionRange_CanFind;

define CanFindLine(define player) :
    IsInLineOfSight(EyePosition(ep), EyePosition(player), BarrierLOS.NoBarriersBlock);

define IsSightedAsEnemy(define player):
        TeamOf(ep) != TeamOf(player) &&
        HasSpawned(player) &&
        IsAlive(player) &&
        CanFindRange(player) &&
        CanFindLine(player) &&
        !(
            IsStealth(player) &&
            DistanceBetween(player, ep) >= 4
        );

define IsSightedAsFriend(define player):
        TeamOf(ep) == TeamOf(player) &&
        HasSpawned(player) &&
        (IsAlive(player) || CanResurrect(player)) &&
        CanFindRange(player) &&
        (CanFindLine(player) || CanSwiftStep(player));

define FindAttackTarget()"FindAttackTarget"{
    return FirstOf(
        SortedArray(
            FilteredArray(
                AllPlayers(EnemyTeamOf()),
                IsSightedAsEnemy(ae)
            ),
            DistanceBetween(ep, ae)
        )
    );
}

define FindSupportTarget()"FindSupportTarget"{
    return FirstOf(
        SortedArray(
            FilteredArray(
                AllPlayers(TeamOf()),
                ae != ep &&
                NormalizedHealth(ae) < 1.0 &&
                IsSightedAsFriend(ae)
            ),
            NormalizedHealth(ae)
        )
    );
}

define FindTarget()"FindTarget"{
    define candidateTarget!;

    for(define tryCount! = 0; tryCount <= 3; tryCount++){
        // by supportPrioloty
        if(ProbabilityTrue(100 * supportPrioloty))
        {
            // find support target
            candidateTarget = FindSupportTarget();

            // not found heal target
            if(candidateTarget == 0){
                // find attack target
                candidateTarget = FindAttackTarget();
            }
        }
        else{
            // find attack target
            candidateTarget = FindAttackTarget();
        }

        if(candidateTarget != 0){
            break;
        }
        Wait(0.1, WaitBehavior.AbortWhenFalse);
    }

    target = candidateTarget;

    if(target == 0){
        StopFacing(ep);
    }
}

define GetNextActionState()"GetNextActionState"{
    define nextActionState!;
    // has target
    if(
        IsAlive() &&
        !IsInSpawnRoom() &&
        target != 0 &&
        HasSpawned(target)
    ){
        // target is friend
        if(
            TeamOf() == TeamOf(target)
        ){
            // Attack state
            nextActionState = ActionState.Support;
        }
        else{
            // Support state
            nextActionState = ActionState.Attack; 
        }
    }
    else{
        // target has not spawn
        nextActionState = ActionState.Non;  
    }
    
    return nextActionState;
}

void SetActionState(define player, define nextActionState!) "SetActionState"{
    // if state changed
    if(nextActionState != player.actionState){
        // reset for button control reload
        enableButtonControl = false;
        Wait(MinValue(), WaitBehavior.IgnoreCondition);
        // set next state
        player.actionState = nextActionState;        
    }
}

define IsSighted(define player):
        player != 0 &&
        TeamOf(ep) == TeamOf(player) ?
            IsSightedAsFriend(player) :
            IsSightedAsEnemy(player);

rule: "Bot/ActionState/StateControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    routineInitCompleted &&
    IsAlive() &&
    !IsInSpawnRoom()
){
    WaitRandomForDistributeServerLoad();

    // is not in spawn room
    if(
        IsAlive()
    ){ 
        define tryFindTarget! = false;
        
        // target not Sighted
        if(!IsSighted(target)){
            tryFindTarget = true;
        }
        // is support role and now supporting
        else if(
            0 < supportPrioloty &&
            actionState == ActionState.Support
        ){
            if(
                // heal target completed
                NormalizedHealth(target) >= 1 ||
                !(
                    IsAlive(target) ||  // target alive
                    CanResurrect(ep)    // can resurrect
                )
            ){
                // change target 
                tryFindTarget = true;
            }
            else if(
                // by no support prioloty
                ProbabilityTrue(100 * (1 - supportPrioloty)) ||
                // by support target health
                ProbabilityTrue(100 * NormalizedHealth(target))                
            ){
                // change target 
                tryFindTarget = true;
            }
        }
        // is not support role hero
        else{
            if(
                // target dead
                !IsAlive(target)
            ){
                // change target 
                tryFindTarget = true;
            }
            else if(
                // by support prioloty
                ProbabilityTrue(100 * supportPrioloty) ||
                // by attack target health
                ProbabilityTrue(50 * NormalizedHealth(target))
            ){
                // change target 
                tryFindTarget = true;
            }
        }

        // get new target
        if(tryFindTarget){
            // find target
            FindTarget();
        }
    }

    // apply next state
    SetActionState(ep, GetNextActionState());

    // call attack by near bots
    CallAttackNearBot();

    Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

rule: "Bot/ActionState/SetNonStateByDead"
Event.OnDeath
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    actionState != ActionState.Non &&
    Victim() == ep
){
    // reset target
    target = 0;
    // apply next state
    SetActionState(ep, ActionState.Non);
}

rule: "Bot/ActionState/ChangeTargetByTargetDead"
Event.OnElimination
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    actionState != ActionState.Non &&
    Victim() == target
){
    // find next target
    FindTarget();
    // apply next state
    SetActionState(ep, GetNextActionState());
}

rule: "Bot/ActionState/ChangeSupportTargetByTargetHealCompleted"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    actionState == ActionState.Support &&
    NormalizedHealth(target) >= 1.0
){
    // find next target
    FindTarget();
    // apply next state
    SetActionState(ep, GetNextActionState());
}

rule: "Bot/ActionState/ChangeTargetByDamageTaken"
Event.OnDamageTaken
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    actionState != ActionState.Non &&
    Attacker() != ep
){
    // change target by target helth
    if(
        ProbabilityTrue(50 * NormalizedHealth(target))
    ){
        // set target by attacker
        target = Attacker();
    }
    // apply next state
    SetActionState(ep, GetNextActionState());

    // call attack by near bots
    CallAttackNearBot();

    // reduce overrun
    Wait(3.0, WaitBehavior.IgnoreCondition);
}

rule: "Bot/ActionState/CallAttackByDamageTaken"
Event.OnDamageTaken
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    actionState == ActionState.Non &&
    Attacker() != ep
){
    // set target by attacker
    target = Attacker();
    // apply next state
    SetActionState(ep, GetNextActionState());

    // call attack by near bots
    CallAttackNearBot();
}

globalvar define isCallAttackCoolingDown1! = false;
globalvar define isCallAttackCoolingDown2! = false;

void CallAttackNearBot()"CallAttackNearBot"{
    // check cooldown for reduce overrun
    if(TeamOf() == Team.Team1){
        if(isCallAttackCoolingDown1) return;
        isCallAttackCoolingDown1 = true;
    }
    else{
        if(isCallAttackCoolingDown2) return;
        isCallAttackCoolingDown2 = true;
    }

    // in attack
    if( 
        actionState == ActionState.Attack
    ){
        // get near idle bot
        define nearFriends = FilteredArray(
            PlayersWithinRadius(
                ep, 30, TeamOf(), RadiusLOS.Off
            ),
            (
                ae != ep &&
                IsDummyBot(ae) &&
                IsAlive(ae) &&
                ae.actionState == ActionState.Non
            )
        );

        for(define nearFriendsIndex! = 0; nearFriendsIndex < CountOf(nearFriends); nearFriendsIndex ++){
            // set target
            nearFriends[nearFriendsIndex].target = ep.target;
            // set attack 
            SetActionState(nearFriends[nearFriendsIndex], ActionState.Attack);
        }

        // dbgHudTxt(<"CallAttackNearBot team=<0>, count=<1>", TeamOf(), CountOf(nearFriends)>);
    }
}

rule: "Bot/ActionState/callAttackCoolDown"
Event.OngoingGlobal
if(
    isCallAttackCoolingDown1 ||
    isCallAttackCoolingDown2
){
    Wait(1.0, WaitBehavior.IgnoreCondition);
    isCallAttackCoolingDown1 = false;
    isCallAttackCoolingDown2 = false;
    Loop();
}

playervar define moveDirFB!;
playervar define moveDirLR!;
playervar define enableRetreat! = true;

void SetMoveDir() playervar "SetMoveDir"{
    if(enemyType == EnemyType.Zombie){
        moveDirFB = Forward();
        moveDirLR = NoDirection();
        return;
    }

    define skipSetMoveDirLR! = false;
    define distToTarget! = DistanceBetween(ep, target);

    // set move dir forward/backward
    // retreat for recevie heal
    if(
        enableRetreat ?
            ProbabilityTrue(150 * (1 - NormalizedHealth())) :
            false &&
        actionState == ActionState.Attack
    ){
        // move to healer for heal
        // set to near healer
        define moveToPlayer! = 
            FirstOf(
                SortedArray(
                    FilteredArray(
                        AllLivingPlayers(TeamOf()),
                        (
                            ep != ae &&
                            0 < ae.supportPrioloty &&
                            IsInLineOfSight(EyePosition(ep), EyePosition(ae))
                        )
                    ),
                    DistanceBetween(ep, ae)
                )
            );
        
        // has near healer
        if(moveToPlayer != null){
            // move to healer
            define dirToHealer! = LocalVectorOf(DirectionTowards(ep, moveToPlayer), ep, Transformation.Rotation);
            moveDirFB = Vector(0, 0, ZOf(dirToHealer));
            moveDirLR = Vector(XOf(dirToHealer), 0, 0);
            skipSetMoveDirLR = true;
        }
        else{
            moveDirFB = Backward();
        }
    }
    else if(actionState != ActionState.Non){
        // move to target for combat
        define distRate! = actionState == ActionState.Attack ? 1 : 0.75;

        // target is far
        if(
            distToTarget > (actionRangeMax * distRate)
        ){
            moveDirFB = Forward();
        }
        // target is close
        else if(
            distToTarget < (actionRangeMin * distRate)
        ){
            moveDirFB = Backward();
        }
        else{
            moveDirFB = NoDirection();
        }
    }

    // set move dir left/right
    // if skip set
    if(!skipSetMoveDirLR){
        // attack state
        if(actionState == ActionState.Attack){
            // start sidestep by distance close and health less
            if(
                ProbabilityTrue(75 * (1 - NormalizedHealth())) ||   // by lost health
                ProbabilityTrue(75 * (1 - (distToTarget / 30)))     // by target distance clsoe
            ){
                if(moveDirLR == NoDirection()){
                    moveDirLR = RandomValueInArray([Left(), Right()]);
                }
                else if(ProbabilityTrue(75)){
                    // change sidestep to reverse
                    moveDirLR = -moveDirLR;
                }
                else{
                    // not change sidestep
                    moveDirLR = moveDirLR;
                }
            }
            else{
                // stop sidestep
                moveDirLR = NoDirection();
            }
        }
        else{
            moveDirLR = NoDirection();
        }
    }
}

playervar define enableCheckAbyss! = true;
playervar define confirmMoveDir!;

void StartMove(define player!) playervar "StartMove"{
    if(noMoving) return;
    
    player.confirmMoveDir = player.moveDirFB + player.moveDirLR;
    // move to position is abyss
    if(
        player.enableCheckAbyss &&
        IsBelowAbyss(
            BlockedPositonByLocalVector(
                player,
                player.confirmMoveDir,
                walkMeterPerSec * player.watchUpdateRate
            )
        )
    ){
        StopMove(player);
    }
    else{
        if(
            player.confirmMoveDir != NoDirection()
        ){
            StartThrottleInDirection(
                player,
                player.confirmMoveDir,
                1,
                Relative.ToPlayer,
                ThrottleBehavior.ReplaceExistingThrottle,
                ThrottleRev.DirectionAndMagnitude
            );
        }
        else{
            StopMove(player);
        }
    }
}

void StopMove(define player) playervar "StopMove"{
    player.moveDirFB = NoDirection();
    player.moveDirLR = NoDirection();
    StopThrottleInDirection(player);
} 

define aimingPosition:
    (
        IsInAlternateForm(target) ?
        EyePosition(target) - Vector(0, 0.6, 0)     // body position
            :
        EyePosition(target) + Vector(0, 0.2, 0)     // head position
    ) +
    RandomPosition(aimScatter, aimScatter, aimScatter)  // aim scatter
        +
    Vector(0, -(aimScatter / 2), 0);    // vertical offset

void StartFacingTarget() playervar "StartFacingTarget"{
    if(
        target != 0 &&
        HasSpawned(target) &&
        IsAlive(target)
    ){
        StartFacing(
            ep, DirectionTowards(EyePosition(), aimingPosition),
            300, Relative.ToWorld, FacingRev.DirectionAndTurnRate);
    }
    else{
        StopFacing(ep);
    }
}

// TAG Bot/ActionState/Non ----------
rule: "Bot/ActionState/Non"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    actionState == ActionState.Non
){
    WaitRandomForDistributeServerLoad();

    // stop button
    enableButtonControl = false;

    // stop facing
    StopFacing(ep);

    // stop move
    StopMove(ep);

    // hero unique action
    PolingHeroUniqueAction();

    Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

// TAG Bot/ActionState/AttackOrSupport ----------
rule: "Bot/ActionState/AttackOrSupport"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    (
        actionState == ActionState.Attack ||
        actionState == ActionState.Support
    )
){
    WaitRandomForDistributeServerLoad();

    // start button control
    enableButtonControl = true;

    // start facing
    StartFacingTarget();

    // set moveDir for comvat
    SetMoveDir();

    // start move by moveDir
    StartMove(ep);

    // hero unique action
    PolingHeroUniqueAction();

    Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

// TAG Bot/HeroUniqueAction ----------
define meleeDamage: 25.0;
define meleeRange: 3.0;

define isOutOfAmmo:
        (MaxAmmo(ep, 0) > 0 && Ammo(ep, 0) <= 0) ||
        (MaxAmmo(ep, 1) > 0 && Ammo(ep, 1) <= 0);

void PolingHeroUniqueAction() playervar "PolingHeroUniqueAction"{
    // common action
    // reload
    if(
        // in idle
        actionState == ActionState.Non
    ){
        // reload by condition 
        PressButton(ep, Button.Reload);
    }
    else{
        // in combat
        if(
            isOutOfAmmo
        ){
            // reload if out of ammo
            PressButton(ep, Button.Reload);
        }
    }

    if(
        // in combat
        actionState != ActionState.Non
    ){
        // melee
        while(
            actionState == ActionState.Attack &&
            target != 0 &&
            DistanceBetween(ep, target) <= meleeRange &&
            (
                Health(target) <= meleeDamage * 2 ||
                enemyType == EnemyType.Zombie
            )
        ){
            // melee by punch
            PressButton(ep, Button.Melee);
            Wait(0.5, WaitBehavior.AbortWhenFalse);
        }

        if(enemyType == EnemyType.Zombie) return;

        // hero unique action
        // Ashe
        if(
            HeroOf() == Hero.Ashe
        ){
            if(
                ProbabilityTrue(90) &&
                IsReloading()
            ){
                // stop repeat firing for reduce reload cancel
                isRepeatFiring = false;
                // reload until full load
                for(define tryCount! = 0; tryCount <= 3; tryCount++){
                    StopHoldingButton(ep, Button.PrimaryFire);
                    StopHoldingButton(ep, Button.SecondaryFire);
                    Wait(0.5, WaitBehavior.AbortWhenFalse);    // wait stop repeat fire
                    PressButton(ep, Button.Reload);
                    if(MaxAmmo(ep, 0) <= Ammo(ep, 0)){
                        break;
                    }
                }
                // restore aiming
                StartHoldingButton(ep, Button.SecondaryFire);
            }
        }
        // Mercy
        else if(
            HeroOf() == Hero.Mercy
        ){
            if(actionState == ActionState.Attack){
                // change to gun
                SetWeapon(ep, 2);
            }
            else if(actionState == ActionState.Support){
                // change to heal arm
                SetWeapon(ep, 1);
                if(
                    // by target health
                    ProbabilityTrue(100 * NormalizedHealth(target))
                ){
                    // damage boost
                    StopHoldingButton(ep, Button.PrimaryFire);
                    StartHoldingButton(ep, Button.SecondaryFire);
                }
                else{
                    // heal
                    StopHoldingButton(ep, Button.SecondaryFire);
                    StartHoldingButton(ep, Button.PrimaryFire);
                }
            }
        }
        // LifeWeever
        else if(
            isLifeWeever
        ){
            // lift up own
            if(
                ProbabilityTrue(50) &&
                AbilityCooldown(ep, Button.Ability1) <= 0
            ){
                // try use lift on own below
                for(define tryCount! = 0; tryCount <= 3; tryCount++){
                    StopMove(ep);
                    FacingTargetBetweenBelowPosition(target, 0.01);
                    Wait(0.5, WaitBehavior.AbortWhenFalse);
                    
                    PressButton(ep, Button.Ability1);
                    if(AbilityCooldown(ep, Button.Ability1) > 0){
                        break;
                    }
                }
                // restore facing
                StartFacingTarget();
            }
        }
        // Widowmaker
        else if(
            HeroOf() == Hero.Widowmaker
        ){
            // fallback by graple hook
            if(
                ProbabilityTrue(90) &&
                DistanceBetween(ep, target) <= Bot_ActionRange_Middle &&
                AbilityCooldown(ep, Button.Ability1) <= 0
            ){
                // try use graple at backword
                for(define tryCount! = 0; tryCount <= 3; tryCount++){
                    StopMove(ep);
                    FacingRetreatPosition(target, 5);
                    Wait(0.5, WaitBehavior.AbortWhenFalse);
                    PressButton(ep, Button.Ability1);
                    if(AbilityCooldown(ep, Button.Ability1) > 0){
                        break;
                    }
                }
                // restore aiming
                // StartHoldingButton(ep, Button.SecondaryFire);
                // restore facing
                StartFacingTarget();
            }
        }

        // Torbjorn
        else if(
            HeroOf() == Hero.Torbjorn
        ){
            if(
                // change to melee mode condition
                ProbabilityTrue(50) &&
                DistanceBetween(ep, target) <= Bot_ActionRange_Close
            ){
                // change to melee arm
                SetWeapon(ep, 2);

                while(
                    // continue melee mode condition
                    ProbabilityTrue(95) &&
                    DistanceBetween(ep, target) <= Bot_ActionRange_Close
                ){
                    // move foward for melee
                    moveDirFB = Forward();
                    moveDirLR = NoDirection();
                    StartMove(ep);
                    // melee by hammer
                    PressButton(ep, Button.PrimaryFire);
                    Wait(0.5, WaitBehavior.AbortWhenFalse);
                }
            }
            else{
                // change to gun
                SetWeapon(ep, 1);
            }
        }
        // WreckingBall
        else if(
            HeroOf() == Hero.WreckingBall
        ){
            if(
                ProbabilityTrue(90) &&
                // can use pile driver
                AbilityCooldown(ep, Button.Crouch) <= 0 &&
                IsButtonHeld(ep, Button.Crouch)
            ){
                // jump for pile driver
                ApplyImpulse(ep, Up(),
                    10, Relative.ToWorld, ContraryMotion.Cancel);
            }
        }
    }
}

define AbortIfNotDepEcho()"AbortIfNotDepEcho"{
    if(HeroOf() == Hero.Echo){
        AbortIf(!IsDuplicating());
    }
}

rule: "Bot/HeroUniqueAction/positionMoveUltmate"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    IsUsingUltimate()
){
    AbortIfNotDepEcho();

    define isPositionMoveUltmate!;
    define waitForStartMove!;
    define moveSpeed!;
    define attackCount!;
    define multiPosAttack!;

    // postion move hero
    if(
        HeroOf() == Hero.Doomfist ||
        HeroBeingDuplicated() == Hero.Doomfist
    ){
        isPositionMoveUltmate = true;
        waitForStartMove = 0.5;
        moveSpeed = 0.06;
        attackCount = 1;
        multiPosAttack = false;
    }
    else if(
        HeroOf() == Hero.Bastion ||
        HeroBeingDuplicated() == Hero.Bastion
    ){
        isPositionMoveUltmate = true;
        waitForStartMove = 1.0;
        moveSpeed = 0.05;
        attackCount = 3;
        multiPosAttack = ProbabilityTrue(50);
    }
    else if(
        HeroOf() == Hero.Junkrat ||
        HeroBeingDuplicated() == Hero.Junkrat
    ){
        isPositionMoveUltmate = true;
        waitForStartMove = 1.5;
        moveSpeed = 0.075;
        attackCount = 1;
        multiPosAttack = false;
    }

    if(isPositionMoveUltmate){
        // stop current moving input
        StopMove(ep);
        StopHoldingButton(ep, Button.PrimaryFire);
        StopHoldingButton(ep, Button.SecondaryFire);
        // wait for start mode
        Wait(waitForStartMove, WaitBehavior.AbortWhenFalse);
        // start move postion selecter to foward
        moveDirFB = Forward();
        moveDirLR = NoDirection();
        StartMove(ep);
        // decrease move speed if multi position attack mode
        if(multiPosAttack) moveSpeed -= 0.01;
        // wait for arrival target
        define dist! = DistanceBetween(ep, target);
        dist = dist <= 5 ? 5 : dist;
        Wait(dist * (moveSpeed), WaitBehavior.AbortWhenFalse);
        // stop move if not multi position attack mode
        if(!multiPosAttack){
            StopMove(ep);
        }
        // trigger attack by attackCount
        for(define tryCount! = 0; tryCount < attackCount; tryCount++){
            PressButton(ep, Button.PrimaryFire);
            if(tryCount < attackCount){
                // button press with random interval
                Wait(RandomReal(0.2, 0.5), WaitBehavior.IgnoreCondition);
            }
        }
        // reduce walking after ult
        StopMove(ep);
    }
}

rule: "Bot/HeroUniqueAction/positionAimUltmate"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    UltimateChargePercent() >= DefaultPercentage() &&
    IsButtonHeld(ep, Button.Ultimate)
){
    AbortIfNotDepEcho();

    define isPositionAimUltmate!;
    define isRotateProb!;
    
    // postion aim hero
    if(
        HeroOf() == Hero.Baptiste ||
        HeroBeingDuplicated() == Hero.Baptiste
    ){
        isPositionAimUltmate = true;
        isRotateProb = 10;
    }
    else if(
        HeroOf() == Hero.Symmetra ||
        HeroBeingDuplicated() == Hero.Symmetra
    ){
        isPositionAimUltmate = true;
        isRotateProb = 50;
    }

    if(isPositionAimUltmate){
        StopHoldingButton(ep, Button.PrimaryFire);
        StopHoldingButton(ep, Button.SecondaryFire);
        for(define tryCount! = 0; tryCount <= 3; tryCount++){
            FacingTargetBetweenBelowPosition(target, 0.5);
            Wait(0.25, WaitBehavior.IgnoreCondition);

            if(ProbabilityTrue(isRotateProb)){
                PressButton(ep, Button.Ultimate);    
                Wait(0.1, WaitBehavior.IgnoreCondition);
            }

            PressButton(ep, Button.PrimaryFire);
            if(UltimateChargePercent() < DefaultPercentage()){
                break;
            }
        }
        // restore facing
        StartFacingTarget();
    }
}

rule: "Bot/HeroUniqueAction/positionAimSecondary"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    AbilityCooldown(ep, Button.SecondaryFire) <= 0 &&
    IsButtonHeld(ep, Button.SecondaryFire)
){
    AbortIfNotDepEcho();

    define isPositionAimSecondary!;

    if(
        HeroOf() == Hero.Ramattra ||
        HeroBeingDuplicated() == Hero.Ramattra
    ){
        if(
            // is omnic form
            !IsNemesisForm(ep)
        ){
            isPositionAimSecondary = true;
        }        
    }

    if(isPositionAimSecondary){
        StopHoldingButton(ep, Button.PrimaryFire);
        for(define tryCount! = 0; tryCount <= 3; tryCount++){
            FacingTargetBetweenBelowPosition(target, 0.25);
            Wait(0.25, WaitBehavior.IgnoreCondition);
            
            PressButton(ep, Button.SecondaryFire);
            if(AbilityCooldown(ep, Button.SecondaryFire) > 0){
                break;
            }
        }
        // restore facing
        StartFacingTarget();
    }
}

rule: "Bot/HeroUniqueAction/positionFixSecondary"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    IsFiringSecondary()
){
    AbortIfNotDepEcho();

    define isPositionFixSecondary!;

    if(
        HeroOf() == Hero.WreckingBall ||
        HeroBeingDuplicated() == Hero.WreckingBall
    ){
        if(IsFiringSecondary()){
            isPositionFixSecondary = true;       
        }
    }

    if(isPositionFixSecondary){
        // accsell for ball tackle
        StopHoldingButton(ep, Button.PrimaryFire);
        define moveDir!;
        while(IsFiringSecondary()){
            if(SpeedOf() >= 12){
                moveDir = VectorTowards(ep, ClosestPlayerTo(ep, EnemyTeamOf()));
            }
            else{
                moveDir = RandomValueInArray([
                    Forward(),
                    Backward(),
                    Right(),
                    Left(),
                    Up(), Up(),
                    Down()
                ]);
            }
            // for ball charge
            ApplyImpulse(ep, 
                VectorTowards(ep, ClosestPlayerTo(ep, EnemyTeamOf())),
                20, Relative.ToWorld, ContraryMotion.Incorporate);
            Wait(RandomReal(0.25, 1.0), WaitBehavior.IgnoreCondition);
        }
    }
}


// TAG Bot/ButtonControl ----------
define noShooting: false;   // for debug
define noMoving: false;   // for debug

enum ButtonControl{
    button,
    buttonBehaivor,
    releaseMin,
    releaseMax,
    pressMin,
    pressMax
}

playervar define isRepeatFiring;
playervar define repeatDuring;

Boolean isMatchButton(define matchButton!, define butttons!){
    return IsTrueForAny(butttons, ae == matchButton);
}

define buttonControlPressScale: 1.0;
define buttonControlReleaseScale: 1.0;

// can's implment as function
void StartButtonControl(define bc){
    if(noShooting) return;
    if(enemyType == EnemyType.Zombie) return;

    define startButton! = false;

    // state dependent buttons
    define stateDependemtButtons! = [
        Button.PrimaryFire,
        Button.SecondaryFire,
        Button.Ability1,
        Button.Ability2
    ];
    
    // if state dependent buttons
    if(
        isMatchButton(bc[ButtonControl.button], stateDependemtButtons)
    ){
        // if match attack state buttons
        if(
            actionState == ActionState.Attack &&
            isMatchButton(bc[ButtonControl.button], attackButtons)
        ){
            startButton = true;
        }
        // if match support state buttons
        else if(
            actionState == ActionState.Support &&
            isMatchButton(bc[ButtonControl.button], supportButtons)
        ){
            startButton = true;
        }
    }
    else{
        startButton = true;
    }

    // is not start button
    if(!startButton){
        // stop button
        StopHoldingButton(ep, bc[ButtonControl.button]);
    }
    else{
        // start button

        // add debug text
        AddEnableButtonBit(bc[ButtonControl.button]);

        // not conbination fire
        if(!canFireButtonCombination){
            // if start primary button, release secondary button
            if(
                bc[ButtonControl.button] == Button.PrimaryFire &&
                IsButtonHeld(ep, Button.SecondaryFire)
            ){
                StopHoldingButton(ep, Button.SecondaryFire);
            }
            // if start secondary button, release primary button
            else if(
                bc[ButtonControl.button] == Button.SecondaryFire &&
                IsButtonHeld(ep, Button.PrimaryFire)
            ){
                StopHoldingButton(ep, Button.PrimaryFire);
            }
        }

        // release-press action
        if(bc[ButtonControl.buttonBehaivor] == ButtonBehaivor.ReleasePress){
            while(true){
                Wait(
                    RandomReal(
                        bc[ButtonControl.releaseMin],
                        bc[ButtonControl.releaseMax]
                    ) * buttonControlReleaseScale,
                    WaitBehavior.AbortWhenFalse
                );

                StartHoldingButton(ep, bc[ButtonControl.button]);

                if(
                    bc[ButtonControl.button] == Button.Jump &&
                    hasDoubleJumpButtonAbility &&
                    ProbabilityTrue(50)
                ){
                    // trigger double jump ability
                    Wait(RandomReal(0.1, 0.3), WaitBehavior.AbortWhenFalse);
                    StopHoldingButton(ep, bc[ButtonControl.button]);
                    Wait(RandomReal(0.1, 0.3), WaitBehavior.AbortWhenFalse);
                    StartHoldingButton(ep, bc[ButtonControl.button]);
                }

                Wait(
                    RandomReal(
                        bc[ButtonControl.pressMin],
                        bc[ButtonControl.pressMax]
                    ) * buttonControlPressScale,
                    WaitBehavior.AbortWhenFalse
                );

                StopHoldingButton(ep, bc[ButtonControl.button]);

                // PressFirstButtonWhenIdle();
            }
        }
        // release-repeat action
        else if(bc[ButtonControl.buttonBehaivor] == ButtonBehaivor.ReleaseRepeat){
            while(true){
                Wait(
                    RandomReal(
                        bc[ButtonControl.releaseMin],
                        bc[ButtonControl.releaseMax]
                    ) * buttonControlReleaseScale,
                    WaitBehavior.AbortWhenFalse
                );

                repeatDuring = 
                    RandomReal(
                        bc[ButtonControl.pressMin],
                        bc[ButtonControl.pressMax]
                    ) * buttonControlPressScale;

                isRepeatFiring = true;
                
                while(
                    isRepeatFiring            
                ){
                    PressButton(ep, bc[ButtonControl.button]);
                    Wait(0.25, WaitBehavior.AbortWhenFalse);
                }

                // PressFirstButtonWhenIdle();
            }
        }
        // else
    }
}

rule: "Bot/ButtonControl/releaseIsRepeaFiring"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    isRepeatFiring
){
    Wait(repeatDuring, WaitBehavior.AbortWhenFalse);
    isRepeatFiring = false;
}

void PressFirstButtonWhenIdle()"PressFirstButtonWhenIdle"{
    Wait(0.1, WaitBehavior.AbortWhenFalse);
    if(
        !IsReloading() &&
        !IsFiringPrimary() &&
        !IsFiringSecondary() &&
        !IsUsingAbility1() &&
        !IsUsingAbility2()
    ){
        if(actionState == ActionState.Attack){
            StartHoldingButton(ep, FirstOf(attackButtons));
        }
        else if(actionState == ActionState.Support){
            StartHoldingButton(ep, FirstOf(supportButtons));
        }

        dbgPlyEft(ep);
    }
}

// TAG Bot/ButtonControl/PrimaryFire ----------
playervar define enableButtonControl!;

rule: "Bot/ButtonControl/PrimaryFire/StartButtonControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    enableButtonControl
){
    StartButtonControl(
        [
            Button.PrimaryFire,
            primaryFireButtonBehaivor,
            primaryFireButtonReleaseMin,
            primaryFireButtonReleaseMax,
            primaryFireButtonPressMin,
            primaryFireButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/SecondaryFire ----------
rule: "Bot/ButtonControl/SecondaryFire/StartButtonControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    enableButtonControl
){
    StartButtonControl(
        [
            Button.SecondaryFire,
            secondaryFireButtonBehaivor,
            secondaryFireButtonReleaseMin,
            secondaryFireButtonReleaseMax,
            secondaryFireButtonPressMin,
            secondaryFireButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Ability1 ----------
rule: "Bot/ButtonControl/Ability1/StartButtonControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    enableButtonControl
){
    StartButtonControl(
        [
            Button.Ability1,
            ButtonBehaivor.ReleasePress,
            ability1ButtonReleaseMin,
            ability1ButtonReleaseMax,
            ability1ButtonPressMin,
            ability1ButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Ability2 ----------
rule: "Bot/ButtonControl/Ability2/StartButtonControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    enableButtonControl
){
    StartButtonControl(
        [
            Button.Ability2,
            ButtonBehaivor.ReleasePress,
            ability2ButtonReleaseMin,
            ability2ButtonReleaseMax,
            ability2ButtonPressMin,
            ability2ButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Ultimate ----------
rule: "Bot/ButtonControl/Ultimate/StartButtonControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    enableButtonControl &&
    UltimateChargePercent() >= DefaultPercentage()
){
    StartButtonControl(
        [
            Button.Ultimate,
            ButtonBehaivor.ReleasePress,
            ultimateButtonReleaseMin,
            ultimateButtonReleaseMax,
            ultimateButtonPressMin,
            ultimateButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Crouch ----------
rule: "Bot/ButtonControl/Crouch/StartButtonControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    enableButtonControl
){
    StartButtonControl(
        [
            Button.Crouch,
            ButtonBehaivor.ReleasePress,
            crouchButtonReleaseMin,
            crouchButtonReleaseMax,
            crouchButtonPressMin,
            crouchButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/Jump ----------
rule: "Bot/ButtonControl/Jump/StartButtonControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    enableButtonControl
){
    StartButtonControl(
        [
            Button.Jump,
            ButtonBehaivor.ReleasePress,
            jumpButtonReleaseMin,
            jumpButtonReleaseMax,
            jumpButtonPressMin,
            jumpButtonPressMax
        ]
    );
}

// TAG Bot/ButtonControl/StopButtonControl ----------
rule: "Bot/ButtonControl/StopButtonControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    !enableButtonControl
){
    StopHoldingButton(ep, Button.PrimaryFire);
    StopHoldingButton(ep, Button.SecondaryFire);
    StopHoldingButton(ep, Button.Ability1);
    StopHoldingButton(ep, Button.Ability2);
    StopHoldingButton(ep, Button.Ultimate);
    StopHoldingButton(ep, Button.Jump);
    StopHoldingButton(ep, Button.Crouch);
    // StopHoldingButton(ep, Button.Reload);

    CleareEableButtonBit();
}

// TAG Debug ----------
rule: "Bot/Debug/ShowDebugInfo"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot()
){
    // actionState text
    CreateInWorldText(
        AllPlayers(),
        actionState == ActionState.Non ? "Non" :
            actionState == ActionState.Attack ? "Attack" :
            actionState == ActionState.Support ? "Support" :
            "Err",
        EyePosition(ep) + Vector(0, 1.25, 0),
        0.8, Clipping.DoNotClip, InworldTextRev.VisibleToPositionStringAndColor,
        actionState == ActionState.Non ? Color.White :
            actionState == ActionState.Attack ? Color.Red :
            actionState == ActionState.Support ? Color.Yellow :
            Color.Purple,
        Spectators.DefaultVisibility);

    // enableButtonControl text
    CreateInWorldText(
        AllPlayers(),
        enableButtonControl,
        EyePosition(ep) + Vector(0, 1.50, 0),
        0.8, Clipping.DoNotClip, InworldTextRev.VisibleToPositionStringAndColor,
        enableButtonControl ? Color.Yellow : Color.White,
        Spectators.DefaultVisibility);

    // enable button text
    CreateInWorldText(
        AllPlayers(),
        enableButtonBit,
        EyePosition(ep) + Vector(0, 1.75, 0),
        0.8, Clipping.DoNotClip, InworldTextRev.VisibleToPositionStringAndColor,
        enableButtonControl ? Color.Yellow : Color.White,
        Spectators.DefaultVisibility);

    // while(true){
    //     // tagret line
    //     if(target != 0){
    //         dbgPlyBemEft(EyePosition(ep), BodyPosition(target));
    //     }
    //     Wait(1);
    // }
}

playervar define enableButtonBit = allButtonBitsNon;   // fomrat is [9PS12]
define allButtonBitsNon: 90000;
define PrimaryFireButtonBit: 1000;
define SecondaryFireButtonBit: 100;
define Ability1FireButtonBit: 10;
define Ability2FireButtonBit: 1;

define AddEnableButtonBit(define button!)"AddEnableButtonBit"{
        // add debug text
        if(button == Button.PrimaryFire){
            enableButtonBit += PrimaryFireButtonBit;
        }
        else if(button == Button.SecondaryFire){
            enableButtonBit += SecondaryFireButtonBit;
        }
        else if(button == Button.Ability1){
            enableButtonBit += Ability1FireButtonBit;
        }
        else if(button == Button.Ability2){
            enableButtonBit += Ability2FireButtonBit;
        }
}

define CleareEableButtonBit()"CleareEableButtonBit"{
    enableButtonBit = allButtonBitsNon;
}