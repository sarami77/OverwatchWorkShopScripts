import "Utility.del";
import "Debug.del";
import "ServerOverLoadMeasures.del";

// split actionDistance by Attack Support

globalvar define botEnableTeams = [Team.Team1, Team.Team2];

define isBotEnableTeam: true;

// TAG Bot/Spawn ----------
enum BotAsset{
    EnemyType,
    Hero,
    Count
}

// TAG Bot/EnemyType ----------
playervar define enemyType;
enum EnemyType{
    Non,
    Minion,
    Elite,
    SubBoss,
    Boss
}

// TAG Bot/Asset ----------
define createBotInterval : 0.1;
define createBotMaxTryCount: 1;

void CreateBotsByAsset(define asset!, define team!, define addLimitNum!)"CreateBotsByAsset"{
    define addNum! = 0;
    // run asset items
    for(define assetIdx! = 0; assetIdx < CountOf(asset); assetIdx++){
        // run bot count in asset
        asset[assetIdx][BotAsset.Count] = RoundToInteger(asset[assetIdx][BotAsset.Count], Rounding.Up);
        for(define botCount! = 0; botCount < asset[assetIdx][BotAsset.Count]; botCount ++){
            if(addNum >= addLimitNum){
                break;
            }

            // if(IsAssemblingHeroes()){
            //     Wait(RandomReal(0.1, 3), WaitBehavior.IgnoreCondition);
            // }

            // get empty slot
            define slot! = GetEmptySlotNo(team);
            for(
                define tryCount! = 0;
                tryCount < createBotMaxTryCount && PlayersInSlot(slot, team) == null;
                tryCount ++
            ){
                // create bot
                CreateDummyBot(
                    asset[assetIdx][BotAsset.Hero],
                    team,
                    slot,
                    SpawnPoints(team)[0],
                    RandomDirection()
                );
                Wait(createBotInterval, WaitBehavior.IgnoreCondition);
                WaitReleaseServerLoad(ServerLoadType.BotCreate);
            }
            // set Bot type as enemy type
            define bot! = PlayersInSlot(slot, team);
            bot.enemyType = asset[assetIdx][BotAsset.EnemyType];
            // count up addNum
            addNum ++;
        }
    }
}

void CreateBotsByHeroList(define heroList!, define team!)"CreateBotsByHeroList"{
    // create bot by asset
    for(define listIdx! = 0; listIdx < CountOf(heroList); listIdx++){
        // get empty slot
        define slot! = GetEmptySlotNo(team);
        for(
            define tryCount! = 0;
            tryCount < createBotMaxTryCount && PlayersInSlot(slot, team) == null;
            tryCount ++
        ){
            // create bot
            CreateDummyBot(
                heroList[listIdx],
                team,
                slot,
                SpawnPoints(team)[0],
                RandomDirection()
            );
            Wait(createBotInterval, WaitBehavior.IgnoreCondition);
            WaitReleaseServerLoad(ServerLoadType.BotCreate);
        }
    }
}

void CreateBotsByHeroInput(define hero!, define num!, define team!)"CreateBotsByHeroInput"{
    // create bot by asset
    for(define listIdx! = 0; listIdx < num; listIdx++){
        // get empty slot
        define slot! = GetEmptySlotNo(team);
        for(
            define tryCount! = 0;
            tryCount < createBotMaxTryCount && PlayersInSlot(slot, team) == null;
            tryCount ++
        ){
            // create bot
            CreateDummyBot(
                hero,
                team,
                slot,
                SpawnPoints(team)[0],
                RandomDirection()
            );
            Wait(createBotInterval, WaitBehavior.IgnoreCondition);
            WaitReleaseServerLoad(ServerLoadType.BotCreate);
        }
    }
}

void DestroyBots(define team!)"DestroyBots"{
    for(define slotIdx! = 0; slotIdx < builtinMaxSlotNum; slotIdx ++){
        DestroyDummyBot(team, slotIdx);
        Wait(0.01, WaitBehavior.IgnoreCondition);
    }
}

// TAG Bot/Moving ----------
playervar define moveDirFB;
playervar define moveDirLR;
playervar define moveTarget;
playervar define enableRetreat! = true;

void SetMoveDir() playervar "SetMoveDir"{
    define distToTarget! = DistanceBetween(ep, aimTarget);
    define objPos! = CurrentObjectOnPosition();
    define nearEnemy! = ClosestPlayerTo(ep, EnemyTeamOf(ep));

    // move to healer or guard
    if(
        enableRetreat
        ?
            (
                // not using ult
                !IsUsingUltimate() &&
                // by low health
                IsProbabilityTrue(150 * (1 - NormalizedHealth()))
            )
        :
            false
    ){
        define supportPlayers = [];
        define notSupportPlayers = [];
        define livingFriends = AllLivingPlayers(TeamOf());

        // make support player list and not support player
        for(define index! = 0; index < CountOf(livingFriends); index ++){
            if(
                // not self
                ep != livingFriends[index]
            ){
                if(IsSupportHero(HeroOf(livingFriends[index]))){
                    // add to support player list
                    supportPlayers[CountOf(supportPlayers)] = livingFriends[index];
                }
                else{
                    // add to not support player list
                    notSupportPlayers[CountOf(notSupportPlayers)] = livingFriends[index];
                }
            }
        }

        // find near healer from support player list
        define nearHealer = 
            FirstOf(
                SortedArray(
                    supportPlayers,
                    DistanceBetween(ep, ae)
                )
            );

        // found healer and not near
        if(
            nearHealer != null &&
            DistanceBetween(ep, nearHealer) > ActionRange.Close / 2
        ){
            // move to healer
            moveTarget = PositionOf(nearHealer) + (FacingDirectionOf(nearHealer) * 3);
            moveDirFB = NoDirection();
            moveDirLR = NoDirection();
        }
        else{
            // find near guard from not support player list
            define nearGuard = 
                FirstOf(
                    SortedArray(
                        notSupportPlayers,
                        DistanceBetween(ep, ae)
                    )
                );

            // found guard and not near
            if(
                nearGuard != null &&
                DistanceBetween(ep, nearGuard) > ActionRange.Close / 2
            ){
                // move to guard
                moveTarget = PositionOf(nearGuard) + (FacingDirectionOf(nearGuard) * 3);
                moveDirFB = NoDirection();
                moveDirLR = NoDirection();
            }
            else{
                // move to back
                moveTarget = null;
                moveDirFB = Backward();
                moveDirLR = RandomValueInArray([NoDirection(), Right(), Left()]);
            }
        } 
    }

    // move to object for secure
    else if(
        // object pos valid
        objPos != null &&
        // payload escort player num is not enough
        (
            // current on object players num
            NumberOfPlayersOnObjective(TeamOf())
                <
            (
                // enemy close win
                IsCloseWin(EnemyTeamOf(ep))
                ?
                    // 1/2 players num of team
                    NumberOfPlayers(TeamOf()) / 2
                :
                    (
                        // offense team
                        IsTeamOnOffense(TeamOf())
                        ?
                            // 3 is max num of payload escort speed
                            3
                        :
                            (
                                // enemy on object
                                NumberOfPlayersOnObjective(EnemyTeamOf(ep)) > 0
                                ?
                                    // 1 is min num of payload stop
                                    1
                                :
                                    // not escorted payload
                                    0
                            )
                    )
            )
        )
    ){
        // move to object
        define dirToObject! = LocalVectorOf(DirectionTowards(ep, objPos), ep, Transformation.Rotation);
        moveTarget = null;
        moveDirFB = Vector(0, 0, ZOf(dirToObject));
        moveDirLR = Vector(XOf(dirToObject), 0, 0);
    }

    // // move away from enemy for support
    // else if(
    //     actionState == ActionState.Support &&
    //     nearEnemy != null &&
    //     // enemy is close
    //     DistanceBetween(ep, nearEnemy) <= ActionRange.Close
    // ){
    //     // set move away from enemy
    //     define dirFromEnemy! = LocalVectorOf(DirectionTowards(nearEnemy, ep), ep, Transformation.Rotation);
    //     moveTarget = null;
    //     moveDirFB = Vector(0, 0, ZOf(dirFromEnemy));
    //     moveDirLR = Vector(XOf(dirFromEnemy), 0, 0);
    //     dbgPlyEft(ep);
    // }

    // move to target for attack or support
    else if(actionState != ActionState.Non){
        moveTarget = null;
        // get distRate by actionState
        define distRate! = (actionState == ActionState.Attack) ? 1 : 0.5;
        // get enemy density
        define enemyDensity! = EnemyDensityRateOfTargetNear(aimTarget, ActionRange.Close);

        // front/back
        if(
            // target is close
            distToTarget < (actionRangeMin * distRate)
        ){
            moveDirFB = Backward();
        }
        else if(
            // target is far
            distToTarget > (actionRangeMax * distRate)
        ){
            if(
                // by enemy density high
                IsProbabilityTrue(150 * enemyDensity)
            ){
                // stop move forward for avoid surrounded by enemy
                moveDirFB = NoDirection();
            }
            else{
                moveDirFB = Forward();
            }
        }
        else{
            // stop move by own action range
            moveDirFB = NoDirection();
        }

        // right/left
        if(
            IsProbabilityTrue(
                100 *
                (
                    actionState == ActionState.Attack ? 
                    (
                        (
                            // by health low
                            1 - NormalizedHealth() +
                            // by distance close
                            1 - (distToTarget / ActionRange.Far)
                        ) *
                        // by enemy density low
                        1 - enemyDensity
                    )
                    :
                    (
                        // by health low
                        1 - NormalizedHealth()
                    )
                )
            )
        ){
            // start side step for dodge attack
            if(
                // no side step
                moveDirLR == NoDirection()
            ){
                // start left/right step
                moveDirLR = RandomValueInArray([Right(), Left()]);
            }
            else if(IsProbabilityTrue(75)){
                // change side step to reverse
                moveDirLR = -moveDirLR;
            }
        }
        else{
            // stop side step by not close and not low helth
            moveDirLR = NoDirection();
        }
    }
}

playervar define enableCheckAbyss! = true;

void StartMove(define player!) playervar "StartMove"{
    if(noMoving) return;

    define confirmMoveDir = NoDirection();
    define hasMoveTarget;

    if(
        moveDirFB != NoDirection() ||
        moveDirLR != NoDirection()
    ){
        confirmMoveDir = player.moveDirFB + player.moveDirLR;
        hasMoveTarget = false;
    }
    else if(moveTarget != null){
        confirmMoveDir = LocalVectorOf(DirectionTowards(player, moveTarget), ep, Transformation.Rotation);
        hasMoveTarget = true;
    }
    
    // move to position is abyss
    if(
        confirmMoveDir != NoDirection() &&
        (
            player.enableCheckAbyss &&
            IsBelowAbyss(
                BlockedPositonByLocalVector(
                    player,
                    confirmMoveDir,
                    walkMeterPerSec * player.watchUpdateRate
                )
            )
        )
    ){
        StopMove(player);
    }
    else{
        if(
            confirmMoveDir != NoDirection()
        ){
            if(!hasMoveTarget){
                StartThrottleInDirection(
                    player,
                    confirmMoveDir,
                    1,
                    Relative.ToPlayer,
                    ThrottleBehavior.ReplaceExistingThrottle,
                    ThrottleRev.None
                );
            }
            else{
                StartThrottleInDirection(
                    player,
                    DirectionTowards(player, moveTarget),
                    1,
                    Relative.ToWorld,
                    ThrottleBehavior.ReplaceExistingThrottle,
                    ThrottleRev.DirectionAndMagnitude
                );
            }
        }
        else{
            StopMove(player);
        }
    }
}

void StopMove(define player!) playervar "StopMove"{
    if(noMoving) return;
    
    player.moveDirFB = NoDirection();
    player.moveDirLR = NoDirection();
    StopThrottleInDirection(player);
} 

// TAG Bot/Aimming ----------
define facingRate:
    actionRangeMax == ActionRange.Melee ?   300 :
    actionRangeMax == ActionRange.Close ?   250 :
    actionRangeMax == ActionRange.Middle ?  200 :
    actionRangeMax == ActionRange.Far ?     150 :
    100;

void StartFacingAimTarget() playervar "StartFacingAimTarget"{
    if(
        aimTarget != null &&
        HasSpawned(aimTarget) &&
        IsAlive(aimTarget)
    ){
        StartFacing(
            ep, DirectionTowards(EyePosition(), aimPosition(aimTarget)),
            facingRate, Relative.ToWorld, FacingRev.DirectionAndTurnRate);
    }
    else{
        StopFacing();
    }
}

define aimPosition(in define player!): 
    (
        IsInAlternateForm(player) ?
        EyePosition(player) - Vector(0, 0.6, 0)     // body position
            :
        EyePosition(player) + Vector(0, 0.2, 0)     // head position
    )
        +
    RandomPosition(aimScatter, aimScatter, aimScatter)  // aim scatter
        +
    Vector(0, -(aimScatter / 2), 0);    // vertical offset

// TAG Bot/ActionState/StateControl ----------
playervar define watchUpdateRate = 2.0;
playervar define isBotActive;
playervar define actionState;
playervar define aimTarget;

enum ActionState{
    Non,
    Attack,
    Support
}

define CanFindRange(in define player!) :
    player != null &&
    DistanceBetween(ep, player) <= ActionRange.CanFind;

define CanFindLine(in define player!) :
    player != null &&
    IsInLineOfSight(EyePosition(ep), EyePosition(player), BarrierLOS.NoBarriersBlock);

define IsSighted(in define player!):
    TeamOf(ep) == TeamOf(player)        ? IsSightedAsFriend(player) :
    TeamOf(ep) == EnemyTeamOf(player)   ? IsSightedAsEnemy(player) :
        false;

define IsSightedAsEnemy(in define player!):
    // valid param
    player != null &&
    // is enemy team
    (TeamOf(ep) == EnemyTeamOf(player)) &&
    // has spawn
    HasSpawned(player) &&
    // alive
    IsAlive(player) &&
    // not in spawn room
    !IsInSpawnRoom(player) &&
    // can find range
    CanFindRange(player) &&
    // can find line
    CanFindLine(player);

define IsSightedAsFriend(in define player!):
    // valid param
    player != null &&
    // is player team
    (TeamOf(ep) == TeamOf(player)) &&
    // has spawn
    HasSpawned(player) &&
    // alive or can resurrect
    (IsAlive(player) || CanResurrect(ep)) &&
    // not in spawn room
    !IsInSpawnRoom(player) &&
    // can find line
    CanFindRange(player) &&
    // can find line or can swift step
    (CanFindLine(player) || CanSwiftStep(player));

define FindAttackTarget()"FindAttackTarget"{
    return FirstOf(
        SortedArray(
            FilteredArray(
                AllPlayers(EnemyTeamOf(ep)),
                // sight as enemy
                IsSightedAsEnemy(ae)
            ),
            DistanceBetween(ep, ae)
        )
    );
}

define neadHealHealthScale: 0.9;

define FindSupportTarget()"FindSupportTarget"{
    return FirstOf(
        SortedArray(
            FilteredArray(
                AllPlayers(TeamOf()),
                // not self
                (ae != ep) &&
                // need heal
                (NormalizedHealth(ae) < neadHealHealthScale) &&
                // sight as friend
                IsSightedAsFriend(ae)
            ),
            NormalizedHealth(ae)
        )
    );
}

void FindTarget()"FindTarget"{
    define candidateTarget;

    // find aim target
    // but, not set as direct to aimTarget for avoid interrupt invalid facing

    // by supportPrioloty
    if(IsProbabilityTrue(100 * supportPrioloty))
    {
        // find support target
        candidateTarget = FindSupportTarget();
        // not found support target
        if(candidateTarget == null){
            // find attack target
            candidateTarget = FindAttackTarget();
        }
    }
    else{
        // find attack target
        candidateTarget = FindAttackTarget();
    }

    if(candidateTarget == null){
        // stop facing before set aimTarget for avoid invalid facing
        StopFacing(ep);
    }

    // confirm as target
    aimTarget = candidateTarget;

}

define GetNextActionState()"GetNextActionState"{
    define nextActionState;
    
    if(
        // self alive
        IsAlive() &&
        // has target
        aimTarget != null
    ){
        if(
            // target is friend
            TeamOf() == TeamOf(aimTarget)
        ){
            // Support state
            nextActionState = ActionState.Support;
        }
        else{
            // Attack state
            nextActionState = ActionState.Attack; 
        }
    }
    else{
        // non state
        nextActionState = ActionState.Non;  
    }
    
    return nextActionState;
}

void SetActionState(define player, define nextActionState) "SetActionState"{
    // if state changed
    if(nextActionState != player.actionState){
        // set next state
        player.actionState = nextActionState;
    }
}

rule: "Bot/ActionState/deactivateState"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    !isBotActive
){
    // reset target
    aimTarget = null;
    // apply next state
    SetActionState(ep, ActionState.Non);
}

rule: "Bot/ActionState/StateControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    isBotActive
){
    while(true){
        define tryFindTarget = false;

        if(IsAlive()){
            // new target
            if(
                // target not Sighted
                !IsSighted(aimTarget)
            ){
                // get new target
                tryFindTarget = true;
            }
            // check target as support action
            else if(
                // is support role and now supporting
                0 < supportPrioloty &&
                actionState == ActionState.Support
            ){
                if(
                    // heal target completed
                    NormalizedHealth(aimTarget) >= neadHealHealthScale ||
                    // can not revive dead player
                    !(CanResurrect(ep) && !IsAlive(aimTarget))
                ){
                    // change target
                    tryFindTarget = true;
                }
                else if(
                    IsProbabilityTrue(
                        // by no support prioloty
                        (50 * (1 - supportPrioloty)) +          
                        // by support target health
                        (50 * NormalizedHealth(aimTarget))      
                    )
                ){
                    // change target 
                    tryFindTarget = true;
                }
                // else{} keep target
            }
            // check target as attack action
            else{
                if(
                    // target dead
                    !IsAlive(aimTarget)
                ){
                    // change target 
                    tryFindTarget = true;
                }
                else if(
                    IsProbabilityTrue(
                        // by attack target health
                        50 * NormalizedHealth(aimTarget) 
                    )
                ){
                    // change target 
                    tryFindTarget = true;
                }
                // else{} keep target
            }

            // get new target
            if(tryFindTarget){
                // find target
                FindTarget();
            }

            // apply next state
            SetActionState(ep, GetNextActionState());
            // action call to near bots
            CallToNearBot();
        }
        else{
            // reset target
            aimTarget = null;
            // apply next state
            SetActionState(ep, GetNextActionState());
        }

        WaitReleaseServerLoad(actionState == ActionState.Non ? ServerLoadType.BotMustAction : ServerLoadType.BotAction);
        Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    }
}

rule: "Bot/ActionState/SetNonStateByDead"
Event.OnDeath
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    Victim() == ep
){
    AbortIf(!isBotActive);

    // reset target
    aimTarget = null;
    // apply next state
    SetActionState(ep, GetNextActionState());
}

rule: "Bot/ActionState/ChangeTargetByTargetDead"
Event.OnElimination
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    IsAlive() &&
    (
        actionState != ActionState.Non &&
        Victim() == aimTarget
    )
){
    AbortIf(!isBotActive);
    WaitReleaseServerLoad(actionState == ActionState.Non ? ServerLoadType.BotMustAction : ServerLoadType.BotAction);

    // find next target
    FindTarget();
    // apply next state
    SetActionState(ep, GetNextActionState());
}

rule: "Bot/ActionState/ChangeSupportTargetByTargetHealCompleted"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    IsAlive() &&
    (
        actionState == ActionState.Support &&
        NormalizedHealth(aimTarget) >= neadHealHealthScale
    )
){
    AbortIf(!isBotActive);
    WaitReleaseServerLoad(actionState == ActionState.Non ? ServerLoadType.BotMustAction : ServerLoadType.BotAction);

    // find next target
    FindTarget();
    // apply next state
    SetActionState(ep, GetNextActionState());
}

rule: "Bot/ActionState/ChangeTargetByDamageTaken"
Event.OnDamageTaken
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    IsAlive() &&
    (
        Attacker() != ep
    )
){
    AbortIf(!isBotActive);
    WaitReleaseServerLoad(actionState == ActionState.Non ? ServerLoadType.BotMustAction : ServerLoadType.BotAction);

    if(
        // set target in Non
        actionState == ActionState.Non ||
        // change target by target helth
        IsProbabilityTrue(50 * NormalizedHealth(aimTarget)) ||
        // can not find aimTarget
        !CanFindLine(aimTarget)
    ){
        // set target by attacker
        aimTarget = Attacker();
        // apply next state
        SetActionState(ep, GetNextActionState());
    }

    // action call to near bots
    CallToNearBot();

    // reduce overrun change target
    Wait(3.0, WaitBehavior.IgnoreCondition);
}

globalvar define isCallAttackCoolingDown1 = false;
globalvar define isCallAttackCoolingDown2 = false;

void CallToNearBot()"CallToNearBot"{
    // check cooldown for reduce overrun
    // if already CoolingDown flag true, ignore action
    if(TeamOf() == Team.Team1){
        if(isCallAttackCoolingDown1){
            return;
        }
        isCallAttackCoolingDown1 = true;
    }
    else if(TeamOf() == Team.Team2){
        if(isCallAttackCoolingDown2){
            return;
        }
        isCallAttackCoolingDown2 = true;
    }

    if(
        // has aim target
        aimTarget != null
    ){
        // get near idle bot
        define nearFriends = FilteredArray(
            PlayersWithinRadius(ep, 0 + ActionRange.CanFind, TeamOf(), RadiusLOS.Off),
            (
                ae != ep &&
                IsDummyBot(ae) &&
                ae.isBotActive &&
                IsAlive(ae) &&
                (
                    // if support state
                    actionState == ActionState.Support ?
                        // call to near supportable bot for support
                        ae.supportPrioloty > 0 :
                        // call to near idle bot for attack
                        ae.actionState == ActionState.Non
                )
            )
        );

        for(define index = 0; index < CountOf(nearFriends); index ++){
            // set same target
            nearFriends[index].aimTarget = ep.aimTarget;
            // set same state 
            SetActionState(nearFriends[index], ep.actionState);
        }
    }
}

rule: "Bot/ActionState/releaseIsCallAttackCoolingDown"
Event.OngoingGlobal
if(
    isCallAttackCoolingDown1 ||
    isCallAttackCoolingDown2
){
    Wait(3.0, WaitBehavior.IgnoreCondition);
    isCallAttackCoolingDown1 = false;
    isCallAttackCoolingDown2 = false;
    Loop();
    // LoopIfConditionIsTrue();
}

// TAG Bot/ActionState/Non ----------
rule: "Bot/ActionState/Non"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    actionState == ActionState.Non
){
    // reset button control
    enableButtonControl = false;
    Wait(0.1, WaitBehavior.IgnoreCondition);

    // stop facing
    StopFacing(ep);
    // stop move
    StopMove(ep);

    while(true){
        // hero unique action
        PolingHeroUniqueAction();
        
        WaitReleaseServerLoad(actionState == ActionState.Non ? ServerLoadType.BotMustAction : ServerLoadType.BotAction);
        Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    }
}

// TAG Bot/ActionState/Attack ----------
rule: "Bot/ActionState/Attack"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    actionState == ActionState.Attack
){
    AbortIf(!isBotActive);

    // reset button control for change depending state button set
    enableButtonControl = false;
    Wait(0.1, WaitBehavior.IgnoreCondition);

    while(true){
        // start button control
        enableButtonControl = true;
        // start facing
        StartFacingAimTarget();
        // set moveDir for combat
        SetMoveDir();
        // start move by moveDir
        StartMove(ep);
        // hero unique action
        PolingHeroUniqueAction();

        WaitReleaseServerLoad(actionState == ActionState.Non ? ServerLoadType.BotMustAction : ServerLoadType.BotAction);
        Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    }
}

// TAG Bot/ActionState/Support ----------
rule: "Bot/ActionState/Support"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    actionState == ActionState.Support
){
    AbortIf(!isBotActive);

    // reset button control for change depending state button set
    enableButtonControl = false;
    Wait(0.1, WaitBehavior.IgnoreCondition);

    while(true){
        // start button control
        enableButtonControl = true;
        // start facing
        StartFacingAimTarget();
        // set moveDir for combat
        SetMoveDir();
        // start move by moveDir
        StartMove(ep);
        // hero unique action
        PolingHeroUniqueAction();

        WaitReleaseServerLoad(actionState == ActionState.Non ? ServerLoadType.BotMustAction : ServerLoadType.BotAction);
        Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    }
}

// TAG Bot/HeroUniqueAction ----------
void StartFacingTemporaryTargetWithButton(define target!, define offset!, define aimTime!, define button!, define keepTime!) playervar "StartFacingTemporaryTargetWithButton"{
    // is player
    if(HasSpawned(target)){
        
        StartFacingPlayer(target, facingRate);
    }
    // is position
    else{
        StartFacing(
            ep, DirectionTowards(EyePosition(), target + offset),
            facingRate, Relative.ToWorld, FacingRev.DirectionAndTurnRate);
    }

    Wait(aimTime, WaitBehavior.IgnoreCondition);
    StartHoldingButton(ep, button);
    Wait(keepTime, WaitBehavior.IgnoreCondition);
    StopHoldingButton(ep, button);
    StartFacingAimTarget();
}

void PolingHeroUniqueAction() playervar "PolingHeroUniqueAction"{
    // common action
    // reload
    if(
        // in idle
        actionState == ActionState.Non
    ){
        // wait  
        Wait(3, WaitBehavior.AbortWhenFalse);
        // reload by condition 
        PressButton(ep, Button.Reload);
    }
    else{
        // is out of ammo
        if(
            isOutOfAmmo
        ){
            // reload
            PressButton(ep, Button.Reload);
        }
    }

    if(
        // in combat
        actionState != ActionState.Non
    ){
        // melee
        while(
            aimTarget != null &&
            actionState == ActionState.Attack &&
            DistanceBetween(ep, aimTarget) <= meleeRange &&
            (
                // can kill by melee helath
                Health(aimTarget) <= meleeDamage * 2
            )
        ){
            // melee
            PressButton(ep, Button.Melee);
            Wait(0.5, WaitBehavior.AbortWhenFalse);
        }

        // hero unique action
        define hero = HeroOfWithDuplicate();
        // Ana
        if(
            hero == Hero.Ana
        ){
            if(
                UltimateChargePercent() >= 100
            ){
                // get ultimate ready or ultimate using or low helath player
                define boostTarget! = 
                    RandomValueInArray(
                        FilteredArray(
                            AllLivingPlayers(TeamOf()),
                            (
                                (
                                    // ult ready
                                    UltimateChargePercent(ae) >= 100 ||
                                    // using ult
                                    IsUsingUltimate(ae) ||
                                    // low health
                                    NormalizedHealth(ae) <= 0.25
                                ) &&
                                CanFindLine(ae)
                            )
                        )
                    );

                if(boostTarget != null){
                    StartFacingTemporaryTargetWithButton(boostTarget, null, 0.5, Button.Ultimate, 0);
                }
            }
        }
        // Baptiste
        if(
            hero == Hero.Baptiste
        ){
            if(
                AbilityCooldown(ep, Button.Ability2) <= 0
            ){
                // get ultimate ready or ultimate using or low helath player
                define protectTarget! = 
                    RandomValueInArray(
                        FilteredArray(
                            AllLivingPlayers(TeamOf()),
                            (
                                (
                                    // low health
                                    NormalizedHealth(ae) <= 0.25
                                ) &&
                                CanFindLine(ae)
                            )
                        )
                    );

                if(protectTarget != null){
                    StartFacingTemporaryTargetWithButton(protectTarget, null, 0.5, Button.Ability2, 0);
                }
            }
        }
        // Zarya
        if(
            hero == Hero.Zarya
        ){
            if(
                IsProbabilityTrue(50) &&
                AbilityCooldown(ep, Button.Ability2) <= 0
            ){
                // get ultimate ready or ultimate using or low helath player
                define protectTarget! = 
                    RandomValueInArray(
                        FilteredArray(
                            AllLivingPlayers(TeamOf()),
                            (
                                (
                                    // low health
                                    NormalizedHealth(ae) <= 0.5
                                ) &&
                                CanFindLine(ae)
                            )
                        )
                    );

                if(protectTarget != null){
                    StartFacingTemporaryTargetWithButton(protectTarget, null, 0.5, Button.Ability2, 0);
                }
            }
        }
        // Mercy
        else if(
            hero == Hero.Mercy
        ){
            if(
                actionState == ActionState.Support
            ){
                // change to heal arm
                SetWeapon(ep, 1);

                if(
                    // by target health
                    IsProbabilityTrue(50 * NormalizedHealth(aimTarget))
                ){
                    // boost aimTarget 
                    StopHoldingButton(ep, Button.PrimaryFire);
                    StartHoldingButton(ep, Button.SecondaryFire);

                    // set boostTarget by ult using player
                    define boostTarget = 
                        RandomValueInArray(
                            FilteredArray(
                                AllLivingPlayers(TeamOf()),
                                (
                                    ae != ep &&
                                    (
                                        // ready ult
                                        100 <= UltimateChargePercent(ae) ||
                                        // using ult
                                        IsUsingUltimate(ae)
                                    ) &&
                                    CanFindLine(ae)
                                )
                            )
                        );

                    if(boostTarget != null){
                        StartFacingTemporaryTargetWithButton(boostTarget, null, 0.5, Button.SecondaryFire, RandomReal(3, 6));
                    }
                }
                else{
                    // heal aimTarget
                    StopHoldingButton(ep, Button.SecondaryFire);
                    StartHoldingButton(ep, Button.PrimaryFire);
                }
            }
            else if(actionState == ActionState.Attack){
                // change to gun
                SetWeapon(ep, 2);
            }
        }
        // Cassidy
        else if(
            hero == Hero.Cassidy
        ){
            if(
                IsProbabilityTrue(50) &&
                DistanceBetween(ep, aimTarget) <= ActionRange.Close &&
                !IsUsingUltimate()  // for not ult cancel
            ){
                // use faning shot
                StopHoldingButton(ep, Button.PrimaryFire);
                PressButton(ep, Button.SecondaryFire);
                Wait(0.7, WaitBehavior.IgnoreCondition);
                if(
                    AbilityCooldown(ep, Button.Ability1) <= 0 &&
                    IsAlive(aimTarget)
                ){
                    PressButton(ep, Button.Ability1);
                    Wait(0.5, WaitBehavior.IgnoreCondition);
                    PressButton(ep, Button.SecondaryFire);
                }
            }
        }
        // Ashe
        else if(
            hero == Hero.Ashe
        ){
            // fallback by corch gun
            if(
                IsProbabilityTrue(50) &&
                DistanceBetween(ep, aimTarget) <= ActionRange.Close
            ){
                if(
                    AbilityCooldown(ep, Button.Ability1) <= 0
                ){
                    // use corch gun
                    PressButton(ep, Button.Ability1);
                }
                else if(IsProbabilityTrue(50)){
                    // fallback by non aiming
                    StopHoldingButton(ep, Button.SecondaryFire);
                }
            }

            if(
                isOutOfAmmo ||
                IsProbabilityTrue(25 * (1 - (Ammo(ep, 0) / MaxAmmo(ep, 0))))  // by ammo charge
            ){
                // stop buton control for reduce reload cancel by fire
                enableButtonControl = false;
                Wait(0.1, WaitBehavior.IgnoreCondition);
                PressButton(ep, Button.Reload);
                Wait(0.1, WaitBehavior.IgnoreCondition);
                // check reload cancel until full load
                while(IsReloading()){
                    Wait(0.5, WaitBehavior.IgnoreCondition);
                    if(
                        IsProbabilityTrue(25 * (Ammo(ep, 0) / MaxAmmo(ep, 0)))  // reload cancel by ammo charge
                    ){
                        break;
                    }
                }
                // restore buton control
                enableButtonControl = true;
            }
        }
        // Sombra
        else if(
            hero == Hero.Sombra
        ){
            if(
                AbilityCooldown(ep, Button.Ability2) <= 0 &&
                // by own health low
                IsProbabilityTrue(150 * (1 - NormalizedHealth()))
            ){
                // aim to backword
                StartFacingPosition(
                    ep +
                    (VectorWithOutY(-FacingDirectionOf()) * 5) + 
                    Vector(0, 5, 0) +
                    RandomPosition(2.5, 2.5, 2.5)                    
                );
                StopMove(ep);
                Wait(0.5, WaitBehavior.IgnoreCondition);
                PressButton(ep, Button.Ability2);
                Wait(0.1, WaitBehavior.IgnoreCondition);
                // restore facing
                StartFacingAimTarget();
            }
            else if(
                AbilityCooldown(ep, Button.Ability2) <= 0 &&
                // by own health high
                IsProbabilityTrue(50 * NormalizedHealth())
            ){
                // throw trance locator at forward
                PressButton(ep, Button.Ability2);
            }
        }
        // LifeWeever
        else if(
            hero == Hero.Lifeweaver
        ){
            // use life grip by aim target low health
            if(
                AbilityCooldown(ep, Button.Ability2) <= 0 &&
                actionState == ActionState.Support &&
                NormalizedHealth(aimTarget) <= 0.5
            ){
                // use life grip
                PressButton(ep, Button.Ability2);
            }

            if(
                AbilityCooldown(ep, Button.Ability1) <= 0 &&
                !IsUsingAbility1(ep) &&
                // by own health low
                IsProbabilityTrue(150 * (1 - NormalizedHealth()))
            ){
                // aim to own step
                StopMove(ep);
                StartFacingPosition(
                    BelowPosition(
                        ep + 
                        VectorWithOutY(FacingDirectionOf()) * 0.1
                    )
                );
                Wait(0.5, WaitBehavior.IgnoreCondition);
                PressButton(ep, Button.Ability1);
                Wait(0.1, WaitBehavior.IgnoreCondition);
                // restore facing
                StartFacingAimTarget();
            }
        }
        // Hanzo
        else if(
            hero == Hero.Hanzo
        ){
            // fallback by double jump
            if(
                IsProbabilityTrue(75) &&
                DistanceBetween(ep, aimTarget) <= ActionRange.Close
            ){
                // move backward for combat
                moveDirFB = Backward();
                StartMove(ep);
                
                if(
                    AbilityCooldown(ep, Button.Jump) <= 0
                ){
                    // use double jump at backword
                    PressButton(ep, Button.Jump);
                    Wait(0.5, WaitBehavior.IgnoreCondition);
                    PressButton(ep, Button.Jump);
                }
            }
        }
        // Widowmaker
        else if(
            hero == Hero.Widowmaker
        ){
            // using infra sight
            if(
                IsUsingUltimate()
            ){
                // Improve accuracy
                aimScatter = 0.0;
            }
            else{
                aimScatter = 0.1;
            }

            if(
                DistanceBetween(ep, aimTarget) <= ActionRange.Close
            ){
                // fallback by graple hook
                if(
                    IsProbabilityTrue(75) &&
                    AbilityCooldown(ep, Button.Ability1) <= 0
                ){
                    define detectDist! = 20;
                    define hasWallDir! = GetHasWallDirection(ep, detectDist);
                    if(hasWallDir != null){
                        StopMove(ep);
                        StopHoldingButton(ep, Button.SecondaryFire);
                        StartFacingWallPosition(hasWallDir, detectDist);
                        Wait(0.5, WaitBehavior.IgnoreCondition);
                        PressButton(ep, Button.Ability1);
                        Wait(0.1, WaitBehavior.IgnoreCondition);
                        // restore aiming
                        StartHoldingButton(ep, Button.SecondaryFire);
                        // restore facing
                        StartFacingAimTarget();
                    }
                }
                // fallback without aiming
                else if(
                    IsProbabilityTrue(75) &&
                    IsButtonHeld(ep, Button.SecondaryFire)
                ){
                    StopHoldingButton(ep, Button.SecondaryFire);
                    Wait(RandomReal(1.0, 3.0), WaitBehavior.IgnoreCondition);
                    // restore aiming
                    StartHoldingButton(ep, Button.SecondaryFire);
                }
            }
        }
        // Lucio
        else if(
            hero == Hero.Lucio
        ){
            if(
                actionState == ActionState.Support &&
                IsProbabilityTrue(50)
            ){
                // move to teammate for heal
                define healTarget! = FindSupportTarget();
                if(healTarget != null){
                    // move to player for heal
                    define localDir! = LocalVectorOf(DirectionTowards(ep, healTarget), ep, Transformation.Rotation);
                    moveDirFB = Vector(0, 0, ZOf(localDir));
                    moveDirLR = Vector(XOf(localDir), 0, 0);
                    StartMove(ep);
                }
            }

            if(
                AbilityCooldown(ep, Button.Ability2) <= 0 &&
                NormalizedHealth(aimTarget) < 
                    actionState == ActionState.Support ? 0.5 : 0.25
            ){
                PressButton(ep, Button.Ability2);
                // keep curent form
                Wait(RandomReal(0.1, 1.5), WaitBehavior.IgnoreCondition);
            }

            // tune form
            if(
                (
                    actionState == ActionState.Support ||
                    // by own health low
                    IsProbabilityTrue(100 * (1 - NormalizedHealth()))
                ) &&
                // speed form
                IsInAlternateForm()
            ){
                // change mode to heal
                PressButton(ep, Button.Ability1);
            }
            else if(
                actionState == ActionState.Attack &&
                // heal form
                !IsInAlternateForm()
            ){
                // change mode to speed
                PressButton(ep, Button.Ability1);
            }
        }
        // Reaper
        else if(
            hero == Hero.Reaper
        ){
            // teleport enemy behind with shadow step 
            if(
                IsProbabilityTrue(75 * NormalizedHealth()) &&
                AbilityCooldown(ep, Button.Ability2) <= 0 &&
                DistanceBetween(ep, aimTarget) > ActionRange.Close
            ){
                // use shadow step
                PressButton(ep, Button.Ability2);
                Wait(0.1, WaitBehavior.IgnoreCondition);
                PressButton(ep, Button.PrimaryFire);
            }
        }
        // Sojourn
        else if(
            hero == Hero.Sojourn
        ){
            // fire charged railgun 
            if(
                IsUsingUltimate()
            ){
                Wait(RandomReal(0.1, 2.5), WaitBehavior.IgnoreCondition);
                // use charged railgun
                PressButton(ep, Button.SecondaryFire);
            }
        }
        // WreckingBall
        else if(
            hero == Hero.WreckingBall
        ){
            // use graple hook and tackle
            if(
                IsProbabilityTrue(75) &&
                AbilityCooldown(ep, Button.SecondaryFire) <= 0
            ){
                define detectDist! = 21;
                define hasWallDir! = GetHasWallDirection(ep, detectDist);
                if(hasWallDir != null){
                    // stop buton control for reduce ball form cancel by fire
                    enableButtonControl = false;
                    StartFacingWallPosition(hasWallDir, detectDist);
                    Wait(0.5, WaitBehavior.IgnoreCondition);
                    StartHoldingButton(ep, Button.SecondaryFire);
                    Wait(0.1, WaitBehavior.IgnoreCondition);
                    // restore facing
                    StartFacingAimTarget();
                }
            }
            // use pile driver
            if(
                IsProbabilityTrue(75) &&
                AbilityCooldown(ep, Button.Crouch) <= 0
            ){
                if(IsOnGround()){
                    // jump for pile driver
                    ApplyImpulse(ep, Up(),
                        10, Relative.ToWorld, ContraryMotion.Cancel);
                    Wait(RandomReal(0.5, 1), WaitBehavior.IgnoreCondition);
                }
                PressButton(ep, Button.Crouch);
            }
        }
        // Torbjorn
        else if(
            hero == Hero.Torbjorn
        ){
            if(
                IsProbabilityTrue(50) &&
                DistanceBetween(ep, aimTarget) <= ActionRange.Close
            ){
                // change to melee arm
                SetWeapon(ep, 2);

                while(
                    // continue melee mode condition
                    IsProbabilityTrue(90) &&
                    IsAlive() &&
                    DistanceBetween(ep, aimTarget) <= ActionRange.Close
                ){
                    // move foward for melee
                    moveDirFB = Forward();
                    moveDirLR = NoDirection();
                    StartMove(ep);
                    // melee by hammer
                    PressButton(ep, Button.PrimaryFire);
                    Wait(0.3, WaitBehavior.IgnoreCondition);
                }
            }
            else{
                // change to gun
                SetWeapon(ep, 1);
            }
        }
        // Zenyatta
        else if(
            hero == Hero.Zenyatta
        ){
            while(
                IsUsingUltimate()
            ){
                define healTarget! = FindSupportTarget();
                if(healTarget != null){
                    // move to player for heal
                    define localDir! = LocalVectorOf(DirectionTowards(ep, healTarget), ep, Transformation.Rotation);
                    moveDirFB = Vector(0, 0, ZOf(localDir));
                    moveDirLR = Vector(XOf(localDir), 0, 0);
                    StartMove(ep);
                }
                Wait(0.5, WaitBehavior.IgnoreCondition);
            }
        }
        // Illari
        else if(
            hero == Hero.Illari
        ){
            if(
                IsProbabilityTrue(75) &&
                AbilityCooldown(ep, Button.Ability1) <= 0
            ){
                PressButton(ep, Button.Ability1);
                StartHoldingButton(ep, Button.Jump);
                Wait(0.5, WaitBehavior.IgnoreCondition);
                StopHoldingButton(ep, Button.Jump);
            }
        }
        // Bastion
        else if(
            hero == Hero.Bastion
        ){
            if(
                IsProbabilityTrue(75) &&
                AbilityCooldown(ep, Button.Ability1) <= 0 &&
                !IsUsingAbility1() &&
                !IsUsingUltimate()
            ){
                PressButton(ep, Button.Ability1);
            }
        }
        // Ramattra
        else if(
            hero == Hero.Ramattra
        ){
            if(
                IsProbabilityTrue(50) &&
                AbilityCooldown(ep, Button.SecondaryFire) <= 0 &&
                !IsNemesisForm(ep)
            ){
                StartHoldingButton(ep, Button.SecondaryFire);
            }

            if(
                IsProbabilityTrue(25) &&
                AbilityCooldown(ep, Button.Ability1) <= 0 &&
                !IsNemesisForm(ep)
            ){
                PressButton(ep, Button.Ability1);
            }}
    }
}

define HeroOfWithDuplicate() "HeroOfWithDuplicate"{
    define hero! = HeroOf();
    if(
        hero == Hero.Echo &&
        IsDuplicating()
    ){
        hero = HeroBeingDuplicated();
    }
    return hero;
}

rule: "Bot/HeroUniqueAction/moveUltmate"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    IsAlive() &&
    IsUsingUltimate()
){
    AbortIf(!isBotActive);
    
    define isCanAction!;
    define waitForStartMove!;
    define moveSpeed!;
    define pressButtonCount!;
    define isMultiPosAttack!;

    define hero! = HeroOfWithDuplicate();
    if(
        hero == Hero.Doomfist
    ){
        isCanAction = true;
        waitForStartMove = 0.5;
        moveSpeed = 0.06;
        pressButtonCount = 1;
        isMultiPosAttack = false;
    }
    else if(
        hero == Hero.Bastion
    ){
        isCanAction = true;
        waitForStartMove = 1.0;
        moveSpeed = 0.04;
        pressButtonCount = 3;
        isMultiPosAttack = IsProbabilityTrue(0);
    }
    else if(
        hero == Hero.Junkrat
    ){
        isCanAction = true;
        waitForStartMove = 1.5;
        moveSpeed = 0.075;
        pressButtonCount = 1;
        isMultiPosAttack = false;
    }

    // move ultmate
    if(isCanAction){
        // stop buton control for reduce cancel
        enableButtonControl = false;
        // stop current moving input
        StopMove(ep);
        // wait for start mode
        Wait(waitForStartMove, WaitBehavior.IgnoreCondition);
        // start move postion selecter to foward
        moveDirFB = Forward();
        moveDirLR = NoDirection();
        StartMove(ep);
        // decrease move speed if multi position attack mode
        if(isMultiPosAttack) moveSpeed -= 0.01;
        // wait for arrival target
        define dist! = DistanceBetween(ep, aimTarget);
        dist = dist <= 5 ? 5 : dist;
        Wait(dist * (moveSpeed), WaitBehavior.IgnoreCondition);
        // stop move if not multi position attack mode
        if(!isMultiPosAttack){
            StopMove(ep);
        }

        // try button press by attackCount
        for(define tryCount! = 0; tryCount < pressButtonCount; tryCount++){
            PressButton(ep, Button.PrimaryFire);
            Wait(RandomReal(0.25, 0.5), WaitBehavior.IgnoreCondition);
        }

        // reduce walking after ult
        StopMove(ep);
        // restore buton control
        enableButtonControl = true;
    }
}

rule: "Bot/HeroUniqueAction/placeUltmate"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    IsAlive() &&
    UltimateChargePercent() >= DefaultPercentage() &&
    IsButtonHeld(ep, Button.Ultimate)
){
    AbortIf(!isBotActive);

    define isCanAction!;
    define rotateProb!;

    define hero! = HeroOfWithDuplicate();
    if(
        hero == Hero.Baptiste
    ){
        isCanAction = true;
        rotateProb = 10;
    }
    else if(
        hero == Hero.Symmetra
    ){
        isCanAction = true;
        rotateProb = 50;
    }

    // place ultmate
    if(isCanAction){
        // stop buton control for reduce cancel
        enableButtonControl = false;
        // rotate
        if(IsProbabilityTrue(rotateProb)){
            PressButton(ep, Button.Ultimate);
            Wait(0.1, WaitBehavior.IgnoreCondition);
        }
        // aim between on ground
        StartFacingPosition(
            BelowPosition(
                ShiftedPosition(
                    ep,
                    VectorTowards(ep, aimTarget),
                    DistanceBetween(ep, aimTarget) * 0.5
                )
            )
        );
        Wait(0.5, WaitBehavior.IgnoreCondition);
        PressButton(ep, Button.PrimaryFire);
        Wait(0.5, WaitBehavior.IgnoreCondition);
        // restore facing
        StartFacingAimTarget();
        // restore buton control
        enableButtonControl = true;
    }
}

rule: "Bot/HeroUniqueAction/placeSecondary"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    IsAlive() &&
    AbilityCooldown(ep, Button.SecondaryFire) <= 0 &&
    IsButtonHeld(ep, Button.SecondaryFire)
){
    AbortIf(!isBotActive);

    define isCanAction!;

    define hero! = HeroOfWithDuplicate();
    if(
        hero == Hero.Ramattra
    ){
        if(
            // is omnic form
            !IsNemesisForm(ep)
        ){
            isCanAction = true;
        }        
    }

    // place secondary
    if(isCanAction){
        // stop buton control for reduce cancel
        enableButtonControl = false;
        // cancel hold SecondaryFire
        CancelPrimaryAction();
        StopHoldingButton(ep, Button.PrimaryFire);
        // aim between on ground
        StartFacingPosition(
            BelowPosition(
                ShiftedPosition(
                    ep,
                    VectorTowards(ep, aimTarget),
                    DistanceBetween(ep, aimTarget) * 0.25
                )
            )
        );
        Wait(0.5, WaitBehavior.IgnoreCondition);
        PressButton(ep, Button.SecondaryFire);
        Wait(0.5, WaitBehavior.IgnoreCondition);
        // restore facing
        StartFacingAimTarget();
        // restore buton control
        enableButtonControl = true;
    }
}

rule: "Bot/HeroUniqueAction/positionFixSecondary"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    IsAlive() &&
    IsFiringSecondary()
){
    AbortIf(!isBotActive);

    define isPositionFixSecondary!;

    define hero! = HeroOfWithDuplicate();
    // postion fix hero
    if(
        hero == Hero.WreckingBall
    ){
        if(IsFiringSecondary()){
            isPositionFixSecondary = true;       
        }
    }

    if(isPositionFixSecondary){
        // stop buton control for reduce ball form cancel by fire
        enableButtonControl = false;

        // using graple hook
        while(
            IsFiringSecondary()
        ){
            // accsell for ball tackle
            BallTackle();
            Wait(0.5, WaitBehavior.IgnoreCondition);
        }

        // restore buton control
        enableButtonControl = true;
    }
}

void BallTackle() playervar "BallTackle"{
    define dir!;
    if(
        SpeedOf() <= 10
    ){
        dir = 1;
    }
    else{
        dir = -1;
    }
    ApplyImpulse(ep, 
        dir * DirectionTowards(ep, ClosestPlayerTo(ep, EnemyTeamOf(ep))),
        25, Relative.ToWorld, ContraryMotion.Incorporate);
}

// TAG Bot/ButtonControl/Propety ----------
rule: "Bot/ButtonControl/Propety/setBySpawned"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    HasSpawned()
){
    SetButtonControlPropety();
}

rule: "Bot/ButtonControl/Propety/setByDuplicateStart"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    HeroOf() == Hero.Echo &&
    IsDuplicating(ep)
){
    // wait hero change
    Wait(0.5, WaitBehavior.IgnoreCondition);
    SetButtonControlPropety();
}

rule: "Bot/ButtonControl/Propety/setByDuplicateEnd"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    HeroOf() == Hero.Echo &&
    !IsDuplicating(ep)
){
    // wait hero change
    Wait(0.5, WaitBehavior.IgnoreCondition);
    SetButtonControlPropety();
}

playervar define hasButtonControlPropety! = false;

playervar define actionRangeMin;
playervar define actionRangeMax;

playervar define aimScatter;
playervar define supportPrioloty;
playervar define supportButtons;
playervar define attackButtons;
playervar define hasDoubleJumpButtonAbility;

playervar define primaryFireButtonBehaivor;
playervar define primaryFireButtonReleaseMin;
playervar define primaryFireButtonReleaseMax;
playervar define primaryFireButtonPressMin;
playervar define primaryFireButtonPressMax;

playervar define secondaryFireButtonBehaivor;
playervar define secondaryFireButtonReleaseMin;
playervar define secondaryFireButtonReleaseMax;
playervar define secondaryFireButtonPressMin;
playervar define secondaryFireButtonPressMax;

playervar define ability1ButtonReleaseMin;
playervar define ability1ButtonReleaseMax;
playervar define ability1ButtonPressMin;
playervar define ability1ButtonPressMax;

playervar define ability2ButtonReleaseMin;
playervar define ability2ButtonReleaseMax;
playervar define ability2ButtonPressMin;
playervar define ability2ButtonPressMax;

playervar define ultimateButtonReleaseMin;
playervar define ultimateButtonReleaseMax;
playervar define ultimateButtonPressMin;
playervar define ultimateButtonPressMax;

playervar define crouchButtonReleaseMin;
playervar define crouchButtonReleaseMax;
playervar define crouchButtonPressMin;
playervar define crouchButtonPressMax;

playervar define jumpButtonReleaseMin;
playervar define jumpButtonReleaseMax;
playervar define jumpButtonPressMin;
playervar define jumpButtonPressMax;

define ControlDisabled(): MaxValue();

void SetButtonControlPropety()"SetButtonControlPropety"{
    // basic routine
    aimScatter = 0.5;
    actionRangeMin = ActionRange.Melee;
    actionRangeMax = ActionRange.Melee;

    hasDoubleJumpButtonAbility = false;
    supportPrioloty = 0.0;
    supportButtons = [
        Button.PrimaryFire,
        Button.SecondaryFire,
        Button.Ability1,
        Button.Ability2
    ];
    attackButtons = [
        Button.PrimaryFire,
        Button.SecondaryFire,
        Button.Ability1,
        Button.Ability2
    ];

    primaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
    primaryFireButtonReleaseMin = 0;
    primaryFireButtonReleaseMax = 1;
    primaryFireButtonPressMin = 0;
    primaryFireButtonPressMax = 10;

    secondaryFireButtonBehaivor = ButtonBehaivor.ReleasePress;
    secondaryFireButtonReleaseMin = 0;
    secondaryFireButtonReleaseMax = 1;
    secondaryFireButtonPressMin = 0;
    secondaryFireButtonPressMax = 10;

    ability1ButtonReleaseMin = 0;
    ability1ButtonReleaseMax = 5;
    ability1ButtonPressMin = 0;
    ability1ButtonPressMax = 1;

    ability2ButtonReleaseMin = 0;
    ability2ButtonReleaseMax = 5;
    ability2ButtonPressMin = 0;
    ability2ButtonPressMax = 1;

    ultimateButtonReleaseMin = 0;
    ultimateButtonReleaseMax = 5;
    ultimateButtonPressMin = 0;
    ultimateButtonPressMax = 1;

    crouchButtonReleaseMin = 0;
    crouchButtonReleaseMax = 10;
    crouchButtonPressMin = 0;
    crouchButtonPressMax = 1;

    jumpButtonReleaseMin = 0;
    jumpButtonReleaseMax = 5;
    jumpButtonPressMin = 0;
    jumpButtonPressMax = 1;

    define hero! = HeroOfWithDuplicate();
    
    switch(hero){
        case Hero.Ana:
        aimScatter = 0.3;   // to precision shooting
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        supportPrioloty = 1.0;
        secondaryFireButtonPressMin = 30;       // to more use scorp
        secondaryFireButtonPressMax = 40;       // to more use scorp
        jumpButtonReleaseMax = 40;              // to suppress cancel scorp
        ultimateButtonReleaseMax = ControlDisabled();          // to suppress over use nano boost (Prefer PolingHeroUniqueAction)
        supportButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability2
        ];
        break;

        case Hero.Ashe:
        aimScatter = 0.3;
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        primaryFireButtonBehaivor = ButtonBehaivor.ReleaseRepeat;
        secondaryFireButtonPressMin = 30;       // to more use scorp
        secondaryFireButtonPressMax = 40;       // to more use scorp
        jumpButtonReleaseMax = 40;              // to suppress cancel scorp
        ability1ButtonReleaseMax = ControlDisabled();          // to suppress over use corch gun (Prefer PolingHeroUniqueAction)
        break;

        case Hero.Baptiste:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        supportPrioloty = 1.0;
        ability1ButtonReleaseMax = ControlDisabled();          // to suppress over use inmortal field (Prefer PolingHeroUniqueAction)
        jumpButtonReleaseMax = 5;               // to more use exo boots
        crouchButtonReleaseMax = 1;             // to more use exo boots
        crouchButtonPressMax = 20;              // to more use exo boots
        supportButtons = [
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.PrimaryFire,
            Button.Ability1
        ];
        break;

        case Hero.Bastion:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        primaryFireButtonReleaseMax = 1;        // to more use primary fire when assault mode
        primaryFireButtonPressMax = 20;        // to more use primary fire when assault mode
        ability1ButtonReleaseMax = ControlDisabled();          // to suppress cancel assault mode (Prefer PolingHeroUniqueAction)
        ultimateButtonReleaseMax = 30;          // to suppress over use artillery
        break;

        case Hero.Brigitte:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        supportPrioloty = 0.5;
        primaryFireButtonPressMax = 20;
        secondaryFireButtonReleaseMax = rva([5, 30]);      // to suppress over use shield
        ability2ButtonReleaseMax = 1;           // to more use repair pack
        supportButtons = [
            Button.SecondaryFire,
            Button.Ability2
        ];
        break;

        case Hero.Cassidy:
        aimScatter = 0.3;
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Middle;
        secondaryFireButtonReleaseMax = 40;     // to suppress overuse fanning shot
        break;

        case Hero.Doomfist:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        ability2ButtonReleaseMin = 3;
        secondaryFireButtonPressMin = 1.3;      // to charge enough rocket punch
        secondaryFireButtonPressMax = 1.5;      // to suppress charge over rocket punch
        jumpButtonReleaseMax = 10;              // to to suppress cancel rocket punch
        break;

        case Hero.Dva:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        ultimateButtonReleaseMax = 40;          // to suppress over use self-destruct / call mech
        break;

        case Hero.Echo:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        jumpButtonReleaseMax = 5;               // to more use float
        jumpButtonPressMax = 5;                 // to more use float
        ultimateButtonReleaseMax = 40;
        break;

        case Hero.Genji:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        hasDoubleJumpButtonAbility = true;
        jumpButtonReleaseMax = 2.5;             // to more use double jump
        jumpButtonPressMax = 3;                 // to more use wall crime
        ability1ButtonReleaseMax = 1;           // to more use swift strike when reset cooldown by kill
        ability1ButtonPressMax = 1;             // to more use swift strike when reset cooldown by kill
        break;

        case Hero.Hanzo:
        aimScatter = 0.3;
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        hasDoubleJumpButtonAbility = true;
        primaryFireButtonReleaseMin = 0;
        primaryFireButtonReleaseMax = 1.0;
        primaryFireButtonPressMin = 0.6;       // to charge enough storm bow  0.7s
        primaryFireButtonPressMax = 0.8;       // to suppress charge over storm bow
        jumpButtonPressMax = 3;                 // to more use wall crime
        secondaryFireButtonBehaivor = ButtonBehaivor.Non;
        break;

        case Hero.JunkerQueen:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        break;

        case Hero.Junkrat:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        break;

        case Hero.Kiriko:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        supportPrioloty = 1.0;
        jumpButtonPressMax = 3;                 // to more use wall crime
        ability1ButtonPressMax = 1;             // to more use swift step
        ability1ButtonReleaseMax = 1;           // to more use swift step        
        supportButtons = [
            Button.PrimaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.SecondaryFire
        ];
        break;

        case Hero.Lucio:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        jumpButtonPressMax = 10;
        ability1ButtonReleaseMax = ControlDisabled();          // to suppress over use cross fade (Prefer PolingHeroUniqueAction)
        supportPrioloty = 0.75;
        supportButtons = [
            Button.Ability1,
            Button.Ability2
        ];
        break;

        case Hero.Lifeweaver:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        hasDoubleJumpButtonAbility = true;
        supportPrioloty = 1.0;
        jumpButtonReleaseMax = 5;               // to more use life step
        ability2ButtonReleaseMax = ControlDisabled();          // to suppress over use life grip (Prefer PolingHeroUniqueAction)
        supportButtons = [
            Button.PrimaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.SecondaryFire,
            Button.Ability1
        ];
        primaryFireButtonPressMin = 0.8;        // to charge enough healing blossom
        primaryFireButtonPressMax = 1.4;        // to suppress charge over healing blossom
        break;

        case Hero.Mei:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        primaryFireButtonReleaseMax = rva([5, 30]);
        break;

        case Hero.Mercy:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        supportPrioloty = 1.0;
        secondaryFireButtonReleaseMax = 10;     // to suppress over use damage boost
        ability2ButtonPressMax = 10;            // to more use resuscitation
        ability2ButtonReleaseMax = 0.1;         // to more use resuscitation
        supportButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        break;

        case Hero.Moira:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        supportPrioloty = 0.75;
        supportButtons = [
            Button.PrimaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        break;

        case Hero.Orisa:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Middle;
        break;

        case Hero.Pharah:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        jumpButtonPressMax = 5;                 // to more use hover jet
        break;

        case Hero.Ramattra:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        secondaryFireButtonReleaseMax = rva([5, 30]);      // to suppress over use guard (on nemesis form)
        secondaryFireButtonPressMin = 2;        // to more keep guard (on nemesis form)
        secondaryFireButtonPressMax = 4;        // to more keep guard (on nemesis form)
        ability1ButtonReleaseMax = ControlDisabled();          // to suppress cancel nemesis form (Prefer PolingHeroUniqueAction)
        break;

        case Hero.Reaper:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        ability2ButtonReleaseMax = ControlDisabled();         // to suppress over use shadow step (Prefer PolingHeroUniqueAction)
        break;

        case Hero.Reinhardt:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        primaryFireButtonPressMax = 20;
        secondaryFireButtonReleaseMax = rva([5, 30]);     // to suppress over use barrier
        break;

        case Hero.Roadhog:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Middle;
        break;

        case Hero.Sigma:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        primaryFireButtonReleaseMax = 0;        // to more confirm gravity flax
        secondaryFireButtonReleaseMax = 3;      // to deploy barrier to far distance
        secondaryFireButtonPressMin = 0.1;        // to deploy barrier to close distance
        secondaryFireButtonPressMax = 0.5;        // to deploy barrier to close distance
        break;

        case Hero.Sojourn:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        secondaryFireButtonReleaseMax = 6;      // to suppress over use railgun (charge enough)
        secondaryFireButtonPressMax = 1;        // to suppress over use railgun (charge enough)
        break;
        
        case Hero.Soldier76:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        break;

        case Hero.Sombra:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        secondaryFireButtonPressMin = 1.5;      // to charge enough hack
        ability2ButtonReleaseMax = 15;          // to suppress over use trans locator
        break;

        case Hero.Symmetra:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        secondaryFireButtonPressMin = 1;        // to charge enough photon bomb
        secondaryFireButtonPressMax = 3;        // to suppress charge over photon bomb
        ability1ButtonReleaseMin = 1;           // to more use turret
        ability1ButtonReleaseMax = 3;           // to more use turret
        ability2ButtonReleaseMax = 15;          // to suppress over use teleporter
        break;

        case Hero.Torbjorn:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        break;

        case Hero.Tracer:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        break;

        case Hero.Widowmaker:
        aimScatter = 0.1;
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        primaryFireButtonReleaseMin = 1.3;      // to charge enough sniper rifle 1.4s
        primaryFireButtonReleaseMax = 1.5;      // to suppress charge over sniper rifle
        primaryFireButtonPressMin = 0;          // to more use sniper rifle
        primaryFireButtonPressMax = 1.0;        // to more use sniper rifle
        secondaryFireButtonPressMin = 30;       // to more use scorp
        secondaryFireButtonPressMax = 40;       // to more use scorp
        jumpButtonReleaseMax = 40;              // to suppress cancel scorp
        ability1ButtonReleaseMax = ControlDisabled();          // to suppress over use grappling hook (Prefer PolingHeroUniqueAction)
        ability2ButtonReleaseMax = 30;          // to suppress over use venom mine
        break;

        case Hero.Winston:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Close;
        primaryFireButtonPressMax = 20;
        secondaryFireButtonReleaseMax = 20;
        ultimateButtonReleaseMax = 40;          // to suppress over use primal rage
        break;

        case Hero.WreckingBall:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        primaryFireButtonPressMax = 15;         // to more use quad machine gun
        primaryFireButtonReleaseMax = 10;       // to suppress over use quad machine gun
        secondaryFireButtonReleaseMax = ControlDisabled();     // to suppress over use grappling crow (Prefer PolingHeroUniqueAction)
        ability1ButtonReleaseMax = 30;          // to suppress cancel ball form
        crouchButtonPressMax = 4;               // to more use pile driver
        break;

        case Hero.Zarya:
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        attackButtons = [
            Button.PrimaryFire,
            Button.SecondaryFire,
            Button.Ability1
        ];
        ability1ButtonReleaseMax = 10;
        ability2ButtonReleaseMax = ControlDisabled();          // to suppress over use inmortal field (Prefer PolingHeroUniqueAction)
        break;

        case Hero.Zenyatta:
        actionRangeMin = ActionRange.Middle;
        actionRangeMax = ActionRange.Far;
        supportPrioloty = 0.5;
        supportButtons = [
            Button.Ability1,
            Button.Ability2
        ];
        primaryFireButtonReleaseMin = 1;
        secondaryFireButtonReleaseMin = 1;
        ability1ButtonPressMin = 0.5;           // to more use orb of discord
        ability1ButtonPressMax = 0.5;           // to more use orb of discord
        ability1ButtonReleaseMin = 0.5;         // to more use orb of discord
        ability1ButtonReleaseMax = 0.5;         // to more use orb of discord
        ability2ButtonPressMin = 0.5;           // to more use orb of harmony
        ability2ButtonPressMax = 0.5;           // to more use orb of harmony
        ability2ButtonReleaseMin = 0.5;         // to more use orb of harmony
        ability2ButtonReleaseMax = 0.5;         // to more use orb of harmony
        ultimateButtonReleaseMax = 30;          // to suppress over use transcendence
        break;

        case Hero.Illari:
        aimScatter = 0.3;
        actionRangeMin = ActionRange.Close;
        actionRangeMax = ActionRange.Middle;
        supportPrioloty = 1.0;
        supportButtons = [
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2
        ];
        attackButtons = [
            Button.PrimaryFire,
            Button.Ability1
        ];
        primaryFireButtonReleaseMin = 0.2;      // to charge enough sorar rifle
        primaryFireButtonReleaseMax = 0.8;      // to suppress charge over sorar rifle
        primaryFireButtonPressMin = 0;          // to more use sorar rifle
        primaryFireButtonPressMax = 1.0;          // to more use sorar rifle
        break;

        case Hero.Mauga:
        actionRangeMin = ActionRange.Melee;
        actionRangeMax = ActionRange.Middle;
        break;

        default:
        break;
    }

    // if already button control enabled
    if(enableButtonControl){
        // restart button control by param changed
        enableButtonControl = false;
        Wait(0.1, WaitBehavior.IgnoreCondition);
        enableButtonControl = true;
    }

    hasButtonControlPropety = true;
}


enum ButtonBehaivor{
    Non,
    ReleasePress,
    ReleaseRepeat
}

// TAG Bot/ButtonControl/StartButtonControl ----------
define noShooting: false;   // for debug
define noMoving: false;   // for debug
playervar define enableButtonControl;

rule: "Bot/ButtonControl/StartButtonControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    hasButtonControlPropety &&
    enableButtonControl
){
    async StartButtonControlOfPrimaryFire();
    async StartButtonControlOfSecondaryFire();
    async StartButtonControlOfAbility1();
    async StartButtonControlOfAbility2();
    async StartButtonControlOfUltimate();
    async StartButtonControlOfJump();
    async StartButtonControlOfCrouch();
}

// implment as function, cuz parallel running by async call
void StartButtonControlOfPrimaryFire()"StartButtonControlOfPrimaryFire"{
    StartButtonControl(
        Button.PrimaryFire,
        primaryFireButtonBehaivor,
        primaryFireButtonReleaseMin,
        primaryFireButtonReleaseMax,
        primaryFireButtonPressMin,
        primaryFireButtonPressMax,
        true
    );
    StopHoldingButton(ep, Button.PrimaryFire);
}

void StartButtonControlOfSecondaryFire()"StartButtonControlOfSecondaryFire"{
    StartButtonControl(
        Button.SecondaryFire,
        secondaryFireButtonBehaivor,
        secondaryFireButtonReleaseMin,
        secondaryFireButtonReleaseMax,
        secondaryFireButtonPressMin,
        secondaryFireButtonPressMax,
        true
    );
    StopHoldingButton(ep, Button.SecondaryFire);
}

void StartButtonControlOfAbility1()"StartButtonControlOfAbility1"{
    StartButtonControl(
        Button.Ability1,
        ButtonBehaivor.ReleasePress,
        ability1ButtonReleaseMin,
        ability1ButtonReleaseMax,
        ability1ButtonPressMin,
        ability1ButtonPressMax,
        true
    );
    StopHoldingButton(ep, Button.Ability1);
}

void StartButtonControlOfAbility2()"StartButtonControlOfAbility2"{
    StartButtonControl(
        Button.Ability2,
        ButtonBehaivor.ReleasePress,
        ability1ButtonReleaseMin,
        ability1ButtonReleaseMax,
        ability1ButtonPressMin,
        ability1ButtonPressMax,
        true
    );
    StopHoldingButton(ep, Button.Ability2);
}

void StartButtonControlOfUltimate()"StartButtonControlOfUltimate"{
    StartButtonControl(
        Button.Ultimate,
        ButtonBehaivor.ReleasePress,
        ultimateButtonReleaseMin,
        ultimateButtonReleaseMax,
        ultimateButtonPressMin,
        ultimateButtonPressMax,
        false
    );
    StopHoldingButton(ep, Button.Ultimate);
}

void StartButtonControlOfJump()"StartButtonControlOfJump"{
    StartButtonControl(
        Button.Jump,
        ButtonBehaivor.ReleasePress,
        jumpButtonReleaseMin,
        jumpButtonReleaseMax,
        jumpButtonPressMin,
        jumpButtonPressMax,
        false
    );
    StopHoldingButton(ep, Button.Jump);
}

void StartButtonControlOfCrouch()"StartButtonControlOfCrouch"{
    StartButtonControl(
        Button.Crouch,
        ButtonBehaivor.ReleasePress,
        ultimateButtonReleaseMin,
        ultimateButtonReleaseMax,
        ultimateButtonPressMin,
        ultimateButtonPressMax,
        false
    );
    StopHoldingButton(ep, Button.Crouch);
}

// TAG Bot/ButtonControl/StopButtonControl ----------
rule: "Bot/ButtonControl/StopButtonControl"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    hasButtonControlPropety &&
    !enableButtonControl
){
    StopHoldingButton(ep, Button.PrimaryFire);
    StopHoldingButton(ep, Button.SecondaryFire);
    StopHoldingButton(ep, Button.Ability1);
    StopHoldingButton(ep, Button.Ability2);
    StopHoldingButton(ep, Button.Ultimate);
    StopHoldingButton(ep, Button.Jump);
    StopHoldingButton(ep, Button.Crouch);
    // ClearButtonBit();
}

// TAG Bot/ButtonControl/Action ----------
playervar define isRepeatFiring;
playervar define repeatDuring;

// can's implment as function, cuz need control instance each button
Boolean isMatchButton(in define matchButton, in define butttons){
    return IsTrueForAny(butttons, ae == matchButton);
}

// can's implment as function, cuz need control instance each button
void StartButtonControl(in define button, in define buttonBehaivor, in define releaseMin, in define releaseMax, in define pressMin, in define pressMax, in define isDependingState){
    if(noShooting) return;
    define startButton = false;

    // if state dependent buttons
    if(
        isDependingState
    ){
        // if attack state dependent buttons
        if(
            actionState == ActionState.Attack &&
            isMatchButton(button, attackButtons)
        ){
            startButton = true;
        }
        // if support state dependent buttons
        else if(
            actionState == ActionState.Support &&
            isMatchButton(button, supportButtons)
        ){
            startButton = true;
        }
        // else
    }
    else{
        startButton = true;
    }

    if(!startButton){
        // stop button
        StopHoldingButton(ep, button);
    }
    else{
        if(IsProbabilityTrue(50)){
            // start fisrt release
            // button release during
            WaitUntil(!enableButtonControl, RandomReal(releaseMin, releaseMax));
            if(!enableButtonControl){ return; }
        }
        
        // start button
        while(enableButtonControl){
            // release-press action
            if(buttonBehaivor == ButtonBehaivor.ReleasePress){
                // start hold button
                if(
                    button == Button.Ultimate &&
                    (
                        // is using ult already
                        IsUsingUltimate() ||
                        // enemy density low
                        IsProbabilityTrue(50 * (1 - EnemyDensityRateOfTargetNear(aimTarget, ActionRange.Close)))
                    )                
                ){
                    // wait only, skip hold ultimate button 
                    Wait(0.1, WaitBehavior.IgnoreCondition);
                }
                else if(
                    button == Button.Jump &&
                    hasDoubleJumpButtonAbility &&
                    IsProbabilityTrue(50)
                ){
                    // use double jump ability
                    StartHoldingButton(ep, button);
                    Wait(RandomReal(0.1, 0.5), WaitBehavior.IgnoreCondition);
                    StopHoldingButton(ep, button);
                    Wait(RandomReal(0.1, 0.5), WaitBehavior.IgnoreCondition);                    
                    StartHoldingButton(ep, button);
                }
                else{
                    StartHoldingButton(ep, button);     // SetButtonBit(button, true);
                }
                
                // button hold during
                WaitUntil(!enableButtonControl, RandomReal(pressMin, pressMax));
                if(!enableButtonControl){ return; }

                // stop hold button
                StopHoldingButton(ep, button);          // SetButtonBit(button, false);
            }
            // release-repeat action
            else if(buttonBehaivor == ButtonBehaivor.ReleaseRepeat){
                // set button repeat during
                repeatDuring = RandomReal(pressMin, pressMax);
                
                // start repeat button
                isRepeatFiring = true;                  // SetButtonBit(button, true);
                while(
                    isRepeatFiring            
                ){
                    // button repeat during
                    PressButton(ep, button);
                    WaitUntil(!enableButtonControl, 0.25);
                    if(!enableButtonControl){ return; }
                }
                
                // stop repeat button
                                                        // SetButtonBit(button, false);
            }
            
            // button release during
            WaitUntil(!enableButtonControl, RandomReal(releaseMin, releaseMax));
            if(!enableButtonControl){ return; }
        }
    }
}

rule: "Bot/ButtonControl/releaseIsRepeatFiring"
Event.OngoingPlayer
if(
    isBotEnableTeam &&
    IsDummyBot() &&
    isRepeatFiring
){
    // button repeat during
    Wait(repeatDuring, WaitBehavior.AbortWhenFalse);
    isRepeatFiring = false;
}

// TAG Debug ----------

// rule: "Bot/Debug/ShowDebugInfo"
// Event.OngoingPlayer
// if(
//     isBotEnableTeam &&
//     IsDummyBot()
// ){
//     // enable button text
//     CreateInWorldText(
//         AllPlayers(),
//         <"Bot_Active = <0>\n\rAction_State = <1>\n\rButton_CONTROL = <2>\n\rButton_Flag = <3>",
//             isBotActive ? "true" : "false",
//                 actionState == ActionState.Non ?        "Non" :
//                 actionState == ActionState.Attack ?     "Attack" :
//                 actionState == ActionState.Support ?    "Support" :
//                                                         "???",
//                     enableButtonControl,
//                         buttonFlagText
//         >,
//         EyePosition(ep) + Vector(0, 1.25, 0),
//         0.8, Clipping.DoNotClip, InworldTextRev.VisibleToPositionStringAndColor,
//         enableButtonControl ? Color.Yellow : Color.White,
//         Spectators.DefaultVisibility);

//     // while(true){
//     //     // tagret line
//     //     if(
//     //         actionState != ActionState.Non &&
//     //         aimTarget != null
//     //     ){
//     //         dbgPlyBemEft(EyePosition(ep), BodyPosition(aimTarget));
//     //     }
//     //     Wait(1);
//     // }
// }

// define initialButtonFlag: [false, false, false, false, false, false, false];
// playervar define buttonFlag = initialButtonFlag;

// void SetButtonBit(define button, define state)"SetButtonBit"{
//     switch(button){
//         case Button.PrimaryFire:    if(state) buttonFlag[0] = true;    else buttonFlag[0] = false; break;
//         case Button.SecondaryFire:  if(state) buttonFlag[1] = true;    else buttonFlag[1] = false; break;
//         case Button.Ability1:       if(state) buttonFlag[2] = true;    else buttonFlag[2] = false; break;
//         case Button.Ability2:       if(state) buttonFlag[3] = true;    else buttonFlag[3] = false; break;
//         case Button.Ultimate:       if(state) buttonFlag[4] = true;    else buttonFlag[4] = false; break;
//         case Button.Jump:           if(state) buttonFlag[5] = true;    else buttonFlag[5] = false; break;
//         case Button.Crouch:         if(state) buttonFlag[6] = true;    else buttonFlag[6] = false; break;
//     }
//     UpdateButtonFlagText();
// }

// void ClearButtonBit()"SetButtonBit"{
//     buttonFlag = initialButtonFlag;
//     UpdateButtonFlagText();
// }

// playervar define buttonFlagText;

// void UpdateButtonFlagText()"UpdateButtonFlagText"{
//     buttonFlagText = "";
//     for (define index = 0; index < CountOf(buttonFlag); index++)
//     {
//         if(buttonFlag[index]){
//             buttonFlagText = <"<0><1>", buttonFlagText, "1">;
//         }
//         else{
//             buttonFlagText = <"<0><1>", buttonFlagText, "0">;
//         }
//     }
// }