import "PerkCore.ostw";

define parallelAnimationNum: 2;

// TAG System ----------
define isServerOverLoad: (targetSlowLevel >= 2);

rule: "Perk/System/ServerOverLoadMeasures"
Event.OngoingGlobal
if(
    isServerOverLoad
){
    StopChasingVariable(AllPlayers(Team.Team1).perkPosition);
    StopChasingVariable(AllPlayers(Team.Team1).perkPosition2);
    StopChasingVariable(AllPlayers(Team.Team1).landPosition);
    StopChasingVariable(AllPlayers(Team.Team1).landZonePosition);
}

// TAG SuperLanding ----------
define superLandingRange: 8;

rule: "Perk/Player/SuperLanding/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.SuperLanding &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 300;
    // set param
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
    // set hud
    perk[Perk.perkEffectAndText] = [];
    CreatePerkEffectHud(<"Hold crouch button <0> in air to landing attack.", ButtonGuide(Button.Crouch)>);
    perk[Perk.perkEffectAndText] [0] = LastTextID();
    CreatePerkEffectHud(<"More hold jump button <0> to hovering.", ButtonGuide(Button.Jump)>);
    perk[Perk.perkEffectAndText] [1] = LastTextID();
    CreatePerkEffectHud(<"Hold jump button <0> to high jump.", ButtonGuide(Button.Jump)>);
    perk[Perk.perkEffectAndText] [2] = LastTextID();
}

rule: "Perk/Player/SuperLanding/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.SuperLanding &&
    perkState  == PerkState.Non
){
    // reset hud
    DestroyHudText(perk[Perk.perkEffectAndText][0]);
    DestroyHudText(perk[Perk.perkEffectAndText][1]);
    DestroyHudText(perk[Perk.perkEffectAndText][2]);
    // reset status
    StopHoldingButton(ep, Button.Crouch);
    SetMoveSpeed(ep, 100);
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/SuperLanding/highJump"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.SuperLanding &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Ready &&
    IsButtonHeld(ep, Button.Jump)
){
    WaitLongPressConfirm();
    ApplyImpulse(ep, Up(), 18,
        Relative.ToPlayer, ContraryMotion.Cancel);
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Triggered;
}

rule: "Perk/Player/SuperLanding/hover"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.SuperLanding &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered &&
    IsButtonHeld(ep, Button.Jump)
){
    Wait(1, WaitBehavior.AbortWhenFalse);
    for(define hovringCount = 0; hovringCount < 50; hovringCount++){
        ApplyImpulse(ep, (Up() * 0.1), 1,
            Relative.ToPlayer, ContraryMotion.Cancel);
        WaitApplyImpulseCycle();
    }
}

rule: "Perk/Player/SuperLanding/descent"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.SuperLanding &&
    perkState  == PerkState.Using &&
    IsButtonHeld(ep, Button.Crouch)
){
    AbortIf(6 > DistanceBetween(ep, BelowPosition(ep)));
    WaitLongPressConfirm();
    ApplyImpulse(ep, Down(), MaxValue(),
        Relative.ToPlayer, ContraryMotion.Cancel);
    perk[Perk.perkEffectStatus] = PerkEffectStatus.SecondTriggered;
}

rule: "Perk/Player/SuperLanding/landing"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.SuperLanding &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.SecondTriggered &&
    IsOnGround()
){
    StartHoldingButton(ep, Button.Crouch);
    SetMoveSpeed(ep, 0);

    // get target
    perk[Perk.perkTargets] = PlayersWithinRadius(
        PositionOf(), superLandingRange, Team.Team2, RadiusLOS.Off);
    // apply blast impulse
    ApplyBlastImpulse(perk[Perk.perkTargets], PositionOf(), superLandingRange);
    // splash damage
    Damage(perk[Perk.perkTargets], ep, 200);
    // play blast sound
    PlayEffect(
        AllPlayers(), PlayEffect.RingExplosionSound,
        Color.White, PositionOf(), 200);
    // play blast effect
    PlayContinuousBlast(
        Color.White,
        PositionOf(),
        superLandingRange,
        2);

    perk[Perk.perkEffectStatus] = PerkEffectStatus.Reloading;
}

rule: "Perk/Player/SuperLanding/resetUsedFlagOnHighJump"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.SuperLanding &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered &&
    IsOnGround()
){
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
}

rule: "Perk/Player/SuperLanding/resetUsedFlagOnDescent"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.SuperLanding &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.SecondTriggered &&
    IsOnGround()
){
    Wait(1.0, WaitBehavior.IgnoreCondition);
    StopHoldingButton(ep, Button.Crouch);
    SetMoveSpeed(ep, 100);
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
}

// TAG GrapplingBeam ----------
rule: "Perk/Player/GrapplingBeam/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.GrapplingBeam &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 300;
    // set param
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
    // set hud
    perk[Perk.perkEffectAndText] = [];
    CreatePerkEffectHud(<"Hold melee button <0> to attract enemy with grapple beam.", ButtonGuide(Button.Melee)>);
    perk[Perk.perkEffectAndText] [0] = LastTextID();
    CreatePerkEffectHud(<"Hold jump button <0> to move in air with grapple beam.", ButtonGuide(Button.Jump)>);
    perk[Perk.perkEffectAndText] [1] = LastTextID();
}

rule: "Perk/Player/GrapplingBeam/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.GrapplingBeam &&
    perkState  == PerkState.Non
){
    // reset hud
    DestroyHudText(perk[Perk.perkEffectAndText] [0]);
    DestroyHudText(perk[Perk.perkEffectAndText] [1]);
    // reset effect
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
    DestroyEffect(perk[Perk.perkEffectAndText] [3]);
    // reset type
    perkType = PerkType.Non;
}

define minMoveImpulse: 20;

rule: "Perk/Player/GrapplingBeam/moveInAir"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.GrapplingBeam &&
    perkState  == PerkState.Using &&
    IsButtonHeld(ep, Button.Jump)
){
    AbortIf(perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered);
    WaitLongPressConfirm();

    // move in air
    aimPosition = AimingPosition();
    if(
        DistanceBetween(ep, aimPosition) <= 100
    ){
        CreateBeamEffect(AllPlayers(), BeamType.GoodBeam,
            ep, aimPosition,
            Color.Green, EffectRev.VisibleToPositionAndRadius);
        perk[Perk.perkEffectAndText] [2] = LastCreatedEntity();
        ApplyImpulse(ep, 
            VectorTowards(ep, aimPosition + (Up() * 1)),
            DistanceBetween(ep, aimPosition) * 2.5 > minMoveImpulse ?
                DistanceBetween(ep, aimPosition) * 2.5 :
                minMoveImpulse,
            Relative.ToWorld, ContraryMotion.Cancel);
    }
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Triggered;

    // show beam effect
    WaitPlayEffect();
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
}

rule: "Perk/Player/GrapplingBeam/pullTarget"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.GrapplingBeam &&
    perkState  == PerkState.Using &&
    IsButtonHeld(ep, Button.Melee)
){
    AbortIf(perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered);
    WaitLongPressConfirm();
    
    // pull target
    perk[Perk.perkTargets] = AimingPlayer();
    if(
        DistanceBetween(ep, perk[Perk.perkTargets]) <= 100 &&
        perk[Perk.perkTargets] != null
    ){
        SetStatus(perk[Perk.perkTargets], ep, Status.Stunned, 1.0);
        // wait move stop
        Wait(0.1, WaitBehavior.IgnoreCondition);
        CreateBeamEffect(AllPlayers(), BeamType.GoodBeam,
            ep, perk[Perk.perkTargets],
            Color.Red, EffectRev.VisibleToPositionAndRadius);
        perk[Perk.perkEffectAndText] [3] = LastCreatedEntity();
        ApplyImpulse(perk[Perk.perkTargets], 
            VectorTowards(perk[Perk.perkTargets], PositionOf(ep) + (Up() * 2.0)),
            DistanceBetween(perk[Perk.perkTargets], ep) * 2.5,
            Relative.ToWorld, ContraryMotion.Cancel);
    }
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Triggered;

    // show beam effect
    WaitPlayEffect();
    DestroyEffect(perk[Perk.perkEffectAndText] [3]);
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
}

// TAG Sprinter ----------
rule: "Perk/Player/Sprinter/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Sprinter &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 300;
    // set param
    perk[Perk.keepMovingSecond] = 0;
    perk[Perk.perkEffectStatus] = 100;
    // set hud
    perk[Perk.perkEffectAndText] = [];
    CreatePerkEffectHud(<"Move speed <0>%", perk[Perk.perkEffectStatus] >);
    perk[Perk.perkEffectAndText] [0] = LastTextID();
}

rule: "Perk/Player/Sprinter/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Sprinter &&
    perkState  == PerkState.Non
){
    // reset hud
    DestroyHudText(perk[Perk.perkEffectAndText] [0]);
    // reset status
    SetMoveSpeed(ep, 100);
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/Sprinter/updateMoveSpeed"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Sprinter &&
    perkState  == PerkState.Using &&
    IsMoving()
){
    if(perk[Perk.keepMovingSecond] < 10)
        perk[Perk.keepMovingSecond] += 1;
    perk[Perk.perkEffectStatus] = RoundToInteger((perk[Perk.keepMovingSecond] / 10) * 150);
    perk[Perk.perkEffectStatus]  += 100;
    SetMoveSpeed(ep, perk[Perk.perkEffectStatus] );
    Wait(0.5, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/Sprinter/resetMoveSpeedByStop"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Sprinter &&
    perkState  == PerkState.Using &&
    !IsMoving()
){
    WaitConditionConfirmed();

    perk[Perk.keepMovingSecond] = 0;
    perk[Perk.perkEffectStatus] = 100;
    SetMoveSpeed(ep, perk[Perk.perkEffectStatus] );
}

rule: "Perk/Player/Sprinter/resetMoveSpeedByDamage"
Event.OnDamageTaken
Team.Team1
if(
    perkType == PerkType.Sprinter &&
    perkState  == PerkState.Using &&
    1 <= EventDamage()
){
    perk[Perk.keepMovingSecond] = 0;
    perk[Perk.perkEffectStatus] = 100;
    SetMoveSpeed(ep, perk[Perk.perkEffectStatus] );
}

// TAG Adrenaline ----------
rule: "Perk/Player/Adrenaline/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Adrenaline &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 300;
    // set param
    perk[Perk.perkEffectStatus] = 100;
    // set hud
    perk[Perk.perkEffectAndText] = [];
    CreatePerkEffectHud(<"Move speed <0>%", perk[Perk.perkEffectStatus] >);
    perk[Perk.perkEffectAndText] [0] = LastTextID();
}

rule: "Perk/Player/Adrenaline/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Adrenaline &&
    perkState  == PerkState.Non
){
    // reset hud
    DestroyHudText(perk[Perk.perkEffectAndText] [0]);
    // reset status
    SetMoveSpeed(ep, 100);
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/Adrenaline/updateMoveSpeed"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Adrenaline &&
    perkState  == PerkState.Using &&    
    Health() < MaxHealth()
){
    perk[Perk.perkEffectStatus] = RoundToInteger((1 - NormalizedHealth()) * 150);
    perk[Perk.perkEffectStatus]  += 100;
    SetMoveSpeed(ep, perk[Perk.perkEffectStatus] );
    Wait(0.5, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/Adrenaline/resetMoveSpeedByFullHealth"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Adrenaline &&
    perkState  == PerkState.Using &&
    Health() == MaxHealth()
){
    perk[Perk.perkEffectStatus] = 100;
    SetMoveSpeed(ep, perk[Perk.perkEffectStatus] );
}

// TAG HeroicAgility ----------
rule: "Perk/Player/HeroicAgility/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.HeroicAgility &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 300;
    // set status
    SetGravity(ep, 75);
    SetMoveSpeed(ep, 150);
    SetJumpVerticalSpeed(ep, 150);
}

rule: "Perk/Player/HeroicAgility/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.HeroicAgility &&
    perkState  == PerkState.Non
){
    // reset status
    SetGravity(ep, 100);
    SetMoveSpeed(ep, 100);
    SetJumpVerticalSpeed(ep, 100);
    // reset type
    perkType = PerkType.Non;
}

// TAG Savior ----------
define saviorStunRange: 10;

rule: "Perk/Player/Savior/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Savior &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 300;
    // set param
    perk[Perk.perkTargets] = [];
}

rule: "Perk/Player/Savior/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Savior &&
    perkState  == PerkState.Non
){
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/Savior/stunEnemy"
Event.OnDamageDealt
Team.Team1
if(
    perkType == PerkType.Savior &&
    perkState  == PerkState.Using
){
    if(Victim() != ep){
        if(!HasStatus(Victim(), Status.Stunned)){
            perk[Perk.perkTargets] = FilteredArray(
                AllPlayers(Team.Team1),
                (
                    ArrayElement() != ep &&
                    Health(ArrayElement()) <= MaxHealth(ArrayElement()) / 2 &&
                    saviorStunRange >= DistanceBetween(Victim(), ArrayElement())
                )
            );
            if(perk[Perk.perkTargets] != []){
                // set stun
                SetStatus(Victim(), ep, Status.Stunned, 2.0);
                // play blast
                PlayEffect(
                    AllPlayers(), PlayEffect.GoodExplosion,
                    Color.Yellow, Victim(), 1.0);
            }
        }
    }
}

define saviorReviveRange: 2.5;

rule: "Perk/Player/Savior/instantyRevive"
Event.OngoingPlayer
Team.Team1
if(
    IsDead() &&
    IsOnGround()&&
    CountOf(
        FilteredArray(
            AllPlayers(TeamOf()), (
                IsAlive(ArrayElement()) &&
                HasSpawned(ArrayElement()) &&
                ArrayElement().perkType == PerkType.Savior &&
                ArrayElement().perkState  == PerkState.Using &&
                DistanceBetween(ep, ArrayElement()) <= saviorReviveRange
            )
        )
    ) > 0
){
    define reviver = ClosestPlayerTo(ep, Team.Team1);

    // revive effect and sound
    PlayEffect(
        AllPlayers(Team.All), PlayEffect.GoodPickupEffect,
        Color.Yellow, ep, 1);
    PlayEffect(
        AllPlayers(Team.All), PlayEffect.RingExplosion,
        Color.Yellow, ep, 8);
    PlayEffect(
        AllPlayers(Team.All), PlayEffect.BuffExplosionSound,
        Color.White, ep, MaxLength());

    Resurrect(ep);

    SmallMessage(reviver,
        <"<0> <1> <2>.", "revived", ep, HeroIconString(HeroOf(ep))>);
    SmallMessage(ep,
        <"<0> <1> <2>.", reviver, HeroIconString(HeroOf(reviver)), "revivied you">);
}

// TAG Fearless ----------
define fearlessRange : 12;
rule: "Perk/Player/Fearless/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Fearless &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 300;
    // set param
    perk[Perk.perkEffectStatus] = 100;
    // set hud
    perk[Perk.perkEffectAndText] = [];
    CreatePerkEffectHud(<"Damage dealt & healing received <0>%", perk[Perk.perkEffectStatus] >);
    perk[Perk.perkEffectAndText] [0] = LastTextID();
    // set effect
    CreateEffect(AllPlayers(), Effect.Ring, Color.SkyBlue,
        ep, fearlessRange, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [1] = LastCreatedEntity();
}

rule: "Perk/Player/Fearless/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Fearless &&
    perkState  == PerkState.Non
){
    // reset hud
    DestroyHudText(perk[Perk.perkEffectAndText] [0]);
    // reset effect
    DestroyEffect(perk[Perk.perkEffectAndText] [1]);
    // reset status
    SetDamageDealt(ep, perk[Perk.perkEffectStatus] );
    SetHealingReceived(ep, perk[Perk.perkEffectStatus] );
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/Fearless/updateDealDamage"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Fearless &&
    perkState  == PerkState.Using
){
    // get enemy count of naer
    define nearEnemyCount = CountOf(
        FilteredArray(
            PlayersWithinRadius(
                PositionOf(ep), fearlessRange, Team.Team2, RadiusLOS.Off
            ), IsAlive(ArrayElement())
        )
    );

    // change status value
    if(nearEnemyCount > 0)
        perk[Perk.perkEffectStatus]  += (nearEnemyCount * 3);
    
    else
        perk[Perk.perkEffectStatus]  -= 10;
    
    // round status value
    if(300 < perk[Perk.perkEffectStatus] )
        perk[Perk.perkEffectStatus] = 300;
    else if(100 > perk[Perk.perkEffectStatus] )
        perk[Perk.perkEffectStatus] = 100;
    
    SetDamageDealt(ep, perk[Perk.perkEffectStatus] );
    SetHealingReceived(ep, perk[Perk.perkEffectStatus] );
    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}

// TAG SteelFormation ----------
define steelRange : 8;

rule: "Perk/Player/SteelFormation/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.SteelFormation &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 180;
    // set hud
    perk[Perk.perkEffectAndText] = [];
    CreatePerkEffectHud(<"Formation include <0> players.", perk[Perk.perkEffectStatus] >);
    perk[Perk.perkEffectAndText] [0] = LastTextID();
    // set effect
    CreateEffect(AllPlayers(), Effect.Ring, Color.Orange,
        ep, steelRange, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [1] = LastCreatedEntity();
}

rule: "Perk/Player/SteelFormation/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.SteelFormation &&
    perkState  == PerkState.Non
){
    // reset hud
    DestroyHudText(perk[Perk.perkEffectAndText] [0]);
    // reset effect
    DestroyEffect(perk[Perk.perkEffectAndText] [1]);
    // reset type
    perkType = PerkType.Non;
}

define nearSteel:
    CountOf(
        FilteredArray(
            AllPlayers(Team.Team1),
            (
                ArrayElement().perkType == PerkType.SteelFormation &&
                ArrayElement().perkState  == PerkState.Using &&
                DistanceBetween(ep, ArrayElement()) <= steelRange
            )
        )
    ) > 0;

rule: "Perk/Player/SteelFormation/updateIncludePlayers"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.SteelFormation &&
    perkState  == PerkState.Using
){
    perk[Perk.perkEffectStatus] = CountOf(
        FilteredArray(
            PlayersWithinRadius(
                PositionOf(ep), steelRange, Team.Team1, RadiusLOS.Off
            ), IsAlive(ArrayElement())
        )
    );
    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/SteelFormation/enableSteel"
Event.OngoingPlayer
Team.Team1
if(
    nearSteel
){
    SetDamageReceived(ep, 50);
}

rule: "Perk/Player/SteelFormation/disableSteel"
Event.OngoingPlayer
Team.Team1
if(
    !nearSteel
){
    SetDamageReceived(ep, 100);
}

// TAG PersonalShelter ----------
define shelterRange : 1.0;
define inShelter:
    CountOf(
        FilteredArray(
            AllPlayers(Team.Team1),
            (
                ArrayElement().perkType == PerkType.PersonalShelter &&
                ArrayElement().perkState  == PerkState.Using &&
                DistanceBetween(ep, ArrayElement().perkPosition) <= shelterRange
            )
        )
    ) > 0;

rule: "Perk/Player/PersonalShelter/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.PersonalShelter &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 60;
    // set param
    perkPosition = BelowPosition(PositionOf());
    // show text
    perk[Perk.perkEffectAndText] = [];
    CreateInWorldText(
        AllPlayers(), <"<0> <1> <2>", ep, HeroIconString(HeroOf()), "Personal Shelter">,
        perkPosition, 1, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
        Color.White, Spectators.DefaultVisibility);
    perk[Perk.perkEffectAndText] [0] = LastTextID();
    // set effect
    CreateEffect(AllPlayers(), Effect.Ring, Color.White,
        perkPosition, shelterRange, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [1] = LastCreatedEntity();
    CreateEffect(AllPlayers(), Effect.LightShaft, Color.White,
        perkPosition, shelterRange, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [2] = LastCreatedEntity();        
}

rule: "Perk/Player/PersonalShelter/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.PersonalShelter &&
    perkState  == PerkState.Non
){
    // reset text
    DestroyInWorldText(perk[Perk.perkEffectAndText] [0]);
    // reset effect
    DestroyEffect(perk[Perk.perkEffectAndText] [1]);
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
    // reset param
    perkPosition = 0;
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/PersonalShelter/enableSafe"
Event.OngoingPlayer
Team.Team1
if(
    inShelter
){
    SetStatus(ep, null, Status.PhasedOut, MaxValue());
}

rule: "Perk/Player/PersonalShelter/disableSafe"
Event.OngoingPlayer
Team.Team1
if(
    !inShelter
){
    ClearStatus(ep, Status.PhasedOut);
}

rule: "Perk/Player/PersonalShelter/failsafeReset"
Event.OngoingPlayer
Team.Team1
if(
    HasStatus(ep, Status.PhasedOut) &&
    !IsInSpawnRoom()
){
    WaitUpdateLongCycle();
    if(!inShelter){
        ClearStatus(ep, Status.PhasedOut);   
        SetInvisible(ep, InvisibleTo.None);
    }
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/PersonalShelter/exclusiveOtherPlayer"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.PersonalShelter &&
    perkState  == PerkState.Using &&
    1 < CountOf(
            PlayersWithinRadius(
                perkPosition, shelterRange, Team.Team1, RadiusLOS.Off))
){
    perk[Perk.perkTargets] = PlayersWithinRadius(
                perkPosition, shelterRange, Team.Team1, RadiusLOS.Off);
    for(pLoopIndex = 0; pLoopIndex < CountOf(perk[Perk.perkTargets]); pLoopIndex++){
        if(perk[Perk.perkTargets][pLoopIndex] != ClosestPlayerTo(perkPosition, Team.Team1)){
            ApplyImpulse(perk[Perk.perkTargets][pLoopIndex],
                VectorTowards(perkPosition, perk[Perk.perkTargets][pLoopIndex] + PositionOffset()),
                10, Relative.ToWorld, ContraryMotion.Cancel);
        }
    }
    WaitApplyImpulseCycle();
    LoopIfConditionIsTrue();
}

// TAG BioticStation ----------
define healRange : 6;
define nearStation:
    CountOf(
        FilteredArray(
            AllPlayers(Team.Team1),
            (
                ArrayElement().perkType == PerkType.BioticStation &&
                ArrayElement().perkState  == PerkState.Using &&
                DistanceBetween(ep, ArrayElement().perkPosition) <= healRange
            )
        )
    ) > 0;

rule: "Perk/Player/BioticStation/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.BioticStation &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 30;
    // set param
    perkPosition = BelowPosition(PositionOf());
    // show text
    perk[Perk.perkEffectAndText] = [];
    CreateInWorldText(
        AllPlayers(), <"<0> <1> <2>", ep, HeroIconString(HeroOf()), "Biotic Station">,
        perkPosition, 1, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
        Color.White, Spectators.DefaultVisibility);
    perk[Perk.perkEffectAndText] [0] = LastTextID();
    // set effect
    CreateEffect(AllPlayers(), Effect.Ring, Color.Yellow,
        perkPosition, healRange, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [1] = LastCreatedEntity();
    CreateEffect(AllPlayers(), Effect.GoodAura, Color.Yellow,
        perkPosition, healRange, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [2] = LastCreatedEntity();
    CreateEffect(AllPlayers(), Effect.LightShaft, Color.Yellow,
        perkPosition, 0.25, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [3] = LastCreatedEntity();   
}

rule: "Perk/Player/BioticStation/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.BioticStation &&
    perkState  == PerkState.Non
){
    // reset text
    DestroyInWorldText(perk[Perk.perkEffectAndText] [0]);
    // reset effect
    DestroyEffect(perk[Perk.perkEffectAndText] [1]);
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
    DestroyEffect(perk[Perk.perkEffectAndText] [3]);
    // reset param
    perkPosition = 0;
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/BioticStation/playWave"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.BioticStation &&
    perkState  == PerkState.Using
){
    // play ring
    PlayEffect(
        AllPlayers(), PlayEffect.RingExplosion,
        Color.Yellow, perkPosition, healRange * 2);
    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/BioticStation/heal"
Event.OngoingPlayer
Team.Team1
if(
    nearStation
){
    // heal
    Heal(ep, ep, 25);
    WaitUpdateShortCycle();
    LoopIfConditionIsTrue();
}

// TAG TrapBeam ----------
define patrolCycle: 0.25;

rule: "Perk/Player/TrapBeam/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.TrapBeam &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 180;
    // show text
    CreateInWorldText(
        AllPlayers(), <"<0> <1> <2>", ep, HeroIconString(HeroOf()), "Trap Beam">,
        perkPosition, 1, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
        Color.White, Spectators.DefaultVisibility);
    perk[Perk.perkEffectAndText] [0] = LastTextID();
    // set effect
    CreateBeamEffect(AllPlayers(), BeamType.GoodBeam,
        perkPosition, aimPosition,
        Color.Yellow, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [1] = LastCreatedEntity();
    CreateEffect(AllPlayers(), Effect.GoodAura, Color.Yellow,
        perkPosition2, 0.25, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [2] = LastCreatedEntity();
    // set param
    StopChasingVariable(perkPosition2);
}

rule: "Perk/Player/TrapBeam/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.TrapBeam &&
    perkState  == PerkState.Non
){
    // reset text
    DestroyInWorldText(perk[Perk.perkEffectAndText] [0]);
    // reset effect
    DestroyEffect(perk[Perk.perkEffectAndText] [1]);
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
    // reset param
    StopChasingVariable(perkPosition2);
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/TrapBeam/deploy"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.TrapBeam &&
    perkState  == PerkState.Using
){
    perkPosition = PositionOf() + PositionOffset();
    aimPosition = AimingPositionIgnorePlayer();
}

rule: "Perk/Player/TrapBeam/moveDetector"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.TrapBeam &&
    perkState  == PerkState.Using
){
    perkPosition2 = perkPosition;
    UpdateEveryFrame(perkPosition2);
    ChaseVariableOverTime(perkPosition2, aimPosition,
        patrolCycle, TimeChaseReevaluation.DestinationAndDuration);
    Wait(patrolCycle, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/TrapBeam/stunByTouched"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.TrapBeam &&
    perkState  == PerkState.Using &&
    // Since the position of the player is judged by the feet,
    //  an offset is added and the collision judgment is shifted to the body.
    DistanceBetween(
        PositionOf(ClosestPlayerTo(perkPosition2, Team.Team2)) + PositionOffset(),
        perkPosition2)
    <= 1.25
){
    perk[Perk.perkTargets] = ClosestPlayerTo(perkPosition2, Team.Team2);
    if(IsAlive(perk[Perk.perkTargets]) &&
     !HasStatus(perk[Perk.perkTargets], Status.Stunned)){
        // set stun
        SetStatus(perk[Perk.perkTargets], ep, Status.Stunned, 2.0);
        // play blast
        PlayEffect(
            AllPlayers(), PlayEffect.GoodExplosion,
            Color.Yellow, perk[Perk.perkTargets], 1.0);
    }
}

// TAG BattleFlag ----------
define battleFlagRange : 15;
rule: "Perk/Player/BattleFlag/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.BattleFlag &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 360;
    // set effect
    perk[Perk.perkEffectAndText] = [];
    CreateEffect(AllPlayers(Team.Team1), Effect.Ring, Color.Blue,
        ep, battleFlagRange, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [0] = LastCreatedEntity();
    // show icon
    CreateIcon(AllPlayers(), PositionOf() + (Up() * 2), Icon.Flag,
        IconRev.VisibleToAndPosition, Color.Blue, false);
    perk[Perk.perkEffectAndText] [1] = LastCreatedEntity();
}

rule: "Perk/Player/BattleFlag/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.BattleFlag &&
    perkState  == PerkState.Non
){
    // reset effect
    DestroyEffect(perk[Perk.perkEffectAndText] [0]);
    // reset icon
    DestroyIcon(perk[Perk.perkEffectAndText] [1]);
    // reset type
    perkType = PerkType.Non;
}

define nearBattleFlag:
    FilteredArray(
        AllPlayers(Team.Team1),
        (
            ArrayElement().perkType == PerkType.BattleFlag &&
            ArrayElement().perkState  == PerkState.Using &&
            DistanceBetween(ep, ArrayElement()) <= battleFlagRange
        )
    );

rule: "Perk/Player/BattleFlag/chargingUlt"
Event.OngoingPlayer
Team.Team1
if(
    CountOf(nearBattleFlag) > 0
){
    WaitUpdateMediumCycle();
    SetUltimateCharge(ep, UltimateChargePercent() + 2);
    LoopIfConditionIsTrue();
}

define raisedBattleFlag:
    CountOf(
        FilteredArray(
            AllPlayers(Team.Team1),
            (
                ArrayElement().perkType == PerkType.BattleFlag &&
                ArrayElement().perkState  == PerkState.Using &&
                ArrayElement() != ep
            )
        )
    ) > 0;

rule: "Perk/Player/BattleFlag/showOperationTeleport"
Event.OngoingPlayer
Team.Team1
if(
    (
        IsInSpawnRoom() &&
        raisedBattleFlag
    )
){
    WaitChangeState();
    // set hud
    CreatePerkEffectHud(<"Hold jump button <0> to teleport to battle flag.", ButtonGuide(Button.Jump)>);
    perk[Perk.perkEffectAndText] [100] = LastTextID();
    CreatePerkEffectHud(<"Our battle flag is raised on battle line.">);
    perk[Perk.perkEffectAndText] [101] = LastTextID();
    // show message
    SmallMessage(ep, <"Our battle flag is raised on battle line.">);
    SmallMessage(ep, <"Hold jump button <0> to teleport to battle flag.", ButtonGuide(Button.Jump)>);
    // play ready sound
    PlayEffect(
        ep, PlayEffect.BuffImpactSound,
        Color.White, ep, 100);
}

rule: "Perk/Player/BattleFlag/hideOperationTeleport"
Event.OngoingPlayer
Team.Team1
if(
    !(
        IsInSpawnRoom() &&
        raisedBattleFlag
    )
){
    WaitChangeState();
    // reset hud
    DestroyHudText(perk[Perk.perkEffectAndText] [100]);
    DestroyHudText(perk[Perk.perkEffectAndText] [101]);
}

rule: "Perk/Player/BattleFlag/teleportToBattleFlag"
Event.OngoingPlayer
Team.Team1
if(
    (
        IsInSpawnRoom() &&
        raisedBattleFlag
    ) &&
    IsButtonHeld(ep, Button.Jump)
){
    WaitLongPressConfirm();
    perk[Perk.perkTargets] = 
        RandomValueInArray(
            FilteredArray(
                AllPlayers(Team.Team1),
                (
                    ArrayElement().perkType == PerkType.BattleFlag &&
                    ArrayElement().perkState  == PerkState.Using
                )
            )
        );
    // teleport to battle flag
    Teleport(ep, perk[Perk.perkTargets]);
    PlayEffect(
        AllPlayers(), PlayEffect.GoodPickupEffect,
        Color.Blue, perk[Perk.perkTargets], 1);
    PlayEffect(
        AllPlayers(), PlayEffect.BuffImpactSound,
        Color.White, perk[Perk.perkTargets], MaxLength());
    SmallMessage(perk[Perk.perkTargets], <"<0> <1> deployed from your battle flag.", ep, HeroIconString(HeroOf())>);
}

// TAG ChainExplosion ----------
rule: "Perk/Player/ChainExplosion/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.ChainExplosion &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 300;
}

rule: "Perk/Player/ChainExplosion/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.ChainExplosion &&
    perkState  == PerkState.Non
){
    // reset type
    perkType = PerkType.Non;
}

define chainExplosionRange: 9;

rule: "Perk/Player/ChainExplosion/explosion"
Event.OnFinalBlow
Team.Team1
if(
    perkType == PerkType.ChainExplosion &&
    perkState  == PerkState.Using
){
    if(Victim() != ep){
        WaitPlayEffect();
        // splash damage
        Damage(
            PlayersWithinRadius(
                PositionOf(Victim()), chainExplosionRange, Team.Team2, RadiusLOS.Off
            ), ep, 300);
        // play blast
        PlayEffect(
            AllPlayers(), PlayEffect.GoodExplosion,
            Color.Orange, Victim(), chainExplosionRange);
        PlayEffect(
            AllPlayers(), PlayEffect.RingExplosion,
            Color.Orange, Victim(), chainExplosionRange);
        // play blast sound
        PlayEffect(
            AllPlayers(), PlayEffect.RingExplosionSound,
            Color.White, Victim(), 100);
    }
}

// TAG IceAge ----------
rule: "Perk/Player/IceAge/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.IceAge &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 240;
}

rule: "Perk/Player/IceAge/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.IceAge &&
    perkState  == PerkState.Non
){
    // reset type
    perkType = PerkType.Non;
}

define IceAgeRange: 12;

rule: "Perk/Player/IceAge/explosion"
Event.OnFinalBlow
Team.Team1
if(
    perkType == PerkType.IceAge &&
    perkState  == PerkState.Using
){
    if(Victim() != ep){
        WaitPlayEffect();
        // splash freeze
        SetStatus(
            PlayersWithinRadius(
                PositionOf(Victim()), IceAgeRange, Team.Team2, RadiusLOS.Off
            ), ep, Status.Frozen, 1.5);
        // play blast
        PlayEffect(
            AllPlayers(), PlayEffect.GoodExplosion,
            Color.Aqua, Victim(), IceAgeRange);
        PlayEffect(
            AllPlayers(), PlayEffect.RingExplosion,
            Color.Aqua, Victim(), IceAgeRange);
        // play blast sound
        PlayEffect(
            AllPlayers(), PlayEffect.BuffImpactSound,
            Color.White, Victim(), 100);
    }
}

// TAG AimHack ----------
rule: "Perk/Player/AimHack/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.AimHack &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 240;
    // set status
    perk[Perk.perkTargets] = 0;
    autoAimingTarget = 0;
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Triggered;
    // set hud
    perk[Perk.perkEffectAndText] = [];
    CreatePerkEffectHud(perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered ?
        "Aim hack Enable." : "Aim hack Disable.");
    perk[Perk.perkEffectAndText] [0] = LastTextID();
    CreatePerkEffectHud(<"Hold melee button <0> to toggle aim hack.", ButtonGuide(Button.Melee)>);
    perk[Perk.perkEffectAndText] [1] = LastTextID();
}

rule: "Perk/Player/AimHack/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.AimHack &&
    perkState  == PerkState.Non
){
    // reset status
    StopFacing();
    perk[Perk.perkTargets] = 0;
    autoAimingTarget = 0;
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Disabled;
    // reset hud
    DestroyHudText(perk[Perk.perkEffectAndText] [0]);
    DestroyHudText(perk[Perk.perkEffectAndText] [1]);
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/AimHack/toggleAimHack"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.AimHack &&
    perkState  == PerkState.Using &&
    IsButtonHeld(ep, Button.Melee)
){
    WaitLongPressConfirm();
    if(perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered){
        perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
    }
    else{
        perk[Perk.perkEffectStatus] = PerkEffectStatus.Triggered;
    }
    // play change sound
    PlayEffect(
        ep, PlayEffect.DebuffImpactSound,
        Color.White, ep, MaxValue());
}

rule: "Perk/Player/AimHack/startAutoAim"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.AimHack &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered
){
    WaitUpdateShortCycle();
    AutoAim();
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/AimHack/stopAutoAim"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.AimHack &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Ready
){
    WaitConditionConfirmed();
    StopFacing(ep);
    autoAimingTarget = 0;
    perk[Perk.perkTargets] = 0;
}

rule: "Perk/Player/AimHack/setTargetByDangerTarget"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.AimHack &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered &&
    Health() <= MaxHealth() / 2
){
    perk[Perk.perkTargets] = ClosestPlayerTo(ep, Team.Team2);
    if(IsInLineOfSight(ep, perk[Perk.perkTargets])){
        autoAimingTarget = perk[Perk.perkTargets];
    }
}

void AutoAim()"AutoAim"{
    if(
        autoAimingTarget == 0 ||    // has not target
        IsDead(autoAimingTarget) || // target dead
        !IsInLineOfSight(           // target hidden
            ep,
            autoAimingTarget,
            BarrierLOS.NoBarriersBlock
        )
    ){
        // get near target in sight
        perk[Perk.perkTargets] = FirstOf(
            SortedArray(
                FilteredArray(
                    PlayersInViewAngle(ep, Team.Team2, 90),
                    (
                        IsAlive(ArrayElement()) &&
                        IsInLineOfSight(ep, ArrayElement(), BarrierLOS.NoBarriersBlock) &&
                        !HasStatus(ArrayElement(), Status.Asleep)
                    )
                ),
                DistanceBetween(ep, ArrayElement())
            )
        );
        // has new target
        if(
            perk[Perk.perkTargets] != 0
        ){
            // start auto aim
            autoAimingTarget = perk[Perk.perkTargets];
            StartAutoAiming();
        }
        // has not target
        else{
            // stop auto aim
            autoAimingTarget = 0;
            StopFacing(ep);
        }
    }
}

// TAG Vampire ----------
rule: "Perk/Player/Vampire/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Vampire &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 300;
}

rule: "Perk/Player/Vampire/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Vampire &&
    perkState  == PerkState.Non
){
    // reset type
    perkType = PerkType.Non;
}


rule: "Perk/Player/Vampire/absorbsHealth"
Event.OnDamageDealt
Team.Team1
if(
    perkType == PerkType.Vampire &&
    perkState  == PerkState.Using
){
    Heal(ep, ep, EventDamage() / 2);
}

// TAG HotShot ----------
rule: "Perk/Player/HotShot/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.HotShot &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 300;
}

rule: "Perk/Player/HotShot/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.HotShot &&
    perkState  == PerkState.Non
){
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/HotShot/refillAbilityAndAmmo"
Event.OnFinalBlow
Team.Team1
if(
    perkType == PerkType.HotShot &&
    perkState  == PerkState.Using
){
    Wait(0.75, WaitBehavior.AbortWhenFalse);

    define clips = [0, 1];
    for(define idx = 0; idx < CountOf(clips); idx++){
        SetAmmo(ep, clips[idx], MaxAmmo(ep, clips[idx]));
    }
    
    define buttons = [
        Button.PrimaryFire,
        Button.SecondaryFire,
        Button.Ability1,
        Button.Ability2, 
        Button.Jump,
        Button.Crouch
    ];
    for(define idx = 0; idx < CountOf(buttons); idx++){
        SetAbilityCooldown(ep, buttons[idx], 0);
        SetAbilityCharge(ep, buttons[idx], 3);
        SetAbilityResource(ep, buttons[idx], 100);
    }
}

// TAG ShotCaller ----------
rule: "Perk/Player/ShotCaller/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.ShotCaller &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 300;

    SetUltimateCharge(ep, 100);
}

rule: "Perk/Player/ShotCaller/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.ShotCaller &&
    perkState  == PerkState.Non
){
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/ShotCaller/shotCall"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.ShotCaller &&
    perkState  == PerkState.Using &&
    IsUsingUltimate()
){
    perk[Perk.perkTargets] = 
        FilteredArray(
            AllPlayers(Team.Team1),
                !(
                    ArrayElement().perkType == PerkType.ShotCaller &&
                    ArrayElement().perkState  == PerkState.Using
                )
        );

    for(pLoopIndex = 0; pLoopIndex < CountOf(perk[Perk.perkTargets]); pLoopIndex++){
        if(perk[Perk.perkTargets][pLoopIndex] != ep){
            SetUltimateCharge(perk[Perk.perkTargets][pLoopIndex], 100);
        }
    }
}

rule: "Perk/Player/ShotCaller/chargingUlt"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.ShotCaller &&
    perkState  == PerkState.Using &&
    !IsUsingUltimate() &&
    UltimateChargePercent() < 100
){
    WaitUpdateMediumCycle();
    SetUltimateCharge(ep, (UltimateChargePercent() + 2));
    LoopIfConditionIsTrue();
}

// TAG GrudgeFireBall ----------

define fireBallMinSpeed: 10;
define fireBallMaxSpeed: 60;
define fireBallMinCollisionRange: 2.0;
define fireBallChargeRate: 3.0;

rule: "Perk/Player/GrudgeFireBall/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.GrudgeFireBall &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 300;
    // set status
    perkPosition = 0;
    landPosition = 0;
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
    // set hud
    perk[Perk.perkEffectAndText] = [];
    CreatePerkEffectHud(<"Fire ball power <0>", perk[Perk.fireBallPower]>);
    perk[Perk.perkEffectAndText] [0] = LastTextID();
    CreatePerkEffectHud(<"Hold melee button <0> to shot fire ball.", ButtonGuide(Button.Melee)>);
    perk[Perk.perkEffectAndText] [1] = LastTextID();
}

rule: "Perk/Player/GrudgeFireBall/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.GrudgeFireBall &&
    perkState  == PerkState.Non
){
    // reset text
    DestroyHudText(perk[Perk.perkEffectAndText] [0]);
    DestroyHudText(perk[Perk.perkEffectAndText] [1]);
    // reset effect
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
    DestroyEffect(perk[Perk.perkEffectAndText] [3]);
    StopChasingVariable(perkPosition);
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/GrudgeFireBall/chargePowerByTakenDamage"
Event.OnDamageTaken
Team.Team1
if(
    perkType == PerkType.GrudgeFireBall &&
    perkState  == PerkState.Using &&
    Attacker() != ep &&
    EventDamage() > 0
){
    perk[Perk.fireBallPower] += RoundToInteger(EventDamage() * fireBallChargeRate);
}

rule: "Perk/Player/GrudgeFireBall/shot"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.GrudgeFireBall &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Ready &&
    IsButtonHeld(ep, Button.Melee)
){
    WaitLongPressConfirm();
    AbortIf(perk[Perk.fireBallPower] <= 0);

    perkPosition = EyePosition() + 
        (FacingDirectionOf(ep) * perk[Perk.fireBallSize] / 2);
    landPosition = AimingPositionIgnorePlayer();
    // set fireball param
    perk[Perk.fireBallSpeed] = fireBallMaxSpeed - (perk[Perk.fireBallPower] / fireBallMaxSpeed);
    perk[Perk.fireBallSpeed] = Max(fireBallMinSpeed, perk[Perk.fireBallSpeed]);
    perk[Perk.fireBallSpeed] = Min(fireBallMaxSpeed, perk[Perk.fireBallSpeed]);
    perk[Perk.fireBallSize] = perk[Perk.fireBallPower] * 0.004;
    perk[Perk.fireBallBlastRange] = perk[Perk.fireBallPower] * 0.02;
    perk[Perk.fireBallTriggerDelay] = perk[Perk.fireBallPower] * 0.0002;
    // start movement
    UpdateEveryFrame(perkPosition);
    ChaseVariableAtRate(
        perkPosition, landPosition, perk[Perk.fireBallSpeed],
        RateChaseReevaluation.DestinationAndRate);
    // show ball
    CreateEffect(AllPlayers(), Effect.Sphere, Color.Orange,
        perkPosition, perk[Perk.fireBallSize], EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [2] = LastCreatedEntity();
    // show aura
    CreateEffect(AllPlayers(), Effect.GoodAura, Color.Orange,
        perkPosition, perk[Perk.fireBallSize] * 1.5, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [3] = LastCreatedEntity();
    // play shot fire
    PlayEffect(
        AllPlayers(), PlayEffect.BadExplosion,
        Color.Orange, perkPosition + (FacingDirectionOf() * 1), perk[Perk.fireBallSize]);

    perk[Perk.perkEffectStatus] = PerkEffectStatus.Triggered;
}

rule: "Perk/Player/GrudgeFireBall/playTrajectory"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.GrudgeFireBall &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered
){
    // play blast
    PlayEffect(
        AllPlayers(), PlayEffect.BadExplosion,
        Color.Yellow, perkPosition, perk[Perk.fireBallSize] * 1.5);

    WaitUpdateVeryShortCycle();
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/GrudgeFireBall/landedToPoint"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.GrudgeFireBall &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered
){
    Wait(
        DistanceBetween(perkPosition, landPosition) / perk[Perk.fireBallSpeed],
        WaitBehavior.AbortWhenFalse);
    ExplodeFireBall();
}

rule: "Perk/Player/GrudgeFireBall/hitToPlayer"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.GrudgeFireBall &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered &&
    IsAlive(ClosestPlayerTo(perkPosition, Team.Team2)) &&
    DistanceBetween(
        perkPosition,
        ClosestPlayerTo(perkPosition, Team.Team2))
        	<= 
        Max(fireBallMinCollisionRange, perk[Perk.fireBallSize])
){
    Wait(perk[Perk.fireBallTriggerDelay], WaitBehavior.IgnoreCondition);
    ExplodeFireBall();
}

rule: "Perk/Player/GrudgeFireBall/timeOut"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.GrudgeFireBall &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered
){
    Wait(3, WaitBehavior.AbortWhenFalse);
    ExplodeFireBall();
}

void ExplodeFireBall()"ExplodeFireBall"{
    AbortIf(perk[Perk.perkEffectStatus]  != PerkEffectStatus.Triggered);
    perk[Perk.perkEffectStatus] = PerkEffectStatus.SecondTriggered;

    // stop movement
    StopChasingVariable(perkPosition);
    // hide ball
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
    // hide aura
    DestroyEffect(perk[Perk.perkEffectAndText] [3]);
    // get target
    perk[Perk.perkTargets] = 
        PlayersWithinRadius(
            perkPosition, Max(fireBallMinCollisionRange, perk[Perk.fireBallBlastRange]),
            Team.Team2, RadiusLOS.Off);
    // apply blast impulse
    ApplyBlastImpulse(perk[Perk.perkTargets], perkPosition, perk[Perk.fireBallBlastRange]);
    // damage
    Damage(perk[Perk.perkTargets], ep, perk[Perk.fireBallPower]);
    // play blast sound
    PlayEffect(
        AllPlayers(), PlayEffect.RingExplosionSound,
        Color.White, perkPosition, perk[Perk.fireBallBlastRange] * 50);
    // play blast effect
    PlayContinuousBlast(
        Color.Orange,
        perkPosition,
        perk[Perk.fireBallBlastRange],
        Min(7, perk[Perk.fireBallSize]));

    // reset charge
    perk[Perk.fireBallPower] = 0;

    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
}

// TAG GrudgeThunderStrike ----------
define thunderStrikeLandingRange: 1;
define thunderStrikeDamageRange: 3;
define thunderStrikeChargeRate: 7.0;
define thunderStrikeConsumePower: 100;

rule: "Perk/Player/GrudgeThunderStrike/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.GrudgeThunderStrike &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 300;
    // set status
    perkPosition = 0;
    landPosition = 0;
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
    // set hud
    perk[Perk.perkEffectAndText] = [];
    CreatePerkEffectHud(<"Thunder strike power <0>", perk[Perk.thunderStrikePower]>);
    perk[Perk.perkEffectAndText] [0] = LastTextID();
    CreatePerkEffectHud(<"Hold melee button <0> to shot thunder strike.", ButtonGuide(Button.Melee)>);
    perk[Perk.perkEffectAndText] [1] = LastTextID();
}

rule: "Perk/Player/GrudgeThunderStrike/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.GrudgeThunderStrike &&
    perkState  == PerkState.Non
){
    // reset text
    DestroyHudText(perk[Perk.perkEffectAndText] [0]);
    DestroyHudText(perk[Perk.perkEffectAndText] [1]);
    // reset effect
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
    DestroyEffect(perk[Perk.perkEffectAndText] [3]);
    DestroyEffect(perk[Perk.perkEffectAndText] [4]);
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/GrudgeThunderStrike/chargePowerByTakenDamage"
Event.OnDamageTaken
Team.Team1
if(
    perkType == PerkType.GrudgeThunderStrike &&
    perkState  == PerkState.Using &&
    Attacker() != ep &&
    EventDamage() > 0
){
    perk[Perk.thunderStrikePower] += RoundToInteger(EventDamage() * thunderStrikeChargeRate);
}

rule: "Perk/Player/GrudgeThunderStrike/shot"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.GrudgeThunderStrike &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Ready &&
    IsButtonHeld(ep, Button.Melee)
){
    WaitLongPressConfirm();
    AbortIf(perk[Perk.thunderStrikePower] <= 0);
    
    // create Trajectory of Thunder
    CreateBeamEffect(AllPlayers(), BeamType.GoodBeam,
        landPosition, landPosition2,
        Color.SkyBlue, EffectRev.VisibleToPositionRadiusAndColor);
    perk[Perk.perkEffectAndText] [4] = LastCreatedEntity(); 

    perk[Perk.perkEffectStatus] = PerkEffectStatus.Triggered;
}

disabled rule: "Perk/Player/GrudgeThunderStrike/cancelShot"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.GrudgeThunderStrike &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered &&
    IsButtonHeld(ep, Button.Melee)
){
    WaitLongPressConfirm();
    DestroyEffect(perk[Perk.perkEffectAndText] [4]);
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
}

rule: "Perk/Player/GrudgeThunderStrike/cancelShotByEmpty"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.GrudgeThunderStrike &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered &&
    perk[Perk.thunderStrikePower] <= 0
){
    DestroyEffect(perk[Perk.perkEffectAndText] [4]);
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
}

rule: "Perk/Player/GrudgeThunderStrike/landedToPoint"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.GrudgeThunderStrike &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered &&
    perk[Perk.thunderStrikePower] > 0
){
    // set land position
    landPosition = 
        AimingPosition() + 
        RandomPosition(
            thunderStrikeLandingRange,
            0,
            thunderStrikeLandingRange
        );
    
    landPosition2 =
        landPosition +
        (Up() * 50) +
        RandomPosition(
            thunderStrikeLandingRange * 5,
            0,
            thunderStrikeLandingRange * 5
        );

    // splash damage
    Damage(
        PlayersWithinRadius(
            landPosition, thunderStrikeDamageRange,
            Team.Team2, RadiusLOS.Off),
        ep, thunderStrikeConsumePower);
    // play blast
    PlayEffect(
        AllPlayers(), PlayEffect.BadExplosion,
        Color.SkyBlue,
        landPosition,
        1);
    // play ring
    PlayEffect(
        AllPlayers(), PlayEffect.RingExplosion,
        Color.SkyBlue,
        landPosition,
        thunderStrikeDamageRange);
    // play blast sound
    PlayEffect(
        AllPlayers(), PlayEffect.RingExplosionSound,
        Color.White,
        landPosition,
        100);

    // consume power
    perk[Perk.thunderStrikePower] =
        perk[Perk.thunderStrikePower] < thunderStrikeConsumePower ?
        0:
        perk[Perk.thunderStrikePower] - thunderStrikeConsumePower;

    WaitContinuousBlastCycle();
    LoopIfConditionIsTrue();
}

// TAG ArtilleryRequest ----------
define artilleryLandingRange: 20;
define artilleryDamageRange: 7;
define artilleryAttackTime: 10;
define artilleryAttackCount: 30;

rule: "Perk/Player/ArtilleryRequest/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.ArtilleryRequest &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 14;
    // set status
    perkPosition = 0;
    perkPosition2 = 0;
    landPosition = -1;
    landPosition2 = -1;  
    perk[Perk.perkEffectCount] = 0; 
    // show text
    // landing zone text
    perk[Perk.perkEffectAndText] = [];
    CreateInWorldText(
        AllPlayers(), <"<0> <1> <2>\n\rBarrage incoming. Stand by...", ep, HeroIconString(HeroOf()), "Artillery Request">,
        landZonePosition + PositionOffset(), 1, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
        Color.White, Spectators.DefaultVisibility);
    perk[Perk.perkEffectAndText] [0] = LastTextID();
    // CreateInWorldText(
    //     AllPlayers(), <"Barrage incoming. Stand by...">,
    //     landZonePosition, 1.2, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
    //     Color.White, Spectators.DefaultVisibility);
    perk[Perk.perkEffectAndText] [1] = LastTextID();
    // set effect
    // shell body1
    CreateEffect(AllPlayers(), Effect.Orb, Color.White,
        perkPosition, 1, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [2] = LastCreatedEntity();
    // shell body2
    CreateEffect(AllPlayers(), Effect.Orb, Color.White,
        perkPosition2, 1, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [3] = LastCreatedEntity();
    // landing zone blast range
    CreateEffect(AllPlayers(), Effect.Sphere, Color.Yellow,
        landZonePosition, artilleryLandingRange, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [4] = LastCreatedEntity();
    // landing zone position
    CreateEffect(AllPlayers(), Effect.Sphere, Color.Red,
        landZonePosition, 0.2, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [5] = LastCreatedEntity(); 
}
rule: "Perk/Player/ArtilleryRequest/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.ArtilleryRequest &&
    perkState  == PerkState.Non
){
    // reset text
    DestroyInWorldText(perk[Perk.perkEffectAndText] [0]);
    DestroyInWorldText(perk[Perk.perkEffectAndText] [1]);
    // reset effect
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
    DestroyEffect(perk[Perk.perkEffectAndText] [3]);
    DestroyEffect(perk[Perk.perkEffectAndText] [4]);
    DestroyEffect(perk[Perk.perkEffectAndText] [5]);
    StopChasingVariable(perkPosition);
    StopChasingVariable(perkPosition2);
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/ArtilleryRequest/setLandingZone"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.ArtilleryRequest &&
    perkState  == PerkState.Using
){
    perkPosition = InvalidPosition();
    perkPosition2 = InvalidPosition();

    // set shell land position to aiming position
    landZonePosition = BelowPosition(AimingPosition());
    Wait(3, WaitBehavior.AbortWhenFalse);

    DestroyEffect(perk[Perk.perkEffectAndText] [4]);
    DestroyEffect(perk[Perk.perkEffectAndText] [5]);

    perk[Perk.firstAnimationDelay] = true;
    perk[Perk.perkEffectCount] = artilleryAttackCount;
}

define artilleryAttackSpeeed:
    (artilleryAttackTime / artilleryAttackCount) * parallelAnimationNum;

rule: "Perk/Player/ArtilleryRequest/launchShell"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.ArtilleryRequest &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectCount] > 0
){
    // set shell at random
    perkPosition = landZonePosition +
        Vector(0, 100, 0) + RandomPosition(10, 0, 10);
    // start shell move
    landPosition = 
        landZonePosition + 
        RandomPosition(
            artilleryLandingRange / 1.5,
            0,
            artilleryLandingRange / 1.5
        );
    
    if(!isServerOverLoad){
        UpdateEveryFrame(perkPosition);
        ChaseVariableOverTime(
            perkPosition, landPosition, artilleryAttackSpeeed,
            TimeChaseReevaluation.DestinationAndDuration);
    }

    Wait(artilleryAttackSpeeed, WaitBehavior.AbortWhenFalse);
    StopChasingVariable(perkPosition);
    // hide shell
    perkPosition = InvalidPosition();
    // on landed play blast
    async ExplodeArtillery(landPosition);
    perk[Perk.perkEffectCount] -- ;
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/ArtilleryRequest/launchShell2"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.ArtilleryRequest &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectCount] > 0
){
    if(perk[Perk.firstAnimationDelay]){
        perk[Perk.firstAnimationDelay] = false;
        Wait(artilleryAttackSpeeed / 2, WaitBehavior.AbortWhenFalse);
    }

    // set shell at random
    perkPosition2 = landZonePosition +
        Vector(0, 100, 0) + RandomPosition(10, 0, 10);
    // start shell move
    landPosition2 = 
        landZonePosition + 
        RandomPosition(
            artilleryLandingRange / 1.5,
            0,
            artilleryLandingRange / 1.5
        );

    if(!isServerOverLoad){
        UpdateEveryFrame(perkPosition2);
        ChaseVariableOverTime(
            perkPosition2, landPosition2, artilleryAttackSpeeed,
            TimeChaseReevaluation.DestinationAndDuration);
    }

    Wait(artilleryAttackSpeeed, WaitBehavior.AbortWhenFalse);
    StopChasingVariable(perkPosition2);
    // hide shell
    perkPosition2 = InvalidPosition();
    // on landed play blast
    async ExplodeArtillery(landPosition2);
    perk[Perk.perkEffectCount] -- ;
    LoopIfConditionIsTrue();
}

void ExplodeArtillery(define position)"ExplodeArtilleryShell"{
    // get target
    perk[Perk.perkTargets] = 
        PlayersWithinRadius(
            position, artilleryDamageRange,
            Team.Team2, RadiusLOS.Off);
    // apply blast impulse
    ApplyBlastImpulse(perk[Perk.perkTargets], position, artilleryDamageRange);
    // damage
    Damage(perk[Perk.perkTargets], ep, 300);
    // play blast sound
    PlayEffect(
        AllPlayers(), PlayEffect.RingExplosionSound,
        Color.White, position, 300);
    // play blast effect
    PlayContinuousBlast(
        Color.Yellow,
        position,
        artilleryDamageRange,
        2);
}

// TAG StrafingSupport ----------
define strafReqLandingRange: 5;
define strafReqDamageRange: 3;
define strafReqAttackTime: 2.0;
define strafReqAttackDistance: 50;
define strafReqAttackInterval: 0.03;
define strafReloadTime: 12;

rule: "Perk/Player/StrafingSupport/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.StrafingSupport &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 300;
    // set status
    perkPosition = 0;
    perkPosition2 = 0;
    landPosition = -1;
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
    // set hud
    perk[Perk.perkEffectAndText] = [];
    CreatePerkEffectHud(
        perk[Perk.perkEffectStatus]  == PerkEffectStatus.Ready ?
            <"Hold melee button <0> to call Strafing Request.", ButtonGuide(Button.Melee)> :
            perk[Perk.perkEffectStatus]  == PerkEffectStatus.Reloading ?
                <"Strafing Request in preparation until <0> seconds.", perk[Perk.perkEffectCoolTime]> :
                "Strafing incoming!"
        );
    perk[Perk.perkEffectAndText] [0] = LastTextID();

    // first use
    StartHoldingButton(ep, Button.Melee);
    Wait(0.5, WaitBehavior.IgnoreCondition);
    StopHoldingButton(ep, Button.Melee);
}
rule: "Perk/Player/StrafingSupport/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.StrafingSupport &&
    perkState  == PerkState.Non
){
    // reset hud
    DestroyHudText(perk[Perk.perkEffectAndText] [0]);
    DestroyInWorldText(perk[Perk.perkEffectAndText] [1]);
    // reset effect
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
    DestroyEffect(perk[Perk.perkEffectAndText] [3]);
    DestroyEffect(perk[Perk.perkEffectAndText] [4]);
    StopChasingVariable(landPosition);
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/StrafingSupport/remindStrafingSupport"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.StrafingSupport &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Ready
){
    // remind use perk.
    Wait(30, WaitBehavior.AbortWhenFalse);
    SmallMessage(ep, <"Forgotten Strafing Support?"> );
    SmallMessage(ep, <"Hold melee button <0> to call Strafing Support.", ButtonGuide(Button.Melee)> );
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/StrafingSupport/startStrafing"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.StrafingSupport &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Ready &&
    IsButtonHeld(ep, Button.Melee)
){
    WaitLongPressConfirm();
    // reset hud
    DestroyInWorldText(perk[Perk.perkEffectAndText] [1]);
    // reset effect
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
    DestroyEffect(perk[Perk.perkEffectAndText] [3]);
    DestroyEffect(perk[Perk.perkEffectAndText] [4]);
    StopChasingVariable(landPosition);
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Triggered;
}

rule: "Perk/Player/StrafingSupport/playLandingZone"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.StrafingSupport &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered
){
    // play set sound
    PlayEffect(
        ep, PlayEffect.DebuffImpactSound,
        Color.White, ep, MaxValue());

    aimPosition = BelowPosition(AimingPosition());
    perk[Perk.approachingAngle] = DirectionTowards(
            aimPosition, ClosestPlayerTo(
                aimPosition,
                Team.Team2
            )
        );
    perk[Perk.approachingAngle] = Vector(
        XOf(perk[Perk.approachingAngle]),
        0,
        ZOf(perk[Perk.approachingAngle])
    );
    // set start point
    perkPosition = 
        aimPosition + 
            // add random direction
            -perk[Perk.approachingAngle] *
            // add static distance
            (strafReqAttackDistance / 2);
    // set end point
    perkPosition2 = 
        aimPosition + 
            // add random direction
            perk[Perk.approachingAngle] *
            // add static distance
            (strafReqAttackDistance / 2);

    // landing zone text
    CreateInWorldText(
        AllPlayers(), <"<0> <1> <2>\n\rStrafing incoming!", ep, HeroIconString(HeroOf()), "Strafing Request">,
        aimPosition + PositionOffset(), 1, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
        Color.White, Spectators.DefaultVisibility);
    perk[Perk.perkEffectAndText] [1] = LastTextID();

    // set effect
    // landing zone blast range
    CreateEffect(AllPlayers(), Effect.Sphere, Color.Yellow,
        landPosition, strafReqLandingRange, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [2] = LastCreatedEntity();
    // landing zone position
    CreateEffect(AllPlayers(), Effect.Sphere, Color.Red,
        aimPosition, 0.2, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [3] = LastCreatedEntity(); 

    // play landing animation
    landPosition = perkPosition;

    UpdateEveryFrame(landPosition);
    ChaseVariableOverTime(
        landPosition, perkPosition2,
        strafReqAttackTime,
        TimeChaseReevaluation.DestinationAndDuration);

    Wait(strafReqAttackTime, WaitBehavior.AbortWhenFalse);
    StopChasingVariable(landPosition);
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
    // start attack
    perk[Perk.perkEffectStatus] = PerkEffectStatus.SecondTriggered;
}

rule: "Perk/Player/StrafingSupport/playLanding"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.StrafingSupport &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.SecondTriggered
){
    // create Ballistic
    CreateBeamEffect(AllPlayers(), BeamType.BadBeam,
        landPosition2, landPosition2 - (perk[Perk.approachingAngle] * 200) + (Up() * 100),
        Color.White, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [4] = LastCreatedEntity(); 

    // chase landing position
    landPosition = perkPosition;

    UpdateEveryFrame(landPosition);
    ChaseVariableOverTime(
        landPosition, perkPosition2,
        strafReqAttackTime,
        TimeChaseReevaluation.DestinationAndDuration);

    Wait(strafReqAttackTime, WaitBehavior.AbortWhenFalse);
    StopChasingVariable(landPosition);
    DestroyInWorldText(perk[Perk.perkEffectAndText] [1]);
    DestroyEffect(perk[Perk.perkEffectAndText] [3]);
    DestroyEffect(perk[Perk.perkEffectAndText] [4]);
    // start reload
    perk[Perk.perkEffectCoolTime] = strafReloadTime;
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Reloading;
}

rule: "Perk/Player/StrafingSupport/landedToPoint"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.StrafingSupport &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.SecondTriggered
){
    // set landed point
    landPosition2 =
        landPosition + 
        RandomPosition(
            strafReqLandingRange / 1.5,
            0,
            strafReqLandingRange / 1.5
        );
    perk[Perk.perkTargets] =
        PlayersWithinRadius(
            landPosition2, strafReqDamageRange,
            Team.Team2, RadiusLOS.Off);
    // damage
    Damage(perk[Perk.perkTargets], ep, 200);
    // play blast sound
    PlayEffect(
        AllPlayers(), PlayEffect.RingExplosionSound,
        Color.White,
        landPosition2,
        100);
    // play blast
    PlayEffect(
        AllPlayers(), PlayEffect.BadExplosion,
        Color.White,
        landPosition2,
        strafReqDamageRange);
        
    Wait(strafReqAttackInterval, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/StrafingSupport/countDownCoolTime"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.StrafingSupport &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Reloading &&
    perk[Perk.perkEffectCoolTime] > 0
){
    // count down perk cooldown time
    WaitUpdateMediumCycle();
    perk[Perk.perkEffectCoolTime] -= 1;
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/StrafingSupport/coolDownComplete"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.StrafingSupport &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Reloading &&
    perk[Perk.perkEffectCoolTime] <= 0
){
    // play ready sound
    PlayEffect(
        ep, PlayEffect.BuffImpactSound,
        Color.White, ep, 100);
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
}

rule: "Perk/Player/StrafingSupport/playAircraft"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.StrafingSupport &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Reloading
){
    // set start point
    perkPosition =
        aimPosition +
        DirectionTowards(aimPosition, perkPosition) * 
        (strafReqAttackDistance * 25) +
        Vector(0, 200, 0); 
    // set end point
    perkPosition2 = 
        aimPosition +
        DirectionTowards(aimPosition, perkPosition2) *
        (strafReqAttackDistance * 25) +
        Vector(0, 1200, 0); 
    // air craft
    CreateEffect(AllPlayers(), Effect.Orb, Color.Red,
        landPosition, 1, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [2] = LastCreatedEntity();
    // air craft aura
    CreateEffect(AllPlayers(), Effect.GoodAura, Color.Red,
        landPosition, 30, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [3] = LastCreatedEntity();

    // play air craft animation
    landPosition = perkPosition;
    
    if(!isServerOverLoad){
        UpdateEveryFrame(landPosition);
        ChaseVariableOverTime(
            landPosition, perkPosition2,
            3,
            TimeChaseReevaluation.DestinationAndDuration);
    }

    Wait(3, WaitBehavior.IgnoreCondition);
    StopChasingVariable(landPosition);
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
    DestroyEffect(perk[Perk.perkEffectAndText] [3]);
}

// TAG MissileBarrage ----------
//define missileLandingRange: 4;
define missileDamageRange: 4;
define missileAttackTime: 5;
define missileAttackCount: 10;
define missleReloadTime: 10;

rule: "Perk/Player/MissileBarrage/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.MissileBarrage &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 300;
    // set status
    perkPosition = 0;
    perkPosition2 = 0;
    landPosition = -1;
    landPosition2 = -1;  
    perk[Perk.perkEffectStatus] = 0; 
    // set hud
    perk[Perk.perkEffectAndText] = [];
    CreatePerkEffectHud(
        perk[Perk.perkEffectStatus]  == PerkEffectStatus.Ready ?
            <"Hold melee button <0> to call Missile Barrage.", ButtonGuide(Button.Melee)> :
            perk[Perk.perkEffectStatus]  == PerkEffectStatus.Reloading ?
                <"Missile barrage in preparation until <0> seconds.", perk[Perk.perkEffectCoolTime]> :
                "Missile incoming!"
        );
    perk[Perk.perkEffectAndText] [0] = LastTextID();

    // first use
    StartHoldingButton(ep, Button.Melee);
    Wait(0.5, WaitBehavior.IgnoreCondition);
    StopHoldingButton(ep, Button.Melee);
}
rule: "Perk/Player/MissileBarrage/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.MissileBarrage &&
    perkState  == PerkState.Non
){
    // reset hud
    DestroyHudText(perk[Perk.perkEffectAndText] [0]);
    // reset text
    DestroyInWorldText(perk[Perk.perkEffectAndText] [1]);
    // reset effect
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
    DestroyEffect(perk[Perk.perkEffectAndText] [3]);
    DestroyEffect(perk[Perk.perkEffectAndText] [4]);
    DestroyEffect(perk[Perk.perkEffectAndText] [5]);
    StopChasingVariable(landZonePosition);
    StopChasingVariable(perkPosition);
    StopChasingVariable(perkPosition2);
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/MissileBarrage/remindMissileBarrage"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.MissileBarrage &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Ready
){
    // remind use perk.
    Wait(30, WaitBehavior.AbortWhenFalse);
    SmallMessage(ep, <"Forgotten Missile Barrage?"> );
    SmallMessage(ep, <"Hold melee button <0> to call Missile Barrage.", ButtonGuide(Button.Melee)> );
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/MissileBarrage/startMissile"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.MissileBarrage &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Ready &&
    IsButtonHeld(ep, Button.Melee)
){
    WaitLongPressConfirm();
    // reset text
    DestroyInWorldText(perk[Perk.perkEffectAndText] [1]);
    // reset effect
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
    DestroyEffect(perk[Perk.perkEffectAndText] [3]);
    DestroyEffect(perk[Perk.perkEffectAndText] [4]);
    DestroyEffect(perk[Perk.perkEffectAndText] [5]);
    StopChasingVariable(landZonePosition);
    StopChasingVariable(perkPosition);
    StopChasingVariable(perkPosition2);

    // shell body1
    CreateEffect(AllPlayers(), Effect.Orb, Color.White,
        perkPosition, 1, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [2] = LastCreatedEntity();
    // shell body2
    CreateEffect(AllPlayers(), Effect.Orb, Color.White,
        perkPosition2, 1, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [3] = LastCreatedEntity();
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Triggered;
}

rule: "Perk/Player/MissileBarrage/setLandingZone"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.MissileBarrage &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered
){
    // play set sound
    PlayEffect(
        ep, PlayEffect.DebuffImpactSound,
        Color.White, ep, MaxValue());

    aimPosition = AimingPosition();
    perkPosition = InvalidPosition();
    perkPosition2 = InvalidPosition();

    // set missile land position to aiming position
    landZonePosition = AimingPosition();

   // landing zone text
    CreateInWorldText(
        AllPlayers(), <"<0> <1> <2>\n\r<3> Missles incoming!", ep, HeroIconString(HeroOf()), "Missile Barrage", perk[Perk.perkEffectCount]>,
        landZonePosition + PositionOffset(), 1, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
        Color.White, Spectators.DefaultVisibility);
    perk[Perk.perkEffectAndText] [1] = LastTextID();
    perk[Perk.perkEffectCount] = missileAttackCount;

    // set effect
    // landing zone blast range
    CreateEffect(AllPlayers(), Effect.Sphere, Color.Yellow,
        landZonePosition, missileDamageRange, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [4] = LastCreatedEntity();
    // landing zone position
    CreateEffect(AllPlayers(), Effect.Sphere, Color.Red,
        landZonePosition, 0.2, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [5] = LastCreatedEntity();

    Wait(2, WaitBehavior.AbortWhenFalse);
    DestroyEffect(perk[Perk.perkEffectAndText] [4]);

    perk[Perk.firstAnimationDelay] = true;
    perk[Perk.perkEffectStatus] = PerkEffectStatus.SecondTriggered;
}

rule: "Perk/Player/MissileBarrage/aimLandPoint"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.MissileBarrage &&
    perkState  == PerkState.Using &&
    (
        perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered ||
        perk[Perk.perkEffectStatus]  == PerkEffectStatus.SecondTriggered
    )
){
    // chase missile land position to aiming position
    Wait(0.5, WaitBehavior.AbortWhenFalse);
    aimPosition = AimingPosition();
    UpdateEveryFrame(landZonePosition);
    ChaseVariableAtRate(
        landZonePosition, aimPosition,
        DistanceBetween(landZonePosition, aimPosition) * 3.0,
        RateChaseReevaluation.DestinationAndRate);
        
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/MissileBarrage/playTrajectory"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.MissileBarrage &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.SecondTriggered &&
    perk[Perk.perkEffectCount] > 0
){
    // play blast
    PlayEffect(
        AllPlayers(), PlayEffect.BadExplosion,
        Color.Orange, perkPosition, 1.5);
    PlayEffect(
        AllPlayers(), PlayEffect.BadExplosion,
        Color.Orange, perkPosition2, 1.5);

    WaitUpdateVeryShortCycle();
    LoopIfConditionIsTrue();
}

define missleAttackSpeeed:
    (missileAttackTime / missileAttackCount) * parallelAnimationNum;

rule: "Perk/Player/MissileBarrage/launchMissile"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.MissileBarrage &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.SecondTriggered &&
    perk[Perk.perkEffectCount] > 0
){
    // set missle at random
    perkPosition = landZonePosition +
        Vector(0, 50, 0) + RandomPosition(25, 0, 25);
    // start missle move
    // landPosition = 
    //     landZonePosition + 
    //     RandomPosition(
    //         missileLandingRange / 1.5,
    //         0,
    //         missileLandingRange / 1.5
    //     );

    if(!isServerOverLoad){
        UpdateEveryFrame(perkPosition);
        ChaseVariableOverTime(
            perkPosition, landZonePosition, missleAttackSpeeed,
            TimeChaseReevaluation.DestinationAndDuration);
    }

    Wait(missleAttackSpeeed, WaitBehavior.AbortWhenFalse);
    StopChasingVariable(perkPosition);
    // hide missle
    perkPosition = InvalidPosition();
    // on landed play blast
    async ExplodeMissile(landZonePosition);
    perk[Perk.perkEffectCount] -- ;
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/MissileBarrage/launchMissle2"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.MissileBarrage &&
    perkState  == PerkState.Using && 
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.SecondTriggered &&
    perk[Perk.perkEffectCount] > 0
){
    if(perk[Perk.firstAnimationDelay]){
        perk[Perk.firstAnimationDelay] = false;
        Wait(missleAttackSpeeed / 2, WaitBehavior.AbortWhenFalse);
    }

    // set missle at random
    perkPosition2 = landZonePosition +
        Vector(0, 50, 0) + RandomPosition(25, 0, 25);
    // start missle move
    // landPosition2 = 
    //     landZonePosition + 
    //     RandomPosition(
    //         missileLandingRange / 1.5,
    //         0,
    //         missileLandingRange / 1.5
    //     );

    if(!isServerOverLoad){
        UpdateEveryFrame(perkPosition2);
        ChaseVariableOverTime(
            perkPosition2, landZonePosition, missleAttackSpeeed,
            TimeChaseReevaluation.DestinationAndDuration);
    }

    Wait(missleAttackSpeeed, WaitBehavior.AbortWhenFalse);
    StopChasingVariable(perkPosition2);
    // hide missle
    perkPosition2 = InvalidPosition();
    // on landed play blast
    async ExplodeMissile(landZonePosition);
    perk[Perk.perkEffectCount] -- ;
    LoopIfConditionIsTrue();
}

void ExplodeMissile(define position)"ExplodeMissile"{
    // get target
    perk[Perk.perkTargets] = 
        PlayersWithinRadius(
            position, missileDamageRange,
            Team.Team2, RadiusLOS.Off);
    // apply blast impulse
    ApplyBlastImpulse(perk[Perk.perkTargets], position, missileDamageRange / 2);
    // damage
    Damage(perk[Perk.perkTargets], ep, 300);
    // play blast sound
    PlayEffect(
        AllPlayers(), PlayEffect.RingExplosionSound,
        Color.White, position, 300);
    // play blast effect
    PlayContinuousBlast(
        Color.Orange,
        position,
        missileDamageRange,
        2);
}

rule: "Perk/Player/MissileBarrage/endMissile"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.MissileBarrage &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.SecondTriggered &&
    perk[Perk.perkEffectCount] <= 0
){
    // reset text
    DestroyInWorldText(perk[Perk.perkEffectAndText] [1]);
    // reset effect
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
    DestroyEffect(perk[Perk.perkEffectAndText] [3]);
    DestroyEffect(perk[Perk.perkEffectAndText] [5]);
    StopChasingVariable(landZonePosition);
    StopChasingVariable(perkPosition);
    StopChasingVariable(perkPosition2);
    // start reload
    perk[Perk.perkEffectCoolTime] = missleReloadTime;
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Reloading;
}

rule: "Perk/Player/MissileBarrage/countDownCoolTime"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.MissileBarrage &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Reloading &&
    perk[Perk.perkEffectCoolTime] > 0
){
    // count down perk cooldown time
    WaitUpdateMediumCycle();
    perk[Perk.perkEffectCoolTime] -= 1;
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/MissileBarrage/coolDownComplete"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.MissileBarrage &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Reloading &&
    perk[Perk.perkEffectCoolTime] <= 0
){
    // play ready sound
    PlayEffect(
        ep, PlayEffect.BuffImpactSound,
        Color.White, ep, 100);
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
}

// TAG CruisingMissile ----------
define crusingMissileDamageRange: 20;
rule: "Perk/Player/CruisingMissile/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.CruisingMissile &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 7;
    // set status
    perk[Perk.perkTargets] = 0;
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
    // show text
    // landing zone text
    perk[Perk.perkEffectAndText] = [];
    CreateInWorldText(
        AllPlayers(), <"<0> <1> <2>\n\rLanding at <3> second. Brace for impact!", ep, HeroIconString(HeroOf()), "Cruising Missile", perk[Perk.perkTimeLimit] >,
        landPosition + PositionOffset(), 1, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
        Color.White, Spectators.DefaultVisibility);
    perk[Perk.perkEffectAndText] [0] = LastTextID();
    // CreateInWorldText(
    //     AllPlayers(), <"Landing at <0> second. Brace for impact!", perk[Perk.perkTimeLimit] >,
    //     landPosition, 1.2, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
    //     Color.White, Spectators.DefaultVisibility);
    perk[Perk.perkEffectAndText] [1] = LastTextID();
    // set effect
    // missile body
    CreateEffect(AllPlayers(), Effect.Orb, Color.Red,
        perkPosition, 10, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [2] = LastCreatedEntity();
    // missile flare
    CreateEffect(AllPlayers(), Effect.GoodAura, Color.White,
        perkPosition, 20, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [3] = LastCreatedEntity();
    // missle sound
    CreateEffect(AllPlayers(), Effect.BadAuraSound, Color.White,
        perkPosition, MaxLength(), EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [4] = LastCreatedEntity();
    // landing zone blast range
    CreateEffect(AllPlayers(), Effect.Sphere, Color.Yellow,
        landPosition, crusingMissileDamageRange, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [5] = LastCreatedEntity();
    // landing zone position
    CreateEffect(AllPlayers(), Effect.Sphere, Color.Red,
        landPosition, 0.2, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [6] = LastCreatedEntity();  
    // landing zone warning icon
    CreateIcon(AllPlayers(), landPosition + (Up() * 2), Icon.Warning,
        IconRev.VisibleToAndPosition, Color.Yellow, true);
    perk[Perk.perkEffectAndText] [7] = LastCreatedEntity();
    // set hud
    CreatePerkEffectHud(perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered ? "locked landing point." : "guiding landing point.");
    perk[Perk.perkEffectAndText] [8] = LastTextID();
    CreatePerkEffectHud(perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered ? <"Hold melee button <0> to guide landing point.", ButtonGuide(Button.Melee)> : <"Hold melee button <0> to lock landing point.", ButtonGuide(Button.Melee)>);
    perk[Perk.perkEffectAndText] [9] = LastTextID();  
}
rule: "Perk/Player/CruisingMissile/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.CruisingMissile &&
    perkState  == PerkState.Non
){
    // reset text
    DestroyInWorldText(perk[Perk.perkEffectAndText] [0]);
    DestroyInWorldText(perk[Perk.perkEffectAndText] [1]);
    // reset effect
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
    DestroyEffect(perk[Perk.perkEffectAndText] [3]);
    DestroyEffect(perk[Perk.perkEffectAndText] [4]);
    DestroyEffect(perk[Perk.perkEffectAndText] [5]);
    DestroyEffect(perk[Perk.perkEffectAndText] [6]);
    StopChasingVariable(perkPosition);
    StopChasingVariable(landPosition);
    // reset icon
    DestroyIcon(perk[Perk.perkEffectAndText] [7]);
    // reset hud
    DestroyHudText(perk[Perk.perkEffectAndText] [8]);
    DestroyHudText(perk[Perk.perkEffectAndText] [9]);
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/CruisingMissile/toggleLockPoint"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.CruisingMissile &&
    perkState  == PerkState.Using &&
    IsButtonHeld(ep, Button.Melee)
){
    WaitLongPressConfirm();
    if(perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered){
        perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
    }
    else{
        perk[Perk.perkEffectStatus] = PerkEffectStatus.Triggered;
    }
    // play change sound
    PlayEffect(
        ep, PlayEffect.DebuffImpactSound,
        Color.White, ep, MaxValue());
}

rule: "Perk/Player/CruisingMissile/playTrajectory"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.CruisingMissile &&
    perkState  == PerkState.Using
){
    // play blast
    PlayEffect(
        AllPlayers(), PlayEffect.BadExplosion,
        Color.Orange, perkPosition, 3.0);

    WaitUpdateVeryShortCycle();
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/CruisingMissile/launchMissle"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.CruisingMissile &&
    perkState  == PerkState.Using
){
    // set missiles at random horizontal positions over 500m
    perkPosition = ep +
        Vector(0, 500, 0) + RandomPosition(250, 0, 250);
    // set missile land position to aiming position
    landPosition = AimingPosition();
    // start missile move
    if(!isServerOverLoad){
        UpdateEveryFrame(perkPosition);
        ChaseVariableOverTime(
            perkPosition, landPosition, perk[Perk.perkTimeLimit] ,
            TimeChaseReevaluation.DestinationAndDuration);
    }
}

rule: "Perk/Player/CruisingMissile/aimLandPoint"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.CruisingMissile &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Ready
){
    // chase missile land position to aiming position
    Wait(0.5, WaitBehavior.AbortWhenFalse);
    aimPosition = AimingPosition();
    UpdateEveryFrame(landPosition);
    ChaseVariableAtRate(
        landPosition, aimPosition,
        DistanceBetween(landPosition, aimPosition) * 3.0,
        RateChaseReevaluation.DestinationAndRate);
        
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/CruisingMissile/hideBlastRange"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.CruisingMissile &&
    perkState  == PerkState.Using &&
    perk[Perk.perkTimeLimit]  <= 1
){
    DestroyEffect(perk[Perk.perkEffectAndText] [5]);
}

rule: "Perk/Player/CruisingMissile/landedToPoint"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.CruisingMissile &&
    perkState  == PerkState.Using &&
    perk[Perk.perkTimeLimit]  <= 0
){
    StopChasingVariable(perkPosition);
    StopChasingVariable(landPosition);

    // apply knockout
    SetStatus(
        PlayersWithinRadius(
            landPosition, crusingMissileDamageRange,
            Team.Team1, RadiusLOS.Off
        ), null, Status.KnockedDown, 3);
    // get target
    perk[Perk.perkTargets] = 
        PlayersWithinRadius(
            landPosition, crusingMissileDamageRange,
            Team.Team2, RadiusLOS.Off);
    // apply blast impulse
    ApplyBlastImpulse(perk[Perk.perkTargets], landPosition, crusingMissileDamageRange);
    // damage
    Damage(perk[Perk.perkTargets], ep, MaxValue());
    // play blast sound
    PlayEffect(
        AllPlayers(), PlayEffect.RingExplosionSound,
        Color.White, landPosition, MaxLength());
    // play blast effect
    PlayContinuousBlast(
        Color.Orange,
        landPosition,
        crusingMissileDamageRange,
        7);

    perkState = PerkState.Non;
}

// TAG OrbitalLaser ----------
define lazerDamageRange: 2.0;
rule: "Perk/Player/OrbitalLaser/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.OrbitalLaser &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 60;
    // set status
    perk[Perk.perkTargets] = 0;
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
    // show text
    // landing zone text
    perk[Perk.perkEffectAndText] = [];
    CreateInWorldText(
        AllPlayers(), <"<0> <1> <2>\n\rIrradiating until <3> seconds.", ep, HeroIconString(HeroOf()), "Orbital Laser", perk[Perk.perkTimeLimit] >,
        landPosition + PositionOffset(), 1, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
        Color.White, Spectators.DefaultVisibility);
    perk[Perk.perkEffectAndText] [0] = LastTextID();
    // set effect
    // Irradiating point
    // CreateEffect(AllPlayers(), Effect.Sphere, Color.Red,
    //     landPosition, 0.2, EffectRev.VisibleToPositionAndRadius);
    // perk[Perk.perkEffectAndText] [1] = LastCreatedEntity();
    // lazer body
    CreateBeamEffect(AllPlayers(), BeamType.GoodBeam,
        perkPosition, landPosition,
        Color.Red, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [2] = LastCreatedEntity();
    // lazer aura
    CreateEffect(AllPlayers(), Effect.GoodAura, Color.Red,
        landPosition, 5, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [3] = LastCreatedEntity();
    // lazer sound
    CreateEffect(AllPlayers(), Effect.EnergySound, Color.White,
        landPosition, MaxLength(), EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [4] = LastCreatedEntity();
    // above lazer aura
    CreateEffect(AllPlayers(), Effect.GoodAura, Color.Red,
         PositionOf(ep) + Vector(0, 1000, 0), 30, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [5] = LastCreatedEntity();
    // lazer shell
    CreateEffect(AllPlayers(), Effect.LightShaft, Color.Red,
        landPosition, 0.3, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [6] = LastCreatedEntity();  
    // landing zone warning icon
    // CreateIcon(AllPlayers(), landPosition + (PositionOffset()*2), Icon.Warning,
    //     IconRev.VisibleToAndPosition, Color.Yellow, true);
    // perk[Perk.perkEffectAndText] [7] = LastCreatedEntity();
    // set hud
    CreatePerkEffectHud(perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered ? "locked irradiation point." : "guiding irradiation point.");
    perk[Perk.perkEffectAndText] [8] = LastTextID();
    CreatePerkEffectHud(perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered ? <"Hold melee button <0> to guide irradiation point.", ButtonGuide(Button.Melee)> : <"Hold melee button <0> to lock irradiation point.", ButtonGuide(Button.Melee)>);
    perk[Perk.perkEffectAndText] [9] = LastTextID();  
}

rule: "Perk/Player/OrbitalLaser/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.OrbitalLaser &&
    perkState  == PerkState.Non
){
    // reset text
    DestroyInWorldText(perk[Perk.perkEffectAndText] [0]);
    // reset effect
    // DestroyEffect(perk[Perk.perkEffectAndText] [1]);
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
    DestroyEffect(perk[Perk.perkEffectAndText] [3]);
    DestroyEffect(perk[Perk.perkEffectAndText] [4]);
    DestroyEffect(perk[Perk.perkEffectAndText] [5]);
    DestroyEffect(perk[Perk.perkEffectAndText] [6]);
    StopChasingVariable(perkPosition);
    StopChasingVariable(landPosition);
    // reset icon
    DestroyIcon(perk[Perk.perkEffectAndText] [7]);
    // reset hud
    DestroyHudText(perk[Perk.perkEffectAndText] [8]);
    DestroyHudText(perk[Perk.perkEffectAndText] [9]);
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/OrbitalLaser/toggleLockPoint"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.OrbitalLaser &&
    perkState  == PerkState.Using &&
    IsButtonHeld(ep, Button.Melee)
){
    WaitLongPressConfirm();
    if(perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered){
        perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
    }
    else{
        perk[Perk.perkEffectStatus] = PerkEffectStatus.Triggered;
    }
    // play change sound
    PlayEffect(
        ep, PlayEffect.DebuffImpactSound,
        Color.White, ep, MaxValue());
}

rule: "Perk/Player/OrbitalLaser/launchLazer"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.OrbitalLaser &&
    perkState  == PerkState.Using
){
    // set lazer at above positions over 500m
    perkPosition = AimingPosition() +
        Vector(0, 1000, 0);
    // set lazer land position to aiming position
    landPosition = BelowPosition(AimingPosition());
}

rule: "Perk/Player/OrbitalLaser/aimLandPoint"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.OrbitalLaser &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Ready
){
    // chase lazer land position to aiming position
    Wait(0.5, WaitBehavior.AbortWhenFalse);
    aimPosition = BelowPosition(AimingPosition());
    UpdateEveryFrame(landPosition);
    ChaseVariableAtRate(
        landPosition, aimPosition,
        DistanceBetween(landPosition, aimPosition) * 3.0,
        RateChaseReevaluation.DestinationAndRate);

    perkPosition = aimPosition + Vector(0, 500, 0);
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/OrbitalLaser/landedToPoint"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.OrbitalLaser &&
    perkState  == PerkState.Using
){
    // damage
    Damage(
        PlayersWithinRadius(
            landPosition, lazerDamageRange,
            Team.Team2, RadiusLOS.Off
        ), ep, 100);
    // play blast effect
    PlayEffect(
        AllPlayers(),
        PlayEffect.BadExplosion,
        Color.Red, landPosition, lazerDamageRange);
    WaitContinuousBlastCycle();
    LoopIfConditionIsTrue();
}

// TAG CarePackage ----------
rule: "Perk/Player/CarePackage/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.CarePackage &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 7;
    // set param
    perk[Perk.perkEffectStatus] = 0;
    // show text
    // landing zone text
    perk[Perk.perkEffectAndText] = [];
    CreateInWorldText(
        AllPlayers(), <"<0> <1> <2>\n\rArrival at <3> second. Stand by...", ep, HeroIconString(HeroOf()), "Care Package", perk[Perk.perkTimeLimit] >,
        landPosition + PositionOffset(), 1, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
        Color.White, Spectators.DefaultVisibility);
    perk[Perk.perkEffectAndText] [0] = LastTextID();
    // CreateInWorldText(
    //     AllPlayers(), <"Arrival at <0> second. Stand by...", perk[Perk.perkTimeLimit] >,
    //     landPosition, 1.2, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
    //     Color.White, Spectators.DefaultVisibility);
    perk[Perk.perkEffectAndText] [1] = LastTextID();
    // set effect
    // package body
    CreateEffect(AllPlayers(), Effect.Orb, Color.Turquoise,
        perkPosition, 1, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [2] = LastCreatedEntity();
    // package flare
    CreateEffect(AllPlayers(), Effect.GoodAura, Color.White,
        perkPosition, 5, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [3] = LastCreatedEntity();
    // package sound
    CreateEffect(AllPlayers(), Effect.BadAuraSound, Color.White,
        perkPosition, MaxLength(), EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [4] = LastCreatedEntity();
    // landing zone smoke
    CreateEffect(AllPlayers(), Effect.Cloud, Color.Turquoise,
        landPosition, 5, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [5] = LastCreatedEntity();
    // landing zone light shaft
    CreateEffect(AllPlayers(), Effect.LightShaft, Color.Turquoise,
        landPosition, 0.1, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [6] = LastCreatedEntity();
    // landing zone check icon
    CreateIcon(AllPlayers(), landPosition + (Up() * 2), Icon.Heart,
        IconRev.VisibleToAndPosition, Color.Turquoise, true);
    perk[Perk.perkEffectAndText] [7] = LastCreatedEntity();
}

rule: "Perk/Player/CarePackage/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.CarePackage &&
    perkState  == PerkState.Non
){
    // reset text
    DestroyInWorldText(perk[Perk.perkEffectAndText] [0]);
    DestroyInWorldText(perk[Perk.perkEffectAndText] [1]);
    // reset effect
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
    DestroyEffect(perk[Perk.perkEffectAndText] [3]);
    DestroyEffect(perk[Perk.perkEffectAndText] [4]);
    DestroyEffect(perk[Perk.perkEffectAndText] [5]);
    DestroyEffect(perk[Perk.perkEffectAndText] [6]);
    StopChasingVariable(perkPosition);
    // reset icon
    DestroyIcon(perk[Perk.perkEffectAndText] [7]);
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/CarePackage/playTrajectory"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.CarePackage &&
    perkState  == PerkState.Using
){
    // play blast
    PlayEffect(
        AllPlayers(), PlayEffect.BadExplosion,
        Color.Orange, perkPosition, 1.0);

    WaitUpdateVeryShortCycle();
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/CarePackage/dropPackage"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.CarePackage &&
    perkState  == PerkState.Using
){
    // set package at horizontal positions over 250
    perkPosition = ep +
        Vector(0, 125, 0) + RandomPosition(0, 0, 0);
    // set package land position to player position
    landPosition = BelowPosition(ep);
    // start package move
    if(!isServerOverLoad){
        UpdateEveryFrame(perkPosition);
        ChaseVariableOverTime(
            perkPosition, landPosition, perk[Perk.perkTimeLimit] ,
            TimeChaseReevaluation.DestinationAndDuration);
    }
}

rule: "Perk/Player/CarePackage/landedToPoint"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.CarePackage &&
    perkState  == PerkState.Using &&
    perk[Perk.perkTimeLimit]  <= 0
){
    StopChasingVariable(perkPosition);

    // play landing effect
    PlayEffect(
        AllPlayers(), PlayEffect.RingExplosion,
        Color.Turquoise, perkPosition, 10);
    PlayEffect(
        AllPlayers(), PlayEffect.GoodExplosion,
        Color.Turquoise, perkPosition, 10);
    PlayEffect(
        AllPlayers(), PlayEffect.RingExplosionSound,
        Color.White, perkPosition, MaxLength());
    
    perk[Perk.perkTargets] = RandomizedArray(AllPlayers(Team.Team1));
    perk[Perk.perkEffectStatus] = RandomReal(1, CountOf(perk[Perk.perkTargets]));
    // Set perk crate position to around of landPosition
    for(pLoopIndex = 0; pLoopIndex < perk[Perk.perkEffectStatus]; pLoopIndex++){
        perk[Perk.perkTargets][pLoopIndex].perk[Perk.perkCratePosition]
            = NearestWalkablePosition(landPosition + RandomPosition(3, 0, 3)) + PositionOffset();    
        perk[Perk.perkTargets][pLoopIndex].perk[Perk.perkCrateState] = PerkCrateState.Dropped;
    }
    perkState = PerkState.Non;
}

// TAG DeathFromAbove ----------
rule: "Perk/Player/DeathFromAbove/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.DeathFromAbove &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 180;
    // set param
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
    // set hud
    perk[Perk.perkEffectAndText] = [];
    CreatePerkEffectHud(
        IsUsingUltimate() ?
            <"Current weapon is <0>.", "150mm HE cannon"> :
            <"Press ability1 button <1> to change weapon. Current weapon is <0>.",
                IsInAlternateForm() ?
                "5mm minigun" :
                "20mm auto cannon" ,
            ButtonGuide(Button.Ability1)>
    );
    perk[Perk.perkEffectAndText] [0] = LastTextID();
    CreatePerkEffectHud(<"Press secondary fire button <0> to afterburner.", ButtonGuide(Button.SecondaryFire)>);
    perk[Perk.perkEffectAndText] [1] = LastTextID();
    CreatePerkEffectHud(<"Hold jump button <0> to flying mode.", ButtonGuide(Button.Jump)>);
    perk[Perk.perkEffectAndText] [2] = LastTextID();
    CreatePerkEffectHud(<"Hold crouch button <0> to walking mode.", ButtonGuide(Button.Crouch)>);
    perk[Perk.perkEffectAndText] [3] = LastTextID();
    // set perk hero
    PerkHero perkHero = new PerkHero();
    perkHero.hero = Hero.Bastion;
    perkHero.statusUnkillable = true;
    perkHero.secondaryFireEnabled = false;
    perkHero.maxHealth = 300;
    perkHero.healingReceived = 5.0;
    perkHero.gravity = 5;
    ForcePlayerPerkHero(ep, perkHero);
    // set status
    StartScalingPlayer(ep, 1.5, false);
    StartModifyingHeroVoiceLines(ep, 0.8, false);

    // fly and change mode
    Wait(0.5, WaitBehavior.AbortWhenFalse);
    StartHoldingButton(ep, Button.Jump);
    Wait(0.5, WaitBehavior.IgnoreCondition);
    StopHoldingButton(ep, Button.Jump);
    PressButton(ep, Button.Ability1);
}

rule: "Perk/Player/DeathFromAbove/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.DeathFromAbove &&
    perkState  == PerkState.Non
){
    // reset status
    ClearStatus(ep, Status.Rooted);
    StopScalingPlayer(ep);
    StopModifyingHeroVoiceLines(ep);
    // reset hud
    DestroyHudText(perk[Perk.perkEffectAndText] [0]);
    DestroyHudText(perk[Perk.perkEffectAndText] [1]);
    DestroyHudText(perk[Perk.perkEffectAndText] [2]);
    DestroyHudText(perk[Perk.perkEffectAndText] [3]);
    // reset perk hero
    StopForcingPerkHero(ep);
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/DeathFromAbove/brokenPerk //by helth 1"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.DeathFromAbove &&
    perkState  == PerkState.Using &&
    Health() <= 1
){
    WaitConditionConfirmed();// If the hero changes, the health is determined to be 0. Avoid waiting by adding waits.
    perkState = PerkState.Non;
}

rule: "Perk/Player/DeathFromAbove/changeFlyingMode"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.DeathFromAbove &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Ready &&
    IsButtonHeld(ep, Button.Jump)
){
    WaitLongPressConfirm();
    SetStatus(ep, null, Status.Rooted, MaxValue());
    SetGravity(ep, 5);
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Triggered;
}

rule: "Perk/Player/DeathFromAbove/changeToLandingMode"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.DeathFromAbove &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered &&
    IsButtonHeld(ep, Button.Crouch)
){
    WaitLongPressConfirm();
    ClearStatus(ep, Status.Rooted);
    SetGravity(ep, 100);
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
}

define keepHeight: 20;

rule: "Perk/Player/DeathFromAbove/flying"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.DeathFromAbove &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered
){
    define distanceFromSurface = DistanceBetween(ep, NearestWalkablePosition(ep));
    
    // if near surface
    if(
        distanceFromSurface < keepHeight
    ){
        // float    
        ApplyImpulse(ep, Up(),
            (keepHeight - distanceFromSurface) * 0.04,
            Relative.ToPlayer, ContraryMotion.Incorporate);
    }

    // if far surface
    if(
        distanceFromSurface > keepHeight
    ){
        // dive    
        ApplyImpulse(ep, Down(),
            (distanceFromSurface - keepHeight) * 0.04,
            Relative.ToPlayer, ContraryMotion.Incorporate);
    }
    
    // if press SF button
    if(IsButtonHeld(ep, Button.SecondaryFire)){
        // move forword
        ApplyImpulse(ep, Forward(), 1.5,
            Relative.ToPlayer, ContraryMotion.Incorporate);
    }
    else{
        ApplyImpulse(ep, Forward(), 0.05,
            Relative.ToPlayer, ContraryMotion.Incorporate);
    }
    WaitApplyImpulseCycle();
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/DeathFromAbove/playAfterBurner"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.DeathFromAbove &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered &&
    IsButtonHeld(ep, Button.SecondaryFire)
){
    // play Afterburner
    PlayEffect(
        AllPlayers(), PlayEffect.GoodExplosion,
        Color.Orange, PositionOf(ep), 0.5);
    WaitUpdateShortCycle();
    LoopIfConditionIsTrue();
}

define splashDamageRangeMinigun: 1.0;

rule: "Perk/Player/DeathFromAbove/splashDamageMinigun"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.DeathFromAbove &&
    perkState  == PerkState.Using &&
    !IsUsingUltimate() &&
    IsInAlternateForm() &&
    IsFiringPrimary()
){
    // get aimPosition
    aimPosition = AimingPosition();
    landPosition = RandomPosition(0.625, 0.625, 0.625);
    // splash damage
    Damage(
        PlayersWithinRadius(
            aimPosition + landPosition, splashDamageRangeMinigun,
            Team.Team2, RadiusLOS.Off),
        ep, 80);
    // play blast
    PlayEffect(
        AllPlayers(), PlayEffect.BadExplosion,
        Color.Yellow,
        aimPosition + landPosition,
        splashDamageRangeMinigun);
    WaitContinuousBlastCycle();

    LoopIfConditionIsTrue();
}

define splashDamageRangeAutoCanon: 2.0;

rule: "Perk/Player/DeathFromAbove/splashDamageAutoCanon"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.DeathFromAbove &&
    perkState  == PerkState.Using &&
    !IsUsingUltimate() &&
    !IsInAlternateForm() &&
    IsFiringPrimary()
){
    // get aimPosition
    aimPosition = AimingPosition();
    landPosition = RandomPosition(1.25, 1.25, 1.25);
    // splash damage
    Damage(
        PlayersWithinRadius(
            aimPosition + landPosition, splashDamageRangeAutoCanon,
            Team.Team2, RadiusLOS.Off),
        ep, 120);
    // play blast
    PlayEffect(
        AllPlayers(Team.All), PlayEffect.GoodExplosion,
        Color.Orange, aimPosition + landPosition,
        splashDamageRangeAutoCanon);
    Wait(0.15, WaitBehavior.IgnoreCondition);
    
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/DeathFromAbove/chargingUlt"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.DeathFromAbove &&
    perkState  == PerkState.Using &&
    !IsUsingUltimate() &&
    UltimateChargePercent() < 100
){
    WaitUpdateMediumCycle();
    SetUltimateCharge(ep, (UltimateChargePercent() + 3));
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/DeathFromAbove/setTankModeDamageBuff"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.DeathFromAbove &&
    perkState  == PerkState.Using &&
    IsUsingUltimate()
){
    SetDamageDealt(ep, 200);
}

rule: "Perk/Player/DeathFromAbove/resetTankModeDamageBuff"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.DeathFromAbove &&
    perkState  == PerkState.Using &&
    !IsUsingUltimate()
){
    SetDamageDealt(ep, 100);
}

// TAG LegendalyNinja ----------
rule: "Perk/Player/LegendalyNinja/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.LegendalyNinja &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 120;
    // set param
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
    // set hud
    perk[Perk.perkEffectAndText] = [];
    CreatePerkEffectHud(<"Hold melee button <0> to attract enemy with grapple hook.", ButtonGuide(Button.Melee)>);
    perk[Perk.perkEffectAndText] [0] = LastTextID();
    CreatePerkEffectHud(<"Hold jump button <0> to move in air with grapple hook.", ButtonGuide(Button.Jump)>);
    perk[Perk.perkEffectAndText] [1] = LastTextID();
    // set perk hero
    PerkHero perkHero = new PerkHero();
    perkHero.hero = Hero.Genji;
    perkHero.statusInvincible = true;
    perkHero.damageDealt = 150;
    perkHero.gravity = 75;
    perkHero.moveSpeed = 150;
    perkHero.jumpSpeed = 125;
    perkHero.ultimateCharge = 100;
    ForcePlayerPerkHero(ep, perkHero);
    Wait(0.5, WaitBehavior.AbortWhenFalse);

    // use ult
    PressButton(ep, Button.Ultimate);
}

rule: "Perk/Player/LegendalyNinja/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.LegendalyNinja &&
    perkState  == PerkState.Non
){
    // reset hud
    DestroyHudText(perk[Perk.perkEffectAndText] [0]);
    DestroyHudText(perk[Perk.perkEffectAndText] [1]);
    // reset effect
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
    DestroyEffect(perk[Perk.perkEffectAndText] [3]);
    // reset perk hero
    StopForcingPerkHero(ep);
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/LegendalyNinja/moveInAir"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.LegendalyNinja &&
    perkState  == PerkState.Using &&
    IsButtonHeld(ep, Button.Jump)
){
    AbortIf(perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered);
    WaitLongPressConfirm();

    // move in air
    aimPosition = AimingPosition();
    if(
        DistanceBetween(ep, aimPosition) <= 100
    ){
        CreateBeamEffect(AllPlayers(), BeamType.GrappleBeam,
            ep, aimPosition,
            Color.Green, EffectRev.VisibleToPositionAndRadius);
        perk[Perk.perkEffectAndText] [2] = LastCreatedEntity();
        ApplyImpulse(ep, 
            VectorTowards(ep, aimPosition + (Up() * 1)),
            DistanceBetween(ep, aimPosition) * 2.5 > minMoveImpulse ?
                DistanceBetween(ep, aimPosition) * 2.5 :
                minMoveImpulse,
            Relative.ToWorld, ContraryMotion.Cancel);
    }
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Triggered;

    // show beam effect
    WaitPlayEffect();
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
}

rule: "Perk/Player/LegendalyNinja/pullTarget"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.LegendalyNinja &&
    perkState  == PerkState.Using &&
    IsButtonHeld(ep, Button.Melee)
){
    AbortIf(perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered);
    WaitLongPressConfirm();
    
    // pull target
    perk[Perk.perkTargets] = AimingPlayer();
    if(
        DistanceBetween(ep, perk[Perk.perkTargets]) <= 100 &&
        perk[Perk.perkTargets] != null
    ){
        SetStatus(perk[Perk.perkTargets], ep, Status.Stunned, 1.0);
        // wait move stop
        Wait(0.1, WaitBehavior.IgnoreCondition);
        CreateBeamEffect(AllPlayers(), BeamType.GrappleBeam,
            ep, perk[Perk.perkTargets],
            Color.Red, EffectRev.VisibleToPositionAndRadius);
        perk[Perk.perkEffectAndText] [3] = LastCreatedEntity();
        ApplyImpulse(perk[Perk.perkTargets], 
            VectorTowards(perk[Perk.perkTargets], PositionOf(ep) + (Up() * 2.0)),
            DistanceBetween(perk[Perk.perkTargets], ep) * 2.5,
            Relative.ToWorld, ContraryMotion.Cancel);
    }
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Triggered;

    // show beam effect
    WaitPlayEffect();
    DestroyEffect(perk[Perk.perkEffectAndText] [3]);
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
}

rule: "Perk/Player/LegendalyNinja/addActivityTime"
Event.OnFinalBlow
Team.Team1
if(
    perkType == PerkType.LegendalyNinja &&
    perkState  == PerkState.Using &&
    perk[Perk.perkTimeLimit]  > 0
){
    SmallMessage(ep, "Added 2 seconds of activity time.");
    perk[Perk.perkTimeLimit]  += 2;
}

rule: "Perk/Player/LegendalyNinja/chargingUlt"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.LegendalyNinja &&
    perkState  == PerkState.Using &&
    !IsUsingUltimate() &&
    UltimateChargePercent() < 100
){
    WaitUpdateMediumCycle();
    SetUltimateCharge(ep, (UltimateChargePercent() + 8));
    LoopIfConditionIsTrue();
}

// TAG MachDelivery ----------
rule: "Perk/Player/MachDelivery/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.MachDelivery &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 240;
    // set param
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
    // set perk hero
    PerkHero perkHero = new PerkHero();
    perkHero.hero = Hero.Tracer;
    perkHero.statusUnkillable = true;
    perkHero.gravity = 75;
    perkHero.moveSpeed = 150;
    perkHero.jumpSpeed = 125;
    perkHero.ultimateCharge = 100;
    ForcePlayerPerkHero(ep, perkHero);
}

rule: "Perk/Player/MachDelivery/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.MachDelivery &&
    perkState  == PerkState.Non
){
    // reset perk hero
    StopForcingPerkHero(ep);
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/MachDelivery/brokenPerk //by helth 1"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.MachDelivery &&
    perkState  == PerkState.Using &&
    Health() <= 1
){
    WaitConditionConfirmed();// If the hero changes, the health is determined to be 0. Avoid waiting by adding waits.
    perkState = PerkState.Non;
}

rule: "Perk/Player/MachDelivery/startBombDelifering"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.MachDelivery &&
    perkState  == PerkState.Using &&
    IsUsingUltimate()
){
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Triggered;
    Wait(2.5, WaitBehavior.RestartWhenTrue);    // wait release delifering
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
}

rule: "Perk/Player/MachDelivery/rechargeByBombCriticalDamage"
Event.OnDamageDealt
Team.Team1
if(
    perkType == PerkType.MachDelivery &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered &&
    EventDamage() >= 300
){
    SetUltimateCharge(ep, 100);
}

rule: "Perk/Player/MachDelivery/rechargeByBombKill"
Event.OnFinalBlow
Team.Team1
if(
    perkType == PerkType.MachDelivery &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered
){
    SetUltimateCharge(ep, 100);
}

rule: "Perk/Player/MachDelivery/chargingUlt"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.MachDelivery &&
    perkState  == PerkState.Using &&
    !IsUsingUltimate() &&
    UltimateChargePercent() < 100
){
    WaitUpdateMediumCycle();
    SetUltimateCharge(ep, (UltimateChargePercent() + 6));
    LoopIfConditionIsTrue();
}

// TAG Juggernaut ----------
define splashDamageRangePlasmaCanon: 1.0;
define gravityBombReloadTime: 8;
define gravityBombReloadTimeWhenUlt: 1;
define gravityBombDamageRange: 7;

rule: "Perk/Player/Juggernaut/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Juggernaut &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 180;
    // set param
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
    // set hud
    perk[Perk.perkEffectAndText] = [];
    CreatePerkEffectHud(
        perk[Perk.perkEffectStatus]  == PerkEffectStatus.Ready ?
            <"Press secondary fire button <0> to shot gravity bomb.", ButtonGuide(Button.SecondaryFire)> :
            perk[Perk.perkEffectStatus]  == PerkEffectStatus.Reloading ?
                <"gravity bomb in recharging until <0> seconds.", perk[Perk.perkEffectCoolTime]> :
                "gravity bomb Fired!"
        );
    perk[Perk.perkEffectAndText] [0] = LastTextID();
    // set perk hero
    PerkHero perkHero = new PerkHero();
    perkHero.hero = Hero.Orisa;
    perkHero.statusUnkillable = true;
    perkHero.maxHealth = 300;
    perkHero.healingReceived = 5.0;
    perkHero.damageDealt = 150;
    perkHero.gravity = 300;
    perkHero.moveSpeed = 75;
    ForcePlayerPerkHero(ep, perkHero);
    // set status
    StartScalingPlayer(ep, 1.5, false);
    StartModifyingHeroVoiceLines(ep, 0.8, false);

    // use secondary
    Wait(0.5, WaitBehavior.AbortWhenFalse);
    PressButton(ep, Button.SecondaryFire);
}

rule: "Perk/Player/Juggernaut/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Juggernaut &&
    perkState  == PerkState.Non
){
    // reset status
    StopScalingPlayer(ep);
    StopModifyingHeroVoiceLines(ep);
    // reset hud
    DestroyHudText(perk[Perk.perkEffectAndText] [0]);
    // reset effect
    DestroyEffect(perk[Perk.perkEffectAndText] [1]);
    StopChasingVariable(perkPosition);
    StopChasingVariable(perkPosition2);
    // reset perk hero
    StopForcingPerkHero(ep);
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/Juggernaut/brokenPerk //by helth 1"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Juggernaut &&
    perkState  == PerkState.Using &&
    Health() <= 1
){
    WaitConditionConfirmed();// If the hero changes, the health is determined to be 0. Avoid waiting by adding waits.
    perkState = PerkState.Non;
}

rule: "Perk/Player/Juggernaut/setFiringSlow"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Juggernaut &&
    perkState  == PerkState.Using &&
    IsFiringPrimary()
)
{
    SetMoveSpeed(ep, 25);
}

rule: "Perk/Player/Juggernaut/resetFiringSlow"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Juggernaut &&
    perkState  == PerkState.Using &&
    !IsFiringPrimary()
)
{
    SetMoveSpeed(ep, 75);
}

rule: "Perk/Player/Juggernaut/splashDamage"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Juggernaut &&
    perkState  == PerkState.Using &&
    IsFiringPrimary()
)
{
    // get aimPosition  
    aimPosition = AimingPosition();
    landPosition = RandomPosition(0.5, 0.5, 0.5);
    // splash damage
    Damage(
        PlayersWithinRadius(
            aimPosition + landPosition,
            splashDamageRangePlasmaCanon,
            Team.Team2, RadiusLOS.Off),
        ep, 40);
    // play blast
    PlayEffect(
        AllPlayers(), PlayEffect.BadExplosion,
        Color.Green, aimPosition + landPosition,
        splashDamageRangePlasmaCanon);
    
    WaitContinuousBlastCycle();
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/Juggernaut/shotGravityBomb"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Juggernaut &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Ready &&
    IsFiringSecondary()
){
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Disabled;
    aimPosition2 = AimingPositionIgnorePlayer();
    perkPosition2 = EyePosition();
    // hide aura
    DestroyEffect(perk[Perk.perkEffectAndText] [1]);
    // show aura
    CreateEffect(AllPlayers(), Effect.GoodAura, Color.LimeGreen,
        perkPosition2, 1, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [1] = LastCreatedEntity();
    // follow the original ability effect
    UpdateEveryFrame(perkPosition2);
    ChaseVariableAtRate(perkPosition2, aimPosition2,
        26, RateChaseReevaluation.DestinationAndRate);

    // wait can trigger
    Wait(0.2, WaitBehavior.IgnoreCondition);    
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Triggered;
}


rule: "Perk/Player/Juggernaut/triggerGravityBomb"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Juggernaut &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered &&
    IsButtonHeld(ep, Button.SecondaryFire)
){
    ExplodeGravityBomb();
}

rule: "Perk/Player/Juggernaut/landedGravityBomb"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Juggernaut &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered &&
    perkPosition2 == aimPosition2
){
    ExplodeGravityBomb();
}

rule: "Perk/Player/Juggernaut/timeoutGravityBomb"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Juggernaut &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered
){
    Wait(3, WaitBehavior.AbortWhenFalse);
    ExplodeGravityBomb();
}

void ExplodeGravityBomb()"ExplodeGravityBomb"{
    perk[Perk.perkEffectStatus] = PerkEffectStatus.SecondTriggered;
    // stop aura
    StopChasingVariable(perkPosition2);
    // hide aura
    DestroyEffect(perk[Perk.perkEffectAndText] [1]);
    // wait builtin ability start cooldown
    Wait(0.7, WaitBehavior.IgnoreCondition);
    // set builtin ability reload time
    if(!IsUsingUltimate()){
        // start reload
        perk[Perk.perkEffectCoolTime] = gravityBombReloadTime;
        perk[Perk.perkEffectStatus] = PerkEffectStatus.Reloading;
        SetAbilityCooldown(ep, Button.SecondaryFire, gravityBombReloadTime);
    }
    else{
        // shorten reload when ult
        perk[Perk.perkEffectCoolTime] = gravityBombReloadTimeWhenUlt;
        perk[Perk.perkEffectStatus] = PerkEffectStatus.Reloading;
        SetAbilityCooldown(ep, Button.SecondaryFire, gravityBombReloadTimeWhenUlt);
    }
    // wait enemy pull by builtin ability 
    Wait(0.2, WaitBehavior.IgnoreCondition);
    // get target
    perk[Perk.perkTargets] = 
        PlayersWithinRadius(
            perkPosition2,
            gravityBombDamageRange,
            Team.Team2, RadiusLOS.Off);
    // apply blast impulse
    ApplyBlastImpulse(perk[Perk.perkTargets], perkPosition2,
        gravityBombDamageRange);
    // damage
    Damage(perk[Perk.perkTargets], ep, 600);
    // play blast sound
    PlayEffect(
        AllPlayers(), PlayEffect.RingExplosionSound,
        Color.White, perkPosition2, MaxLength());
    // play blast effect
    PlayContinuousBlast(
        Color.LimeGreen,
        perkPosition2,
        gravityBombDamageRange,
        5);
}

rule: "Perk/Player/Juggernaut/countDownCoolTimeGravityBomb"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Juggernaut &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Reloading &&
    perk[Perk.perkEffectCoolTime] > 0
){
    // count down perk cooldown time
    WaitUpdateMediumCycle();
    perk[Perk.perkEffectCoolTime] -= 1;
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/Juggernaut/coolDownCompleteGravityBomb"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Juggernaut &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Reloading &&
    perk[Perk.perkEffectCoolTime] <= 0
){
    // play ready sound
    PlayEffect(
        ep, PlayEffect.BuffImpactSound,
        Color.White, ep, 100);
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
}

rule: "Perk/Player/Juggernaut/skipReloadGravityBomb"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Juggernaut &&
    perkState  == PerkState.Using &&
    IsUsingUltimate()
){
    if(gravityBombReloadTimeWhenUlt < AbilityCooldown(ep, Button.SecondaryFire)){
        // start reload
        perk[Perk.perkEffectCoolTime] = gravityBombReloadTimeWhenUlt;
        perk[Perk.perkEffectStatus] = PerkEffectStatus.Reloading;
        SetAbilityCooldown(ep, Button.SecondaryFire, gravityBombReloadTimeWhenUlt);
    }
}

// TAG BeamSniper ----------
rule: "Perk/Player/BeamSniper/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.BeamSniper &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 300;
    // set param
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Reloading;
    // set hud
    perk[Perk.perkEffectAndText] = [];
    CreatePerkEffectHud("Can shoot enemy through wall when blinking blue.");
    perk[Perk.perkEffectAndText] [0] = LastTextID();
    // set perk hero
    PerkHero perkHero = new PerkHero();
    perkHero.hero = Hero.Widowmaker;
    perkHero.statusUnkillable = true;
    perkHero.damageDealt = 200;
    perkHero.ultimateCharge = 100;
    ForcePlayerPerkHero(ep, perkHero);

    // use ult
    Wait(0.5, WaitBehavior.AbortWhenFalse);
    PressButton(ep, Button.Ultimate);
}

rule: "Perk/Player/BeamSniper/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.BeamSniper &&
    perkState  == PerkState.Non
){
    // reset effect
    DestroyEffect(perk[Perk.perkEffectAndText] [1]);
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
    // reset hud
    DestroyHudText(perk[Perk.perkEffectAndText] [0]);
    // reset perk hero
    StopForcingPerkHero(ep);
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/BeamSniper/brokenPerk //by helth 1"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.BeamSniper &&
    perkState  == PerkState.Using &&
    Health() <= 1
){
    WaitConditionConfirmed();// If the hero changes, the health is determined to be 0. Avoid waiting by adding waits.
    perkState = PerkState.Non;
}

rule: "Perk/Player/BeamSniper/chargingUlt"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.BeamSniper &&
    perkState  == PerkState.Using &&
    !IsUsingUltimate() &&
    UltimateChargePercent() < 100
){
    WaitUpdateMediumCycle();
    SetUltimateCharge(ep, (UltimateChargePercent() + 6));
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/BeamSniper/startCharge"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.BeamSniper &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Reloading &&
    IsButtonHeld(ep, Button.SecondaryFire) &&
    IsFiringSecondary() &&
    !IsFiringPrimary()
){
    Wait(1.3, WaitBehavior.AbortWhenFalse);
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
}

rule: "Perk/Player/BeamSniper/cancelCharge"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.BeamSniper &&
    perkState  == PerkState.Using &&
    !IsButtonHeld(ep, Button.SecondaryFire)
){
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Reloading;
}

rule: "Perk/Player/BeamSniper/markTarget"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.BeamSniper &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Ready
){
    perk[Perk.perkTargets] = FilteredArray(
        PlayersInViewAngle(ep, Team.Team2, 1.25),
        IsAlive(ArrayElement()));
    if(perk[Perk.perkTargets] != []){
        PlayEffect(
            ep, PlayEffect.GoodPickupEffect,
            Color.Aqua, perk[Perk.perkTargets], 1.0);
        PlayEffect(
            ep, PlayEffect.GoodExplosion,
            Color.Aqua, AimingPosition(), 0.01);
    }

    // Since the impact point will shift due to the recoil when shooting, get the position before shooting
    aimPosition = AimingPosition();     

    WaitUpdateVeryShortCycle();
    LoopIfConditionIsTrue();
}

define beamSniperDamageRange: 3;

rule: "Perk/Player/BeamSniper/shotSniperBeam"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.BeamSniper &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Ready &&
    IsButtonHeld(ep, Button.SecondaryFire) &&
    IsButtonHeld(ep, Button.PrimaryFire)
){
    AbortIf(perk[Perk.perkEffectStatus]  == PerkEffectStatus.Reloading);
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Reloading;

    // give hit damage to enemy near penetration ballistic
    if(perk[Perk.perkTargets] != []){
        PlayEffect(
            AllPlayers(), PlayEffect.GoodExplosion,
            Color.Aqua, perk[Perk.perkTargets], beamSniperDamageRange);
        Damage(perk[Perk.perkTargets], ep, 400);
    }
    // give splash damage to enemy near landed position
    perk[Perk.perkTargets] = FilteredArray(
        PlayersWithinRadius(aimPosition, beamSniperDamageRange, Team.Team2, RadiusLOS.Off),
        IsAlive(ArrayElement()));
    if(perk[Perk.perkTargets] != []){
        Damage(perk[Perk.perkTargets], ep, 100);
    }

    // set offset for gun sight
    perkPosition = EyePosition() - PositionOffset(); 

    // set landing position for penetration
    landPosition = EyePosition() +
        (FacingDirectionOf() * MaxLength());

    // play shot sound
    PlayEffect(
        AllPlayers(), PlayEffect.RingExplosionSound,
        Color.Aqua, ep, 100);
    // play shot fire
    PlayEffect(
        AllPlayers(), PlayEffect.BadExplosion,
        Color.Aqua, perkPosition + (FacingDirectionOf() * 1), 1.0);
    // play landed position blast
    PlayContinuousBlast(
        Color.Aqua,
        aimPosition,
        beamSniperDamageRange,
        3);

    // show ballistics for aiming
    CreateBeamEffect(AllPlayers(),
        BeamType.BadBeam, perkPosition, aimPosition,
        Color.Aqua, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [1] = LastCreatedEntity();
    // show ballistic for penetration
    CreateBeamEffect(AllPlayers(),
        BeamType.BadBeam, aimPosition, landPosition,
        Color.Aqua, EffectRev.VisibleToPositionAndRadius);
    perk[Perk.perkEffectAndText] [2] = LastCreatedEntity();

    WaitPlayEffect();
    DestroyEffect(perk[Perk.perkEffectAndText] [1]);
    DestroyEffect(perk[Perk.perkEffectAndText] [2]);
}

// TAG DragonStorm ----------
rule: "Perk/Player/DragonStorm/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.DragonStorm &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 120;
    // set param
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
    // set hud
    perk[Perk.perkEffectAndText] = [];
    CreatePerkEffectHud(<"Hold ultimate button <0> to shot dragon storm.", ButtonGuide(Button.Ultimate)>);
    perk[Perk.perkEffectAndText] [0] = LastTextID();
    CreatePerkEffectHud(<"Press ultimate button <0> to shot dragon strike.", ButtonGuide(Button.Ultimate)>);
    perk[Perk.perkEffectAndText] [1] = LastTextID();
    // set perk hero
    PerkHero perkHero = new PerkHero();
    perkHero.hero = Hero.Hanzo;
    perkHero.statusUnkillable = true;
    perkHero.damageDealt = 150;
    perkHero.gravity = 75;
    perkHero.moveSpeed = 150;
    perkHero.ultimateCharge = 100;
    ForcePlayerPerkHero(ep, perkHero);

    // use ult
    Wait(0.5, WaitBehavior.AbortWhenFalse);
    StartHoldingButton(ep, Button.Ultimate);
    Wait(0.5, WaitBehavior.IgnoreCondition);
    StopHoldingButton(ep, Button.Ultimate);
}

rule: "Perk/Player/DragonStorm/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.DragonStorm &&
    perkState  == PerkState.Non
){
    // reset status
    ClearStatus(ep, Status.Rooted);
    ClearStatus(ep, Status.Invincible);
    StopFacing();
    if(perk[Perk.isInAir]){
        Teleport(ep, PositionOf() + Vector(0, -60, 0));
    }
    perk[Perk.isInAir] = false;
    // hide enemy outline
    StopForcingPlayerOutlines(
        AllPlayers(Team.Team2),
        ep
    );
    // reset hud
    DestroyHudText(perk[Perk.perkEffectAndText] [0]);
    DestroyHudText(perk[Perk.perkEffectAndText] [1]);
    // reset perk hero
    StopForcingPerkHero(ep);
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/DragonStorm/brokenPerk //by helth 1"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.DragonStorm &&
    perkState  == PerkState.Using &&
    Health() <= 1
){
    WaitConditionConfirmed();// If the hero changes, the health is determined to be 0. Avoid waiting by adding waits.
    perkState = PerkState.Non;
}

define maxOfDragon: 9;
rule: "Perk/Player/DragonStorm/startDragonStorm"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.DragonStorm &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Ready &&
    IsUsingUltimate()
){
    WaitLongPressConfirm();
    AbortIf(!IsButtonHeld(ep, Button.Ultimate));

    CancelPrimaryAction();
    // jump movement
    ApplyImpulse(ep, Up(),
        25, Relative.ToWorld, ContraryMotion.Cancel);
    Wait(0.5, WaitBehavior.IgnoreCondition);
    // set position
    Teleport(ep, PositionOf() + Vector(0, 60, 0));
    perk[Perk.isInAir] = true;
    perkPosition = PositionOf();
    // set status
    SetStatus(ep, null, Status.Rooted, MaxValue());
    SetStatus(ep, null, Status.Invincible, MaxValue());
    SetGravity(ep, 0);
    SetDamageDealt(ep, 700);
    // show enemy outline
    StartForcingPlayerOutlines(
        AllLivingPlayers(Team.Team2),
        ep,
        true,
        Color.Red,
        OutlineType.Always
    );  
    // face enemy
    perk[Perk.perkTargets] = ClosestPlayerTo(ep, Team.Team2);
    // start auto aim
    autoAimingTarget = perk[Perk.perkTargets];
    StartAutoAiming();
    Wait(0.1, WaitBehavior.IgnoreCondition);
    StopFacing();

    // wait aim
    Wait(0.5, WaitBehavior.IgnoreCondition);

    perk[Perk.deployDragonNum] = 0;
    perk[Perk.perkEffectStatus] = PerkEffectStatus.Triggered;
}

rule: "Perk/Player/DragonStorm/deployDragons"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.DragonStorm &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered &&
    perk[Perk.deployDragonNum] < maxOfDragon &&
    !IsUsingUltimate()
){
    SetUltimateCharge(ep, 100);
    SetProjectileSpeed(ep, 5 + perk[Perk.deployDragonNum]);
    PressButton(ep, Button.Ultimate);
    perk[Perk.deployDragonNum] ++;
}

rule: "Perk/Player/DragonStorm/finishDragonStorm"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.DragonStorm &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  == PerkEffectStatus.Triggered &&
    perk[Perk.deployDragonNum] >= maxOfDragon
){
    Wait(1.0, WaitBehavior.AbortWhenFalse);
    SetProjectileSpeed(ep, DefaultPercentage());
    // wait deploy dragon
    Wait(4.0, WaitBehavior.AbortWhenFalse);
    // reset position
    Teleport(ep, PositionOf() - Vector(0, 60, 0));
    perk[Perk.isInAir] = false;
    // reset status
    SetProjectileSpeed(ep, DefaultPercentage());
    ClearStatus(ep, Status.Rooted);
    ClearStatus(ep, Status.Invincible);
    SetGravity(ep, DefaultPercentage());
    SetDamageDealt(ep, 150);
    // hide enemy outline
    StopForcingPlayerOutlines(
        AllPlayers(Team.Team2),
        ep
    );
    // face enemy
    perk[Perk.perkTargets] = ClosestPlayerTo(ep, Team.Team2);
    // start auto aim
    autoAimingTarget = perk[Perk.perkTargets];
    StartAutoAiming();
    Wait(0.1, WaitBehavior.IgnoreCondition);
    StopFacing();

    perk[Perk.perkEffectStatus] = PerkEffectStatus.Ready;
}

rule: "Perk/Player/DragonStorm/keepPosition"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.DragonStorm &&
    perkState  == PerkState.Using &&
    perk[Perk.isInAir] &&
    DistanceBetween(ep, perkPosition) >= 0.01
){
    ApplyImpulse(ep, VectorTowards(ep, perkPosition),
        DistanceBetween(ep, perkPosition),
        Relative.ToWorld, ContraryMotion.Cancel);
    WaitApplyImpulseCycle();
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/DragonStorm/addActivityTime"
Event.OnFinalBlow
Team.Team1
if(
    perkType == PerkType.DragonStorm &&
    perkState  == PerkState.Using &&
    perk[Perk.perkTimeLimit]  > 0
){
    SmallMessage(ep, "Added 3 seconds of activity time.");
    perk[Perk.perkTimeLimit]  += 3;
}

rule: "Perk/Player/DragonStorm/chargingUlt"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.DragonStorm &&
    perkState  == PerkState.Using &&
    !IsUsingUltimate() &&
    UltimateChargePercent() < 100
){
    WaitUpdateMediumCycle();
    SetUltimateCharge(ep, (UltimateChargePercent() + 3));
    LoopIfConditionIsTrue();
}

// TAG Titan ----------
rule: "Perk/Player/Titan/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Titan &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 120;
    // set param
    perk[Perk.perkEffectStatus] = 0;
    perk[Perk.rider] = 0;
    // set hud
    perk[Perk.perkEffectAndText] = [];
    CreatePerkEffectHud(
        perk[Perk.rider] != 0 ?
            <"<0> <1> riding on your back.", perk[Perk.rider], HeroIconString(HeroOf(perk[Perk.rider]))> :
            "Teammate can ride your back.");
    perk[Perk.perkEffectAndText] [0] = LastTextID();
    CreatePerkEffectHud(<"Hold crouch button <0> to get smaller.", ButtonGuide(Button.Crouch)>);
    perk[Perk.perkEffectAndText] [1] = LastTextID();
    // set perk hero
    PerkHero perkHero = new PerkHero();
    perkHero.hero = Hero.Reinhardt;
    perkHero.statusUnkillable = true;
    perkHero.maxHealth = 200;
    perkHero.healingReceived = 10.0;
    perkHero.damageDealt = 300;
    perkHero.ultimateCharge = 100;
    ForcePlayerPerkHero(ep, perkHero);
    Wait(0.5, WaitBehavior.AbortWhenFalse);

    // set pool health
    AddHealthPoolToPlayer(ep, HealthType.Armor, 1500, true, false);
    perk[Perk.healthPoolID] = LastCreatedHealthPool();

    // start grow big
    PressButton(ep, Button.Crouch);
}

rule: "Perk/Player/Titan/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Titan &&
    perkState  == PerkState.Non
){
    // set param
    perk[Perk.perkEffectStatus] = 0;
    DetachPlayers(perk[Perk.rider]);
    Teleport(perk[Perk.rider], ep);
    perk[Perk.rider].perk[Perk.ridingTarget] = 0;
    perk[Perk.rider] = 0;
    // reset hud
    DestroyHudText(perk[Perk.perkEffectAndText] [0]);
    DestroyHudText(perk[Perk.perkEffectAndText] [1]);
    // reset perk hero
    StopForcingPerkHero(ep);
    // reset status
    RemoveHealthPoolFromPlayer(perk[Perk.healthPoolID]);
    StopScalingPlayer(ep);
    StopModifyingHeroVoiceLines(ep);
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/Titan/brokenPerk //by helth 1"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Titan &&
    perkState  == PerkState.Using &&
    Health() <= 1
){
    WaitConditionConfirmed();// If the hero changes, the health is determined to be 0. Avoid waiting by adding waits.
    perkState = PerkState.Non;
}

rule: "Perk/Player/Titan/growBig"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Titan &&
    perkState  == PerkState.Using &&
    !(IsCrouching() || IsButtonHeld(ep, Button.Crouch))
){
    PlayEffect(
        AllPlayers(), PlayEffect.GoodPickupEffect,
        Color.White, ep, 1);

    if(!( 0 <= perk[Perk.perkEffectStatus]  && perk[Perk.perkEffectStatus]  <= 1)) perk[Perk.perkEffectStatus] = 0;
    while(perk[Perk.perkEffectStatus]  < 1){
        StartScalingPlayer(ep, 1 + (perk[Perk.perkEffectStatus]  * 1.25), false);
        perk[Perk.perkEffectStatus]  += 0.1;
        WaitUpdateVeryShortCycle();
    }
    StartModifyingHeroVoiceLines(ep, 0.8, false);
}

rule: "Perk/Player/Titan/getSmall"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Titan &&
    perkState  == PerkState.Using &&
    (IsCrouching() || IsButtonHeld(ep, Button.Crouch))
){
    DetachPlayers(perk[Perk.rider]);
    Teleport(perk[Perk.rider], ep);
    perk[Perk.rider].perk[Perk.ridingTarget] = 0;
    perk[Perk.rider] = 0;

    PlayEffect(
        AllPlayers(), PlayEffect.GoodPickupEffect,
        Color.White, ep, 1);

    if(!( 0 <= perk[Perk.perkEffectStatus]  && perk[Perk.perkEffectStatus]  <= 1)) perk[Perk.perkEffectStatus] = 1;
    while(perk[Perk.perkEffectStatus]  > 0){
        StartScalingPlayer(ep, 1 + (perk[Perk.perkEffectStatus]  * 1.25), false);
        perk[Perk.perkEffectStatus]  -= 0.1;
        WaitUpdateVeryShortCycle();
    }
    StartModifyingHeroVoiceLines(ep, 1.0, false);
}

rule: "Perk/Player/Titan/chargingUlt"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Titan &&
    perkState  == PerkState.Using &&
    !IsUsingUltimate() &&
    UltimateChargePercent() < 100
){
    WaitUpdateMediumCycle();
    SetUltimateCharge(ep, (UltimateChargePercent() + 3));
    LoopIfConditionIsTrue();
}

define canRidingRange : 6.0;

define canRideTitan:
    IsAlive() &&
    !isRidingTitan &&
    CountOf(nearCanRideTitan) > 0;

define nearCanRideTitan:
    FilteredArray(
        AllPlayers(Team.Team1),
        (
            DistanceBetween(ep, ArrayElement()) <= canRidingRange &&
            ArrayElement() != ep &&
            ArrayElement().perk[Perk.rider] == 0 &&
            ArrayElement().perk[Perk.perkEffectStatus]  == 1 &&
            ArrayElement().perkState  == PerkState.Using &&
            ArrayElement().perkType == PerkType.Titan
        )
    );

define isRidingTitan:
    perk[Perk.ridingTarget] != 0 &&
    perk[Perk.ridingTarget].perk[Perk.rider] == ep &&
    perk[Perk.ridingTarget].perkState == PerkState.Using &&
    perk[Perk.ridingTarget].perkType == PerkType.Titan;

rule: "Perk/Player/Titan/showOperationGetOn"
Event.OngoingPlayer
Team.Team1
if(
    canRideTitan
){
    // set hud
    CreatePerkEffectHud(<"Can add titan's activity time by kill enemy when riding titan.">);
    perk[Perk.perkEffectAndText] [200] = LastTextID();
    CreatePerkEffectHud(<"Hold jump button <0> to get on titan.", ButtonGuide(Button.Jump)>);
    perk[Perk.perkEffectAndText] [201] = LastTextID();
}

rule: "Perk/Player/Titan/hideOperationGetOn"
Event.OngoingPlayer
Team.Team1
if(
    !canRideTitan
){
    DestroyHudText(perk[Perk.perkEffectAndText] [200]);
    DestroyHudText(perk[Perk.perkEffectAndText] [201]);
}

rule: "Perk/Player/Titan/showOperationGetOff"
Event.OngoingPlayer
Team.Team1
if(
    isRidingTitan
){
    // set hud
    CreatePerkEffectHud(<"Hold crouch button <0> to get off titan.", ButtonGuide(Button.Crouch)>);
    perk[Perk.perkEffectAndText] [202] = LastTextID();
}

rule: "Perk/Player/Titan/hideOperationGetOff"
Event.OngoingPlayer
Team.Team1
if(
    !isRidingTitan
){
    DestroyHudText(perk[Perk.perkEffectAndText] [202]);
}

rule: "Perk/Player/Titan/getOn"
Event.OngoingPlayer
Team.Team1
if(
    canRideTitan &&
    IsButtonHeld(ep, Button.Jump)
){
    WaitLongPressConfirm();
    perk[Perk.ridingTarget] = FirstOf(nearCanRideTitan);
    AttachPlayers(ep, perk[Perk.ridingTarget], Up() * 3.75);
    perk[Perk.ridingTarget].perk[Perk.rider] = ep;
}

rule: "Perk/Player/Titan/getOff"
Event.OngoingPlayer
Team.Team1
if(
    isRidingTitan &&
    (
        IsButtonHeld(ep, Button.Crouch) ||
        IsDead(ep)
    )
){
    if(IsButtonHeld(ep, Button.Crouch))
        WaitLongPressConfirm();
    DetachPlayers(perk[Perk.ridingTarget].perk[Perk.rider]);
    Teleport(ep, perk[Perk.ridingTarget] + PositionOffset());
    perk[Perk.ridingTarget].perk[Perk.rider] = 0;
    perk[Perk.ridingTarget] = 0;
}

rule: "Perk/Player/Titan/addActivityTime"
Event.OnFinalBlow
Team.Team1
if(
    perk[Perk.ridingTarget].perkType == PerkType.Titan &&
    perk[Perk.ridingTarget].perkState  == PerkState.Using &&
    perk[Perk.ridingTarget].perk[Perk.perkTimeLimit]  > 0

){
    SmallMessage(ep, "Added 10 seconds of titan's activity time.");
    perk[Perk.ridingTarget].perk[Perk.perkTimeLimit]  += 10;
}

// TAG Behemoth ----------
rule: "Perk/Player/Behemoth/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Behemoth &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 120;
    // set param
    perk[Perk.perkEffectStatus] = 0;
    perk[Perk.rider] = 0;
    // set hud
    perk[Perk.perkEffectAndText] = [];
    CreatePerkEffectHud(
        perk[Perk.rider] != 0 ?
            <"<0> <1> riding on your back.", perk[Perk.rider], HeroIconString(HeroOf(perk[Perk.rider]))> :
            "Teammate can ride your back.");
    perk[Perk.perkEffectAndText] [0] = LastTextID();
    CreatePerkEffectHud(<"Hold crouch button <0> to get smaller.", ButtonGuide(Button.Crouch)>);
    perk[Perk.perkEffectAndText] [1] = LastTextID();
    // set perk hero
    PerkHero perkHero = new PerkHero();
    perkHero.hero = Hero.Roadhog;
    perkHero.statusUnkillable = true;
    perkHero.maxHealth = 200;
    perkHero.healingReceived = 10.0;
    perkHero.damageDealt = 125;
    perkHero.ultimateCharge = 100;
    ForcePlayerPerkHero(EventPlayer(), perkHero);
    Wait(0.5, WaitBehavior.AbortWhenFalse);

    // use ult
    PressButton(EventPlayer(), Button.Ultimate);

    // start grow big
    PressButton(EventPlayer(), Button.Crouch);
}

rule: "Perk/Player/Behemoth/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Behemoth &&
    perkState  == PerkState.Non
){
    // set param
    perk[Perk.perkEffectStatus] = 0;
    DetachPlayers(perk[Perk.rider]);
    Teleport(perk[Perk.rider], EventPlayer());
    perk[Perk.rider].perk[Perk.ridingTarget] = 0;
    perk[Perk.rider] = 0;
    // reset hud
    DestroyHudText(perk[Perk.perkEffectAndText] [0]);
    DestroyHudText(perk[Perk.perkEffectAndText] [1]);
    // reset perk hero
    StopForcingPerkHero(EventPlayer());
    // reset status
    StopScalingPlayer(EventPlayer());
    StopModifyingHeroVoiceLines(EventPlayer());
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/Behemoth/brokenPerk //by helth 1"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Behemoth &&
    perkState  == PerkState.Using &&
    Health() <= 1
){
    WaitConditionConfirmed();// If the hero changes, the health is determined to be 0. Avoid waiting by adding waits.
    perkState = PerkState.Non;
}

rule: "Perk/Player/Behemoth/growBig"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Behemoth &&
    perkState  == PerkState.Using &&
    !(IsCrouching() || IsButtonHeld(EventPlayer(), Button.Crouch))
){
    PlayEffect(
        AllPlayers(), PlayEffect.GoodPickupEffect,
        Color.White, EventPlayer(), 1);

    if(!( 0 <= perk[Perk.perkEffectStatus]  && perk[Perk.perkEffectStatus]  <= 1)) perk[Perk.perkEffectStatus] = 0;
    while(perk[Perk.perkEffectStatus]  < 1){
        StartScalingPlayer(EventPlayer(), 1 + (perk[Perk.perkEffectStatus]  * 1.25), false);
        perk[Perk.perkEffectStatus]  += 0.1;
        WaitUpdateVeryShortCycle();
    }
    StartModifyingHeroVoiceLines(EventPlayer(), 0.8, false);
}

rule: "Perk/Player/Behemoth/getSmall"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Behemoth &&
    perkState  == PerkState.Using &&
    (IsCrouching() || IsButtonHeld(EventPlayer(), Button.Crouch))
){
    DetachPlayers(perk[Perk.rider]);
    Teleport(perk[Perk.rider], EventPlayer());
    perk[Perk.rider].perk[Perk.ridingTarget] = 0;
    perk[Perk.rider] = 0;

    PlayEffect(
        AllPlayers(), PlayEffect.GoodPickupEffect,
        Color.White, EventPlayer(), 1);

    if(!( 0 <= perk[Perk.perkEffectStatus]  && perk[Perk.perkEffectStatus]  <= 1)) perk[Perk.perkEffectStatus] = 1;
    while(perk[Perk.perkEffectStatus]  > 0){
        StartScalingPlayer(EventPlayer(), 1 + (perk[Perk.perkEffectStatus]  * 1.25), false);
        perk[Perk.perkEffectStatus]  -= 0.1;
        WaitUpdateVeryShortCycle();
    }
    StartModifyingHeroVoiceLines(EventPlayer(), 1.0, false);
}

rule: "Perk/Player/Behemoth/chargingUlt"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Behemoth &&
    perkState  == PerkState.Using &&
    !IsUsingUltimate() &&
    UltimateChargePercent() < 100
){
    WaitUpdateMediumCycle();
    SetUltimateCharge(EventPlayer(), (UltimateChargePercent() + 10));
    LoopIfConditionIsTrue();
}

define canRideBehemoth:
    IsAlive() &&
    !isRidingBehemoth &&
    CountOf(nearCanRideBehemoth) > 0;

define nearCanRideBehemoth:
    FilteredArray(
        AllPlayers(Team.Team1),
        (
            DistanceBetween(ep, ArrayElement()) <= canRidingRange &&
            ArrayElement() != ep &&
            ArrayElement().perk[Perk.rider] == 0 &&
            ArrayElement().perk[Perk.perkEffectStatus]  == 1 &&
            ArrayElement().perkState  == PerkState.Using &&
            ArrayElement().perkType == PerkType.Behemoth
        )
    );


define isRidingBehemoth: 
    perk[Perk.ridingTarget] != 0 &&
    perk[Perk.ridingTarget].perk[Perk.rider] == ep &&
    perk[Perk.ridingTarget].perkState == PerkState.Using &&
    perk[Perk.ridingTarget].perkType == PerkType.Behemoth;

rule: "Perk/Player/Behemoth/showOperationGetOn"
Event.OngoingPlayer
Team.Team1
if(
    canRideBehemoth
){
    // set hud
    CreatePerkEffectHud(<"Can add Behemoth's activity time by kill enemy when riding Behemoth.">);
    perk[Perk.perkEffectAndText] [300] = LastTextID();
    CreatePerkEffectHud(<"Hold jump button <0> to get on Behemoth.", ButtonGuide(Button.Jump)>);
    perk[Perk.perkEffectAndText] [301] = LastTextID();
}

rule: "Perk/Player/Behemoth/hideOperationGetOn"
Event.OngoingPlayer
Team.Team1
if(
    !canRideBehemoth
){
    DestroyHudText(perk[Perk.perkEffectAndText] [300]);
    DestroyHudText(perk[Perk.perkEffectAndText] [301]);
}

rule: "Perk/Player/Behemoth/showOperationGetOff"
Event.OngoingPlayer
Team.Team1
if(
    isRidingBehemoth
){
    // set hud
    CreatePerkEffectHud(<"Hold crouch button <0> to get off Behemoth.", ButtonGuide(Button.Crouch)>);
    perk[Perk.perkEffectAndText] [302] = LastTextID();
}

rule: "Perk/Player/Behemoth/hideOperationGetOff"
Event.OngoingPlayer
Team.Team1
if(
    !isRidingBehemoth
){
    DestroyHudText(perk[Perk.perkEffectAndText] [302]);
}

rule: "Perk/Player/Behemoth/getOn"
Event.OngoingPlayer
Team.Team1
if(
    canRideBehemoth &&
    IsButtonHeld(EventPlayer(), Button.Jump)
){
    WaitLongPressConfirm();
    perk[Perk.ridingTarget] = FirstOf(nearCanRideBehemoth);
    AttachPlayers(EventPlayer(), perk[Perk.ridingTarget], Up() * 3.75);
    perk[Perk.ridingTarget].perk[Perk.rider] = EventPlayer();
}

rule: "Perk/Player/Behemoth/getOff"
Event.OngoingPlayer
Team.Team1
if(
    isRidingBehemoth &&
    (
        IsButtonHeld(EventPlayer(), Button.Crouch) ||
        IsDead(EventPlayer())
    )
){
    if(IsButtonHeld(EventPlayer(), Button.Crouch))
        WaitLongPressConfirm();
    DetachPlayers(perk[Perk.ridingTarget].perk[Perk.rider]);
    Teleport(ep, perk[Perk.ridingTarget] + PositionOffset());
    perk[Perk.ridingTarget].perk[Perk.rider] = 0;
    perk[Perk.ridingTarget] = 0;
}

rule: "Perk/Player/Behemoth/getOffBehemothByDead"
Event.OngoingPlayer
Team.Team1
if(
    isRidingBehemoth &&
    IsDead(EventPlayer())
){
    DetachPlayers(perk[Perk.ridingTarget].perk[Perk.rider]);
    Teleport(ep, perk[Perk.ridingTarget] + PositionOffset());
    perk[Perk.ridingTarget].perk[Perk.rider] = 0;
    perk[Perk.ridingTarget] = 0;
}

rule: "Perk/Player/Behemoth/addActivityTime"
Event.OnFinalBlow
Team.Team1
if(
    perk[Perk.ridingTarget].perkType == PerkType.Behemoth &&
    perk[Perk.ridingTarget].perkState  == PerkState.Using &&
    perk[Perk.ridingTarget].perk[Perk.perkTimeLimit]  > 0
){
    SmallMessage(EventPlayer(), "Added 10 seconds of Behemoth's activity time.");
    perk[Perk.ridingTarget].perk[Perk.perkTimeLimit]  += 10;
}

rule: "Perk/Player/Behemoth/addtionalHeal"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Behemoth &&
    perkState  == PerkState.Using &&
    IsUsingAbility2()
){
    // heal
    Heal(EventPlayer(), EventPlayer(), 500);
    WaitUpdateShortCycle();
    LoopIfConditionIsTrue();
}

define splashDamageRangeBehemothBullet: 2.0;

rule: "Perk/Player/Behemoth/splashDamage"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Behemoth &&
    perkState  == PerkState.Using &&
    (
        IsFiringPrimary() ||
        IsFiringSecondary() ||
        IsUsingUltimate()
    )
){
    aimPosition = AimingPositionWithLimit(100);
    define distance! = DistanceBetween(EyePosition(), aimPosition) * 0.1;
    define splashRange! = IsUsingUltimate() ? distance * 3 : distance;
    define pelletCount! = IsUsingUltimate() ? 20 : 10;
    define damage! = IsUsingUltimate() ? 50 : 75;

    if(!IsUsingUltimate())
        Wait(distance * 0.08, WaitBehavior.IgnoreCondition);

    for(pLoopIndex = 0; pLoopIndex < pelletCount; pLoopIndex++){   
        landPosition = RandomPosition(
            splashRange,
            IsUsingUltimate() ? splashRange / 4 : splashRange,
            splashRange);
        // splash damage
        Damage(
            PlayersWithinRadius(
                aimPosition + landPosition,
                splashDamageRangeBehemothBullet,
                Team.Team2, RadiusLOS.Off),
            ep, damage);
        // play blast
        PlayEffect(
            AllPlayers(Team.All), PlayEffect.BadExplosion,
            Color.Orange, aimPosition + landPosition,
            splashDamageRangeBehemothBullet);
        Wait(RandomReal(0, 0.016), WaitBehavior.IgnoreCondition);
    }

    if(IsUsingUltimate()){
        WaitContinuousBlastCycle();
        LoopIfConditionIsTrue();
    }
}

// TAG Annihilator ----------
rule: "Perk/Player/Annihilator/activate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Annihilator &&
    perkState  == PerkState.Using
){
    // set time limit
    perk[Perk.perkTimeLimit] = 150;
    // set param
    perk[Perk.perkEffectStatus] = 0;
    // set perk hero
    PerkHero perkHero = new PerkHero();
    perkHero.hero = Hero.Reaper;
    perkHero.statusUnkillable = true;
    perkHero.maxHealth = 150;
    perkHero.damageDealt = 150;
    perkHero.gravity = 75;
    perkHero.moveSpeed = 150;
    perkHero.jumpSpeed = 125;
    perkHero.ultimateCharge = 100;
    ForcePlayerPerkHero(ep, perkHero);
    Wait(0.5, WaitBehavior.AbortWhenFalse);

    // use ult
    PressButton(ep, Button.Ultimate);
}

rule: "Perk/Player/Annihilator/deactivate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Annihilator &&
    perkState  == PerkState.Non
){
    // reset param
    StopCamera(ep);
    perk[Perk.perkEffectStatus] = 0;
    // reset perk hero
    StopForcingPerkHero(ep);
    // reset type
    perkType = PerkType.Non;
}

rule: "Perk/Player/Annihilator/brokenPerk //by helth 1"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Annihilator &&
    perkState  == PerkState.Using &&
    Health() <= 1
){
    WaitConditionConfirmed();// If the hero changes, the health is determined to be 0. Avoid waiting by adding waits.
    perkState = PerkState.Non;
}

rule: "Perk/Player/Annihilator/startAnnihilate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Annihilator &&
    perkState  == PerkState.Using &&
    IsUsingUltimate()
){
    SetDamageDealt(ep, 400);
    SetMoveSpeed(ep, 400);

    perk[Perk.perkTargets] = 
        SortedArray(
            FilteredArray(
                AllPlayers(Team.Team2), 
                (
                    IsAlive(ArrayElement()) &&
                    IsInLineOfSight(ep, ArrayElement(), BarrierLOS.NoBarriersBlock)
                )
            ),
            Health(ArrayElement())
        );
    // get target with insight and lowest health
    perk[Perk.perkTargets] = FirstOf(perk[Perk.perkTargets]);

    perkPosition = EyePosition();
    if(perk[Perk.perkTargets] != 0){
        // set camera
        StartCamera(ep, perkPosition, EyePosition(), 10);
    }

    perk[Perk.perkEffectStatus] = 0;
}

rule: "Perk/Player/Annihilator/chaseNextTarget"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Annihilator &&
    perkState  == PerkState.Using &&
    IsUsingUltimate()
){
    perk[Perk.perkEffectStatus]  ++;

    perk[Perk.perkTargets] = 
        SortedArray(
            FilteredArray(
                AllPlayers(Team.Team2), 
                (
                    IsAlive(ArrayElement()) &&
                    IsInLineOfSight(ep, ArrayElement(), BarrierLOS.NoBarriersBlock)
                )
            ),
            Health(ArrayElement())
        );
    if(perk[Perk.perkEffectStatus]  <= 22){
        // get target with insight and lowest health for kill more
        perk[Perk.perkTargets] = FirstOf(perk[Perk.perkTargets]);
    }
    else{
        // get target with insight and highst health for deal finish damage
        perk[Perk.perkTargets] = LastOf(perk[Perk.perkTargets]);
    }

    if(perk[Perk.perkTargets] == 0){
        // get target with near random
        perk[Perk.perkTargets] = RandomValueInArray(perk[Perk.perkTargets]);
            RandomValueInArray(
                FilteredArray(
                    AllPlayers(Team.Team2), 
                    (
                        IsAlive(ArrayElement()) &&
                        DistanceBetween(ep, ArrayElement()) <= 10
                    )
                )
            );
    }
    if(perk[Perk.perkTargets] != 0){
        // chase target
        ApplyImpulse(ep,
            VectorTowards(ep, perk[Perk.perkTargets] + Up() + RandomPosition(1, 1, 1)),
            MaxValue(), Relative.ToWorld, ContraryMotion.Cancel);
        // play movement pulse
        PlayEffect(
            AllPlayers(), PlayEffect.BadPickupEffect,
            Color.Red, ep, 1.0);

        // camera too far to player
        if(DistanceBetween(perkPosition, EyePosition()) > 15){
            // camera set to middle point
            perkPosition = (perkPosition + EyePosition()) / 2;
        }
        // camera too close to player
        if(DistanceBetween(perkPosition, EyePosition()) < 5){
            // camera move to backword
            perkPosition = perkPosition + (VectorTowards(perk[Perk.perkTargets], perkPosition) * 2.0);
        }
        // camera blocked by wall
        while(!IsInLineOfSight(perkPosition, EyePosition(), BarrierLOS.NoBarriersBlock)){
            // camera set to middle point
            perkPosition = (perkPosition + EyePosition()) / 2;
        }
        // update camera
        StartCamera(ep, perkPosition, EyePosition(), 10);
    }

    WaitUpdateVeryShortCycle();
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/Annihilator/finishAnnihilate"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Annihilator &&
    perkState  == PerkState.Using &&
    !IsUsingUltimate()
){
    // finish damage
    Damage(
        PlayersWithinRadius(PositionOf(ep), 10, Team.Team2, RadiusLOS.Off ),
        ep, MaxValue()
    );

    SetDamageDealt(ep, 200);
    SetMoveSpeed(ep, 150);
    StopCamera(ep);
    Wait(4, WaitBehavior.AbortWhenFalse);

    perk[Perk.perkEffectStatus] = 0;
}

rule: "Perk/Player/Annihilator/returnGround"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Annihilator &&
    perkState  == PerkState.Using &&
    perk[Perk.perkEffectStatus]  > 0
){
    Wait(0.5, WaitBehavior.AbortWhenFalse);
    if(
        DistanceBetween(
            ep,
            NearestWalkablePosition(ep)
        ) >= 5
    ){
        // return to safe ground
        Teleport(ep, NearestWalkablePosition(ep));
        // play movement pulse
        PlayEffect(
            AllPlayers(), PlayEffect.BadPickupEffect,
            Color.Red, ep, 1.0);
    }
    LoopIfConditionIsTrue();
}

rule: "Perk/Player/Annihilator/chargingUlt"
Event.OngoingPlayer
Team.Team1
if(
    perkType == PerkType.Annihilator &&
    perkState  == PerkState.Using &&
    !IsUsingUltimate() &&
    UltimateChargePercent() < 100
){
    WaitUpdateMediumCycle();
    SetUltimateCharge(ep, (UltimateChargePercent() + 4));
    LoopIfConditionIsTrue();
}

