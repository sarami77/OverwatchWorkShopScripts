import "Debug.del";

// TAG HeroMod ----------
playervar define heroModType;
playervar define heroModName;
playervar define heroModDetail;

enum HeroModType{
    INIT,
    NO_MOD,
    MEDIC,              // [STATUS BUFF]
    HIT_MAN,            // [STATUS BUFF]
    ASSASSIN,           // [STATUS BUFF]
    SPRINTER,           // [STATUS BUFF]
    BIRD_MAN,           // [STATUS BUFF]
    LIGHT_ARMOR,        // [STATUS BUFF]
    HEAVY_ARMOR,        // [STATUS BUFF]
    FIXED_TURRET,       // [STATUS BUFF]
    ADRENALINE_RUSH,    // [STATUS BUFF]
    SURVIVALIST,        // [PASSIVE ABILITY]
    ARTILLERY_SUPPORT,  // [PASSIVE ABILITY] 
    ZOMBIE,             // [PASSIVE ABILITY]
    GUARD_DOG,          // [PASSIVE ABILITY]
    HEALING_SYRINGE,    // [SUPPORT ABILITY]
    SAVIOR,             // [SUPPORT ABILITY]
    POWERFUL_GIFT,      // [SUPPORT ABILITY]
    SANCTUARY,          // [SUPPORT ABILITY]
    TECHNICIAN,         // [ATTACK ABILITY]
    GRUDGE_LIGHTNING,   // [ATTACK ABILITY]
    GRUDGE_FIRE_BALL,   // [ATTACK ABILITY]
    ARTILLERY_REQUEST,  // [ATTACK ABILITY]
    STRAFING_REQUEST,   // [ATTACK ABILITY]
    RAGE,               // [EXTENDED ULT]
    PAYBACK,            // [EXTENDED ULT]
    FAST_CHARGE,        // [EXTENDED ULT]
    SHOT_CALL,          // [EXTENDED ULT]
    SUPER_ULT,          // [EXTENDED ULT]
    TITAN_FORM,         // [TRANSFORM ULT]
    BEAM_SNIPER,        // [TRANSFORM ULT]
    GUNSHIP_GUNNER,     // [TRANSFORM ULT]
    LAST
}

enum HeroModTrigger{
    ACTIVATE,
    DEACTIVATE,
    LONG_PRESS_MELEE_KEY,
    TIME_PASSED,
    STOP,
    MOVING,
    USING_PRIMARY,
    NOT_USING_PRIMARY,
    USING_SECONDARY,
    NOT_USING_SECONDARY,
    USING_ULT,
    NOT_USING_ULT,
    CHARGING_ULT,
    LOST_HEALTH,
    RECEIVE_DAMAGE,
    DEAL_HEAL,
    KILL,
    DEATH,
    TEAMMATE_DEATH
}

playervar define modOpeText;

define HM_AscKey: Button.Melee;
define HM_DisKey: Button.Crouch;

void UpdateHeroModText()"UpdateHeroModText"{
    DestroyHudText(modOpeText[0]);
    DestroyHudText(modOpeText[1]);
    DestroyInWorldText(modOpeText[2]);

    if(CanChangeHeroMod()){
        modOpeText[0] = CreateHudText(ep, null,
            <
                "You can change hero mod anytime.\n\rPress <2>/<3> key while standing still to change mod.\n\r●Your mod = <0> <1>",
                heroModName,
                <"(<0>/<1>)", heroModType - 1, HeroModType.LAST - 2>,
                ButtonGuide(HM_AscKey),
                ButtonGuide(HM_DisKey)
            >,
            null, Location.Left, 101, null, Color.Blue, null, HudTextRev.String, Spectators.DefaultVisibility);
    }
    else{
        modOpeText[0] = CreateHudText(ep, null,
            <
                "You can change hero mod anytime in respawn area.\n\r●Your mod = <0> <1>",
                heroModName,
                <"(<0>/<1>)", heroModType - 1, HeroModType.LAST - 2>
            >,
            null, Location.Left, 101, null, Color.Blue, null, HudTextRev.String, Spectators.DefaultVisibility);
    }

    modOpeText[1] = CreateHudText(ep, null,
        heroModDetail,
        null, Location.Left, 102, null, Color.White, null, HudTextRev.StringAndColor, Spectators.DefaultVisibility);

    modOpeText[2] = CreateInWorldText(AllPlayers(),
        heroModName,
        ep, basicInWorldTextSize, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString, Color.SkyBlue, Spectators.DefaultVisibility);
}

define CanChangeHeroMod():
    !IsDummyBot() &&
    IsInSpawnRoom() &&
    !isTransformed ;

rule: "HeroMod/updateHeroModAllTextOnEnterSpawnRoom"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    CanChangeHeroMod()
){
    UpdateHeroModText();
}

rule: "HeroMod/updateHeroModAllTextOnExitSpawnRoom"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    !CanChangeHeroMod()
){
    UpdateHeroModText();
}

rule: "HeroMod/initSelectHeroMod"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    HasSpawned()
){
    if(
        !IsDummyBot()
    ){
        // player
        // select no mod as player
        heroModType = HeroModType.NO_MOD;
    }
    else{
        // dummy bot
        if(
            !IsSupportHero(HeroOf())
        ){
            // not support hero
            while(
                IsTrueForAny(HealerOnlyMods(), heroModType == ae) ||
                heroModType == 0
            ){
                // select mod from not healer only mod
                heroModType = RandomInteger(HeroModType.INIT + 1, HeroModType.LAST - 1);
                Wait(0.1, WaitBehavior.IgnoreCondition);
            }
        }
        else{
            // support hero
            if(
                IsTrueProbability(75)
            ){
                // select mod from healer recommend mod
                heroModType = RandomValueInArray(HealerRecommendMods());
            }
            else{
                // select mod by random
                heroModType = RandomInteger(HeroModType.INIT + 1, HeroModType.LAST - 1);
            }
        }
    }

    DoHeroModAction(heroModType, HeroModTrigger.ACTIVATE, null);
    UpdateHeroModText();
}

define HealerOnlyMods():
    [
        HeroModType.MEDIC,
        HeroModType.GRUDGE_FIRE_BALL
    ];

define HealerRecommendMods():
    [
        HeroModType.NO_MOD,
        HeroModType.MEDIC,
        HeroModType.MEDIC,
        HeroModType.GRUDGE_FIRE_BALL,
        HeroModType.GUARD_DOG
    ];

rule: "HeroMod/switchSelectHeroMod"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    CanChangeHeroMod() &&
    (
        ( IsButtonHeld(ep, HM_AscKey) && !IsButtonHeld(ep, HM_DisKey) ) ||
        ( !IsButtonHeld(ep, HM_AscKey) && IsButtonHeld(ep, HM_DisKey) )
    )
){
    AbortIf(
        IsMoving() ||
        IsUsingUltimate()
    );
    // do heromod deactivate action
    DoHeroModAction(heroModType, HeroModTrigger.DEACTIVATE, null);
    // switch mod
    heroModType = 
        ( IsButtonHeld(ep, HM_AscKey) && !IsButtonHeld(ep, HM_DisKey) ) ?
            heroModType < HeroModType.LAST - 1 ? heroModType + 1 : HeroModType.INIT + 1 :
            heroModType > HeroModType.INIT + 1 ? heroModType - 1 : HeroModType.LAST - 1 ;
    // do heromod activate action
    DoHeroModAction(heroModType, HeroModTrigger.ACTIVATE, null);
    // update text
    UpdateHeroModText();
    // play switch effect
    PlayEffect(AllPlayers(), PlayEffect.GoodPickupEffect, Color.White, ep, 1);
    PlayEffect(ep, PlayEffect.DebuffImpactSound, null, ep, DefaultPercentage());
}

// TAG HeroMod/Action ----------
void DoHeroModAction(define heromod!, define trigger!, define inputPayload!) playervar "DoHeroModAction"{
    // TAG HeroModTriggerAction
    switch(trigger){
        // TAG TEAMMATE_DEATH
        // give ult charge to player with RAGE
        case HeroModTrigger.TEAMMATE_DEATH:
        define ragePlayers! = FilteredArray(
            AllPlayers(humanTeam),
            (
                ae != ep &&
                IsAlive(ae) &&
                ae.heroModType == HeroModType.RAGE
            )
        );
        for(define index! = 0; index < CountOf(ragePlayers); index++){
            define target! = ragePlayers[index];
            SetUltimateCharge(target, UltimateChargePercent(target) + 50);
        }
        break;
        default:
    }

    // TAG HeroModTypeAction
    switch(heromod){
        case HeroModType.NO_MOD:            HeroMod_Action_NO_MOD(trigger);                             break;
        case HeroModType.MEDIC:             HeroMod_Action_MEDIC(trigger);                              break;
        case HeroModType.HIT_MAN:           HeroMod_Action_HIT_MAN(trigger);                            break;
        case HeroModType.ASSASSIN:          HeroMod_Action_ASSASSIN(trigger);                           break;
        case HeroModType.SPRINTER:          HeroMod_Action_SPRINTER(trigger);                           break;
        case HeroModType.BIRD_MAN:          HeroMod_Action_BIRD_MAN(trigger);                           break;
        case HeroModType.LIGHT_ARMOR:       HeroMod_Action_LIGHT_ARMOR(trigger);                        break;
        case HeroModType.HEAVY_ARMOR:       HeroMod_Action_HEAVY_ARMOR(trigger);                        break;
        case HeroModType.FIXED_TURRET:      HeroMod_Action_FIXED_TURRET(trigger);                       break;
        case HeroModType.ADRENALINE_RUSH:   HeroMod_Action_ADRENALINE_RUSH(trigger);                    break;
        case HeroModType.HEALING_SYRINGE:   HeroMod_Action_HEALING_SYRINGE(trigger);                    break;
        case HeroModType.SAVIOR:            HeroMod_Action_SAVIOR(trigger);                             break;
        case HeroModType.POWERFUL_GIFT:     HeroMod_Action_POWERFUL_GIFT(trigger);                      break;
        case HeroModType.SANCTUARY:         HeroMod_Action_SANCTUARY(trigger);                          break;
        case HeroModType.TECHNICIAN:        HeroMod_Action_TECHNICIAN(trigger);                         break;
        case HeroModType.SURVIVALIST:       HeroMod_Action_SURVIVALIST(trigger);                        break;
        case HeroModType.ARTILLERY_SUPPORT: HeroMod_Action_ARTILLERY_SUPPORT(trigger);                  break;
        case HeroModType.RAGE:              HeroMod_Action_RAGE(trigger);                               break;
        case HeroModType.FAST_CHARGE:       HeroMod_Action_FAST_CHARGE(trigger);                        break;
        case HeroModType.SHOT_CALL:         HeroMod_Action_SHOT_CALL(trigger);                          break;
        case HeroModType.SUPER_ULT:         HeroMod_Action_SUPER_ULT(trigger);                          break;
        case HeroModType.PAYBACK:           HeroMod_Action_PAYBACK(trigger, inputPayload);              break;
        case HeroModType.GRUDGE_LIGHTNING:  HeroMod_Action_GRUDGE_LIGHTNING(trigger, inputPayload);     break;
        case HeroModType.GRUDGE_FIRE_BALL:  HeroMod_Action_GRUDGE_FIRE_BALL(trigger, inputPayload);     break;
        case HeroModType.ARTILLERY_REQUEST: HeroMod_Action_ARTILLERY_REQUEST(trigger);                  break;
        case HeroModType.STRAFING_REQUEST:  HeroMod_Action_STRAFING_REQUEST(trigger);                   break;
        case HeroModType.TITAN_FORM:        HeroMod_Action_TITAN_FORM(trigger);                         break;
        case HeroModType.BEAM_SNIPER:       HeroMod_Action_BEAM_SNIPER(trigger);                        break;
        case HeroModType.GUNSHIP_GUNNER:    HeroMod_Action_GUNSHIP_GUNNER(trigger);                     break;
        case HeroModType.ZOMBIE:            HeroMod_Action_ZOMBIE(trigger);                             break;
        case HeroModType.GUARD_DOG:         HeroMod_Action_GUARD_DOG(trigger);                          break;
        default:
    }
}

// TAG HeroMod/Variable ----------
// TAG GRUDGE_FIRE_BALL & GRUDGE_LIGHTNING
playervar define grudgePower!;    
// TAG TITAN_FORM & BEAM_SNIPER
playervar define isTransformed!;
// TAG BEAM_SNIPER
playervar define beamAimPos!;
playervar define beamCharged!;
// TAG GUARD_DOG
playervar define isDogAttaking!;
playervar define dogEntity!;
playervar define dogPos;
playervar define dogDest!;

// TAG HeroMod/Function ----------
define CanTouchPlayerList():
    (
        IsDummyBot(ep) ?
            AllPlayers(humanTeam) :
            PlayersInViewAngle(ep, humanTeam, 90)
    );

define CanTouchArrayElement():
    DistanceBetween(ep, ae) <= 
        (
            IsDummyBot(ep) ?
                meleeRange * 3 :
                meleeRange * 1.5
        );

// TAG NO_MOD
void HeroMod_Action_NO_MOD(define trigger!) playervar "HeroMod_Action_NO_MOD"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "NO MOD";
        heroModDetail = "[NO MOD CATEGORY]" + NL +
            "no modified" + NL +
            "no pros(+), no cons(-), no detail(*)";
    }
}
// TAG MEDIC
void HeroMod_Action_MEDIC(define trigger!) playervar "HeroMod_Action_MEDIC"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "MEDIC";
        heroModDetail = "[STATUS BUFF]" + NL +
            "+ deal heal 150%" + NL +
            "  * include self healing" + NL +
            "- deal damage 50%";
        SetHealingDealt(ep, 150);
        SetDamageDealt(ep, 50);
    }
    else if(
        trigger == HeroModTrigger.DEACTIVATE
    ){
        SetHealingDealt(ep, DefaultPercentage());
        SetDamageDealt(ep, DefaultPercentage());
    }
}
// TAG HIT_MAN
void HeroMod_Action_HIT_MAN(define trigger!) playervar "HeroMod_Action_HIT_MAN"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "HIT MAN";
        heroModDetail = "[STATUS BUFF]" + NL +
            "+ deal damage 150%" + NL +
            "- receive heal 50%";
        SetDamageDealt(ep, 150);
        SetHealingReceived(ep, 50);
    }
    else if(
        trigger == HeroModTrigger.DEACTIVATE
    ){
        SetDamageDealt(ep, DefaultPercentage());
        SetHealingReceived(ep, DefaultPercentage());
    }

}
// TAG ASSASSIN
void HeroMod_Action_ASSASSIN(define trigger!) playervar "HeroMod_Action_ASSASSIN"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "ASSASSIN";
        heroModDetail = "[STATUS BUFF]" + NL +
            "+ deal damage 125%" + NL +
            "+ move speed 125%" + NL +
            "- max Health 75%";
        SetDamageDealt(ep, 125);
        SetMoveSpeed(ep, 125);
        SetMaxHealth(ep, 75);
    }
    else if(
        trigger == HeroModTrigger.DEACTIVATE
    ){
        SetDamageDealt(ep, DefaultPercentage());
        SetMoveSpeed(ep, DefaultPercentage());
        SetMaxHealth(ep, DefaultPercentage());
    }
}
// TAG SPRINTER
void HeroMod_Action_SPRINTER(define trigger!) playervar "HeroMod_Action_SPRINTER"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "SPRINTER";
        heroModDetail = "[STATUS BUFF]" + NL +
            "+ move speed 150%" + NL +
            "- max health 75%";
        SetMoveSpeed(ep, 150);
        SetMaxHealth(ep, 75);
    }
    else if(
        trigger == HeroModTrigger.DEACTIVATE
    ){
        SetMoveSpeed(ep, DefaultPercentage());
        SetMaxHealth(ep, DefaultPercentage());
    }
}
// TAG BIRD_MAN
void HeroMod_Action_BIRD_MAN(define trigger!) playervar "HeroMod_Action_BIRD_MAN"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "BIRD MAN";
        heroModDetail = "[STATUS BUFF]" + NL +
            "+ gravity 5%" + NL +
            "  * long press melee key in air to dive" + NL +
            "- max health 50%";
        SetGravity(ep, 5);
        SetMaxHealth(ep, 50);
    }
    else if(
        trigger == HeroModTrigger.DEACTIVATE
    ){
        SetGravity(ep, DefaultPercentage());
        SetMaxHealth(ep, DefaultPercentage());
    }
    else if(
        trigger == HeroModTrigger.LONG_PRESS_MELEE_KEY &&
        IsAlive()
    ){
        ApplyImpulse(ep, 
            Down(),
            20, Relative.ToWorld, ContraryMotion.Cancel);
    }
}
// TAG LIGHT_ARMOR
void HeroMod_Action_LIGHT_ARMOR(define trigger!) playervar "HeroMod_Action_LIGHT_ARMOR"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "LIGHT ARMOR";
        heroModDetail = "[STATUS BUFF]" + NL +
            "+ max health 150%" + NL +
            "- move speed 75%" + NL +
            "- receive heal 50%";
        SetMaxHealth(ep, 150);
        SetMoveSpeed(ep, 75);
        SetHealingReceived(ep, 50);
        Heal(ep, null, MaxValue());
    }
    else if(
        trigger == HeroModTrigger.DEACTIVATE
    ){
        SetMaxHealth(ep, DefaultPercentage());
        SetMoveSpeed(ep, DefaultPercentage());
        SetHealingReceived(ep, DefaultPercentage());
    }
}
// TAG HEAVY_ARMOR
void HeroMod_Action_HEAVY_ARMOR(define trigger!) playervar "HeroMod_Action_HEAVY_ARMOR"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "HEAVY ARMOR";
        heroModDetail = "[STATUS BUFF]" + NL +
            "+ max health 300%" + NL +
            "- move speed 50%" + NL +
            "- receive heal 25%";
        SetMaxHealth(ep, 300);
        SetMoveSpeed(ep, 50);
        SetHealingReceived(ep, 25);
        Heal(ep, null, MaxValue());
    }
    else if(
        trigger == HeroModTrigger.DEACTIVATE
    ){
        SetMaxHealth(ep, DefaultPercentage());
        SetMoveSpeed(ep, DefaultPercentage());
        SetHealingReceived(ep, DefaultPercentage());
    }
}
// TAG FIXED_TURRET
void HeroMod_Action_FIXED_TURRET(define trigger!) playervar "HeroMod_Action_FIXED_TURRET"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "FIXED TURRET";
        heroModDetail = "[STATUS BUFF]" + NL +
            "in not moving to..." + NL +
            "  + deal damage 150%" + NL +
            "  + deal heal 150%" + NL +
            "  + max health 200%" + NL +
            "in moving to..." + NL +
            "  - deal damage 50%" + NL +
            "  - deal heal 50%";
    }
    else if(
        trigger == HeroModTrigger.DEACTIVATE
    ){
        SetDamageDealt(ep, DefaultPercentage());
        SetHealingDealt(ep, DefaultPercentage());
        SetMaxHealth(ep, DefaultPercentage());
    }
    else if(
        trigger == HeroModTrigger.TIME_PASSED
    ){
        while(
            IsDummyBot() &&
            IsOnObjective()
        ){
            SetStatus(ep, null, Status.Rooted, 5.5);
            Wait(5, WaitBehavior.AbortWhenFalse);
        }
        Wait(5, WaitBehavior.AbortWhenFalse);
    }
    else if(
        trigger == HeroModTrigger.STOP
    ){
        Wait(0.2, WaitBehavior.AbortWhenFalse);
        SetDamageDealt(ep, 150);
        SetHealingDealt(ep, 150);
        SetMaxHealth(ep, 200);
    }
    else if(
        trigger == HeroModTrigger.MOVING
    ){
        Wait(0.2, WaitBehavior.AbortWhenFalse);
        SetDamageDealt(ep, 50);
        SetHealingDealt(ep, 50);
        SetMaxHealth(ep, DefaultPercentage());
    }
}
// TAG ADRENALINE_RUSH
void HeroMod_Action_ADRENALINE_RUSH(define trigger!) playervar "HeroMod_Action_ADRENALINE_RUSH"{
    if(
        trigger == HeroModTrigger.ACTIVATE ||
        trigger == HeroModTrigger.TIME_PASSED
    ){
        define addValue! = IsAlive() ? ((1 - NormalizedHealth()) * DefaultPercentage()) : 0;
        heroModName = "ADRENALINE RUSH";
        heroModDetail = "[STATUS BUFF]" + NL +
            "more lost health to..." + NL +
            "  + more deal damage (now "+ RoundToInteger((DefaultPercentage() + addValue), Rounding.Nearest) +"% / 200%)" + NL +
            "  + more move speed (now "+ RoundToInteger((DefaultPercentage() + addValue), Rounding.Nearest) +"% / 200%)" + NL +
            "- receive heal 50%";

        if(
            trigger == HeroModTrigger.ACTIVATE
        ){
            SetHealingReceived(ep, 50);
        }
        else if(
            trigger == HeroModTrigger.TIME_PASSED
        ){
            SetDamageDealt(ep, (DefaultPercentage() + addValue));
            SetMoveSpeed(ep, (DefaultPercentage() + addValue));       
            
            Wait(1, WaitBehavior.AbortWhenFalse);
        }
    }
    else if(
        trigger == HeroModTrigger.DEACTIVATE
    ){
        SetHealingReceived(ep, DefaultPercentage());
        SetMaxHealth(ep, DefaultPercentage());
        SetMoveSpeed(ep, DefaultPercentage());
    }
}
// TAG HEALING_SYRINGE
void HeroMod_Action_HEALING_SYRINGE(define trigger!) playervar "HeroMod_Action_HEALING_SYRINGE"{
    define consumeUltCharge! = 20;

    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "HEALING SYRINGE";
        heroModDetail = "[SUPPORT ABILITY]" + NL +
            "long press melee key to..." + NL +
            "  + with near teammate to fully heal teammate" + NL +
            "    * teammate blink white if you can heal" + NL +
            "  + without near teammate to fully heal yourself" + NL +
            "  - lose 20% ult charge";
    }
    else if(
        trigger == HeroModTrigger.TIME_PASSED
    ){
        if(
            !IsDummyBot() &&
            IsAlive() &&
            UltimateChargePercent() >= consumeUltCharge
        ){
            define targets! = FilteredArray(
                AllLivingPlayers(humanTeam),
                (
                    ae != ep &&
                    NormalizedHealth(ae) < 1.0
                )
            );
            for(define index! = 0; index < CountOf(targets); index++){
                // play white effect
                PlayEffect(
                    ep, PlayEffect.GoodPickupEffect,
                    Color.White, targets[index], 1);
            }
        }

        Wait(2, WaitBehavior.AbortWhenFalse);
    }
    else if(
        trigger == HeroModTrigger.LONG_PRESS_MELEE_KEY &&
        IsAlive() &&
        UltimateChargePercent() >= consumeUltCharge
    ){
        define target! = 
            FirstOf(
                SortedArray(
                    FilteredArray(
                        CanTouchPlayerList(),
                        (
                            ae != ep &&
                            CanTouchArrayElement() &&
                            IsAlive(ae) &&
                            (
                                IsDummyBot(ep) ?
                                    NormalizedHealth(ae) < 0.5 :
                                    NormalizedHealth(ae) < 1.0
                            )
                        )
                    ),
                    DistanceBetween(ep, ae)
                )
            );

        if(
            target != null
        ){
            Heal(target, ep, MaxValue());
            SetUltimateCharge(ep, UltimateChargePercent() - consumeUltCharge);

            PlayEffect(AllPlayers(), PlayEffect.GoodPickupEffect, Color.Yellow, target, 1);
            PlayEffect([ep, target], PlayEffect.BuffExplosionSound, null, target, DefaultPercentage());
            
            SmallMessage(ep, "Healed "+ target + HeroIconString(HeroOf(target)));
            SmallMessage(target, "Healed by "+ ep + HeroIconString(HeroOf(ep)));
        }
        else if(NormalizedHealth(ep) < 1.0){
            Heal(ep, ep, 500);
            SetUltimateCharge(ep, UltimateChargePercent() - consumeUltCharge);

            PlayEffect(AllPlayers(), PlayEffect.GoodPickupEffect, Color.Yellow, ep, 1);
            PlayEffect(ep, PlayEffect.BuffExplosionSound, null, ep, DefaultPercentage());
        }
        
    }
}
// TAG SAVIOR
void HeroMod_Action_SAVIOR(define trigger!) playervar "HeroMod_Action_SAVIOR"{
    define consumeUltCharge! = 50;

    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "SAVIOR";
        heroModDetail = "[SUPPORT ABILITY]" + NL +
            "long press melee key to near dead teammate..." + NL +
            "  + revive teammate" + NL +
            "    * teammate blink white if you can revive" + NL +
            "  - lose 50% ult charge";
    }
    else if(
        trigger == HeroModTrigger.TIME_PASSED
    ){
        if(
            !IsDummyBot() &&
            IsAlive() &&
            UltimateChargePercent() >= consumeUltCharge
        ){
            define targets! = FilteredArray(
                AllDeadPlayers(humanTeam),
                (
                    ae != ep
                )
            );
            for(define index! = 0; index < CountOf(targets); index++){
                // play white effect
                PlayEffect(
                    ep, PlayEffect.GoodPickupEffect,
                    Color.White, targets[index], 1);
            }
        }

        Wait(2, WaitBehavior.AbortWhenFalse);
    }
    else if(
        trigger == HeroModTrigger.LONG_PRESS_MELEE_KEY &&
        IsAlive() &&
        UltimateChargePercent() >= consumeUltCharge
    ){
        define target! = 
            FirstOf(
                SortedArray(
                    FilteredArray(
                        CanTouchPlayerList(),
                        (
                            ae != ep &&
                            CanTouchArrayElement() &&
                            IsDead(ae)
                        )
                    ),
                    DistanceBetween(ep, ae)
                )
            );
        
        if(
            target != null
        ){
            Resurrect(target);
            SetUltimateCharge(ep, UltimateChargePercent() - consumeUltCharge);

            PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.Yellow, target, 1.5);
            PlayEffect(AllPlayers(), PlayEffect.GoodPickupEffect, Color.Yellow, target, 1);
            PlayEffect([ep, target], PlayEffect.BuffExplosionSound, null, target, DefaultPercentage());

            SmallMessage(ep, "Revived "+ target + HeroIconString(HeroOf(target)));
            SmallMessage(target, "Revived by "+ ep + HeroIconString(HeroOf(ep)));
        }
    }
}
// TAG POWERFUL_GIFT
void HeroMod_Action_POWERFUL_GIFT(define trigger!) playervar "HeroMod_Action_POWERFUL_GIFT"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "POWERFUL GIFT";
        heroModDetail = "[SUPPORT ABILITY]" + NL +
            "long press melee key to near teammate..." + NL +
            "  - give your ult charge to teammate" + NL +
            "    * teammate blink white if you can give" + NL +
            "  + given ult charge increase to 150%" + NL +
            "    * overflowed ult charge return to yourself";
    }
    else if(
        trigger == HeroModTrigger.TIME_PASSED
    ){
        if(
            !IsDummyBot() &&
            IsAlive() &&
            UltimateChargePercent() > 0
        ){
            define targets! = FilteredArray(
                AllLivingPlayers(humanTeam),
                (
                    ae != ep &&
                    UltimateChargePercent(ae) < DefaultPercentage()
                )
            );
            for(define index! = 0; index < CountOf(targets); index++){
                // play white effect
                PlayEffect(
                    ep, PlayEffect.GoodPickupEffect,
                    Color.White, targets[index], 1);
            }
        }

        Wait(2, WaitBehavior.AbortWhenFalse);
    }
    else if(
        trigger == HeroModTrigger.LONG_PRESS_MELEE_KEY &&
        IsAlive() &&
        UltimateChargePercent() > 0
    ){
        define target! = 
            FirstOf(
                SortedArray(
                    FilteredArray(
                        CanTouchPlayerList(),
                        (
                            ae != ep &&
                            CanTouchArrayElement() &&
                            IsAlive(ae) &&
                            UltimateChargePercent(ae) < DefaultPercentage()
                        )
                    ),
                    DistanceBetween(ep, ae)
                )
            );
        
        if(
            target != null
        ){
            define charge! = UltimateChargePercent() * 1.5;
            define fillableCharge! = DefaultPercentage() - UltimateChargePercent(target);
            define remainCharge! = charge - fillableCharge;
            SetUltimateCharge(target, UltimateChargePercent(target) + charge);
            SetUltimateCharge(ep, remainCharge);

            PlayEffect(AllPlayers(), PlayEffect.GoodPickupEffect, Color.SkyBlue, target, 1);
            PlayEffect([ep, target], PlayEffect.BuffExplosionSound, null, target, DefaultPercentage());

            SmallMessage(ep, "Ult charge given "+ target + HeroIconString(HeroOf(target)));
            SmallMessage(target, "Ult charge given by "+ ep + HeroIconString(HeroOf(ep)));
        }
    }
}
// TAG SANCTUARY
void HeroMod_Action_SANCTUARY(define trigger!) playervar "HeroMod_Action_SANCTUARY"{
    define consumeHealth! = IsDummyBot() ? 50 : 100;

    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "SANCTUARY";
        heroModDetail = "[SUPPORT ABILITY]" + NL +
            "hold melee key..." + NL +
            "  + deploy safe zone and protect you and arround teammate" + NL +
            "    * in safezone players disable any receive damage and knockback" + NL +
            "  - consume your 100 health by every 1 second passed" + NL +
            "    * not die even if consume all health";
    }
    else if(
        trigger == HeroModTrigger.LONG_PRESS_MELEE_KEY &&
        Health() >= consumeHealth
    ){
        define bunkerPos! = BelowPosition(PositionOf());
        define bunkerRange! = 6;
        define bunkerEntity! = [];

        PlayEffect(AllPlayers(), PlayEffect.GoodExplosion, Color.Orange, bunkerPos, 3);
        PlayEffect(AllPlayers(), PlayEffect.BuffExplosionSound, null, bunkerPos, DefaultPercentage());

        DestroyEffect(bunkerEntity[0]);
        DestroyEffect(bunkerEntity[1]);
        DestroyInWorldText(bunkerEntity[2]);
        DestroyIcon(bunkerEntity[3]);

        bunkerEntity[0] = CreateBeamEffect(AllPlayers(), BeamType.BadBeam,
            BodyPosition(ep), bunkerPos + PositionOffset(),
            Color.Orange, EffectRev.VisibleToPositionAndRadius);
        bunkerEntity[1] = CreateEffect(AllPlayers(), Effect.Ring,
            Color.Orange,
            bunkerPos, bunkerRange, EffectRev.PositionAndRadius);
        bunkerEntity[2] = CreateInWorldText(AllPlayers(),
            <"Safe zone here\n\rRemaining <0>%", RoundToInteger(Health() / MaxHealth() * 100, Rounding.Up)>,
            bunkerPos + Vector(0, 1.5, 0), basicInWorldTextSize * 2, Clipping.ClipAgainstSurfaces,
            InworldTextRev.VisibleToPositionAndString, Color.Orange, Spectators.DefaultVisibility);
        bunkerEntity[3] = CreateIcon(AllPlayers(), bunkerPos,
            Icon.ArrowDown, IconRev.PositionAndColor, Color.Orange, true);

        define duaringCount!;
        while(
            IsButtonHeld(ep, Button.Melee) ||
            IsDummyBot()
        ){
            define target! = 
                FilteredArray(
                    AllLivingPlayers(humanTeam),
                    (
                        DistanceBetween(bunkerPos, ae) <= bunkerRange
                    )
                );

            for(define index! = 0; index < CountOf(target); index++){
                PlayEffect(AllPlayers(), PlayEffect.GoodPickupEffect, Color.Orange, target[index], 1);
            }                
            PlayEffect(target, PlayEffect.BuffImpactSound, Color.Orange, bunkerPos, DefaultPercentage());
            SetStatus(target, ep, Status.PhasedOut, 1.5);
            
            if(duaringCount >= 5){
                duaringCount = 0;
                consumeHealth *= 2;
            }
            else{
                duaringCount ++;
            }

            if(
                Health() <= consumeHealth
            ){
                SetPlayerHealth(ep, 1);
                break;
            }
            else{
                SetPlayerHealth(ep, Health() - consumeHealth);
            }

            Wait(1, WaitBehavior.IgnoreCondition);
        }

        DestroyEffect(bunkerEntity[0]);
        DestroyEffect(bunkerEntity[1]);
        DestroyInWorldText(bunkerEntity[2]);
        DestroyIcon(bunkerEntity[3]);
    }
}
// TAG TECHNICIAN
void HeroMod_Action_TECHNICIAN(define trigger!) playervar "HeroMod_Action_TECHNICIAN"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "TECHNICIAN";
        heroModDetail = "[ATTACK ABILITY]" + NL +
            "kill enemy to..." + NL +
            "  + get 150% move speed until 3 seconds" + NL +
            "  + reset cooldown all normal ability" + NL +
            "    * has 3 seconds cooldown to re-trigger" + NL + 
            "- receive heal 50%";
        SetHealingReceived(ep, 50);
    }
    else if(
        trigger == HeroModTrigger.DEACTIVATE
    ){
        SetHealingReceived(ep, DefaultPercentage());
    }
    else if(
        trigger == HeroModTrigger.KILL
    ){
        // set fast status
        SetMoveSpeed(ep, 150);
        Wait(0.1, WaitBehavior.IgnoreCondition);

        define buttonList! = [
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2,
            Button.Jump,
            Button.Crouch
        ];

        // add ability stock
        for(define index! = 0; index < CountOf(buttonList); index++){
            AddAbilityStock(buttonList[index], 1);
        }

        Wait(3, WaitBehavior.IgnoreCondition);

        // reset fast status
        SetMoveSpeed(ep, DefaultPercentage());
    }
}
// TAG SURVIVALIST
void HeroMod_Action_SURVIVALIST(define trigger!) playervar "HeroMod_Action_SURVIVALIST"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "SURVIVALIST";
        heroModDetail = "[PASSIVE ABILITY]" + NL +
            "lost 50% health to..." + NL + 
            "  + get unkillable until 3 seconds" + NL +
            "  + auto use jump and left ability (default shift key)" + NL +
            "  + reset cooldown all normal ability" + NL +
            "    * has 6 seconds cooldown to re-trigger" + NL + 
            "- receive heal 50%";
        SetHealingReceived(ep, 50);
    }
    else if(
        trigger == HeroModTrigger.DEACTIVATE
    ){
        SetHealingReceived(ep, DefaultPercentage());
    }
    else if(
        trigger == HeroModTrigger.LOST_HEALTH
    ){
        // set unkillable status
        SetStatus(ep, ep, Status.Unkillable, 3);

        define buttonList! = [
            Button.SecondaryFire,
            Button.Ability1,
            Button.Ability2,
            Button.Jump,
            Button.Crouch
        ];

        // add ability stock
        for(define index! = 0; index < CountOf(buttonList); index++){
            AddAbilityStock(buttonList[index], 1);
        }

        // use jump abiliry
        PressButton(ep, Button.Jump);
        Wait(0.1, WaitBehavior.IgnoreCondition);
        PressButton(ep, Button.Jump);   
        Wait(0.1, WaitBehavior.IgnoreCondition);

        // use Ability1 abiliry
        if(!IsUsingAbility1()){
            PressButton(ep, Button.Ability1);
        }
        Wait(0.1, WaitBehavior.IgnoreCondition);
        
        // wait ability finish
        if(
            IsUsingAbility1()
        ){
            WaitUntil(!IsUsingAbility1(), 10);
        }

        buttonList = [
            Button.Ability1,
            Button.Jump
        ];

        // add ability stock after auto use
        for(define index! = 0; index < CountOf(buttonList); index++){
            AddAbilityStock(buttonList[index], 1);
        }

        Wait(6, WaitBehavior.IgnoreCondition);
    }

}
// TAG ARTILLERY_SUPPORT
void HeroMod_Action_ARTILLERY_SUPPORT(define trigger!) playervar "HeroMod_Action_ARTILLERY_SUPPORT"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "ARTILLERY SUPPORT";
        heroModDetail = "[PASSIVE ABILITY]" + NL +
            "lost 50% health to..." + NL + 
            "  + incoming artillery and attack nearby enemy for protect you" + NL + 
            "    * has 10 seconds cooldown to re-trigger" + NL + 
            "- receive heal 50%";
        SetHealingReceived(ep, 50);
    }
    else if(
        trigger == HeroModTrigger.DEACTIVATE
    ){
        SetHealingReceived(ep, DefaultPercentage());
    }
    else if(
        trigger == HeroModTrigger.LOST_HEALTH
    ){
        HeroMod_Action_ARTILLERY(ARTILLERY_MODE.SUPPORT);
        Wait(10, WaitBehavior.IgnoreCondition);
    }
}
// TAG RAGE
void HeroMod_Action_RAGE(define trigger!) playervar "HeroMod_Action_RAGE"{
    // RAGE has HeroModTrigger Action TEAMMATE_DEATH
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "RAGE";
        heroModDetail = "[EXTENDED ULT]" + NL +
            "+ at teammate dead in you alive, gain 50% ult charge" + NL +
            "- at yourself dead, lose all ult charge";
    }
    else if(
        trigger == HeroModTrigger.DEATH
    ){
        SetUltimateCharge(ep, 0);
    }
}
// TAG PAYBACK
void HeroMod_Action_PAYBACK(define trigger!, define inputPayload!) playervar "HeroMod_Action_PAYBACK"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "PAYBACK";
        heroModDetail = "[EXTENDED ULT]" + NL +
            "+ receive damage to charge ult charge" + NL +
            "- at dead, lose all ult charge";
    }
    else if(
        trigger == HeroModTrigger.RECEIVE_DAMAGE &&
        DefaultPercentage() > UltimateChargePercent()
    ){
        define gainCharge! = inputPayload * 0.1;
        SetUltimateCharge(ep, UltimateChargePercent() + gainCharge);
    }
    else if(
        trigger == HeroModTrigger.DEATH
    ){
        SetUltimateCharge(ep, 0);
    }
}
// TAG FAST_CHARGE
void HeroMod_Action_FAST_CHARGE(define trigger!) playervar "HeroMod_Action_FAST_CHARGE"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "FAST CHARGE";
        heroModDetail = "[EXTENDED ULT]" + NL +
            "+ every 1 second passed to gain 3% ult charge" + NL +
            "- max health 50%";
        SetMaxHealth(ep, 50);
    }
    else if(
        trigger == HeroModTrigger.DEACTIVATE
    ){
        SetMaxHealth(ep, DefaultPercentage());
    }
    else if(
        trigger == HeroModTrigger.CHARGING_ULT
    ){
        Wait(1, WaitBehavior.AbortWhenFalse);
        if(
            IsGameInProgress() &&
            UltimateChargePercent() < DefaultPercentage()
        ){
            SetUltimateCharge(ep, UltimateChargePercent() + 3);
        }
    }
}
// TAG SHOT_CALL
void HeroMod_Action_SHOT_CALL(define trigger!) playervar "HeroMod_Action_SHOT_CALL"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "SHOT CALL";
        heroModDetail = "[EXTENDED ULT]" + NL +
            "+ use ult to all teammates gain ult full charge" + NL +
            "  * each bot teammate use ult with you for combo attack" + NL +
            "- every 6 seconds passed to lose 1% ult charge";
    }
    else if(
        trigger == HeroModTrigger.CHARGING_ULT
    ){
        Wait(6, WaitBehavior.AbortWhenFalse);
        if(UltimateChargePercent() < DefaultPercentage()){
            SetUltimateCharge(ep, UltimateChargePercent() - 1);
        }
    }
    else if(
        trigger == HeroModTrigger.USING_ULT
    ){
        define msg! = <"[<0><1>]: <2>", ep, HeroIconString(HeroOf()), RandomValueInArray([
            "Let's show them what we've got!",
            "Now's our chance, let's go!",
            "Time to bring the victory!",
            "Charge in!",
            "Smash 'em!"
        ])>;

        // SmallMessage(ep, "gave full ult charge to all teammate");
        BigMessage(ep, msg);

        // play Pickup
        PlayEffect(
            AllPlayers(), PlayEffect.GoodPickupEffect,
            Color.Yellow,
            ep,
            1
        );

        define playerArray! = FilteredArray(
            AllPlayers(humanTeam),
            (
                ae != ep &&
                (
                    ae.heroModType != HeroModType.SHOT_CALL &&
                    ae.heroModType != HeroModType.POWERFUL_GIFT
                )
            )
        );

        // set ult full charge to players of teammate
        for(define index! = 0; index < CountOf(playerArray); index++){
            define target! = playerArray[index];
            SetUltimateCharge(target, DefaultPercentage());

            // SmallMessage(target, "Full ult charge given by "+ ep + HeroIconString(HeroOf()));
            BigMessage(target, msg);

            PlayEffect(target, PlayEffect.BuffExplosionSound, null, target, DefaultPercentage());
        }

        // sync use ult by buddy
        for(define index! = 0; index < CountOf(playerArray); index++){
            define target! = playerArray[index];
            if(
                IsDummyBot(target) &&
                IsTrueProbability(70)
            ){
                // bot use ult bt syc attack
                PressButton(target, Button.Ultimate);
                Wait(0.1, WaitBehavior.AbortWhenFalse);
                if(!IsUsingUltimate(target)){
                    PressButton(target, Button.PrimaryFire);
                }
                // PressButton(player, Button.PrimaryFire);
                Wait(RandomReal(0.1, 0.3), WaitBehavior.AbortWhenFalse);
            }
        }
    }
}
// TAG SUPER_ULT
void HeroMod_Action_SUPER_ULT(define trigger!) playervar "HeroMod_Action_SUPER_ULT"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "SUPER ULT";
        heroModDetail = "[EXTENDED ULT]" + NL +
            "in ult using to..." + NL +
            "  + get invincible" + NL +
            "  + deal damage 300%" + NL +
            "  + deal heal 300%" + NL +
            "  + move speed 200%" + NL +
            "  + gravity 50%" + NL +
            "+ at ult end, gain more ult full charge by 50% probability" + NL +
            "- every 5 seconds passed to lose 1% ult charge";
    }
    else if(
        trigger == HeroModTrigger.DEACTIVATE ||
        trigger == HeroModTrigger.NOT_USING_ULT
    ){
        ClearStatus(ep, Status.PhasedOut);
        SetDamageDealt(ep, DefaultPercentage());
        SetHealingDealt(ep, DefaultPercentage());
        SetMoveSpeed(ep, DefaultPercentage());
        SetGravity(ep, DefaultPercentage());

        if(
            trigger == HeroModTrigger.NOT_USING_ULT &&
            // is ult using started by SUPER_ULT
            isUltUsed
        ){
            // reset ult using started by SUPER_ULT 
            isUltUsed = false;
            if(
                IsTrueProbability(50)
            ){
                SetUltimateCharge(ep, DefaultPercentage());
                PlayEffect(ep, PlayEffect.BuffExplosionSound, null, ep, DefaultPercentage());
                SmallMessage(ep, "gained more ult full charge!");
            }
        }
    }
    else if(
        trigger == HeroModTrigger.CHARGING_ULT
    ){
        Wait(5, WaitBehavior.AbortWhenFalse);
        if(UltimateChargePercent() < DefaultPercentage()){
            SetUltimateCharge(ep, UltimateChargePercent() - 1);
        }
    }
    else if(
        trigger == HeroModTrigger.USING_ULT
    ){
        // set ult using started by SUPER_ULT (for exclude change mod with ult using)
        isUltUsed = true;
        
        SetStatus(ep, null, Status.PhasedOut, MaxValue());
        SetDamageDealt(ep, 300);
        SetHealingDealt(ep, 300);
        SetMoveSpeed(ep, 200);
        SetGravity(ep, 50);
    }
}
// TAG GRUDGE_LIGHTNING
define detail_GRUDGE_LIGHTNING(in define value): 
    "[ATTACK ABILITY]" + NL +
    "+ receive damage to charge grudge power (now "+ value +"% / 100%)" + NL +
    "+ hold melee key to shot grudge power as continuous lightning " + NL +
    "  * more grudge power to more continuous damage and stun" + NL +
    "- receive heal 50%";

void HeroMod_Action_GRUDGE_LIGHTNING(define trigger!, define inputPayload!) playervar "HeroMod_Action_GRUDGE_LIGHTNING"{
    if(
        trigger == HeroModTrigger.ACTIVATE ||
        trigger == HeroModTrigger.TIME_PASSED
    ){
        heroModName = "GRUDGE LIGHTNING";
        heroModDetail = detail_GRUDGE_LIGHTNING(RoundToInteger(grudgePower, Rounding.Nearest));

        if(
            trigger == HeroModTrigger.ACTIVATE
        ){
            SetHealingReceived(ep, 50);
            grudgePower = 0;
        }
        else if(
            trigger == HeroModTrigger.TIME_PASSED
        ){

            Wait(1, WaitBehavior.AbortWhenFalse);
        }
    }
    else if(
        trigger == HeroModTrigger.DEACTIVATE
    ){
        SetHealingReceived(ep, DefaultPercentage());
    }
    else if(
        trigger == HeroModTrigger.RECEIVE_DAMAGE &&
        DefaultPercentage() > grudgePower
    ){
        define gainPower! = inputPayload * 0.1;
        if(grudgePower + gainPower > DefaultPercentage()){
            grudgePower = DefaultPercentage();
        }
        else{
            grudgePower = grudgePower + gainPower;
        }
    }
    else if(
        trigger == HeroModTrigger.LONG_PRESS_MELEE_KEY &&
        IsAlive() &&
        grudgePower > 0
    ){
        if(IsDummyBot()){
            StartHoldingButton(ep, Button.Melee);
        }
        define landPos;
        define aimPos;
        define scatter;
        define targets;
        define case = 0;
        define ballisticEffect! = CreateBeamEffect(AllPlayers(), BeamType.BadBeam,
            EyePosition() + Vector(0, -0.1, 0), landPos,
            Color.SkyBlue, EffectRev.VisibleToPositionAndRadius);
        define sound = CreateEffect(AllPlayers(), Effect.EnergySound, null, ep, DefaultPercentage(), EffectRev.PositionAndRadius);

        while(
            IsAlive() &&
            IsButtonHeld(ep, Button.Melee) &&
            grudgePower > 0
        ){
            if(case == 0){
                define dist! = DistanceBetween(EyePosition(), landPos);
                aimPos = AimingPosition(40, null);
                scatter = dist * 0.04;

                // get inside sight players
                targets = PlayersInViewAngle(ep, EnemyTeamOf(ep), 4);
                // add ryacast hit player
                targets[Last(targets)] = AimingPlayer(40, EnemyTeamOf(ep));
                SetStatus(targets, ep, Status.Stunned, 0.5);
                Damage(targets, ep, 40);

                grudgePower -= 3;
                grudgePower = grudgePower < 0 ? 0 : grudgePower;

                heroModDetail = detail_GRUDGE_LIGHTNING(RoundToInteger(grudgePower, Rounding.Nearest));
            }

            landPos = aimPos + RandomPosition(scatter, scatter, scatter);

            case = case < 10 ? case + 1 : 0;
            Wait(0.01, WaitBehavior.IgnoreCondition);
        }
        DestroyEffect(ballisticEffect);
        DestroyEffect(sound);
    }
}
// TAG GRUDGE_FIRE_BALL
void HeroMod_Action_GRUDGE_FIRE_BALL(define trigger!, define inputPayload!) playervar "HeroMod_Action_GRUDGE_FIRE_BALL"{
    if(
        trigger == HeroModTrigger.ACTIVATE ||
        trigger == HeroModTrigger.TIME_PASSED
    ){
        define currentValue! = RoundToInteger(grudgePower, Rounding.Nearest);
        heroModName = "GRUDGE FIRE BALL";
        heroModDetail = "[ATTACK ABILITY]" + NL +
            "+ heal teammate to charge grudge power (now "+ currentValue +"% / 100%)" + NL +
            "+ long press melee key to shot grudge power as one fire ball" + NL +
            "  * more grudge power to more damage and blast range" + NL +
            "- receive heal 50%";

        if(
            trigger == HeroModTrigger.ACTIVATE
        ){
            SetHealingReceived(ep, 50);
            grudgePower = 0;
        }
        else if(
            trigger == HeroModTrigger.TIME_PASSED
        ){

            Wait(1, WaitBehavior.AbortWhenFalse);
        }
    }
    else if(
        trigger == HeroModTrigger.DEACTIVATE
    ){
        SetHealingReceived(ep, DefaultPercentage());
    }
    else if(
        trigger == HeroModTrigger.DEAL_HEAL &&
        DefaultPercentage() > grudgePower
    ){
        define gainPower! = inputPayload * 0.15;
        if(grudgePower + gainPower > DefaultPercentage()){
            grudgePower = DefaultPercentage();
        }
        else{
            grudgePower = grudgePower + gainPower;
        }
    }
    else if(
        trigger == HeroModTrigger.LONG_PRESS_MELEE_KEY &&
        IsAlive() &&
        grudgePower > 0
    ){
        define power! = grudgePower;
        grudgePower = 0;
        HeroMod_Action_FIRE_BALL(power);
    }
}
// TAG ARTILLERY_REQUEST
void HeroMod_Action_ARTILLERY_REQUEST(define trigger!) playervar "HeroMod_Action_ARTILLERY_REQUEST"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "ARTILLERY REQUEST";
        heroModDetail = "[ATTACK ABILITY]" + NL +
            "+ use ult to request artillery and attack aimming position" + NL +
            "  * change aiming position to change attack position" + NL +
            "- every 8 seconds passed to lose 1% ult charge";
    }
    else if(
        trigger == HeroModTrigger.CHARGING_ULT
    ){
        Wait(8, WaitBehavior.AbortWhenFalse);
        if(UltimateChargePercent() < DefaultPercentage()){
            SetUltimateCharge(ep, UltimateChargePercent() - 1);
        }
    }
    else if(
        trigger == HeroModTrigger.USING_ULT
    ){
        HeroMod_Action_ARTILLERY(ARTILLERY_MODE.REQUEST);
    }
}
// TAG STRAFING_REQUEST
void HeroMod_Action_STRAFING_REQUEST(define trigger!) playervar "HeroMod_Action_STRAFING_REQUEST"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "STRAFING REQUEST";
        heroModDetail = "[ATTACK ABILITY]" + NL +
            "+ use ult to request strafing fire and attack aimming position" + NL +
            "  * attacks wide straight line shape in direction you facing" + NL +
            "- every 8 seconds passed to lose 1% ult charge";
    }
    else if(
        trigger == HeroModTrigger.CHARGING_ULT
    ){
        Wait(8, WaitBehavior.AbortWhenFalse);
        if(UltimateChargePercent() < DefaultPercentage()){
            SetUltimateCharge(ep, UltimateChargePercent() - 1);
        }
    }
    else if(
        trigger == HeroModTrigger.USING_ULT
    ){
        Wait(0.5, WaitBehavior.IgnoreCondition);

        // config value
        define strafReqAttackDistance! = 60;
        define strafReqAttackTime! = 2.5;
        define strafReqAttackInterval = 0.05;
        define strafReqScatterRange! = 8;
        define strafReqDamageRange! = 8;
        define strafReqDamage! = 180;

        // set attack angle base point from aimming position
        define attackPosition! = BelowPosition(AimingPosition(40, null));

        /// set entering angle
        define enteringAngle! = VectorWithOutY(FacingDirectionOf());
        // set start/end position
        define startPosition! = attackPosition + (-enteringAngle * strafReqAttackDistance / 2);
        define endPosition! =   attackPosition + ( enteringAngle * strafReqAttackDistance / 2);
        // move landAreaPosition
        define landAreaPosition = startPosition;
        ChaseVariableOverTime(
            landAreaPosition, endPosition,
            strafReqAttackTime,
            TimeChaseReevaluation.DestinationAndDuration);
        // create ballistic
        define landPosition;
        define ballisticEffect! = CreateBeamEffect(AllPlayers(), BeamType.BadBeam,
            endPosition - (enteringAngle * 200) + (Up() * 200), landPosition,
            Color.White, EffectRev.VisibleToPositionAndRadius);
        // blast animation
        for(define count = strafReqAttackTime / strafReqAttackInterval; count > 0; count --){
            // set landed point
            landPosition =
                landAreaPosition + 
                RandomPosition(
                    strafReqScatterRange,
                    0,
                    strafReqScatterRange
                );
            // play blast sound
            PlayEffect(
                AllPlayers(), PlayEffect.RingExplosionSound,
                Color.White,
                landPosition,
                MaxLength());
            // play blast
            PlayEffect(
                AllPlayers(), PlayEffect.BadExplosion,
                Color.White,
                landPosition,
                strafReqDamageRange);
            // damage
            Damage(
                PlayersWithinRadius(
                    landPosition, strafReqDamageRange,
                    EnemyTeamOf(ep), RadiusLOS.Off
                ),
                ep, strafReqDamage
            );
            Wait(strafReqAttackInterval, WaitBehavior.IgnoreCondition);
        }
        StopChasingVariable(landAreaPosition);
        DestroyEffect(ballisticEffect);

        SetUltimateCharge(ep, 0);
    }
}
// TAG TITAN_FORM
void HeroMod_Action_TITAN_FORM(define trigger!) playervar "HeroMod_Action_TITAN_FORM"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "TITAN FORM";
        heroModDetail = "[TRANSFORM ULT]" + NL +
            "+ use ult to transform to titan and rampage until 25 second" + NL +
            "  * titan has super toughness and wide range hammer attack" + NL +
            "  * titan has fast cooldown abilitys and ult charge" + NL +
            "- every 4 seconds passed to lose 1% ult charge";
    }
    else if(
        trigger == HeroModTrigger.CHARGING_ULT
    ){
        Wait(4, WaitBehavior.AbortWhenFalse);
        if(
            !isTransformed &&
            UltimateChargePercent() < DefaultPercentage()
        ){
            SetUltimateCharge(ep, UltimateChargePercent() - 1);
        }
    }
    else if(
        trigger == HeroModTrigger.USING_ULT &&
        !isTransformed
    ){
        isTransformed = true;

        CancelPrimaryAction();
        define prevHero! = HeroOf();
        ForcePlayerHero(ep, Hero.Reinhardt);
        SetButtonControlPropety();
        SetMaxHealth(ep, 400);
        SetDamageDealt(ep, 250);
        Wait(0.1, WaitBehavior.IgnoreCondition);
        Heal(ep, null, MaxValue());
        SetUltimateCharge(ep, DefaultPercentage());
        PressButton(ep, Button.Ultimate);

        define tianScale! = 2.5;
        for(define scale! = 1; scale < tianScale; scale += 0.1){
            StartScalingPlayer(ep, scale);
            Wait(0.1, WaitBehavior.IgnoreCondition);
        }
        StartModifyingHeroVoiceLines(ep, 0.1, false);

        for(define remainSecond! = 25; remainSecond > 0; remainSecond--){
            if(
                ep == hp &&
                IsGodMode()
            ){
                remainSecond = 25;
                SetUltimateCharge(ep, 100);
            } 

            if(IsDead()){
                break;
            }
            if(UltimateChargePercent() < DefaultPercentage()){
                SetUltimateCharge(ep, UltimateChargePercent() + 20);
            }
            SetAbilityCooldown(ep, Button.Ability1, 0);
            SetAbilityCooldown(ep, Button.Ability2, 0);

            if(
                IsDummyBot() &&
                actionState == ActionState.Attack
            ){
                StartHoldingButton(ep, Button.PrimaryFire);
                StopHoldingButton(ep, Button.SecondaryFire);
                if(IsTrueProbability(50)){
                    PressButton(ep, Button.Jump);
                }
            }

            Wait(1, WaitBehavior.IgnoreCondition);
        }

        StopModifyingHeroVoiceLines(ep);
        for(define scale! = tianScale; scale > 1.0; scale -= 0.1){
            StartScalingPlayer(ep, scale);
            Wait(0.1, WaitBehavior.IgnoreCondition);
        }
        SetUltimateCharge(ep, 0);
        SetMaxHealth(ep, DefaultPercentage());
        SetDamageDealt(ep, DefaultPercentage());
        ForcePlayerHero(ep, prevHero);
        StopForcingHero(ep);
        SetButtonControlPropety();
        // wait using ult fin for not retrigger (if hero not changed by some hero)
        WaitUntil(!IsUsingUltimate(), MaxValue());

        isTransformed = false;
    }
}
// TAG BEAM_SNIPER
void HeroMod_Action_BEAM_SNIPER(define trigger!) playervar "HeroMod_Action_BEAM_SNIPER"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "BEAM SNIPER";
        heroModDetail = "[TRANSFORM ULT]" + NL +
            "+ use ult to transform to beam sniper and rampage until 40 seconds" + NL +
            "  * max charge to shot powerfull beam with penetrate wall and blast" + NL +
            "  * direct shot more deal damage than penetrate shot" + NL +
            "- every 4 seconds passed to lose 1% ult charge";
        beamCharged = false;  // not charging
    }
    else if(
        trigger == HeroModTrigger.CHARGING_ULT
    ){
        Wait(4, WaitBehavior.AbortWhenFalse);
        if(
            !isTransformed &&
            UltimateChargePercent() < DefaultPercentage()
        ){
            SetUltimateCharge(ep, UltimateChargePercent() - 1);
        }
    }
    else if(
        trigger == HeroModTrigger.USING_ULT &&
        !isTransformed
    ){
        isTransformed = true;

        CancelPrimaryAction();
        define prevHero! = HeroOf();
        ForcePlayerHero(ep, Hero.Widowmaker);
        SetButtonControlPropety();
        SetMaxHealth(ep, 200);
        Wait(0.1, WaitBehavior.IgnoreCondition);
        Heal(ep, null, MaxValue());
        SetUltimateCharge(ep, DefaultPercentage());
        PressButton(ep, Button.Ultimate);

        for(define remainSecond! = 40; remainSecond > 0; remainSecond--){
            if(
                ep == hp &&
                IsGodMode()
            ){
                remainSecond = 40;
                beamCharged = true;
                beamAimPos = AimingPosition(MaxLength(), EnemyTeamOf(ep));
                SetUltimateCharge(ep, 100);
            } 

            if(IsDead()){
                break;
            }
            if(UltimateChargePercent() < DefaultPercentage()){
                SetUltimateCharge(ep, UltimateChargePercent() + 5);
            }
            // SetAbilityCooldown(ep, Button.Ability1, 0);
            // SetAbilityCooldown(ep, Button.Ability2, 0);
            Wait(1, WaitBehavior.IgnoreCondition);
        }

        SetUltimateCharge(ep, 0);
        SetMaxHealth(ep, DefaultPercentage());
        ForcePlayerHero(ep, prevHero);
        StopForcingHero(ep);
        SetButtonControlPropety();
        // wait using ult fin for not retrigger (if hero not changed by some hero)
        WaitUntil(!IsUsingUltimate(), MaxValue());

        isTransformed = false;
    }
    else if(
        trigger == HeroModTrigger.USING_SECONDARY &&
        isTransformed
    ){
        while(IsFiringSecondary()){
            // avoid infinite loop
            Wait(0.1, WaitBehavior.AbortWhenFalse);
            // waiting charge fin
            WaitUntil(IsFiringPrimary(), 1.15);
            // primary fire interrupted before charging fin
            if(IsFiringPrimary()){
                // restart waiting
                continue;
            }
            // scorping ended
            else if(!IsFiringSecondary()){
                // clear waiting
                Abort();
            }
            else if(IsFiringSecondary()){
                // charge fin
                beamCharged = true;
                // update aim pos
                while(beamCharged){
                    // pre set aim pos
                    beamAimPos = AimingPosition(MaxLength(), EnemyTeamOf(ep));
                    Wait(
                        IsDummyBot() ? 
                            0.2 :
                            0.1,
                        WaitBehavior.AbortWhenFalse);
                }
            }
        }
    }
    else if(
        trigger == HeroModTrigger.NOT_USING_SECONDARY &&
        isTransformed
    ){
        beamCharged = false;
    }
    else if(
        trigger == HeroModTrigger.USING_PRIMARY &&
        isTransformed
    ){
        define beamSniperDamage! = 300;
        define beamSniperDamageRange! = 4;

        // charging fin
        if(beamCharged){
            // reset charge
            beamCharged = false;

            // deal damage to target at direct hit
            define targets! = AimingPlayer(MaxLength(), EnemyTeamOf(ep));
            Damage(targets, ep, beamSniperDamage);
            // deal damage to target on ballstic
            targets = FilteredArray(
                PlayersInViewAngle(ep, EnemyTeamOf(ep), 2.5),
                IsAlive(ae)
            );
            Damage(targets, ep, beamSniperDamage / 2);
            // deal damage to target in landed blast range
            targets = FilteredArray(
                PlayersWithinRadius(beamAimPos, beamSniperDamageRange, EnemyTeamOf(ep), RadiusLOS.Off),
                IsAlive(ae)
            );
            ApplyBlastImpulse(targets, beamAimPos, beamSniperDamageRange, 3);
            Damage(targets, ep, beamSniperDamage / 2);

            // set offset for gun sight
            define gunSightPos! =
                EyePosition() +
                FacingDirectionOf() +
                Vector(0, IsDummyBot() ? -0.045 : -0.6, 0);
            // set landing position for penetration
            define landPos! =
                EyePosition() +
                (FacingDirectionOf() * MaxLength());

            // play shot sound
            PlayEffect(
                AllPlayers(), PlayEffect.RingExplosionSound,
                Color.Purple, ep, MaxLength());
            // play shot fire
            PlayEffect(
                AllPlayers(), PlayEffect.BadExplosion,
                Color.Purple, gunSightPos, 1.0);

            // show landed ballistics
            define beamEffect! = [];
            beamEffect[0] = CreateBeamEffect(AllPlayers(),
                BeamType.BadBeam, gunSightPos, beamAimPos,
                Color.Purple, EffectRev.VisibleTo);
            // show penetration ballistic
            beamEffect[1] =  CreateBeamEffect(AllPlayers(),
                BeamType.BadBeam, beamAimPos, landPos,
                Color.Purple, EffectRev.VisibleTo);

            // play big blast with sound
            PlayContinuousBlast(
                Color.Purple,
                beamAimPos,
                beamSniperDamageRange,
                3,
                2
            );

            Wait(0.6, WaitBehavior.IgnoreCondition);

            // hide ballistics
            DestroyEffect(beamEffect[0]);
            DestroyEffect(beamEffect[1]);
        }
        else{
            // reset charge
            beamCharged = false;
        }
    }
}
// TAG GUNSHIP_GUNNER
void HeroMod_Action_GUNSHIP_GUNNER(define trigger!) playervar "HeroMod_Action_GUNSHIP_GUNNER"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "GUNSHIP GUNNER";
        heroModDetail = "[TRANSFORM ULT]" + NL +
            "+ use ult to transform to gunship and rampage until 30 seconds" + NL +
            "  * gunship has powerful auto cannon with blast and barrage" + NL +
            "  * press secondary fire key to shot grenade machine gun" + NL +
            "  * long press melee key to shot ult charge as nuke cannon" + NL +
            "  * hold crouch key to descent" + NL +
            "- every 4 seconds passed to lose 1% ult charge";
    }
    else if(
        trigger == HeroModTrigger.CHARGING_ULT
    ){
        Wait(4, WaitBehavior.AbortWhenFalse);
        if(
            !isTransformed &&
            UltimateChargePercent() < DefaultPercentage()
        ){
            SetUltimateCharge(ep, UltimateChargePercent() - 1);
        }
    }
    else if(
        trigger == HeroModTrigger.USING_ULT &&
        !isTransformed
    ){
        isTransformed = true;

        CancelPrimaryAction();
        define prevHero! = HeroOf();
        ForcePlayerHero(ep, Hero.Bastion);
        SetButtonControlPropety();
        SetMaxHealth(ep, 300);
        SetDamageDealt(ep, 200);
        SetGravity(ep, 1);
        PressButton(ep, Button.Jump);
        // SetStatus(ep, null, Status.Rooted, MaxValue());
        Wait(0.1, WaitBehavior.IgnoreCondition);
        Heal(ep, null, MaxValue());
        define tianScale! = 2.5;
        for(define scale! = 1; scale < tianScale; scale += 0.1){
            StartScalingPlayer(ep, scale);
            Wait(0.1, WaitBehavior.IgnoreCondition);
        }
        StartModifyingHeroVoiceLines(ep, 0.1, false);
        // define gunshipSightEnt! = CreateBeamEffect(AllPlayers(),
        //     BeamType.GoodBeam, EyePosition() - PositionOffset(), AimingPosition(ActionRange.CanFind, EnemyTeamOf(ep)),
        //     humanTeamColor, EffectRev.PositionAndRadius);

        for(define remainSecond! = 30; remainSecond > 0; remainSecond--){
            if(
                ep == hp &&
                IsGodMode()
            ){
                remainSecond = 30;
                SetAbilityCooldown(ep, Button.SecondaryFire);
                SetUltimateCharge(ep, 100);
            } 

            if(IsDead()){
                break;
            }

            if(UltimateChargePercent() < DefaultPercentage()){
                SetUltimateCharge(ep, UltimateChargePercent() + 5);
            }

            if(AbilityCooldown(ep, Button.SecondaryFire) > 5){
                SetAbilityCooldown(ep, Button.SecondaryFire, 5);
            }
            
            // shot nuke as ult triggered
            if(IsUsingUltimate()){
                CancelPrimaryAction();
                define aimPos! = PositionOf(
                        FirstOf(
                            SortedArray(
                                FilteredArray(
                                    AllLivingPlayers(EnemyTeamOf(ep)),
                                    // has lien
                                    IsInLineOfSight(ep, ae)
                                ),
                                DistanceBetween(ep, ae)
                            )
                        )
                    );
                if(aimPos == null){
                    aimPos = BelowPosition(ep);
                }
                // auto aim enemy
                StartFacingPosition(aimPos);
                Wait(1.0, WaitBehavior.IgnoreCondition);
                StopFacing(ep);
                SetUltimateCharge(ep, DefaultPercentage());
                HeroMod_Action_NUKE_CANON();
            }

            // change to assult mode
            if(
                !IsInAlternateForm() &&
                !IsFiringSecondary()
            ){
                SetAbilityCooldown(ep, Button.Ability1, 0);
                PressButton(ep, Button.Ability1);
                Wait(0.5, WaitBehavior.IgnoreCondition);
            }
            
            define faceDir! = FacingDirectionOf();
            define dist! = DistanceBetween(ep, BelowPosition(ep));
            define hightLimit! = 16;
            
            // apply impulse
            if(
                (
                    !IsDummyBot() &&
                    // descent buton held
                    IsButtonHeld(ep, Button.Crouch) 
                ) ||
                (
                    // aim downward
                    YOf(faceDir) < 0 &&
                    // is front blocked
                    IsBlockedBetween(
                        EyePosition(),
                        ShiftedPosition(EyePosition(), VectorWithOutY(faceDir), 4)
                    )
                )
            ){
                // down with force
                ApplyImpulse(ep, 
                    Down(),
                    4.0,
                    Relative.ToWorld,
                    ContraryMotion.Incorporate);
            }
            else{
                // get speed by dist to hightLimit
                define speed! = (hightLimit - dist) * 0.3;
                // float impulse
                ApplyImpulse(ep, 
                    dist < hightLimit ?
                        Up() :
                        NoDirection(),
                    dist < hightLimit ?
                        speed:
                        0,
                    Relative.ToWorld,
                    ContraryMotion.Incorporate);
                // facing impulse
                ApplyImpulse(ep, 
                    YOf(faceDir) < 0 ?
                        VectorWithOutY(faceDir) :
                        faceDir,
                    1.0,
                    Relative.ToWorld,
                    ContraryMotion.Incorporate);
            }
        
            Wait(1, WaitBehavior.IgnoreCondition);
        }

        // DestroyEffect(gunshipSightEnt);
        StopModifyingHeroVoiceLines(ep);
        for(define scale! = tianScale; scale > 1.0; scale -= 0.1){
            StartScalingPlayer(ep, scale);
            Wait(0.1, WaitBehavior.IgnoreCondition);
        }
        SetUltimateCharge(ep, 0);
        SetMaxHealth(ep, DefaultPercentage());
        SetDamageDealt(ep, DefaultPercentage());
        SetGravity(ep, DefaultPercentage());
        // ClearStatus(ep, Status.Rooted);
        if(prevHero != Hero.Bastion){
            ForcePlayerHero(ep, prevHero);
        }
        else{
            Resurrect();
        }
        StopForcingHero(ep);
        SetButtonControlPropety();
        // wait using ult fin for not retrigger (if hero not changed by some hero)
        WaitUntil(!IsUsingUltimate(), MaxValue());
        
        isTransformed = false;
    }
    else if(
        trigger == HeroModTrigger.USING_PRIMARY &&
        isTransformed
    ){
        define splashDamageRangeMinigun: 1.5;
        define case = 0;
        define aimPosition;
        define scat;
        define landPosition;
        define targets;

        while(IsFiringPrimary()){
            // get aimPosition
            aimPosition = AimingPosition(40, EnemyTeamOf(ep));
            scat = DistanceBetween(EyePosition(), aimPosition) * 0.04;
            landPosition = aimPosition + RandomPosition(scat, scat, scat);

            if(case == 0){
                // get target
                targets = PlayersWithinRadius(
                    landPosition, splashDamageRangeMinigun,
                    EnemyTeamOf(ep), RadiusLOS.Off);
            }

            // splash damage
            Damage(targets, ep, 30);
            // play blast
            PlayEffect(
                AllPlayers(), PlayEffect.BadExplosion,
                Color.Orange,
                landPosition,
                splashDamageRangeMinigun);

            Wait(
                !IsInAlternateForm() ? 0.2 : 0.1,
                WaitBehavior.IgnoreCondition);
            
            case = case < 2 ? case + 1 : 0;
        }
    }
    else if(
        trigger == HeroModTrigger.USING_SECONDARY &&
        isTransformed
    ){
        for(define remainShot! = 15; remainShot > 0; remainShot--)
        {
            if(
                !isTransformed ||
                IsDead()
            ){
                break;
            }
            PressButton(ep, Button.SecondaryFire);
            CancelPrimaryAction();
            SetAbilityCooldown(ep, Button.SecondaryFire, 0);

            Wait(0.1, WaitBehavior.IgnoreCondition);
        }
    }
    else if(
        trigger == HeroModTrigger.LONG_PRESS_MELEE_KEY &&
        isTransformed &&
        IsAlive() &&
        UltimateChargePercent(ep) > 0
    ){
        HeroMod_Action_NUKE_CANON();
    }
}
// TAG ZOMBIE
void HeroMod_Action_ZOMBIE(define trigger!) playervar "HeroMod_Action_ZOMBIE"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "ZOMBIE";
        heroModDetail = "[PASSIVE ABILITY]" + NL +
            "+ at dead, revive yourself after 5 seconds" + NL +
            "  * in over time is exclude" + NL +
            "  * long press melee key in dead to force return to spawn room" + NL +
            "- max health 50%" + NL +
            "- receive heal 50%";
        SetMaxHealth(ep, 50);
        SetHealingReceived(ep, 50);
    }
    else if(
        trigger == HeroModTrigger.DEACTIVATE
    ){
        SetMaxHealth(ep, DefaultPercentage());
        SetHealingReceived(ep, DefaultPercentage());
    }
    else if(
        trigger == HeroModTrigger.DEATH &&
        !IsOverTime()
    ){
        Wait(5, WaitBehavior.AbortWhenFalse);
        if(IsDeadByAbyss()){
            Teleport(ep, NearestWalkablePosition(ep));
            Wait(0.1, WaitBehavior.AbortWhenFalse);
        }
        SetStatus(ep, null, Status.Invincible, 3);
        Resurrect(ep);
    }
    else if(
        trigger == HeroModTrigger.LONG_PRESS_MELEE_KEY &&
        IsDead()
    ){
        Respawn();
    }
}

// TAG GUARD_DOG
void HeroMod_Action_GUARD_DOG(define trigger!) playervar "HeroMod_Action_GUARD_DOG"{
    if(
        trigger == HeroModTrigger.ACTIVATE
    ){
        heroModName = "GUARD DOG";
        heroModDetail = "[PASSIVE ABILITY]" + NL +
            "+ deploy drone and pattrole arround for guard you" + NL +
            "  * drone stun nearby enemy with little damage" + NL +
            "  * drone notify you danger of close enemy with blink icon" + NL +
            "- receive heal 50%";
        SetHealingReceived(ep, 50);

        isDogAttaking = false;
        dogPos = PositionOf();

        dogEntity = [];
        dogEntity[0] = CreateIcon(ep, dogPos + Vector(0, DistanceBetween(ep, dogPos) * -0.08 , 0),
            Icon.Happy, IconRev.PositionAndColor,
            isDogAttaking ?
                cautionColor :
                Color.Team2, true);
        dogEntity[1] = CreateEffect(AllPlayers(), Effect.Sphere,
            isDogAttaking ?
                Color.Yellow :
                Color.Team2,
            dogPos, 0.2, EffectRev.PositionRadiusAndColor);
    }
    else if(
        trigger == HeroModTrigger.DEACTIVATE
    ){
        SetHealingReceived(ep, DefaultPercentage());
        DestroyIcon(dogEntity[0]);
        DestroyEffect(dogEntity[1]);
        DestroyEffect(dogEntity[2]);
        StopChasingVariable(dogPos);
    }
    else if(
        trigger == HeroModTrigger.TIME_PASSED
    ){
        // config value
        define dogActionInterval! = [0.5, 2.0];
        define dogPatrolRange! = 6;
        define dogAttackRange! = dogPatrolRange * 2;
        define dogRetreatRange! = dogPatrolRange * 3;
        define dogDealDamage! = 25;

        // set action interval by random
        define interval! = RandomReal(dogActionInterval[0], dogActionInterval[1]);

        // start move by interval half
        ChaseVariableOverTime(dogPos, dogDest, interval / 2, TimeChaseReevaluation.DestinationAndDuration);
        Wait(interval / 2, WaitBehavior.IgnoreCondition);

        // find attack target
        define target! = 
            FirstOf(
                SortedArray(
                    FilteredArray(
                        AllLivingPlayers(EnemyTeamOf(ep)),
                        (
                            DistanceBetween(dogPos, ae) <= dogAttackRange
                        )
                    ),
                    DistanceBetween(ep, ae)
                )
            );

        if(
            // has target
            target != null &&
            // not far to event player
            DistanceBetween(ep, target) <= dogRetreatRange
        ){
            isDogAttaking = true;
            // damage and stun target
            SetStatus(target, ep, Status.Stunned, 0.5);
            Damage(target, ep, dogDealDamage);
            // blink beam 
            DestroyEffect(dogEntity[2]);
            dogEntity[2] = CreateBeamEffect(AllPlayers(),
                BeamType.BadBeam, dogPos, BodyPosition(target),
                Color.Yellow, EffectRev.PositionAndRadius);
            Wait(0.2, WaitBehavior.IgnoreCondition);
            DestroyEffect(dogEntity[2]);
            // set dest to target nearby
            dogDest =
                PositionOf(target) +
                RandomPosition(dogPatrolRange, dogPatrolRange / 2, dogPatrolRange) +
                Vector(0, dogPatrolRange / 2, 0);

        }
        else{
            isDogAttaking = false;
            // set dest to event player nearby
            dogDest =
                PositionOf() +
                RandomPosition(dogPatrolRange, dogPatrolRange / 2, dogPatrolRange) +
                Vector(0, dogPatrolRange / 2, 0);
        }

        // wait by interval half
        Wait(interval / 2, WaitBehavior.IgnoreCondition);
    }
}

// TAG HeroMod/SubFunction ----------
enum ARTILLERY_MODE{
    SUPPORT,
    REQUEST
}

// TAG HeroMod_Action_ARTILLERY
void HeroMod_Action_ARTILLERY(define targetMode!) playervar "HeroMod_Action_ARTILLERY" {
    Wait(0.5, WaitBehavior.IgnoreCondition);

    // config value
    define artilleryAttackInterval! = 0.33;
    define attackCount = targetMode == ARTILLERY_MODE.SUPPORT ? 30 : 40;
    define artilleryScatterRange! = targetMode == ARTILLERY_MODE.SUPPORT ? 8.0 : 4.0;
    define artilleryDamageRange! = 6.0;
    define artilleryDamage! = 120;

    // create shell
    define deployPosition = PositionOf(ep) + (VectorWithOutY(RandomDirection()) * 40) + (Up() * 80);
    define landPosition1;
    define landPosition2;
    define shellPosition1;
    define shellPosition2;
    define shellEffect1! = CreateEffect(AllPlayers(), Effect.Orb,
        Color.White,
        shellPosition1,
        1, EffectRev.PositionAndRadius
    );
    define shellEffect2! = CreateEffect(AllPlayers(), Effect.Orb,
        Color.White,
        shellPosition2,
        1, EffectRev.PositionAndRadius
    );
    define isFirstShot! = true;

    // blast animation
    for(define count = attackCount / 2; count > 0; count --){
        // get target by base position
        define basePosition! =
            targetMode == ARTILLERY_MODE.SUPPORT ? PositionOf(ep) : AimingPosition(40, EnemyTeamOf(ep));
        define target! = basePosition;
        
        define attackPosition!;
        if(
            target == null
        ){
            // if not found target, get attack position by base position
            attackPosition = basePosition;
        }
        else{
            // get attack position by target
            attackPosition = BelowPosition(PositionOf(target));
        }

        // land animation1
        // set landed position by attackPosition with random scatter
        landPosition1 =
            attackPosition + 
            RandomPosition(
                artilleryScatterRange,
                0,
                artilleryScatterRange
            );
        // shell land animation
        shellPosition1 = deployPosition;
        ChaseVariableOverTime(
            shellPosition1,
            landPosition1,
            artilleryAttackInterval * 2,
            TimeChaseReevaluation.None
        );
        
        Wait(artilleryAttackInterval, WaitBehavior.IgnoreCondition);

        // first attack
        if(isFirstShot){
            isFirstShot = false;
            // skip blast animation2
        }
        else{
            // blast animation2
            // play blast sound
            PlayEffect(
                AllPlayers(), PlayEffect.RingExplosionSound,
                Color .White,
                landPosition2,
                MaxLength());
            // play blast
            PlayEffect(
                AllPlayers(), PlayEffect.GoodExplosion,
                Color.Orange,
                landPosition2,
                artilleryDamageRange);
            // damage
            Damage(
                PlayersWithinRadius(
                    landPosition2, artilleryDamageRange,
                    EnemyTeamOf(ep), RadiusLOS.Off
                ),
                ep, artilleryDamage
            );
        }

        // land animation2
        // set landed position by attackPosition with random scatter
        landPosition2 =
            attackPosition + 
            RandomPosition(
                artilleryScatterRange,
                0,
                artilleryScatterRange
            );
        // shell land animation
        shellPosition2 = deployPosition;
        ChaseVariableOverTime(
            shellPosition2,
                landPosition2,
                artilleryAttackInterval * 2,
                TimeChaseReevaluation.None
            );

        Wait(artilleryAttackInterval, WaitBehavior.IgnoreCondition);
        
        // blast animation1
        // play blast sound
        PlayEffect(
            AllPlayers(), PlayEffect.RingExplosionSound,
            Color .White,
            landPosition1,
            MaxLength());
        // play blast
        PlayEffect(
            AllPlayers(), PlayEffect.GoodExplosion,
            Color.Orange,
            landPosition1,
            artilleryDamageRange);
        // damage
        Damage(
            PlayersWithinRadius(
                landPosition1, artilleryDamageRange,
                EnemyTeamOf(ep), RadiusLOS.Off
            ),
            ep, artilleryDamage
        );
    }

    Wait(artilleryAttackInterval, WaitBehavior.IgnoreCondition);

    // final blast animation2
    // play blast sound
    PlayEffect(
        AllPlayers(), PlayEffect.RingExplosionSound,
        Color .White,
        landPosition2,
        MaxLength());
    // play blast
    PlayEffect(
        AllPlayers(), PlayEffect.GoodExplosion,
        Color.Orange,
        landPosition2,
        artilleryDamageRange);
    // damage
    Damage(
        PlayersWithinRadius(
            landPosition2, artilleryDamageRange,
            EnemyTeamOf(ep), RadiusLOS.Off
        ),
        ep, artilleryDamage
    ); 

    StopChasingVariable(shellPosition1);
    StopChasingVariable(shellPosition2);
    DestroyEffect(shellEffect1);
    DestroyEffect(shellEffect2);

    if(targetMode == ARTILLERY_MODE.REQUEST){
        SetUltimateCharge(ep, 0);
    }
}

// TAG HeroMod_Action_FIRE_BALL
void HeroMod_Action_FIRE_BALL(define power!) playervar "HeroMod_Action_FIRE_BALL"{
    define ballSpeed! = 30;
    define ballDistance! = 60;
    define ballSize! = power * 0.025;
    define ballDamage! = power * 5;
    define ballBlastRange! = power * 0.15;
    define ballBlastCount! = RoundToInteger(power / 25, Rounding.Down);
    ballBlastCount = ballBlastCount < 1 ? 1 : ballBlastCount;
    define minCollisionSize! = ballSpeed / 20;
    define collisionSize! = ballSize;
    collisionSize = collisionSize < minCollisionSize ? minCollisionSize : collisionSize;

    define ballPos = EyePosition() + Vector(0, -0.1, 0);
    define aimPos! = AimingPosition(ballDistance, null);
    define effects!;
    DestroyEffect(effects);
    effects = CreateEffect(AllPlayers(), Effect.Sphere, Color.Orange,
        ballPos, ballSize, EffectRev.PositionAndRadius);

    ChaseVariableAtRate(
        ballPos, aimPos, ballSpeed,
        RateChaseReevaluation.DestinationAndRate);

    define maxCount! = (ballDistance / ballSpeed) * 10;
    for(define count! = 0; count < maxCount; count++){
        PlayEffect(AllPlayers(), PlayEffect.BadExplosion, Color.Orange, ballPos, ballSize * 1.5);
        define closeEnemy! = ClosestPlayerTo(ballPos, EnemyTeamOf(ep));

        if(
            // hit aimed position
            DistanceBetween(ballPos, aimPos) <= 0 ||
            // hit enemy
            (
                IsAlive(closeEnemy) &&
                DistanceBetween(ballPos, closeEnemy) <= collisionSize
            )
        ){
            break;
        }
        Wait(0.1, WaitBehavior.IgnoreCondition);
    }
    StopChasingVariable(ballPos);
    DestroyEffect(effects);
    
    define targets! = PlayersWithinRadius(ballPos, collisionSize < minCollisionSize ? minCollisionSize : ballBlastRange, EnemyTeamOf(ep), RadiusLOS.Off);
    SetStatus(targets, ep, Status.Burning, 3);
    ApplyBlastImpulse(targets, ballPos, ballBlastRange, 4);
    Damage(targets, ep, ballDamage);
    PlayContinuousBlast(Color.Orange, ballPos, ballBlastRange, ballBlastCount, ballBlastCount);
}

// TAG HeroMod_Action_NUKE_CANON
void HeroMod_Action_NUKE_CANON() playervar "HeroMod_Action_NUKE_CANON"{
    define chargeRate! = UltimateChargePercent() / DefaultPercentage();

    // play blast sound
    PlayEffect(
        AllPlayers(), PlayEffect.RingExplosionSound,
        Color.White,
        ep,
        chargeRate * 200);
    PlayEffect(
        AllPlayers(), PlayEffect.DebuffImpactSound,
        Color.White,
        ep,
        chargeRate * 200);
    // play blast
    PlayEffect(
        AllPlayers(), PlayEffect.GoodExplosion,
        Color.White,
        EyePosition() + (FacingDirectionOf() * 5),
        chargeRate * 10);
    PlayEffect(
        AllPlayers(), PlayEffect.BadExplosion,
        Color.Orange,
        EyePosition() + (FacingDirectionOf() * 5),
        chargeRate * 10);

    ApplyImpulse(
        ep, -1 * FacingDirectionOf(),
        chargeRate * (IsDummyBot() ? 10 : 20),
        Relative.ToWorld, ContraryMotion.Incorporate);           

    define power! = UltimateChargePercent();
    SetUltimateCharge(ep, 0);
    HeroMod_Action_FIRE_BALL(power);
}

// TAG HeroMod/Trigger ----------
playervar define isUltUsed!;

// TAG TIME_PASSED
rule: "HeroModTrigger/TIME_PASSED"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    (
        heroModType == HeroModType.FIXED_TURRET ||
        heroModType == HeroModType.HEALING_SYRINGE ||
        heroModType == HeroModType.SAVIOR ||
        heroModType == HeroModType.POWERFUL_GIFT ||
        heroModType == HeroModType.ADRENALINE_RUSH ||
        heroModType == HeroModType.GRUDGE_FIRE_BALL ||
        heroModType == HeroModType.GRUDGE_LIGHTNING ||
        heroModType == HeroModType.GUARD_DOG
    )
){
    DoHeroModAction(heroModType, HeroModTrigger.TIME_PASSED, null);
    LoopIfConditionIsTrue();
}

// TAG STOP
rule: "HeroModTrigger/STOP"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    (
        heroModType == HeroModType.FIXED_TURRET
    ) &&
    !IsMoving()
){
    DoHeroModAction(heroModType, HeroModTrigger.STOP, null);
}

// TAG MOVING
rule: "HeroModTrigger/MOVING"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    (
        heroModType == HeroModType.FIXED_TURRET
    ) &&
    IsMoving()
){
    DoHeroModAction(heroModType, HeroModTrigger.MOVING, null);
}

// TAG LONG_PRESS_MELEE_KEY
rule: "HeroModTrigger/LONG_PRESS_MELEE_KEY"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    (
        heroModType == HeroModType.BIRD_MAN ||
        heroModType == HeroModType.HEALING_SYRINGE ||
        heroModType == HeroModType.SAVIOR ||
        heroModType == HeroModType.SANCTUARY ||
        heroModType == HeroModType.POWERFUL_GIFT ||
        heroModType == HeroModType.GRUDGE_FIRE_BALL ||
        heroModType == HeroModType.GRUDGE_LIGHTNING ||
        heroModType == HeroModType.GUNSHIP_GUNNER ||
        heroModType == HeroModType.ZOMBIE
    ) &&
    (
        (
            !IsDummyBot() &&
            IsButtonHeld(ep, Button.Melee)
        ) ||
        (
            IsDummyBot()
        )
    )
){
    if(!IsDummyBot()){
        WaitLongPressConfirm();
        DoHeroModAction(heroModType, HeroModTrigger.LONG_PRESS_MELEE_KEY, null);
    }
    else{
        // Bots are determined based on cycles instead of button presses
        define density! = EnemyDensity(aimTarget, ActionRange.Close);
        define prob!;
        if(
            heroModType == HeroModType.SANCTUARY ||
            heroModType == HeroModType.GRUDGE_FIRE_BALL
        ){
            prob = 25 * density;
        }
        else if(
            heroModType == HeroModType.GUNSHIP_GUNNER
        ){
            prob = 50 * density;
        }
        else{
            prob = 25;
        }

        if(IsTrueProbability(prob)){
            DoHeroModAction(heroModType, HeroModTrigger.LONG_PRESS_MELEE_KEY, null);
        }

        Wait(3, WaitBehavior.IgnoreCondition);
        LoopIfConditionIsTrue();
    }
}

// TAG USING_PRIMARY
rule: "HeroModTrigger/USING_PRIMARY"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    (
        heroModType == HeroModType.BEAM_SNIPER ||
        heroModType == HeroModType.GUNSHIP_GUNNER
    ) &&
    IsFiringPrimary()
){
    DoHeroModAction(heroModType, HeroModTrigger.USING_PRIMARY, null);
}

// TAG NOT_USING_PRIMARY
rule: "HeroModTrigger/NOT_USING_PRIMARY"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    (
        heroModType == HeroModType.BEAM_SNIPER
    ) &&
    !IsFiringPrimary()
){
    DoHeroModAction(heroModType, HeroModTrigger.NOT_USING_PRIMARY, null);
}

// TAG USING_SECONDARY
rule: "HeroModTrigger/USING_SECONDARY"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    (
        heroModType == HeroModType.BEAM_SNIPER ||
        heroModType == HeroModType.GUNSHIP_GUNNER
    ) &&
    IsFiringSecondary()
){
    DoHeroModAction(heroModType, HeroModTrigger.USING_SECONDARY, null);
}

// TAG NOT_USING_SECONDARY
rule: "HeroModTrigger/NOT_USING_SECONDARY"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    (
        heroModType == HeroModType.BEAM_SNIPER
    ) &&
    !IsFiringSecondary()
){
    DoHeroModAction(heroModType, HeroModTrigger.NOT_USING_SECONDARY, null);
}

// TAG USING_ULT
rule: "HeroModTrigger/USING_ULT"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    (
        heroModType == HeroModType.SHOT_CALL ||
        heroModType == HeroModType.SUPER_ULT ||
        heroModType == HeroModType.ARTILLERY_REQUEST ||
        heroModType == HeroModType.STRAFING_REQUEST ||
        heroModType == HeroModType.TITAN_FORM ||
        heroModType == HeroModType.BEAM_SNIPER ||
        heroModType == HeroModType.GUNSHIP_GUNNER
    ) &&
    IsUsingUltimate()
){
    if(IsMechCalling(ep)){return;}
    DoHeroModAction(heroModType, HeroModTrigger.USING_ULT, null);
}

// TAG NOT_USING_ULT
rule: "HeroModTrigger/NOT_USING_ULT"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    (
        heroModType == HeroModType.SUPER_ULT
    ) &&
    !IsUsingUltimate()
){
    DoHeroModAction(heroModType, HeroModTrigger.NOT_USING_ULT, null);
}

// TAG CHARGING_ULT
rule: "HeroModTrigger/CHARGING_ULT"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    (
        heroModType == HeroModType.SHOT_CALL ||
        heroModType == HeroModType.FAST_CHARGE ||
        heroModType == HeroModType.SUPER_ULT ||
        heroModType == HeroModType.TITAN_FORM ||
        heroModType == HeroModType.BEAM_SNIPER ||
        heroModType == HeroModType.ARTILLERY_REQUEST ||
        heroModType == HeroModType.STRAFING_REQUEST ||
        heroModType == HeroModType.GUNSHIP_GUNNER
    ) &&
    UltimateChargePercent(ep) < DefaultPercentage()
){
    DoHeroModAction(heroModType, HeroModTrigger.CHARGING_ULT, null);
    LoopIfConditionIsTrue();
}

// TAG LOST_HEALTH
rule: "HeroModTrigger/LOST_HEALTH"
Event.OngoingPlayer
if(
    TeamOf() == humanTeam &&
    (
        heroModType == HeroModType.SURVIVALIST ||
        heroModType == HeroModType.ARTILLERY_SUPPORT
    ) &&
    NormalizedHealth() <= 0.5 &&
    !IsInSpawnRoom()
){
    DoHeroModAction(heroModType, HeroModTrigger.LOST_HEALTH, null);
}

// TAG RECEIVE_DAMAGE
rule: "HeroModTrigger/RECEIVE_DAMAGE"
Event.OnDamageTaken
if(
    TeamOf() == humanTeam &&
    (
        heroModType == HeroModType.PAYBACK ||
        heroModType == HeroModType.GRUDGE_LIGHTNING        
    ) &&
    Attacker() != ep
){
    DoHeroModAction(heroModType, HeroModTrigger.RECEIVE_DAMAGE, EventDamage());
}

// TAG DEAL_HEAL
rule: "HeroModTrigger/DEAL_HEAL"
Event.OnHealingDealt
if(
    TeamOf() == humanTeam &&
    (
        heroModType == HeroModType.GRUDGE_FIRE_BALL
    ) &&
    Healee() != ep
){
    DoHeroModAction(heroModType, HeroModTrigger.DEAL_HEAL, EventHealing());
}

// TAG KILL
rule: "HeroModTrigger/KILL"
Event.OnElimination
if(
    TeamOf() == humanTeam &&
    (
        heroModType == HeroModType.TECHNICIAN
    )
){
    DoHeroModAction(heroModType, HeroModTrigger.KILL, null);
}

// TAG DEATH
rule: "HeroModTrigger/DEATH"
Event.OnDeath
if(
    TeamOf() == humanTeam &&
    (
        heroModType == HeroModType.RAGE ||
        heroModType == HeroModType.PAYBACK ||
        heroModType == HeroModType.ZOMBIE
    )
){
    DoHeroModAction(heroModType, HeroModTrigger.DEATH, null);
}

// TAG TEAMMATE_DEATH
rule: "HeroModTrigger/TEAMMATE_DEATH"
Event.OnDeath
if(
    TeamOf() == humanTeam &&
    ep != Attacker()
){
    DoHeroModAction(heroModType, HeroModTrigger.TEAMMATE_DEATH, null);
}
