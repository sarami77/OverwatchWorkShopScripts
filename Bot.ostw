import "Lib/Utility.ostw";
import "Lib/Debug.ostw";
//import "Lib/PerkCore.ostw";

// Builtin -----------------------------------------------

rule: "Builtin"
Event.OngoingPlayer
if(
    HostPlayer() == EventPlayer() &&
    HasSpawned()
){
    SetDamageDealt(EventPlayer(), 600);
    SetDamageReceived(EventPlayer(), 1);
    SetHealingDealt(EventPlayer(), 100);
    SetHealingReceived(EventPlayer(), 100);
    SetMaxHealth(EventPlayer(), 100);
    SetJumpVerticalSpeed(EventPlayer(), 100);
    SetMoveSpeed(EventPlayer(), 1000);
    SetGravity(EventPlayer(), 7);
    SetProjectileSpeed(EventPlayer(), 100);
    SetProjectileGravity(EventPlayer(), 100);
    StartScalingPlayer(EventPlayer(), 1);
    StartScalingBarriers(EventPlayer(), 1);
    SetUltimateCharge(EventPlayer(), 0);

    define others = FilteredArray(AllPlayers(), ArrayElement() != EventPlayer());
    SetMoveSpeed(others, 1000);

    SetRespawnMaxTime(AllPlayers(Team.Team2), 1);

    // SetStatus(AllPlayers(Team.Team2), null, Status.Rooted, 99999);
    // ForcePlayerHero(EventPlayer(), Hero.Widowmaker);

    // CreateEffect(EventPlayer(), Effect.Ring, Color.White,
    //     EventPlayer(), 10, EffectRev.VisibleToPositionAndRadius);
    // CreateEffect(EventPlayer(), Effect.Ring, Color.White,
    //     EventPlayer(), 20, EffectRev.VisibleToPositionAndRadius);
    // CreateEffect(EventPlayer(), Effect.Ring, Color.White,
    //     EventPlayer(), 30, EffectRev.VisibleToPositionAndRadius);
}

// TAG Enemy/SpawnControl ----------
define spawnHeroList: [
    Hero.Ana,
    Hero.Ashe,
    Hero.Baptiste,
    Hero.Bastion,
    Hero.Brigitte,
    Hero.Doomfist,
    Hero.Dva,
    Hero.Echo,
    Hero.Genji,
    Hero.Hanzo,
    Hero.Junkrat,
    Hero.Lucio,
    Hero.Mccree,
    Hero.Mei,
    Hero.Mercy,
    Hero.Moira,
    Hero.Orisa,
    Hero.Pharah,
    Hero.Reaper,
    Hero.Reinhardt,
    Hero.Roadhog,
    Hero.Sigma,
    Hero.Soldier76,
    Hero.Sombra,
    Hero.Symmetra,
    Hero.Torbjorn,
    Hero.Tracer,
    Hero.Widowmaker,
    Hero.Winston,
    Hero.WreckingBall,
    Hero.Zarya,
    Hero.Zenyatta
];

define heroNameList: [
    "Ana",
    "Ashe",
    "Baptiste",
    "Bastion",
    "Brigitte",
    "Doomfist",
    "Dva",
    "Echo",
    "Genji",
    "Hanzo",
    "Junkrat",
    "Lucio",
    "Mccree",
    "Mei",
    "Mercy",
    "Moira",
    "Orisa",
    "Pharah",
    "Reaper",
    "Reinhardt",
    "Roadhog",
    "Sigma",
    "Soldier76",
    "Sombra",
    "Symmetra",
    "Torbjorn",
    "Tracer",
    "Widowmaker",
    "Winston",
    "WreckingBall",
    "Zarya",
    "Zenyatt"
];

define maxBotNum: 24;
globalvar define isSpawnedBot;
rule: "Enemy/SpawnControl/SpawnAllBot/RemoveAllBot"
Event.OngoingPlayer
if(
    ep == HostPlayer() &&
    IsButtonHeld(ep, Button.Interact)
){
    WaitLongPressConfirm();
    if(isSpawnedBot){
        isSpawnedBot = false;
        dbgMsg("Start Remove All Bot");
        for(define idx = 0; idx < maxBotNum; idx ++){
            DestroyDummyBot(
                Team.Team1, idx);
            Wait(0.01, WaitBehavior.IgnoreCondition);
        }
        for(define idx = 0; idx < maxBotNum; idx ++){
            DestroyDummyBot(
                Team.Team2, idx);
            Wait(0.01, WaitBehavior.RestartWhenTrue);
        }
        dbgMsg("Finish Remove All Bot");
        
    }
    else{
        isSpawnedBot = true;
        dbgMsg("Start Spawn All Bot");
        while(NumberOfPlayers() <= maxBotNum){
            CreateDummyBot(
                IsCrouching() ? RandomValueInArray(spawnHeroList) : spawnHeroList[spawnHero],
                (NumberOfPlayers() % 2 == 0 ? Team.Team1 : Team.Team2),
                NumberOfPlayers(NumberOfPlayers() % 2 == 0 ? Team.Team1 : Team.Team2,),
                AimingPosition(),
                FacingDirectionOf());
            Wait(0.1, WaitBehavior.RestartWhenTrue);
        }
        dbgMsg("Finish Spawn All Bot");
    }    
}

rule: "Enemy/SpawnControl/SpawnOneBot"
Event.OngoingPlayer
if(
    ep == HostPlayer() &&
    intaractDoublePressed &&
    !IsButtonHeld(ep, Button.Jump)
){
    isSpawnedBot = true;
    CreateDummyBot(
        spawnHeroList[spawnHero],
        (NumberOfPlayers() % 2 == 0 ? Team.Team1 : Team.Team2),
        NumberOfPlayers(NumberOfPlayers() % 2 == 0 ? Team.Team1 : Team.Team2,),
        AimingPosition(),
        FacingDirectionOf());
}

globalvar define spawnHero;

rule: "Enemy/SpawnControl/changeBotHero"
Event.OngoingPlayer
if(
    ep == HostPlayer() &&
    intaractDoublePressed &&
    IsButtonHeld(ep, Button.Jump)
){
    spawnHero ++;
    if(spawnHero >= CountOf(spawnHeroList)){
        spawnHero = 0;
    }
    dbgMsg(heroNameList[spawnHero]);
}

// TAG Enemy/Class/AutoBot ----------
class AutoBot{
    public define hero = null;
    public define actionState = null;
    public define combatRange = null;
    public define primaryWeaponButton = null;
    public define primaryButtonBehaivor = null;
    public define primaryWeaponRange = null;
    public define primaryWeaponTarget = null;
    public define secondaryWeaponButton = null;
    public define secondaryButtonBehaivor = null;
    public define secondaryWeaponRange = null;
    public define secondaryWeaponTarget = null;

    public AutoBot(Hero setHero){
        // set hero
        hero = setHero;
        // set combatRange
        switch(setHero){
            case Hero.Reinhardt:
            case Hero.Brigitte:
            combatRange = CombatRange.Melee; 
            break;

            case Hero.Doomfist:
            case Hero.Dva:
            case Hero.Genji:
            case Hero.Mei:
            case Hero.Reaper:
            case Hero.Roadhog:
            case Hero.Sigma:
            case Hero.Winston:
            case Hero.Zarya:
            combatRange = CombatRange.Close; 
            break;

            case Hero.Baptiste:
            case Hero.Bastion:
            case Hero.Echo:
            case Hero.Junkrat:
            case Hero.Lucio:        
            case Hero.Mccree:
            case Hero.Moira:
            case Hero.Orisa:
            case Hero.Pharah:
            case Hero.Soldier76:
            case Hero.Sombra:
            case Hero.Symmetra:
            case Hero.Torbjorn:
            case Hero.Tracer:
            case Hero.WreckingBall:
            case Hero.Zenyatta:
            combatRange = CombatRange.Middle; 
            break;

            case Hero.Ana:
            case Hero.Ashe:
            case Hero.Hanzo:
            case Hero.Mercy:
            case Hero.Widowmaker:
            combatRange = CombatRange.Far; 
            break;

            default:
            break;
        }
        // set primaryWeaponButton
        switch(setHero){
            case Hero.Ana:
            case Hero.Ashe:
            case Hero.Baptiste:
            case Hero.Bastion:
            case Hero.Brigitte:
            case Hero.Doomfist:
            case Hero.Dva:
            case Hero.Echo:
            case Hero.Genji:
            case Hero.Hanzo:
            case Hero.Junkrat:
            case Hero.Lucio:        
            case Hero.Mccree:
            case Hero.Mei:
            case Hero.Mercy:
            case Hero.Orisa:
            case Hero.Pharah:
            case Hero.Reaper:
            case Hero.Reinhardt:
            case Hero.Roadhog:
            case Hero.Sigma:
            case Hero.Soldier76:
            case Hero.Sombra:
            case Hero.Symmetra:
            case Hero.Torbjorn:
            case Hero.Tracer:
            case Hero.Widowmaker:
            case Hero.Winston:
            case Hero.WreckingBall:
            case Hero.Zarya:
            case Hero.Zenyatta:
            primaryWeaponButton = Button.PrimaryFire; 
            break;

            case Hero.Moira:
            primaryWeaponButton = Button.SecondaryFire; 
            break;

            default:
            break;
        }
        // set primaryButtonBehaivor
        switch(setHero){
            case Hero.Baptiste:
            case Hero.Bastion:
            case Hero.Brigitte:
            case Hero.Doomfist:
            case Hero.Dva:
            case Hero.Echo:
            case Hero.Genji:
            case Hero.Junkrat:
            case Hero.Lucio:        
            case Hero.Mccree:
            case Hero.Mei:
            case Hero.Mercy:
            case Hero.Moira:
            case Hero.Orisa:
            case Hero.Pharah:
            case Hero.Reaper:
            case Hero.Reinhardt:
            case Hero.Roadhog:
            case Hero.Sigma:
            case Hero.Soldier76:
            case Hero.Sombra:
            case Hero.Symmetra:
            case Hero.Torbjorn:
            case Hero.Tracer:
            case Hero.Winston:
            case Hero.WreckingBall:
            case Hero.Zarya:
            case Hero.Zenyatta:
            primaryButtonBehaivor = ButtonBehaivor.Hold; 
            
            case Hero.Hanzo:
            primaryButtonBehaivor = ButtonBehaivor.HoldAndRelease; 
            break;
            
            case Hero.Ana:
            case Hero.Ashe:
            case Hero.Widowmaker:
            primaryButtonBehaivor = ButtonBehaivor.ADS; 
            break;

            default:
            break;
        }
        // set primaryWeaponTarget
        switch(setHero){
            case Hero.Ana:
            case Hero.Ashe:
            case Hero.Baptiste:
            case Hero.Bastion:
            case Hero.Brigitte:
            case Hero.Doomfist:
            case Hero.Dva:
            case Hero.Echo:
            case Hero.Genji:
            case Hero.Hanzo:
            case Hero.Junkrat:
            case Hero.Lucio:        
            case Hero.Mccree:
            case Hero.Mei:
            case Hero.Moira:
            case Hero.Orisa:
            case Hero.Pharah:
            case Hero.Reaper:
            case Hero.Reinhardt:
            case Hero.Roadhog:
            case Hero.Sigma:
            case Hero.Soldier76:
            case Hero.Sombra:
            case Hero.Symmetra:
            case Hero.Torbjorn:
            case Hero.Tracer:
            case Hero.Widowmaker:
            case Hero.Winston:
            case Hero.WreckingBall:
            case Hero.Zarya:
            case Hero.Zenyatta:
            primaryWeaponTarget = WeaponTarget.Enemy; 
            break;

            case Hero.Mercy:
            primaryWeaponTarget = WeaponTarget.Friend; 
            break;

            default:
            break;
        }
    }
}


enum State{
    Non,
    Wandering,
    Combat,
    Searching
}

enum CombatRange{
    Non,
    Melee,
    Close,
    Middle,
    Far
}

enum ButtonBehaivor{
    Non,
    Hold,
    HoldAndRelease,
    ADS
}

enum WeaponTarget{
    Non,
    Enemy,
    Friend,
    Both
}

// TAG Enemy/ShowDebugInfo ----------
define showDebugInfo: true;

rule: "Enemy/ShowDebugInfo"
Event.OngoingPlayer
if(
    HasSpawned() &&
    showDebugInfo
){
    // // show status text
    CreateInWorldText(
        HostPlayer(), statusText,
        ep + (Up() * 2), 1, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
        Color.White, Spectators.DefaultVisibility);

    // show status text
    CreateInWorldText(
        HostPlayer(), statusText2,
        ep + (Up() * 1), 1, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
        Color.White, Spectators.DefaultVisibility);

    // // show frontDetector path
    // CreateBeamEffect(
    //     HostPlayer(), BeamType.GoodBeam,
    //     detectorRoot, frontDetector,
    //     Color.White,
    //     EffectRev.VisibleToPositionRadiusAndColor);
    // // show upperDetector path
    // CreateBeamEffect(
    //     HostPlayer(), BeamType.GoodBeam,
    //     detectorRoot, upperDetector,
    //     Color.Blue,
    //     EffectRev.VisibleToPositionRadiusAndColor);
    // // show underDetector path
    // CreateBeamEffect(
    //     HostPlayer(), BeamType.GoodBeam,
    //     frontDetector, underDetector,
    //     Color.Green,
    //     EffectRev.VisibleToPositionRadiusAndColor);

    // // show targetPos path
    // CreateBeamEffect(
    //     HostPlayer(), BeamType.GoodBeam,
    //     EyePosition(), targetPos,
    //     Color.Red,
    //     EffectRev.VisibleToPositionRadiusAndColor);
}

// TAG Enemy/ObjectDetector ----------
playervar define detectorRoot;
playervar define upperDetector;
playervar define frontDetector;
playervar define underDetector;
define upperDetectorLength : 3;
define frontDetectorLength : 6;
define underDetectorLength : 6;

enum DetectedObject{
    None,
    Wall,
    Criff,
    DownStair,
    UpStair
}

Boolean getDetectedObject()"getDetectedObject"{
    DetectedObject detecObj = DetectedObject.None;
    define moveDir = Vector(
        XOf(FacingDirectionOf()),
        0,
        ZOf(FacingDirectionOf())
    );
    moveDir = Normalize(moveDir);
    detectorRoot = EyePosition();
    frontDetector = ShiftedPosition(detectorRoot, moveDir, frontDetectorLength);
    upperDetector = ShiftedPosition(frontDetector, Up(), upperDetectorLength);
    underDetector = ShiftedPosition(frontDetector, Down(), underDetectorLength);
    define isFrontBlocked = IsBlockedBetween(detectorRoot, frontDetector);
    define isUpperBlocked = IsBlockedBetween(detectorRoot, upperDetector);
    define isUnderBlocked = IsBlockedBetween(frontDetector, underDetector);
    if(isFrontBlocked){
        if(isUpperBlocked){
            detecObj = DetectedObject.Wall;
        }
        else{
            detecObj = DetectedObject.UpStair;
        }
    }
    else{
        if(isUnderBlocked){
            detecObj = DetectedObject.DownStair;
        }
        else{
            detecObj = DetectedObject.Criff;
        }
    }
    return detecObj;
}

// TAG Enemy/State/StateControl ----------
playervar define statusText;
playervar define statusText2;
playervar define state;
playervar define tuneDir;
playervar define target;
playervar define watchUpdateRate;

define isStacked:
    SpeedOf() <= 2.0;

define isContactPlayer: 
    IsInLineOfSight(ep, ClosestPlayerTo(ep, OppositeTeamOf(TeamOf()))) &&
    !(
        HeroOf(target) == Hero.Sombra && IsUsingAbility1(target) &&
        DistanceBetween(ep, ClosestPlayerTo(ep, OppositeTeamOf(TeamOf()))) >= 2
    );

rule: "Enemy/State/StateControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    HasSpawned()
){
    if(IsDead()){
        // non by dead
        state = State.Non; 
    }
    else if(isContactPlayer){
        // combat by contact player
        state = State.Combat; 
    }
    else
    {
        if(
            isStacked ||  // stacked
            DistanceBetween(ep, targetPos) < 1  // near targetPos
        ){
            // start wardering by target lost
            state = State.Wandering;    
        }
        else{
            // start searching by target lost
            state = State.Searching;
        }
        
    }

    Wait(1, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

// TAG Enemy/State/Wandering ----------
define StartMove(define dir):
            StartThrottleInDirection(
                ep, dir, 1,
                Relative.ToPlayer,
                ThrottleBehavior.ReplaceExistingThrottle,
                ThrottleRev.DirectionAndMagnitude);

define StopMove(): StopThrottleInDirection();

rule: "Enemy/State/Wandering"
Event.OngoingPlayer
if(
    state == State.Wandering
){
    statusText = <"Wandering">;

    // set initial status
    targetPos = 0;
    StopFacing(ep);
    SetMoveSpeed(ep, 100);

    // action loop
    while(true){
        DetectedObject object = getDetectedObject();
        // blocked by cliff
        if(object == DetectedObject.Criff){
            statusText = <"Wandering/BlockedByCliff">;

            // not set turn direction
            if(tuneDir == 0){
                // set turn direction
                if(RandomInteger(0, 100) <= 50){
                    tuneDir = Right();
                }
                else{
                    tuneDir = Left();
                }
            }
            // set curve to left/right direction
            SetFacing(ep, Forward() + (tuneDir * 1), Relative.ToPlayer);
            // shorten watch update rate
            watchUpdateRate = 0.1;
        }
        // blocked by wall
        else if(object == DetectedObject.Wall){
            statusText = <"Wandering/BlockedByWall">;

            if(tuneDir == 0){
                if(RandomInteger(0, 100) <= 50){
                    tuneDir = Right();
                }
                else{
                    tuneDir = Left();
                }
            }
            SetFacing(ep, Forward() + (tuneDir * 0.25), Relative.ToPlayer);
            watchUpdateRate = 0.1;
        }
        // not blocked
        else{
            statusText = <"Wandering/Walking">;

            tuneDir = 0;    // reset turn direction
            StartMove(Forward());
            watchUpdateRate = 0.5;
        }

        if(isStacked){
            PressButton(ep, Button.Jump);
            Wait(1, WaitBehavior.AbortWhenFalse);
            if(isStacked){
                SetFacing(ep, Backward(), Relative.ToPlayer);
            }
        }

        Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    }
}

playervar define targetPos;
playervar define sideStepDir;
playervar define sideStepKeepSecond;

// TAG Enemy/State/Searching ----------
rule: "Enemy/State/Searching"
Event.OngoingPlayer
if(
    state == State.Searching
){
    statusText = <"Searching">;

    // set initial status
    StopFacing(ep); 
    SetMoveSpeed(ep, 150);

    if(sideStepDir == 0){
        sideStepDir = RandomValueInArray([Right(),Left()]);
    }
    else{
        // set reverse side step for find player
        sideStepDir = -sideStepDir;
    }

    // change combat distance
    DetectedObject object = getDetectedObject();
    define distToTarget = DistanceBetween(ep, target);
    if(object == DetectedObject.Criff){
        moveDir = 0;
        statusText = <"Combat/BlockedByCliff">;
    }

    if(moveDir != 0){
        StartMove(Forward() + sideStepDir);
    }
    else{
        StopMove();
    }

    SetFacing(ep, DirectionTowards(ep, targetPos), Relative.ToWorld);
}

rule: "Enemy/SideStepKeepSecond"
Event.OngoingPlayer
if(
    0 < sideStepKeepSecond
){
    while(true){
        Wait(1, WaitBehavior.AbortWhenFalse);
        sideStepKeepSecond--;
    }
}

// TAG Enemy/State/Combat ----------
playervar define primaryWeaponButton;
playervar define primaryWeaponBehavor;
playervar define combatMinRange;
playervar define combatMaxRange;
playervar define moveDir;

rule: "Enemy/State/Combat"
Event.OngoingPlayer
if(
    state == State.Combat
){
    statusText = <"Combat">;
    SetRespawnMaxTime(ep, 1);

    AutoBot bot = new AutoBot(HeroOf(ep));
    primaryWeaponButton = bot.primaryWeaponButton;
    primaryWeaponBehavor = bot.primaryButtonBehaivor;

    // set initial status
    watchUpdateRate = 0.5;
    moveDir = 0;
    sideStepDir = 0;
    StartFacing(
            ep,
            DirectionTowards(
                EyePosition(),
                target + (Up() * 1.0)),
            MaxValue(),
            Relative.ToWorld, FacingRev.DirectionAndTurnRate
        );   
    SetMoveSpeed(ep, 100);

    // set combat range
    switch(bot.combatRange){
        case CombatRange.Melee:
            combatMinRange = 1;
            combatMaxRange = 3;
            break;
        case CombatRange.Close:
            combatMinRange = 1;
            combatMaxRange = 8;
            break;
        case CombatRange.Middle:
            combatMinRange = 8;
            combatMaxRange = 16;
            break;
        case CombatRange.Far:
            combatMinRange = 16;
            combatMaxRange = 24;
            break;
    }
    
    // action loop
    while(true){
        // set target
        target = ClosestPlayerTo(ep, OppositeTeamOf(TeamOf()));
        targetPos = PositionOf(target);

        // change combat distance
        DetectedObject object = getDetectedObject();
        define distToTarget = DistanceBetween(ep, target);
        if(object == DetectedObject.Criff){
            moveDir = 0;
            statusText = <"Combat/BlockedByCliff">;
        }
        else if(distToTarget > combatMaxRange){
            moveDir = Forward();
            statusText = <"Combat/Forward">;
        }
        else if(distToTarget < combatMinRange){
            moveDir = Backward();
            statusText = <"Combat/Backward">;
        }
        else{
            moveDir = 0;
            statusText = <"Combat/SideStep">;
        }

        // change side step
        if(
            sideStepKeepSecond == 0  || // not keep side step
            isStacked
        ){
            if(RandomInteger(0, 100) <= 50){
                sideStepDir = RandomValueInArray([Right(),Left()]);
                sideStepKeepSecond = RandomInteger(1, 3);
            }
            else{
                sideStepDir = 0;
                sideStepKeepSecond = RandomInteger(1, 3);
            }
        }
        // set move direction
        if(moveDir != 0 && sideStepDir != 0){
            StartMove(moveDir + sideStepDir);
        }
        else if(moveDir == 0 && sideStepDir != 0){
            StartMove(sideStepDir);
        }
        else if(moveDir != 0 && sideStepDir == 0){
            StartMove(moveDir);
        }
        else{
            StopMove();
        }

        Wait(watchUpdateRate, WaitBehavior.AbortWhenFalse);
    }
}

// TAG Enemy/CooldownControl
disabled rule: "Enemy/CooldownControl"
Event.OngoingPlayer
if(
    state == State.Combat
){
    while(true){
        SetAbilityCooldown(ep, Button.Jump, 0);
        SetAbilityCooldown(ep, Button.Crouch, 0);
        SetAbilityCooldown(ep, Button.Ability1, 0);
        SetAbilityCooldown(ep, Button.Ability2, 0);
        SetAbilityCooldown(ep, Button.PrimaryFire, 0);
        SetAbilityCooldown(ep, Button.SecondaryFire, 0);
        SetUltimateCharge(ep, 100);
        Wait(1, WaitBehavior.AbortWhenFalse);
    }
}

// TAG Enemy/ButtonControl
define waitPrimaryFireButton: RandomReal(0, 5);
define holdPrimaryFireButton: RandomReal(0, 5);
define holdPrimaryFireButtonForSniper: RandomReal(1, 2);

define waitSecondaryButton: RandomReal(0, 10);
define holdSecondaryButton: RandomReal(0, 10);

define waitAbilityButton: RandomReal(0, 10);
define holdAbilityButton: RandomReal(0, 1);


define waitUltimateButton: RandomReal(0, 20);
define holdUltimateButton: RandomReal(0, 1);

define waitJumpButton: RandomReal(0, 2);
define holdJumpButton: RandomReal(0, 4);

define waitWeaponChange: RandomReal(0, 30);

void StartButtonControl(define button, define buttonOperation, define waitDuring, define holdDuring){
    

    if(buttonOperation == ButtonBehaivor.Hold){
        if(button == Button.PrimaryFire) statusText2 = <"Hold">;
        StartHoldingButton(ep, button);
    }
    else if(buttonOperation == ButtonBehaivor.HoldAndRelease){
        while(true){
            if(button == Button.PrimaryFire) statusText2 = <"HoldAndRelease/Wait">;
            Wait(waitPrimaryFireButton, WaitBehavior.AbortWhenFalse);
            StartHoldingButton(ep, button);
            if(button == Button.PrimaryFire) statusText2 = <"HoldAndRelease/Hold">;
            Wait(holdPrimaryFireButtonForSniper, WaitBehavior.AbortWhenFalse);
            StopHoldingButton(ep, button);
        }
    }
    else if(buttonOperation == ButtonBehaivor.ADS){
        while(true){
            Wait(waitPrimaryFireButton, WaitBehavior.AbortWhenFalse);
            if(RandomInteger(0, 100) <= 90){
                StopHoldingButton(ep, button);
                StartHoldingButton(ep, Button.SecondaryFire);
                if(button == Button.PrimaryFire) statusText2 = <"ADS/Wait">;
                Wait(holdPrimaryFireButtonForSniper, WaitBehavior.AbortWhenFalse);
                PressButton(ep, button);
            }
            else{
                StopHoldingButton(ep, Button.SecondaryFire);
                StartHoldingButton(ep, button);
                if(button == Button.PrimaryFire) statusText2 = <"ADS/Hold">;
                Wait(holdPrimaryFireButton, WaitBehavior.AbortWhenFalse);
            }
        }
    }
}

rule: "Enemy/ButtonControl/PrimaryFire/StartButtonControl"
Event.OngoingPlayer
if(
    state == State.Combat
){
    StartButtonControl(primaryWeaponButton, primaryWeaponBehavor, waitPrimaryFireButton, holdPrimaryFireButton);
}

rule: "Enemy/ButtonControl/SeconaryFire/StartButtonControl"
Event.OngoingPlayer
if(
    state == State.Combat
){
    StartButtonControl(Button.SecondaryFire, ButtonBehaivor.HoldAndRelease, waitSecondaryButton, holdSecondaryButton);
}

rule: "Enemy/ButtonControl/Ability1/StartButtonControl"
Event.OngoingPlayer
if(
    state == State.Combat
){
    StartButtonControl(Button.Ability1, ButtonBehaivor.HoldAndRelease, waitAbilityButton, holdAbilityButton);
}

rule: "Enemy/ButtonControl/Ability2/StartButtonControl"
Event.OngoingPlayer
if(
    state == State.Combat
){
    StartButtonControl(Button.Ability2, ButtonBehaivor.HoldAndRelease, waitAbilityButton, holdAbilityButton);
}


rule: "Enemy/ButtonControl/Ultimate/StartButtonControl"
Event.OngoingPlayer
if(
    state == State.Combat &&
    UltimateChargePercent() == 100
){
    StartButtonControl(Button.Ultimate, ButtonBehaivor.HoldAndRelease, waitUltimateButton, holdUltimateButton);
}

rule: "Enemy/ButtonControl/Jump/StartButtonControl"
Event.OngoingPlayer
if(
    state == State.Combat
){
    StartButtonControl(Button.Jump, ButtonBehaivor.HoldAndRelease, waitJumpButton, holdJumpButton);
}

rule: "Enemy/ButtonControl/WeaponSwitch/StartButtonControl"
Event.OngoingPlayer
if(
    state == State.Combat
){
    while(true){
        Wait(waitWeaponChange, WaitBehavior.AbortWhenFalse);
        SetWeapon(ep, RandomInteger(0, 2));
    }
}

rule: "Enemy/ButtonControl/StopButtonControl"
Event.OngoingPlayer
if(
    state != State.Combat
){
    StopHoldingButton(ep, Button.PrimaryFire);
    StopHoldingButton(ep, Button.SecondaryFire);
    StopHoldingButton(ep, Button.Ability1);
    StopHoldingButton(ep, Button.Ability2);
    StopHoldingButton(ep, Button.Ultimate);
    StopHoldingButton(ep, Button.Jump);
}

// TAG Enemy/Teleport -----------------------------------------------
playervar define teleportPosition;

disabled rule: "Enemy/Teleport/teleportToPlayerOnRespawn"
Event.OngoingPlayer
Player.All
if(
    IsAlive() &&
    IsInSpawnRoom()
){
    TeleportPositionToPlayer(ClosestPlayerTo(ep, OppositeTeamOf(TeamOf())));
}

disabled rule: "Enemy/Teleport/teleportByNotPlayerFound"
Event.OngoingPlayer
Player.All
if(
    IsAlive() &&
    state != State.Non &&
    state != State.Combat
){
    if(state == State.Searching){
        Wait(10, WaitBehavior.AbortWhenFalse);
    }
    else{
        Wait(5, WaitBehavior.AbortWhenFalse);
    }
    TeleportPositionToPlayer(ClosestPlayerTo(ep, OppositeTeamOf(TeamOf())));
    LoopIfConditionIsTrue();
}

void TeleportPositionToPlayer(define target)"TeleportPositionToPlayer"{
    // set teleport position by blind spot from player
    // find place that will be a blind spot up to 10 times
    for(pLoopIndex = 0; pLoopIndex < 10; pLoopIndex++){
        teleportPosition =
            NearestWalkablePosition(
                target
                    +
                RandomPosition(20, 20, 20)
            ) + Up();
        
        if(
            DistanceBetween(    // Not too close to player
                target, teleportPosition)
            > 5
                    &&
            IsInLineOfSight(   // can line from player 
                target,
                teleportPosition + Up(),
                BarrierLOS.NoBarriersBlock)
                    &&
            !IsInViewAngle(   // not see from player 
                target,
                teleportPosition + Up(),
                90)
        ){
            break;
        }
    }
    Teleport(ep, teleportPosition);
    PlayEffect(
        AllPlayers(Team.All), PlayEffect.BadExplosion,
        Color.Purple, ep, 4);
}

// Debug -----------------------------------------------
define changeTimeInterval: 0.2;
globalvar define tuneVal = 1;
globalvar define consecutiveChangeCount = 0;
define initialTuneUnit : 0.1;
globalvar define tuneUnit = initialTuneUnit;

rule: "showParam"
Event.OngoingGlobal
{
    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "tune Val", tuneVal>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "Server Load", ServerLoad()>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "spawn hero name", heroNameList[spawnHero]>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);      
}

rule: "startIncreaseParam"
Event.OngoingPlayer
if(
    HostPlayer() &&
    (
        IsButtonHeld(EventPlayer(), Button.Interact) &&
        IsButtonHeld(EventPlayer(), Button.Ability2)
    )
){
    tuneVal += tuneUnit;
    Wait(changeTimeInterval, WaitBehavior.AbortWhenFalse);
    changeTuneUnit();
    LoopIfConditionIsTrue();
}

rule: "stopIncreaseParam"
Event.OngoingPlayer
if(
    HostPlayer() &&
    !(
        IsButtonHeld(EventPlayer(), Button.Interact) &&
        IsButtonHeld(EventPlayer(), Button.Ability2)
    )
){
    resetTuneUnit();
}

rule: "startDecreaseParam"
Event.OngoingPlayer
if(
    HostPlayer() &&
    (
        IsButtonHeld(EventPlayer(), Button.Interact) &&
        IsButtonHeld(EventPlayer(), Button.Ability1)
    )
){
    tuneVal -= tuneUnit;
    Wait(changeTimeInterval, WaitBehavior.AbortWhenFalse);
    changeTuneUnit();
    LoopIfConditionIsTrue();
}

rule: "stopDecreaseParam"
Event.OngoingPlayer
if(
    HostPlayer() &&
    !(
        IsButtonHeld(EventPlayer(), Button.Interact) &&
        IsButtonHeld(EventPlayer(), Button.Ability1)
    )
){
    resetTuneUnit();
}

void resetTuneUnit(){
    tuneUnit = initialTuneUnit;
    consecutiveChangeCount= 0;
}

void changeTuneUnit(){
    consecutiveChangeCount ++;
    if(consecutiveChangeCount < 10)
        tuneUnit =  initialTuneUnit * 1;
    else if(consecutiveChangeCount < 20 )
        tuneUnit = initialTuneUnit * 10;
    else
        tuneUnit = initialTuneUnit * 100;
}