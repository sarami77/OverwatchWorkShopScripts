import "Lib/Utility.ostw";
import "Lib/Debug.ostw";
//import "Lib/PerkCore.ostw";

// Builtin -----------------------------------------------

rule: "Builtin/HostOption"
Event.OngoingPlayer
if(
    HostPlayer() == EventPlayer() &&
    HasSpawned()
){
    SetDamageReceived(EventPlayer(), 1);
    SetMoveSpeed(EventPlayer(), 1000);
    SetGravity(EventPlayer(), 10);
    // SetDamageDealt(EventPlayer(), 600);
    // SetHealingDealt(EventPlayer(), 100);
    // SetHealingReceived(EventPlayer(), 100);
    // SetMaxHealth(EventPlayer(), 100);
    // SetJumpVerticalSpeed(EventPlayer(), 100);
    // SetProjectileSpeed(EventPlayer(), 100);
    // SetProjectileGravity(EventPlayer(), 100);
    // StartScalingPlayer(EventPlayer(), 1);
    // StartScalingBarriers(EventPlayer(), 1);
    // SetUltimateCharge(EventPlayer(), 0);
}

rule: "Builtin/ShowOperationHUD"
Event.OngoingGlobal
{
    // show HUD of bot operation
    CreateHudText(AllPlayers(Team.Team1),
        null, <"hold intaract key <0> to spawn/destory all bot.\n\r  with crouch key <1> to random hero.",
            ButtonGuide(Button.Interact), ButtonGuide(Button.Crouch)>, null,
        Location.Left, -2,
        Color.Yellow, Color.Yellow, Color.Yellow,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);
    CreateHudText(AllPlayers(Team.Team1),
        null, <"double press intaract key <0> to spawn one bot.\n\r  with crouch key <1> to random hero.",
            ButtonGuide(Button.Interact), ButtonGuide(Button.Crouch)>, null,
        Location.Left, -2,
        Color.Yellow, Color.Yellow, Color.Yellow,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);
    CreateHudText(AllPlayers(Team.Team1),
        null, <"press intaract key <0> & jump key <1> to change spawn hero.",
            ButtonGuide(Button.Interact), ButtonGuide(Button.Jump)>, null,
        Location.Left, -2,
        Color.Yellow, Color.Yellow, Color.Yellow,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);     
}

rule: "Builtin/AutoResurrectBot"
Event.OngoingPlayer
if(
    HostPlayer() == EventPlayer() &&
    HasSpawned()
){
    while(true){
        SetRespawnMaxTime(AllPlayers(), 5);
        Resurrect(AllDeadPlayers());
        Wait(5, WaitBehavior.AbortWhenFalse);
    }
}

// TAG Enemy/Debug ----------
rule: "Enemy/ShowDebugInfo"
Event.OngoingPlayer
if(
    HasSpawned() &&
    IsDummyBot() &&
    false
){  
    // show status text
    CreateInWorldText(
        HostPlayer(), botInfo[BotInfo.statusText],
        ep + (Up() * 3), 1, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
        Color.White, Spectators.DefaultVisibility);
    // show status2 text
    CreateInWorldText(
        HostPlayer(), botInfo[BotInfo.statusText2],
        ep + (Up() * 2), 1, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
        Color.White, Spectators.DefaultVisibility);

    // show botInfo[BotInfo.frontDetector] path
    CreateBeamEffect(
        ep.botInfo[BotInfo.state] == State.Wandering ? HostPlayer() : null, BeamType.GoodBeam,
        botInfo[BotInfo.detectorRoot], botInfo[BotInfo.frontDetector],
        Color.White,
        EffectRev.VisibleToPositionRadiusAndColor);
    // show botInfo[BotInfo.upperDetector] path
    CreateBeamEffect(
        ep.botInfo[BotInfo.state] == State.Wandering ? HostPlayer() : null, BeamType.GoodBeam,
        botInfo[BotInfo.detectorRoot], botInfo[BotInfo.upperDetector],
        Color.Blue,
        EffectRev.VisibleToPositionRadiusAndColor);
    // show botInfo[BotInfo.underDetector] path
    CreateBeamEffect(
        ep.botInfo[BotInfo.state] == State.Wandering ? HostPlayer() : null, BeamType.GoodBeam,
        botInfo[BotInfo.frontDetector], botInfo[BotInfo.underDetector],
        Color.Green,
        EffectRev.VisibleToPositionRadiusAndColor);

    // show botInfo[BotInfo.targetPos] path
    CreateBeamEffect(
        ep.botInfo[BotInfo.state] == State.Combat || ep.botInfo[BotInfo.state] == State.Searching ? HostPlayer() : null,
        BeamType.GoodBeam,
        EyePosition(), botInfo[BotInfo.targetPos],
        Color.Red,
        EffectRev.VisibleToPositionRadiusAndColor);
    // show botInfo[BotInfo.targetPos]
    CreateEffect(
        ep.botInfo[BotInfo.state] == State.Searching ? HostPlayer() : null,
        Effect.Ring, Color.Red,
        botInfo[BotInfo.targetPos], targetPosRange, EffectRev.VisibleToPositionAndRadius);

    // show stackPos
    CreateEffect(
        ep.botInfo[BotInfo.state] == State.Stacked ? HostPlayer() : null,
        Effect.Ring, Color.White,
        ep.botInfo[BotInfo.stackPos], stackPosRange, EffectRev.VisibleToPositionAndRadius);
}

// TAG Enemy/SpawnControl ----------
define spawnHeroList: [
    Hero.Ana,
    Hero.Ashe,
    Hero.Baptiste,
    Hero.Bastion,
    Hero.Brigitte,
    Hero.Doomfist,
    Hero.Dva,
    Hero.Echo,
    Hero.Genji,
    Hero.Hanzo,
    Hero.Junkrat,
    Hero.Lucio,
    Hero.Mccree,
    Hero.Mei,
    Hero.Mercy,
    Hero.Moira,
    Hero.Orisa,
    Hero.Pharah,
    Hero.Reaper,
    Hero.Reinhardt,
    Hero.Roadhog,
    Hero.Sigma,
    Hero.Soldier76,
    Hero.Sombra,
    Hero.Symmetra,
    Hero.Torbjorn,
    Hero.Tracer,
    Hero.Widowmaker,
    Hero.Winston,
    Hero.WreckingBall,
    Hero.Zarya,
    Hero.Zenyatta
];

define heroNameList: [
    "Ana",
    "Ashe",
    "Baptiste",
    "Bastion",
    "Brigitte",
    "Doomfist",
    "Dva",
    "Echo",
    "Genji",
    "Hanzo",
    "Junkrat",
    "Lucio",
    "Mccree",
    "Mei",
    "Mercy",
    "Moira",
    "Orisa",
    "Pharah",
    "Reaper",
    "Reinhardt",
    "Roadhog",
    "Sigma",
    "Soldier76",
    "Sombra",
    "Symmetra",
    "Torbjorn",
    "Tracer",
    "Widowmaker",
    "Winston",
    "WreckingBall",
    "Zarya",
    "Zenyatta"
];

define maxBotNum: 24;
globalvar define spawnHero = 0;

rule: "Enemy/SpawnControl/changeBotHero"
Event.OngoingPlayer
if(
    ep == HostPlayer() &&
    IsButtonHeld(ep, Button.Jump) &&
    IsButtonHeld(ep, Button.Crouch)
){
    if(true)
        spawnHero ++;
    else
        spawnHero --;

    if(spawnHero >= CountOf(spawnHeroList))
        spawnHero = 0;
    else if(spawnHero < 0)
        spawnHero = CountOf(spawnHeroList) - 1;
}

rule: "Enemy/SpawnControl/CreateOneBot"
Event.OngoingPlayer
if(
    ep == HostPlayer() &&
    intaractDoublePressed
){
    isSpawnedBot = true;
    spawnPos = AimingPosition();
    CreateOneBot(
        spawnPos,
        IsButtonHeld(ep, Button.Crouch) ?
            AllHeroes() :
            spawnHeroList[spawnHero]);
}

globalvar define isSpawnedBot = false;
globalvar define spawnPos = 0;

rule: "Enemy/SpawnControl/CreateAllBotByAsset"
Event.OngoingPlayer
if(
    ep == HostPlayer() &&
    IsButtonHeld(ep, Button.Interact) &&
    !isSpawnedBot
){
    WaitLongPressConfirm();
    isSpawnedBot = true;
    spawnPos = AimingPosition();
    CreateAllBot(
        spawnPos,
        FacingDirectionOf(),
        IsButtonHeld(ep, Button.Crouch) ?
            AllHeroes() :
            spawnHeroList[spawnHero]
    );
}

disabled rule: "Enemy/SpawnControl/CreateAllBot"
Event.OngoingPlayer
if(
    ep == HostPlayer() &&
    IsButtonHeld(ep, Button.Interact) &&
    !isSpawnedBot
){
    WaitLongPressConfirm();
    isSpawnedBot = true;
    spawnPos = AimingPosition();
    CreateAllBot(
        spawnPos,
        FacingDirectionOf(),
        IsButtonHeld(ep, Button.Crouch) ?
            AllHeroes() :
            spawnHeroList[spawnHero]
    );
}

rule: "Enemy/SpawnControl/DestroyAllBot"
Event.OngoingPlayer
if(
    ep == HostPlayer() &&
    IsButtonHeld(ep, Button.Interact) &&
    isSpawnedBot
){
    WaitLongPressConfirm();
    isSpawnedBot = false;
    DestroyAllBot();
}

define teamAsign: NumberOfPlayers() % 2 == 0 ? Team.Team1 : Team.Team2;

void CreateOneBot(define position, define heroList)"CreateOneBot"{
    CreateDummyBot(
        RandomValueInArray(heroList),
        teamAsign,
        NumberOfPlayers(teamAsign),
        position,
        FacingDirectionOf());
}

define tryLimit: 200;
void CreateAllBot(define position, define direction, define heroList)"CreateAllBot"{
    dbgMsg("Start Create All Bot");
    define tryCount = 0;
    while(
        NumberOfPlayers() < maxBotNum &&
        tryCount < tryLimit &&
        isSpawnedBot
    ){
        CreateDummyBot(
            RandomValueInArray(heroList),
            teamAsign,
            NumberOfPlayers(teamAsign),
            position,
            direction);
        tryCount ++;
        if(ServerLoad() >= 200)
            Wait(0.5);
        else
            Wait(0.1);
    }
    if(tryCount >= tryLimit){
        dbgMsg("Cancel Create All Bot By Try Limit");
    }
    else{
        dbgMsg("Finish Create All Bot");
    }
}

void DestroyAllBot()"DestroyAllBot"{
    dbgMsg("Start Destroy All Bot");
    for(define idx = 0; idx < maxBotNum; idx ++){
        DestroyDummyBot(
            Team.Team1, idx);
        if(ServerLoad() >= 200)
            Wait(0.05);
        else
            Wait(0.01);
    }
    for(define idx = 0; idx < maxBotNum; idx ++){
        DestroyDummyBot(
            Team.Team2, idx);
        if(ServerLoad() >= 200)
            Wait(0.05);
        else
            Wait(0.01);
    }
    dbgMsg("Finish Destroy All Bot"); 
}


// TAG Enemy/SetBotInfo ----------
playervar define botInfo = [];
enum BotInfo{
    heroName,
    combatRange,
    combatRangeMin,
    combatRangeMax,
    primaryFireButtonBehaivor,
    primaryFireButtonWaitMin,
    primaryFireButtonWaitMax,
    primaryFireButtonHoldMin,
    primaryFireButtonHoldMax,
    secondaryFireButtonBehaivor,
    secondaryFireButtonWaitMin,
    secondaryFireButtonWaitMax,
    secondaryFireButtonHoldMin,
    secondaryFireButtonHoldMax,
    ability1ButtonWaitMin,
    ability1ButtonWaitMax,
    ability1ButtonHoldMin,
    ability1ButtonHoldMax,
    ability2ButtonWaitMin,
    ability2ButtonWaitMax,
    ability2ButtonHoldMin,
    ability2ButtonHoldMax,
    detectorRoot,
    upperDetector,
    frontDetector,
    underDetector,
    statusText,
    statusText2,
    state,
    tuneDir,
    target,
    targetPos,
    stackPos,
    watchUpdateRate
}

define targetPosRange: 8;
define stackPosRange: 2;

rule: "Enemy/SetBotInfo"
Event.OngoingPlayer
if(
    HasSpawned() &&
    IsDummyBot()
){
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        botInfo[BotInfo.primaryFireButtonBehaivor] = ButtonBehaivor.HoldOnly;
        botInfo[BotInfo.primaryFireButtonWaitMin] = 0;
        botInfo[BotInfo.primaryFireButtonWaitMax] = 10;
        botInfo[BotInfo.primaryFireButtonHoldMin] = 0;
        botInfo[BotInfo.primaryFireButtonHoldMax] = 10;

        botInfo[BotInfo.secondaryFireButtonBehaivor] = ButtonBehaivor.HoldAndRelease;
        botInfo[BotInfo.secondaryFireButtonWaitMin] = 0;
        botInfo[BotInfo.secondaryFireButtonWaitMax] = 10;
        botInfo[BotInfo.secondaryFireButtonHoldMin] = 0;
        botInfo[BotInfo.secondaryFireButtonHoldMax] = 10;

        botInfo[BotInfo.ability1ButtonWaitMin] = 0;
        botInfo[BotInfo.ability1ButtonWaitMax] = 10;
        botInfo[BotInfo.ability1ButtonHoldMin] = 0;
        botInfo[BotInfo.ability1ButtonHoldMax] = 1;

        botInfo[BotInfo.ability2ButtonWaitMin] = 0;
        botInfo[BotInfo.ability2ButtonWaitMax] = 10;
        botInfo[BotInfo.ability2ButtonHoldMin] = 0;
        botInfo[BotInfo.ability2ButtonHoldMax] = 1;

    switch(HeroOf()){
        case Hero.Ana:
        botInfo[BotInfo.heroName] = "Ana";
        botInfo[BotInfo.combatRange] = CombatRange.Far;
        botInfo[BotInfo.primaryFireButtonBehaivor] = ButtonBehaivor.HoldOnly;
        botInfo[BotInfo.secondaryFireButtonBehaivor] = ButtonBehaivor.HoldAndRelease;
        botInfo[BotInfo.secondaryFireButtonWaitMin] = 0;
        botInfo[BotInfo.secondaryFireButtonWaitMax] = 10;
        botInfo[BotInfo.secondaryFireButtonHoldMin] = 10;
        botInfo[BotInfo.secondaryFireButtonHoldMax] = 10;
        break;

        case Hero.Ashe:
        botInfo[BotInfo.heroName] = "Ashe";
        botInfo[BotInfo.combatRange] = CombatRange.Far;
        botInfo[BotInfo.primaryFireButtonBehaivor] = ButtonBehaivor.Repeat;
        botInfo[BotInfo.secondaryFireButtonBehaivor] = ButtonBehaivor.HoldAndRelease;
        botInfo[BotInfo.secondaryFireButtonWaitMin] = 0;
        botInfo[BotInfo.secondaryFireButtonWaitMax] = 10;
        botInfo[BotInfo.secondaryFireButtonHoldMin] = 10;
        botInfo[BotInfo.secondaryFireButtonHoldMax] = 10;
        break;

        case Hero.Baptiste:
        botInfo[BotInfo.heroName] = "Baptiste";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        break;

        case Hero.Bastion:
        botInfo[BotInfo.heroName] = "Bastion";
        botInfo[BotInfo.combatRange] = CombatRange.Far;
        break;

        case Hero.Brigitte:
        botInfo[BotInfo.heroName] = "Brigitte";
        botInfo[BotInfo.combatRange] = CombatRange.Melee;
        break;

        case Hero.Doomfist:
        botInfo[BotInfo.heroName] = "Doomfist";
        botInfo[BotInfo.combatRange] = CombatRange.Close;
        break;

        case Hero.Dva:
        botInfo[BotInfo.heroName] = "Doomfist";
        botInfo[BotInfo.combatRange] = CombatRange.Close;
        break;

        case Hero.Echo:
        botInfo[BotInfo.heroName] = "Echo";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        break;

        case Hero.Genji:
        botInfo[BotInfo.heroName] = "Genji";
        botInfo[BotInfo.combatRange] = CombatRange.Close;
        break;

        case Hero.Hanzo:
        botInfo[BotInfo.heroName] = "Hanzo";
        botInfo[BotInfo.combatRange] = CombatRange.Far;
        botInfo[BotInfo.primaryFireButtonBehaivor] = ButtonBehaivor.HoldAndRelease;
        botInfo[BotInfo.primaryFireButtonWaitMin] = 0;
        botInfo[BotInfo.primaryFireButtonWaitMax] = 0;
        botInfo[BotInfo.primaryFireButtonHoldMin] = 2;
        botInfo[BotInfo.primaryFireButtonHoldMax] = 4;
        botInfo[BotInfo.secondaryFireButtonBehaivor] = ButtonBehaivor.Non;
        break;

        case Hero.Junkrat:
        botInfo[BotInfo.heroName] = "Junkrat";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        break;

        case Hero.Lucio:
        botInfo[BotInfo.heroName] = "Lucio";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        break;

        case Hero.Mccree:
        botInfo[BotInfo.heroName] = "Mccree";
        botInfo[BotInfo.combatRange] = CombatRange.Close;
        break;

        case Hero.Mei:
        botInfo[BotInfo.heroName] = "Mei";
        botInfo[BotInfo.combatRange] = CombatRange.Close;
        botInfo[BotInfo.primaryFireButtonBehaivor] = ButtonBehaivor.HoldAndRelease;
        break;

        case Hero.Mercy:
        botInfo[BotInfo.heroName] = "Mercy";
        botInfo[BotInfo.combatRange] = CombatRange.Far;
        break;

        case Hero.Moira:
        botInfo[BotInfo.heroName] = "Moira";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        botInfo[BotInfo.primaryFireButtonBehaivor] = ButtonBehaivor.HoldAndRelease;
        botInfo[BotInfo.secondaryFireButtonBehaivor] = ButtonBehaivor.HoldOnly;
        break;

        case Hero.Orisa:
        botInfo[BotInfo.heroName] = "Orisa";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        break;

        case Hero.Pharah:
        botInfo[BotInfo.heroName] = "Pharah";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        break;

        case Hero.Reaper:
        botInfo[BotInfo.heroName] = "Reaper";
        botInfo[BotInfo.combatRange] = CombatRange.Close;
        break;

        case Hero.Reinhardt:
        botInfo[BotInfo.heroName] = "Reinhardt";
        botInfo[BotInfo.combatRange] = CombatRange.Melee;
        break;

        case Hero.Roadhog:
        botInfo[BotInfo.heroName] = "Reaper";
        botInfo[BotInfo.combatRange] = CombatRange.Close;
        break;

        case Hero.Sigma:
        botInfo[BotInfo.heroName] = "Sigma";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        botInfo[BotInfo.secondaryFireButtonWaitMin] = 0;
        botInfo[BotInfo.secondaryFireButtonWaitMax] = 10;
        botInfo[BotInfo.secondaryFireButtonHoldMin] = 0;
        botInfo[BotInfo.secondaryFireButtonHoldMax] = 1;
        break;

        case Hero.Soldier76:
        botInfo[BotInfo.heroName] = "Soldier76";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        break;

        case Hero.Sombra:
        botInfo[BotInfo.heroName] = "Sombra";
        botInfo[BotInfo.combatRange] = CombatRange.Close;
        break;

        case Hero.Symmetra:
        botInfo[BotInfo.heroName] = "Symmetra";
        botInfo[BotInfo.combatRange] = CombatRange.Close;
        break;

        case Hero.Torbjorn:
        botInfo[BotInfo.heroName] = "Torbjorn";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        break;

        case Hero.Tracer:
        botInfo[BotInfo.heroName] = "Tracer";
        botInfo[BotInfo.combatRange] = CombatRange.Close;
        break;

        case Hero.Widowmaker:
        botInfo[BotInfo.heroName] = "Widowmaker";
        botInfo[BotInfo.combatRange] = CombatRange.Far;
        botInfo[BotInfo.primaryFireButtonBehaivor] = ButtonBehaivor.HoldAndRelease;
        botInfo[BotInfo.primaryFireButtonWaitMin] = 1;
        botInfo[BotInfo.primaryFireButtonWaitMax] = 2;
        botInfo[BotInfo.primaryFireButtonHoldMin] = 1;
        botInfo[BotInfo.primaryFireButtonHoldMax] = 2;

        botInfo[BotInfo.secondaryFireButtonBehaivor] = ButtonBehaivor.HoldAndRelease;
        botInfo[BotInfo.secondaryFireButtonWaitMin] = 0;
        botInfo[BotInfo.secondaryFireButtonWaitMax] = 3;
        botInfo[BotInfo.secondaryFireButtonHoldMin] = 10;
        botInfo[BotInfo.secondaryFireButtonHoldMax] = 20;
        break;

        case Hero.Winston:
        botInfo[BotInfo.heroName] = "Winston";
        botInfo[BotInfo.combatRange] = CombatRange.Close;
        break;

        case Hero.WreckingBall:
        botInfo[BotInfo.heroName] = "WreckingBall";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        break;

        case Hero.Zarya:
        botInfo[BotInfo.heroName] = "Zarya";
        botInfo[BotInfo.combatRange] = CombatRange.Middle;
        break;

        case Hero.Zenyatta:
        botInfo[BotInfo.heroName] = "Zenyatta";
        botInfo[BotInfo.combatRange] = CombatRange.Far;
        break;
    }

    // set combat range
    switch(botInfo[BotInfo.combatRange]){
        case CombatRange.Melee:
            botInfo[BotInfo.combatRangeMin] = 1;
            botInfo[BotInfo.combatRangeMax] = 3;
            break;
        case CombatRange.Close:
            botInfo[BotInfo.combatRangeMin] = 1;
            botInfo[BotInfo.combatRangeMax] = 10;
            break;
        case CombatRange.Middle:
            botInfo[BotInfo.combatRangeMin] = 10;
            botInfo[BotInfo.combatRangeMax] = 18;
            break;
        case CombatRange.Far:
            botInfo[BotInfo.combatRangeMin] = 18;
            botInfo[BotInfo.combatRangeMax] = 26;
            break;
    }
}

enum State{
    Non,
    Wandering,
    Combat,
    Searching,
    Stacked
}

enum CombatRange{
    Non,
    Melee,
    Close,
    Middle,
    Far
}

enum ButtonBehaivor{
    Non,
    HoldOnly,
    HoldAndRelease,
    Repeat
}

enum WeaponbotInfoTarget{
    Non,
    Enemy,
    Friend,
    Both
}

// TAG Enemy/ObjectDetector ----------

define upperDetectorLength: 4;
define frontDetectorLength: 8;
define underDetectorLength: 6;

enum DetectedObject{
    None,
    Wall,
    Criff,
    DownStair,
    UpStair
}

Boolean getDetectedObject()"getDetectedObject"{
    DetectedObject detecObj = DetectedObject.None;
    define moveDir = Vector(
        XOf(FacingDirectionOf()),
        0,
        ZOf(FacingDirectionOf())
    );
    moveDir = Normalize(moveDir);
    botInfo[BotInfo.detectorRoot] = EyePosition();
    botInfo[BotInfo.frontDetector] = ShiftedPosition(botInfo[BotInfo.detectorRoot], moveDir, frontDetectorLength);
    botInfo[BotInfo.upperDetector] = ShiftedPosition(botInfo[BotInfo.frontDetector], Up(), upperDetectorLength);
    botInfo[BotInfo.underDetector] = ShiftedPosition(botInfo[BotInfo.frontDetector], Down(), underDetectorLength);
    define isFrontBlocked = IsBlockedBetween(botInfo[BotInfo.detectorRoot], botInfo[BotInfo.frontDetector]);
    define isUpperBlocked = IsBlockedBetween(botInfo[BotInfo.detectorRoot], botInfo[BotInfo.upperDetector]);
    define isUnderBlocked = IsBlockedBetween(botInfo[BotInfo.frontDetector], botInfo[BotInfo.underDetector]);
    if(isFrontBlocked){
        if(isUpperBlocked){
            detecObj = DetectedObject.Wall;
        }
        else{
            detecObj = DetectedObject.UpStair;
        }
    }
    else{
        if(isUnderBlocked){
            detecObj = DetectedObject.DownStair;
        }
        else{
            detecObj = DetectedObject.Criff;
        }
    }
    return detecObj;
}

// TAG Enemy/botInfo[BotInfo.state]/botInfo[BotInfo.state]Control ----------
define basicUpdateRate: 1.0;

define isStacking:
    SpeedOf() <= 3.0;

define isContactPlayer: 
    HasSpawned(ClosestPlayerTo(ep, OppositeTeamOf(TeamOf()))) &&
    IsAlive(ClosestPlayerTo(ep, OppositeTeamOf(TeamOf()))) &&
    IsInLineOfSight(ep, ClosestPlayerTo(ep, OppositeTeamOf(TeamOf()))) &&
    !(
        HeroOf(botInfo[BotInfo.target]) == Hero.Sombra && IsUsingAbility1(botInfo[BotInfo.target]) &&
        DistanceBetween(ep, ClosestPlayerTo(ep, OppositeTeamOf(TeamOf()))) >= 2
    );

rule: "Enemy/botInfo[BotInfo.state]/botInfo[BotInfo.state]Control"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    HasSpawned()
){
    if(IsDead()){
        // non by dead
        botInfo[BotInfo.state] = State.Non; 
    }
    else if(isContactPlayer){
        // combat by contact player
        botInfo[BotInfo.state] = State.Combat; 
    }
    else
    {
        if(
            botInfo[BotInfo.targetPos] != 0
        ){
            // start searching at botInfo[BotInfo.target] lost position
            botInfo[BotInfo.state] = State.Searching;
        }
        else{
            // start wardering by botInfo[BotInfo.target] lost
            botInfo[BotInfo.state] = State.Wandering;
        }
    }

    Wait(basicUpdateRate, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

// TAG Enemy/botInfo/State/Non ----------
rule: "Enemy/botInfo/State/Non"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Non
){
    botInfo[BotInfo.statusText] = <"Non">;
    botInfo[BotInfo.targetPos] = 0;
}

// TAG Enemy/botInfo/State/Wandering ----------
define StartMove(define dir):
            StartThrottleInDirection(
                ep, dir, 1,
                Relative.ToPlayer,
                ThrottleBehavior.ReplaceExistingThrottle,
                ThrottleRev.DirectionAndMagnitude);

define StopMove(): StopThrottleInDirection();

rule: "Enemy/botInfo/State/Wandering"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Wandering
){
    botInfo[BotInfo.statusText] = <"Wandering">;

    // set initial status
    botInfo[BotInfo.watchUpdateRate] = basicUpdateRate;
    botInfo[BotInfo.targetPos] = 0;
    StopFacing(ep);

    // action loop
    while(true){
        DetectedObject object = getDetectedObject();
        // blocked by cliff
        if(object == DetectedObject.Criff){
            botInfo[BotInfo.statusText] = <"Wandering/Blocked_By_Cliff">;

            // not set turn direction
            if(botInfo[BotInfo.tuneDir] == 0){
                // set turn direction
                if(RandomInteger(0, 100) <= 50){
                    botInfo[BotInfo.tuneDir] = Right();
                }
                else{
                    botInfo[BotInfo.tuneDir] = Left();
                }
            }
            // set curve to left/right direction
            SetFacing(ep, Forward() + (botInfo[BotInfo.tuneDir] * 2.0), Relative.ToPlayer);
            // shorten watch update rate
            botInfo[BotInfo.watchUpdateRate] = basicUpdateRate / 4;
        }
        // blocked by wall
        else if(object == DetectedObject.Wall){
            botInfo[BotInfo.statusText] = <"Wandering/Blocked_By_Wall">;

            if(botInfo[BotInfo.tuneDir] == 0){
                if(RandomInteger(0, 100) <= 50){
                    botInfo[BotInfo.tuneDir] = Right();
                }
                else{
                    botInfo[BotInfo.tuneDir] = Left();
                }
            }
            SetFacing(ep, Forward() + (botInfo[BotInfo.tuneDir] * 0.5), Relative.ToPlayer);
            botInfo[BotInfo.watchUpdateRate] = basicUpdateRate / 4;
        }
        // not blocked
        else{
            botInfo[BotInfo.statusText] = <"Wandering/Walking">;
            // reset turn direction
            botInfo[BotInfo.tuneDir] = 0;    
            StartMove(Forward());
            // sence near enemy
            if(RandomInteger(0, 100) <= 10){
                SetFacing(
                    ep,
                    DirectionTowards(
                        EyePosition(),
                        ClosestPlayerTo(ep, OppositeTeamOf(TeamOf()))),
                    Relative.ToWorld
                );   
            }
            botInfo[BotInfo.watchUpdateRate] = basicUpdateRate;
        }

        // check stack
        if(isStacking){
            while(RandomInteger(0, 100) <= 40){
                StartHoldingButton(ep, Button.Jump);
                Wait(RandomReal(1, 2), WaitBehavior.AbortWhenFalse);
                StopHoldingButton(ep, Button.Jump);
            }
            if(isStacking){
                botInfo[BotInfo.state] = State.Stacked;
            }
        }

        Wait(botInfo[BotInfo.watchUpdateRate], WaitBehavior.AbortWhenFalse);
    }
}

playervar define sideStepDir;
playervar define sideStepKeepSecond;

// TAG Enemy/botInfo/State/Searching ----------
rule: "Enemy/botInfo/State/Searching"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Searching
){
    botInfo[BotInfo.statusText] = <"Searching">;

    // set initial status
    botInfo[BotInfo.watchUpdateRate] = basicUpdateRate;
    StopFacing(ep); 

    if(sideStepDir == 0){
        //sideStepDir = RandomValueInArray([Right(),Left()]);
        sideStepDir = 0;
    }
    else{
        // set reverse side step for find player
        sideStepDir = -sideStepDir;
    }
    
    // action loop
    while(true){
        botInfo[BotInfo.targetPos] = BelowPosition(botInfo[BotInfo.targetPos]);
        SetFacing(ep, DirectionTowards(ep, botInfo[BotInfo.targetPos]), Relative.ToWorld);

        // blocked by cliff
        DetectedObject object = getDetectedObject();
        define distToTarget = DistanceBetween(ep, botInfo[BotInfo.target]);
        if(object == DetectedObject.Criff){
            moveDir = 0;
            botInfo[BotInfo.statusText] = <"Searching/Blocked_By_Cliff">;
        }
        else{
            moveDir = Forward();
            botInfo[BotInfo.statusText] = <"Searching/Walking">;
        }

        // set move direction
        if(moveDir != 0 && sideStepDir != 0){
            StartMove(moveDir + sideStepDir);
        }
        else if(moveDir == 0 && sideStepDir != 0){
            StartMove(sideStepDir);
        }
        else if(moveDir != 0 && sideStepDir == 0){
            StartMove(moveDir);
        }
        else{
            StopMove();
        }

        // check stack
        if(isStacking){
            StartMove(-sideStepDir + Forward());
            while(RandomInteger(0, 100) <= 40){
                StartHoldingButton(ep, Button.Jump);
                Wait(RandomReal(1, 2), WaitBehavior.AbortWhenFalse);
                StopHoldingButton(ep, Button.Jump);
            }
            if(isStacking){
                botInfo[BotInfo.state] = State.Stacked;
            }
        }

        // arrival botInfo[BotInfo.target] lost position
        if(DistanceBetween(botInfo[BotInfo.targetPos], ep) <= 5){
            botInfo[BotInfo.statusText] = <"Searching/Canceled">;
            Wait(1, WaitBehavior.IgnoreCondition);
            botInfo[BotInfo.targetPos] = 0;
            botInfo[BotInfo.state] = State.Wandering;
        }
 
        Wait(botInfo[BotInfo.watchUpdateRate], WaitBehavior.AbortWhenFalse);
    }
}

rule: "Enemy/SideStepKeepSecond"
Event.OngoingPlayer
if(
    0 < sideStepKeepSecond
){
    while(true){
        Wait(1, WaitBehavior.AbortWhenFalse);
        sideStepKeepSecond--;
    }
}

// TAG Enemy/botInfo/State/Combat ----------
playervar define moveDir;

rule: "Enemy/botInfo/State/Combat"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat
){
    botInfo[BotInfo.statusText] = <"Combat">;

    // set initial status
    botInfo[BotInfo.watchUpdateRate] = basicUpdateRate;
    moveDir = 0;
    sideStepDir = 0;
    StartFacing(
            ep,
            DirectionTowards(
                EyePosition(),
                botInfo[BotInfo.target] + (Up() * 1.0)),
            300,
            Relative.ToWorld, FacingRev.DirectionAndTurnRate
        );   
    
    // action loop
    while(true){
        // set botInfo state
        botInfo[BotInfo.target] = ClosestPlayerTo(ep, OppositeTeamOf(TeamOf()));
        botInfo[BotInfo.targetPos] = PositionOf(botInfo[BotInfo.target]);

        // change combat distance
        DetectedObject object = getDetectedObject();
        define distToTarget = DistanceBetween(ep, botInfo[BotInfo.target]);
        if(object == DetectedObject.Criff){
            moveDir = 0;
            botInfo[BotInfo.statusText] = <"Combat/Blocked_By_Cliff">;
        }
        else if(distToTarget > botInfo[BotInfo.combatRangeMax]){
            moveDir = Forward();
            botInfo[BotInfo.statusText] = <"Combat/Forward">;
        }
        else if(distToTarget < botInfo[BotInfo.combatRangeMin]){
            moveDir = Backward();
            botInfo[BotInfo.statusText] = <"Combat/Backward">;
        }
        else{
            moveDir = 0;
            botInfo[BotInfo.statusText] = <"Combat/Keep_Distance">;
        }

        // change side step
        if(
            sideStepKeepSecond == 0
        ){
            if(RandomInteger(0, 100) <= 70){
                sideStepDir = RandomValueInArray([Right(),Left()]);
                sideStepKeepSecond = RandomInteger(1, 3);
            }
            else{
                sideStepDir = 0;
                sideStepKeepSecond = RandomInteger(0, 2);
            }
        }

        // check stack
        if(isStacking){
            sideStepDir = -sideStepDir; 
        }

        // set move direction
        if(moveDir != 0 && sideStepDir != 0){
            StartMove(moveDir + sideStepDir);
        }
        else if(moveDir == 0 && sideStepDir != 0){
            StartMove(sideStepDir);
        }
        else if(moveDir != 0 && sideStepDir == 0){
            StartMove(moveDir);
        }
        else{
            StopMove();
        }

        Wait(botInfo[BotInfo.watchUpdateRate], WaitBehavior.AbortWhenFalse);
    }
}

// TAG Enemy/botInfo[BotInfo.state]/Stacked ----------
rule: "Enemy/botInfo[BotInfo.state]/Stacked"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Stacked
){
    botInfo[BotInfo.statusText] = <"Stacked">;
    botInfo[BotInfo.stackPos] = PositionOf();
    Wait(2, WaitBehavior.RestartWhenTrue);

    if(DistanceBetween(botInfo[BotInfo.stackPos], ep) <= stackPosRange){
        botInfo[BotInfo.statusText] = <"Stacked/Reset">;
        SetFacing(ep, Backward(), Relative.ToPlayer);
        botInfo[BotInfo.state] = State.Wandering;
    }
}

// TAG Enemy/CooldownControl
disabled rule: "Enemy/CooldownControl"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat
){
    while(true){
        SetAbilityCooldown(ep, Button.Jump, 0);
        SetAbilityCooldown(ep, Button.Crouch, 0);
        SetAbilityCooldown(ep, Button.Ability1, 0);
        SetAbilityCooldown(ep, Button.Ability2, 0);
        SetAbilityCooldown(ep, Button.PrimaryFire, 0);
        SetAbilityCooldown(ep, Button.SecondaryFire, 0);
        SetUltimateCharge (ep, 100);
        Wait(1, WaitBehavior.AbortWhenFalse);
    }
}

// TAG Enemy/ButtonControl
define waitPrimaryFireButton: RandomReal(0, 5);
define holdPrimaryFireButton: RandomReal(0, 5);
define holdPrimaryFireButtonForSniper: RandomReal(1, 2);

void StartButtonControl(
    define button, define buttonOperation,
    define waitDuringMin, define waitDuringMax,
    define holdDuringMin, define holdDuringMax
){
    if(buttonOperation == ButtonBehaivor.HoldOnly){
        while(true){
            StartHoldingButton(ep, button);
            Wait(RandomReal(holdDuringMin, holdDuringMax), WaitBehavior.AbortWhenFalse);
            StopHoldingButton(ep, button);
        }
    }
    else if(buttonOperation == ButtonBehaivor.HoldAndRelease){
        while(true){
            Wait(RandomReal(waitDuringMin, waitDuringMax), WaitBehavior.AbortWhenFalse);
            StartHoldingButton(ep, button);
            Wait(RandomReal(holdDuringMin, holdDuringMax), WaitBehavior.AbortWhenFalse);
            StopHoldingButton(ep, button);
        }
    }
    else if(buttonOperation == ButtonBehaivor.Repeat){
        repeatDuringMin = holdDuringMin;
        repeatDuringMax = holdDuringMax;
        while(true){
            Wait(RandomReal(waitDuringMin, waitDuringMax), WaitBehavior.AbortWhenFalse);
            isRepeating = true;
            while(isRepeating){
                PressButton(ep, button); 
                Wait(0.5, WaitBehavior.AbortWhenFalse);
            }
        }
    }
}

playervar define isRepeating;
playervar define repeatDuringMin;
playervar define repeatDuringMax;

rule: "Enemy/ButtonControl/isRepeating"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat &&
    isRepeating
){
    Wait(RandomReal(repeatDuringMin, repeatDuringMax), WaitBehavior.AbortWhenFalse);
    isRepeating = false;
}

rule: "Enemy/ButtonControl/PrimaryFire/StartButtonControl"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat
){
    StartButtonControl(
        Button.PrimaryFire,
        botInfo[BotInfo.primaryFireButtonBehaivor],
        botInfo[BotInfo.primaryFireButtonWaitMin],
        botInfo[BotInfo.primaryFireButtonWaitMax],
        botInfo[BotInfo.primaryFireButtonHoldMin],
        botInfo[BotInfo.primaryFireButtonHoldMax]
    );
}

rule: "Enemy/ButtonControl/SeconaryFire/StartButtonControl"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat
){
     StartButtonControl(
        Button.SecondaryFire,
        botInfo[BotInfo.secondaryFireButtonBehaivor],
        botInfo[BotInfo.secondaryFireButtonWaitMin],
        botInfo[BotInfo.secondaryFireButtonWaitMax],
        botInfo[BotInfo.secondaryFireButtonHoldMin],
        botInfo[BotInfo.secondaryFireButtonHoldMax]
    );
}

rule: "Enemy/ButtonControl/Ability1/StartButtonControl"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat
){
     StartButtonControl(
        Button.Ability1,
        ButtonBehaivor.HoldAndRelease,
        botInfo[BotInfo.ability1ButtonWaitMin],
        botInfo[BotInfo.ability1ButtonWaitMax],
        botInfo[BotInfo.ability1ButtonHoldMin],
        botInfo[BotInfo.ability1ButtonHoldMax]
    );
}

rule: "Enemy/ButtonControl/Ability2/StartButtonControl"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat
){
     StartButtonControl(
        Button.Ability2,
        ButtonBehaivor.HoldAndRelease,
        botInfo[BotInfo.ability2ButtonWaitMin],
        botInfo[BotInfo.ability2ButtonWaitMax],
        botInfo[BotInfo.ability2ButtonHoldMin],
        botInfo[BotInfo.ability2ButtonHoldMax]
    );
}

rule: "Enemy/ButtonControl/Ultimate/StartButtonControl"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat &&
    UltimateChargePercent() == 100
){
     StartButtonControl(
        Button.Ultimate,
        ButtonBehaivor.HoldAndRelease,
        0,
        5,
        0,
        1
    );
}

rule: "Enemy/ButtonControl/Jump/StartButtonControl"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat
){
     StartButtonControl(
        Button.Jump, ButtonBehaivor.HoldAndRelease,
        0,
        5,
        0,
        5
    );
}

rule: "Enemy/ButtonControl/Crouch/StartButtonControl"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat
){
     StartButtonControl(
        Button.Crouch, ButtonBehaivor.HoldAndRelease,
        0,
        5,
        0,
        3
    );
}

rule: "Enemy/ButtonControl/WeaponSwitch/StartButtonControl"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] == State.Combat
){
    while(true){
        Wait(RandomReal(0, 30), WaitBehavior.AbortWhenFalse);
        SetWeapon(ep, RandomInteger(0, 1));
    }
}

rule: "Enemy/ButtonControl/StopButtonControl"
Event.OngoingPlayer
if(
    botInfo[BotInfo.state] != State.Combat
){
    botInfo[BotInfo.statusText2] = <"Not_Combat">;

    StopHoldingButton(ep, Button.PrimaryFire);
    StopHoldingButton(ep, Button.SecondaryFire);
    StopHoldingButton(ep, Button.Ability1);
    StopHoldingButton(ep, Button.Ability2);
    StopHoldingButton(ep, Button.Ultimate);
    StopHoldingButton(ep, Button.Jump);
    StopHoldingButton(ep, Button.Crouch);
}

// Debug -----------------------------------------------
rule: "showParam"
Event.OngoingGlobal
{
    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "Server Load", ServerLoad()>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "Server Load Average", ServerLoadAverage()>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "Server Load Peak", ServerLoadPeak()>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "spawn hero name", heroNameList[spawnHero]>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);      
}
