import "Lib/Utility.ostw";
import "Lib/Debug.ostw";
//import "Lib/PerkCore.ostw";

// TAG Builtin -----------------------------------------------
define playerTeam: Team.Team1;
define playerList: AllPlayers(playerTeam);
define playerExist: NumberOfPlayers(playerTeam) > 0;
define botTeam: Team.Team2;
define botList: AllPlayers(botTeam);
define botExist: NumberOfPlayers(botTeam) > 0;

define enemyColor: Color.Purple;

define ClosestSpawnPosPlayerList():
    SortedArray(
        FilteredArray(
            AllLivingPlayers(playerTeam), 
            (
                !IsInSpawnRoom(ArrayElement())
            )
        ),
        -DistanceBetween(botSpawnPos, ArrayElement())
    );

define ClosestSpawnPosPlayer():
    ClosestSpawnPosPlayerList()[0];


// TAG Debug/SpawnControl ----------
define spawnHeroList: [
    Hero.Ana,
    Hero.Ashe,
    Hero.Baptiste,
    Hero.Bastion,
    Hero.Brigitte,
    Hero.Doomfist,
    Hero.Dva,
    Hero.Echo,
    Hero.Genji,
    Hero.Hanzo,
    Hero.Junkrat,
    Hero.Lucio,
    Hero.Mccree,
    Hero.Mei,
    Hero.Mercy,
    Hero.Moira,
    Hero.Orisa,
    Hero.Pharah,
    Hero.Reaper,
    Hero.Reinhardt,
    Hero.Roadhog,
    Hero.Sigma,
    Hero.Soldier76,
    Hero.Sombra,
    Hero.Symmetra,
    Hero.Torbjorn,
    Hero.Tracer,
    Hero.Widowmaker,
    Hero.Winston,
    Hero.WreckingBall,
    Hero.Zarya,
    Hero.Zenyatta
];

define heroNameList: [
    "Ana",
    "Ashe",
    "Baptiste",
    "Bastion",
    "Brigitte",
    "Doomfist",
    "Dva",
    "Echo",
    "Genji",
    "Hanzo",
    "Junkrat",
    "Lucio",
    "Mccree",
    "Mei",
    "Mercy",
    "Moira",
    "Orisa",
    "Pharah",
    "Reaper",
    "Reinhardt",
    "Roadhog",
    "Sigma",
    "Soldier76",
    "Sombra",
    "Symmetra",
    "Torbjorn",
    "Tracer",
    "Widowmaker",
    "Winston",
    "WreckingBall",
    "Zarya",
    "Zenyatta"
];

define maxBotNum: 18;

// TAG Bot/SpawnControl -----------------------------------------------
globalvar define initialWaitFin;
rule: "Bot/SpawnControl/initialWait"
Event.OngoingPlayer
Team.Team1
if(
    !initialWaitFin &&
    HasSpawned()
){
    // show botSpawnPos
    CreateIcon(AllPlayers(), botSpawnPos, Icon.ArrowDown,
        IconRev.VisibleToAndPosition, Color.Purple, true);

    // show teleportRange
    // CreateEffect(
    //     HostPlayer(),
    //     Effect.Sphere, Color.Purple,
    //     teleportRangePosition, teleportRangeSize, EffectRev.VisibleToPositionAndRadius);
        


    initialWaitFin = true;
}

rule: "Bot/SpawnControl/ChangeBotSpawnPos"
Event.OngoingGlobal
if(
    initialWaitFin &&
    playerExist
){
    botSpawnPos = PositionOf(RandomValueInArray(playerList));

    while(true){
        dbgMsg("ChangeBotSpawnPos"); 
        // change botSpawnPos
        ChangeBotSpawnPos();
        Wait(120, WaitBehavior.AbortWhenFalse);
    }
}



// TAG Bot/SpawnControl/ReloadBotList -----------------------------------------------

define BotInfo_EnemyType: 0;
define BotInfo_Count: 1;
define BotInfo_Hero: 2;

globalvar define isAllBotsSpawned;

rule: "Bot/SpawnControl/ReloadBotList"
Event.OngoingGlobal
if(
    initialWaitFin &&
    playerExist &&
    botSpawnPos != 0
){
    isAllBotsSpawned = false;
    DestroyAllBot();
    WaitUntil(NumberOfPlayers(Team.Team2) <= 0, 10);

    // hero type until 5, hero count until 18
    define botInfoList = [
        [EnemyType.Minion, 7, Hero.Reinhardt],
        [EnemyType.Elite,  3, Hero.Bastion],
        [EnemyType.Elite,  3, Hero.Reaper],
        [EnemyType.Elite,  3, Hero.Widowmaker],
        [EnemyType.Boss,   2, Hero.Reinhardt]
    ];
    CreateAllBot(botInfoList);
    isAllBotsSpawned = true;

    Wait(180, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

void CreateAllBot(define botInfoList)"CreateAllBot"{
    define slot = 0;
    for(define idx = 0; idx < CountOf(botInfoList); idx ++){
        define botInfo = botInfoList[idx];
        for(define idx2 = 0; idx2 < botInfo[BotInfo_Count]; idx2 ++){
            CreateOneBot(botInfo, slot);
            slot ++;
        }
    }
}

void CreateOneBot(define botInfoList, define slot)"CreateOneBot"{
    // create bot
    while(botInfoList[BotInfo_Hero] != HeroOf(PlayersInSlot(slot, botTeam))){
        CreateDummyBot(
            botInfoList[BotInfo_Hero], botTeam, slot, botSpawnPos,
            DirectionTowards(botSpawnPos,
                ClosestSpawnPosPlayer()
            )
        );
        Wait(0.3, WaitBehavior.AbortWhenFalse);
    }
    // set enemyType
    PlayersInSlot(slot, botTeam).enemyType = botInfoList[BotInfo_EnemyType];
}

void DestroyAllBot()"DestroyAllBot"{
    for(define idx = 0; idx < maxBotNum; idx ++){
        DestroyDummyBot(
            botTeam, idx);
        Wait(0.01);
    }
}

// TAG Bot/SpawnControl/DetectInvalidArea -----------------------------------------------
globalvar define sucideCount;

rule: "Bot/SpawnControl/DetectInvalidArea/countupSucideCount"
Event.OnDeath 
Team.Team2
Player.All
if(
    Attacker() == ep
){
    sucideCount ++;
}

rule: "Bot/SpawnControl/DetectInvalidArea/reduceSucideCount"
Event.OngoingGlobal
if(
    sucideCount > 0
){
    Wait(1, WaitBehavior.AbortWhenFalse);
    sucideCount --;
    LoopIfConditionIsTrue();
}

rule: "Bot/SpawnControl/DetectInvalidArea/changeBotSpawn"
Event.OngoingGlobal
if(
    sucideCount >= (NumberOfPlayers(botTeam) / 4)
){
    dbgMsg("ChangeBotSpawnPos By SucideCount");
    ChangeBotSpawnPos();
}

void ChangeBotSpawnPos()"ChangeBotSpawnPos"{
    // change botSpawnPos
    botSpawnPos = 
        NearestWalkablePosition(
            botSpawnPos +
            // add random direction
            DirectionFromAngles(
                RandomReal(0, 360),
                RandomReal(90, -90)
            ) * 
            // add random distance
            RandomReal(50, 200)
        );
}

// TAG Bot/EnemyType -----------------------------------------------
define minionList: 
    FilteredArray(botList, 
        ArrayElement().enemyType == EnemyType.Minion);
define eliteList: 
    FilteredArray(botList, 
        ArrayElement().enemyType == EnemyType.Elite);

define bossList:
    FilteredArray(botList, 
        ArrayElement().enemyType == EnemyType.Boss);

playervar define enemyType;
enum EnemyType{
    None,
    Minion,
    Elite,
    Boss
}

playervar define enemyTypeDamageDealtRate;

rule: "Bot/EnemyType/setParameter"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    enemyType != EnemyType.None
){
    if(enemyType == EnemyType.Minion){ 
        SetMaxHealth(ep, 100);
        SetMoveSpeed(ep, 100);
        SetGravity(ep, 100);
        StartScalingPlayer(ep, 0.5, false);
        StartModifyingHeroVoiceLines(ep, 1.5, false);
        enemyTypeDamageDealtRate = 0.1;
    }
    else if(enemyType == EnemyType.Elite){
        SetMaxHealth(ep, 300);
        SetMoveSpeed(ep, 90);
        SetGravity(ep, 150);
        StartScalingPlayer(ep, 1.0, false);
        StartModifyingHeroVoiceLines(ep, 1.0, false);
        enemyTypeDamageDealtRate = 0.3;
    }
    else if(enemyType == EnemyType.Boss){
        SetMaxHealth(ep, 1000);
        SetMoveSpeed(ep, 80);
        SetGravity(ep, 300);
        StartScalingPlayer(ep, 1.5, false);
        StartModifyingHeroVoiceLines(ep, 0.5, false);
        enemyTypeDamageDealtRate = 0.6;
    }

    enemyDamageReceived = 100 * enemyBalanceRate * 1.0;
    SetDamageReceived(ep, enemyDamageReceived);

    enemyDamageDealt = 100 / enemyBalanceRate * 1.0;
    SetDamageDealt(ep, enemyDamageDealt * enemyTypeDamageDealtRate);

    Wait(0.1, WaitBehavior.AbortWhenFalse);
    Heal(ep, null, MaxValue());
}

playervar define enemyTypeEntity;

rule: "Bot/EnemyType/setEffect&Text"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    enemyType != EnemyType.None && IsAlive()
){
    enemyTypeEntity = [];
    if(enemyType == EnemyType.Minion){
        CreateInWorldText(
            AllPlayers(Team.All), "Minion", 
            ep, 0.8, Clipping.ClipAgainstSurfaces,
            InworldTextRev.VisibleToPositionAndString,
            Color.White, Spectators.DefaultVisibility);
        enemyTypeEntity[0] = LastTextID();

        CreateEffect(AllPlayers(Team.All),
            Effect.Cloud, enemyColor,
            ep, 1.0, EffectRev.VisibleToPositionAndRadius);
        enemyTypeEntity[1] = LastCreatedEntity();
    }
    else if(enemyType == EnemyType.Elite){
        CreateInWorldText(
            AllPlayers(Team.All), "Elite", 
            ep, 1.4, Clipping.ClipAgainstSurfaces,
            InworldTextRev.VisibleToPositionAndString,
            Color.Yellow, Spectators.DefaultVisibility);
        enemyTypeEntity[0] = LastTextID();

        CreateEffect(AllPlayers(Team.All),
            Effect.Cloud, enemyColor,
            ep, 2.0, EffectRev.VisibleToPositionAndRadius);
        enemyTypeEntity[1] = LastCreatedEntity();
    }
    else if(enemyType == EnemyType.Boss){
        CreateInWorldText(
            AllPlayers(Team.All), "Boss", 
            ep, 2.0, Clipping.ClipAgainstSurfaces,
            InworldTextRev.VisibleToPositionAndString,
            Color.Red, Spectators.DefaultVisibility);
        enemyTypeEntity[0] = LastTextID();
        
        CreateEffect(AllPlayers(Team.All),
            Effect.Cloud, enemyColor,
            ep, 4.0, EffectRev.VisibleToPositionAndRadius);
        enemyTypeEntity[1] = LastCreatedEntity();
    }
}

rule: "Bot/EnemyType/resetEffect&Text"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    !(enemyType != EnemyType.None && IsAlive())
){
    DestroyInWorldText(enemyTypeEntity[0]);
    DestroyEffect(enemyTypeEntity[1]);
}

rule: "Bot/EnemyType/chargeUltimateAbility"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    enemyType != EnemyType.None
){
    if(enemyType == EnemyType.Minion){
        Wait(180, WaitBehavior.AbortWhenFalse);
    }
    else if(enemyType == EnemyType.Elite){
        Wait(60, WaitBehavior.AbortWhenFalse);
    }
    else if(enemyType == EnemyType.Boss){
        Wait(10, WaitBehavior.AbortWhenFalse);
    }
    
    SetUltimateCharge(ep, 100);

    LoopIfConditionIsTrue();
}

// TAG Bot/Balance -----------------------------------------------
define enemyBalanceRate: NumberOfSlots(playerTeam) / NumberOfPlayers(playerTeam);
globalvar define enemyDamageDealt;
globalvar define enemyDamageReceived;

rule: "Bot/setBalance"
Event.OngoingGlobal
Player.All
if(
    initialWaitFin
){
    enemyDamageReceived = 100 * enemyBalanceRate * 1.0;
    SetDamageReceived(botList, enemyDamageReceived);

    for(define idx; idx < CountOf(botList); idx ++){
        enemyDamageDealt = 100 / enemyBalanceRate * 1.0;
        SetDamageDealt(botList[idx], enemyDamageDealt * botList[idx].enemyTypeDamageDealtRate);
    }    
    
    Wait(10, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

// TAG Bot/Teleport -----------------------------------------------
rule: "Bot/Teleport/teleportBotWhenRespawn"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    IsAlive()
){
    ep.state = State.Non;
}

rule: "Bot/Teleport/teleportBotToPlayer"
Event.OngoingGlobal
if(
    playerExist &&
    botExist
){
    // get far bot
    define closestPlayer = ClosestSpawnPosPlayer();
    define teleportBotList;

    if(closestPlayer != null){
    teleportBotList =  
        SortedArray(
            FilteredArray(
                AllLivingPlayers(botTeam), 
                (
                    !IsInLineOfSight(
                        closestPlayer, ArrayElement(),
                        BarrierLOS.NoBarriersBlock)
                )
            ),
            -DistanceBetween(closestPlayer, ArrayElement())
        );
    }
    
    if(teleportBotList != []){
        // pickup multiple teleportTarget
        define listNum = CountOf(teleportBotList);
        define teleportNum = RandomInteger(1, 10);
        teleportBotList = ArraySlice(teleportBotList, 0, teleportNum);
        // teleport
        TeleportToPlayersFront(teleportBotList);
        // show icon
        define icon = CreateIcon(AllPlayers(), teleportPosition, Icon.Warning,
            IconRev.VisibleToAndPosition, Color.Yellow, true);
        Wait(3, WaitBehavior.IgnoreCondition);
        DestroyIcon(icon);
    }
    Wait(RandomReal(5, 20), WaitBehavior.AbortWhenFalse);

    LoopIfConditionIsTrue();
}

define teleportRangeSize: 15;
globalvar define teleportRangePosition;
globalvar define teleportPosition;

void TeleportToPlayersFront(define terelportTarget)"TeleportToPlayerRoad"{
    // set teleport position by blind spot from player
    // find place that will be a blind spot up to 10 times
    //define teleportPosition;
    define hasLine;
    define inSight;
    define nearPlayer = ClosestSpawnPosPlayer();
    define distSpawnPosToPlayer = DistanceBetween(botSpawnPos, nearPlayer);


    for(gLoopIndex = 0; gLoopIndex < 10; gLoopIndex++){
        // outside teleport range
        if(distSpawnPosToPlayer >= teleportRangeSize){
            // set teleport range position to player front
            teleportRangePosition = 
                nearPlayer +
                (
                    Normalize(DirectionTowards(nearPlayer, botSpawnPos)) *
                    teleportRangeSize
                );
        }
        else{
            // set teleport range position to botSpawnPos
            teleportRangePosition = botSpawnPos;
        }

        // randomize set teleport position in range
        teleportPosition = 
            NearestWalkablePosition(
                teleportRangePosition +
                RandomPosition(teleportRangeSize, teleportRangeSize, teleportRangeSize)
            );
        // get hasLine
        hasLine = IsInLineOfSight(
            nearPlayer,
            teleportPosition + Up(),
            BarrierLOS.NoBarriersBlock);
        
        if(
            // not too close
            DistanceBetween(teleportPosition, nearPlayer) > (teleportRangeSize / 2) &&
            // has line
            hasLine
        ){
            break;
        }
    }
    Teleport(terelportTarget, teleportPosition);
    PlayEffect(
        AllPlayers(), PlayEffect.BadExplosion,
        Color.Purple, teleportPosition, CountOf(terelportTarget) * 1.5);
}

// TAG Bot/ObjectDetect -----------------------------------------------
playervar define detectorRoot;
playervar define upperDetector;
playervar define frontDetector;
playervar define underDetector;
define upperDetectorLength : 4;
define frontDetectorLength : 8;
define underDetectorLength : 6;

enum DetectedObject{
    None,
    Wall,
    Criff,
    DownStair,
    UpStair
}

Boolean getDetectedObject()"getDetectedObject"{
    DetectedObject detecObj = DetectedObject.None;
    define moveDir = Vector(
        XOf(FacingDirectionOf()),
        0,
        ZOf(FacingDirectionOf())
    );
    moveDir = Normalize(moveDir);
    detectorRoot = EyePosition();
    frontDetector = ShiftedPosition(detectorRoot, moveDir, frontDetectorLength);
    upperDetector = ShiftedPosition(frontDetector, Up(), upperDetectorLength);
    underDetector = ShiftedPosition(frontDetector, Down(), underDetectorLength);
    define isFrontBlocked = IsBlockedBetween(detectorRoot, frontDetector);
    define isUpperBlocked = IsBlockedBetween(detectorRoot, upperDetector);
    define isUnderBlocked = IsBlockedBetween(frontDetector, underDetector);
    if(isFrontBlocked){
        if(isUpperBlocked){
            detecObj = DetectedObject.Wall;
        }
        else{
            detecObj = DetectedObject.UpStair;
        }
    }
    else{
        if(isUnderBlocked){
            detecObj = DetectedObject.DownStair;
        }
        else{
            detecObj = DetectedObject.Criff;
        }
    }
    return detecObj;
}

// TAG Bot/State/StateControl -----------------------------------------------
playervar define statusText;
playervar define statusText2;
playervar define tuneDir;
playervar define target;
playervar define updateRate;
define basicUpdateRate: 1.0;

define IsStacking():
    SpeedOf() <= 3.0;

define IsContactPlayer():
    IsAlive(ClosestPlayerTo(ep, playerTeam)) &&
    IsInLineOfSight(ep, ClosestPlayerTo(ep, playerTeam)) &&
    !(
        HeroOf(ClosestPlayerTo(ep, playerTeam)) == Hero.Sombra &&
        IsUsingAbility1(ClosestPlayerTo(ep, playerTeam)) &&
        DistanceBetween(ep, ClosestPlayerTo(ep, playerTeam)) >= 2
    );


playervar define state;
enum State{
    Non,
    Wandering, 
    Combat,
    Searching,
    Stacked
}

rule: "Bot/State/StateControl"
Event.OngoingPlayer
if(
    IsDummyBot() &&
    HasSpawned()
){
    if(IsInSpawnRoom() || IsDead()){
        // idle
        state = State.Non; 
    }
    else if(IsContactPlayer()){
        // combat by contact player
        state = State.Combat; 
    }
    else
    {
        if(
            targetPos != 0
        ){
            // start searching at target lost position
            state = State.Searching;
        }
        else{
            // start wardering by target lost
            state = State.Wandering;
        }
    }

    Wait(basicUpdateRate, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

// TAG Bot/State/Non -----------------------------------------------
rule: "Bot/State/Non"
Event.OngoingPlayer
if(
    state == State.Non
){
    statusText = <"Non">;
    targetPos = 0;
    StopFacing(ep);
    StopMove();
}

// TAG Bot/State/Wandering -----------------------------------------------
define StartMove(define dir):
            StartThrottleInDirection(
                ep, dir, 1,
                Relative.ToPlayer,
                ThrottleBehavior.ReplaceExistingThrottle,
                ThrottleRev.DirectionAndMagnitude);

define StopMove(): StopThrottleInDirection();

rule: "Bot/State/Wandering"
Event.OngoingPlayer
if(
    state == State.Wandering
){
    statusText = <"Wandering">;

    // set initial status
    updateRate = basicUpdateRate;
    targetPos = 0;
    StopFacing(ep);

    // action loop
    while(true){
        DetectedObject object = getDetectedObject();
        // blocked by cliff
        if(object == DetectedObject.Criff){
            statusText = <"Wandering/Blocked_By_Cliff">;

            // not set turn direction
            if(tuneDir == 0){
                // set turn direction
                if(RandomInteger(0, 100) <= 50){
                    tuneDir = Right();
                }
                else{
                    tuneDir = Left();
                }
            }
            // set curve to left/right direction
            SetFacing(ep, Forward() + (tuneDir * 2.0), Relative.ToPlayer);
            // shorten watch update rate
            updateRate = basicUpdateRate / 4;
        }
        // blocked by wall
        else if(object == DetectedObject.Wall){
            statusText = <"Wandering/Blocked_By_Wall">;

            if(tuneDir == 0){
                if(RandomInteger(0, 100) <= 50){
                    tuneDir = Right();
                }
                else{
                    tuneDir = Left();
                }
            }
            SetFacing(ep, Forward() + (tuneDir * 0.5), Relative.ToPlayer);
            updateRate = basicUpdateRate / 4;
        }
        // not blocked
        else{
            statusText = <"Wandering/Walking">;
            // reset turn direction
            tuneDir = 0;    
            StartMove(Forward());
            // sence near enemy
            if(RandomInteger(0, 100) <= 10){
                SetFacing(
                    ep,
                    DirectionTowards(
                        EyePosition(),
                        ClosestSpawnPosPlayer()),
                    Relative.ToWorld
                );   
            }
            updateRate = basicUpdateRate;
        }

        // check stack
        if(IsStacking()){
            while(RandomInteger(0, 100) <= 40){
                StartHoldingButton(ep, Button.Jump);
                Wait(RandomReal(1, 2), WaitBehavior.AbortWhenFalse);
                StopHoldingButton(ep, Button.Jump);
            }
            if(IsStacking()){
                state = State.Stacked;
            }
        }

        Wait(updateRate, WaitBehavior.AbortWhenFalse);
    }
}

playervar define targetPos;
define targetPosRange: 5;
playervar define sideStepDir;
playervar define sideStepKeepSecond;

// TAG Bot/State/Searching -----------------------------------------------
rule: "Bot/State/Searching"
Event.OngoingPlayer
if(
    state == State.Searching
){
    statusText = <"Searching">;

    // set initial status
    updateRate = basicUpdateRate;
    StopFacing(ep); 

    if(sideStepDir == 0){
        sideStepDir = 0;
    }
    else{
        // set reverse side step for find player
        sideStepDir = -sideStepDir;
    }
    
    // action loop
    while(true){
        targetPos = BelowPosition(targetPos);
        SetFacing(ep, DirectionTowards(ep, targetPos), Relative.ToWorld);

        // blocked by cliff
        DetectedObject object = getDetectedObject();
        define distToTarget = DistanceBetween(ep, target);
        if(object == DetectedObject.Criff){
            moveDir = 0;
            statusText = <"Searching/Blocked_By_Cliff">;
        }
        else{
            moveDir = Forward();
            statusText = <"Searching/Walking">;
        }

        // set move direction
        if(moveDir != 0 && sideStepDir != 0){
            StartMove(moveDir + sideStepDir);
        }
        else if(moveDir == 0 && sideStepDir != 0){
            StartMove(sideStepDir);
        }
        else if(moveDir != 0 && sideStepDir == 0){
            StartMove(moveDir);
        }
        else{
            StopMove();
        }

        // check stack
        if(IsStacking()){
            StartMove(-sideStepDir + Forward());
            while(RandomInteger(0, 100) <= 40){
                StartHoldingButton(ep, Button.Jump);
                Wait(RandomReal(1, 2), WaitBehavior.AbortWhenFalse);
                StopHoldingButton(ep, Button.Jump);
            }
            if(IsStacking()){
                state = State.Stacked;
            }
        }

        // arrival target lost position
        if(DistanceBetween(targetPos, ep) <= 5){
            statusText = <"Searching/Canceled">;
            Wait(1, WaitBehavior.IgnoreCondition);
            targetPos = 0;
            state = State.Wandering;
        }
 
        Wait(updateRate, WaitBehavior.AbortWhenFalse);
    }
}

rule: "Bot/SideStepKeepSecond"
Event.OngoingPlayer
if(
    0 < sideStepKeepSecond
){
    Wait(1, WaitBehavior.AbortWhenFalse);
    sideStepKeepSecond--;
    LoopIfConditionIsTrue();
}

// TAG Bot/State/Combat -----------------------------------------------
playervar define moveDir;

rule: "Bot/State/Combat"
Event.OngoingPlayer
if(
    state == State.Combat
){
    statusText = <"Combat">;

    // set initial status
    updateRate = basicUpdateRate;
    moveDir = 0;
    sideStepDir = 0;
    StartFacing(
            ep,
            DirectionTowards(
                EyePosition(),
                target + (Up() * 1.0)),
            RandomReal(300, 100),
            Relative.ToWorld, FacingRev.DirectionAndTurnRate
        );   
    
    // action loop
    while(true){
        // set target
        target = ClosestSpawnPosPlayer();
        targetPos = PositionOf(target);

        // change combat distance
        DetectedObject object = getDetectedObject();
        define distToTarget = DistanceBetween(ep, target);
        if(object == DetectedObject.Criff){
            moveDir = 0;
            statusText = <"Combat/Blocked_By_Cliff">;
        }
        else if(distToTarget > combatRangeMax){
            moveDir = Forward();
            statusText = <"Combat/Forward">;
        }
        else if(distToTarget < combatRangeMin){
            moveDir = Backward();
            statusText = <"Combat/Backward">;
        }
        else{
            moveDir = 0;
            statusText = <"Combat/Keep_Distance">;
        }

        // change side step
        if(
            sideStepKeepSecond == 0
        ){
            if(RandomInteger(0, 100) <= 70){
                sideStepDir = RandomValueInArray([Right(),Left()]);
                sideStepKeepSecond = RandomInteger(1, 3);
            }
            else{
                sideStepDir = 0;
                sideStepKeepSecond = RandomInteger(0, 2);
            }
        }

        // check stack
        if(IsStacking()){
            sideStepDir = -sideStepDir; 
        }

        // set move direction
        if(moveDir != 0 && sideStepDir != 0){
            StartMove(moveDir + sideStepDir);
        }
        else if(moveDir == 0 && sideStepDir != 0){
            StartMove(sideStepDir);
        }
        else if(moveDir != 0 && sideStepDir == 0){
            StartMove(moveDir);
        }
        else{
            StopMove();
        }

        Wait(updateRate, WaitBehavior.AbortWhenFalse);
    }
}

// TAG Bot/State/Stacked -----------------------------------------------
playervar define stackPos;
define stackPosRange: 2;

rule: "Bot/State/Stacked"
Event.OngoingPlayer
if(
    state == State.Stacked
){
    statusText = <"Stacked">;
    stackPos = PositionOf();
    Wait(2, WaitBehavior.RestartWhenTrue);

    if(DistanceBetween(stackPos, ep) <= stackPosRange){
        statusText = <"Stacked/Reset">;
        SetFacing(ep, Backward(), Relative.ToPlayer);
        state = State.Wandering;
    }
}

// TAG Bot/ButtonControl -----------------------------------------------
playervar define combatRange;
playervar define combatRangeMin;
playervar define combatRangeMax;

playervar define primaryFireButtonBehaivor;
playervar define primaryFireButtonWaitMin;
playervar define primaryFireButtonWaitMax;
playervar define primaryFireButtonHoldMin;
playervar define primaryFireButtonHoldMax;

playervar define secondaryFireButtonBehaivor;
playervar define secondaryFireButtonWaitMin;
playervar define secondaryFireButtonWaitMax;
playervar define secondaryFireButtonHoldMin;
playervar define secondaryFireButtonHoldMax;

playervar define ability1ButtonWaitMin;
playervar define ability1ButtonWaitMax;
playervar define ability1ButtonHoldMin;
playervar define ability1ButtonHoldMax;

playervar define ability2ButtonWaitMin;
playervar define ability2ButtonWaitMax;
playervar define ability2ButtonHoldMin;
playervar define ability2ButtonHoldMax;

rule: "Bot/SetButtonControl&CombatRange"
Event.OngoingPlayer
if(
    HasSpawned() &&
    IsDummyBot()
){
        combatRange = CombatRange.Middle;
        primaryFireButtonBehaivor = ButtonBehaivor.HoldOnly;
        primaryFireButtonWaitMin = 0;
        primaryFireButtonWaitMax = 1;
        primaryFireButtonHoldMin = 0;
        primaryFireButtonHoldMax = 10;

        secondaryFireButtonBehaivor = ButtonBehaivor.HoldAndRelease;
        secondaryFireButtonWaitMin = 0;
        secondaryFireButtonWaitMax = 10;
        secondaryFireButtonHoldMin = 0;
        secondaryFireButtonHoldMax = 5;

        ability1ButtonWaitMin = 0;
        ability1ButtonWaitMax = 10;
        ability1ButtonHoldMin = 0;
        ability1ButtonHoldMax = 5;

        ability2ButtonWaitMin = 0;
        ability2ButtonWaitMax = 10;
        ability2ButtonHoldMin = 0;
        ability2ButtonHoldMax = 5;

    switch(HeroOf()){
        case Hero.Ana:
        combatRange = CombatRange.Far;
        primaryFireButtonBehaivor = ButtonBehaivor.HoldOnly;
        secondaryFireButtonBehaivor = ButtonBehaivor.HoldAndRelease;
        secondaryFireButtonWaitMin = 0;
        secondaryFireButtonWaitMax = 5;
        secondaryFireButtonHoldMin = 5;
        secondaryFireButtonHoldMax = 20;
        break;

        case Hero.Ashe:
        combatRange = CombatRange.Far;
        primaryFireButtonBehaivor = ButtonBehaivor.Repeat;
        secondaryFireButtonBehaivor = ButtonBehaivor.HoldAndRelease;
        secondaryFireButtonWaitMin = 0;
        secondaryFireButtonWaitMax = 5;
        secondaryFireButtonHoldMin = 5;
        secondaryFireButtonHoldMax = 20;
        break;

        case Hero.Baptiste:
        combatRange = CombatRange.Middle;
        break;

        case Hero.Bastion:
        combatRange = CombatRange.Far;
        break;

        case Hero.Brigitte:
        combatRange = CombatRange.Melee;
        break;

        case Hero.Doomfist:
        combatRange = CombatRange.Close;
        break;

        case Hero.Dva:
        combatRange = CombatRange.Close;
        break;

        case Hero.Echo:
        combatRange = CombatRange.Middle;
        break;

        case Hero.Genji:
        combatRange = CombatRange.Middle;
        break;

        case Hero.Hanzo:
        combatRange = CombatRange.Far;
        primaryFireButtonBehaivor = ButtonBehaivor.HoldAndRelease;
        primaryFireButtonWaitMin = 0;
        primaryFireButtonWaitMax = 1;
        primaryFireButtonHoldMin = 1;
        primaryFireButtonHoldMax = 3;
        secondaryFireButtonBehaivor = ButtonBehaivor.Non;
        break;

        case Hero.Junkrat:
        combatRange = CombatRange.Middle;
        break;

        case Hero.Lucio:
        combatRange = CombatRange.Middle;
        break;

        case Hero.Mccree:
        combatRange = CombatRange.Close;
        break;

        case Hero.Mei:
        combatRange = CombatRange.Close;
        primaryFireButtonBehaivor = ButtonBehaivor.HoldAndRelease;
        break;

        case Hero.Mercy:
        combatRange = CombatRange.Far;
        break;

        case Hero.Moira:
        combatRange = CombatRange.Middle;
        primaryFireButtonBehaivor = ButtonBehaivor.HoldAndRelease;
        secondaryFireButtonBehaivor = ButtonBehaivor.HoldOnly;
        break;

        case Hero.Orisa:
        combatRange = CombatRange.Middle;
        break;

        case Hero.Pharah:
        combatRange = CombatRange.Middle;
        break;

        case Hero.Reaper:
        combatRange = CombatRange.Close;
        break;

        case Hero.Reinhardt:
        combatRange = CombatRange.Melee;
        break;

        case Hero.Roadhog:
        combatRange = CombatRange.Close;
        break;

        case Hero.Sigma:
        combatRange = CombatRange.Middle;
        break;

        case Hero.Soldier76:
        combatRange = CombatRange.Middle;
        break;

        case Hero.Sombra:
        combatRange = CombatRange.Close;
        break;

        case Hero.Symmetra:
        combatRange = CombatRange.Close;
        primaryFireButtonBehaivor = ButtonBehaivor.HoldAndRelease;
        break;

        case Hero.Torbjorn:
        combatRange = CombatRange.Middle;
        break;

        case Hero.Tracer:
        combatRange = CombatRange.Close;
        break;

        case Hero.Widowmaker:
        combatRange = CombatRange.Far;
        primaryFireButtonBehaivor = ButtonBehaivor.HoldAndRelease;
        secondaryFireButtonWaitMin = 0;
        secondaryFireButtonWaitMax = 5;
        secondaryFireButtonHoldMin = 5;
        secondaryFireButtonHoldMax = 20;
        break;

        case Hero.Winston:
        combatRange = CombatRange.Close;
        break;

        case Hero.WreckingBall:
        combatRange = CombatRange.Middle;
        break;

        case Hero.Zarya:
        combatRange = CombatRange.Middle;
        break;

        case Hero.Zenyatta:
        combatRange = CombatRange.Far;
        break;
    }

    // set combat range
    switch(combatRange){
        case CombatRange.Melee:
            combatRangeMin = 1;
            combatRangeMax = 3;
            break;
        case CombatRange.Close:
            combatRangeMin = 1;
            combatRangeMax = 8;
            break;
        case CombatRange.Middle:
            combatRangeMin = 8;
            combatRangeMax = 16;
            break;
        case CombatRange.Far:
            combatRangeMin = 16;
            combatRangeMax = 24;
            break;
    }
}



enum CombatRange{
    Non,
    Melee,
    Close,
    Middle,
    Far
}

enum ButtonBehaivor{
    Non,
    HoldOnly,
    HoldAndRelease,
    Repeat
}

enum WeaponTarget{
    Non,
    Enemy,
    Friend,
    Both
}
void StartButtonControl(
    define button, define buttonOperation,
    define waitDuringMin, define waitDuringMax,
    define holdDuringMin, define holdDuringMax
){
    if(buttonOperation == ButtonBehaivor.HoldOnly){
        StartHoldingButton(ep, button);
    }
    else if(buttonOperation == ButtonBehaivor.HoldAndRelease){
        while(true){
            Wait(RandomReal(waitDuringMin, waitDuringMax), WaitBehavior.AbortWhenFalse);
            StartHoldingButton(ep, button);
            Wait(RandomReal(holdDuringMin, holdDuringMax), WaitBehavior.AbortWhenFalse);
            StopHoldingButton(ep, button);
        }
    }
    else if(buttonOperation == ButtonBehaivor.Repeat){
        repeatDuringMin = holdDuringMin;
        repeatDuringMax = holdDuringMax;
        while(true){
            Wait(RandomReal(waitDuringMin, waitDuringMax), WaitBehavior.AbortWhenFalse);
            isRepeating = true;
            while(isRepeating){
                PressButton(ep, button); 
                Wait(0.2, WaitBehavior.AbortWhenFalse);
            }
        }
    }
}

playervar define isRepeating;
playervar define repeatDuringMin;
playervar define repeatDuringMax;

rule: "Bot/ButtonControl/isRepeating"
Event.OngoingPlayer
if(
    state == State.Combat &&
    isRepeating
){
    Wait(RandomReal(repeatDuringMin, repeatDuringMax), WaitBehavior.AbortWhenFalse);
    isRepeating = false;
}

rule: "Bot/ButtonControl/PrimaryFire/StartButtonControl"
Event.OngoingPlayer
if(
    state == State.Combat
){
    StartButtonControl(
        Button.PrimaryFire,
        primaryFireButtonBehaivor,
        primaryFireButtonWaitMin,
        primaryFireButtonWaitMax,
        primaryFireButtonHoldMin,
        primaryFireButtonHoldMax
    );
}

rule: "Bot/ButtonControl/SeconaryFire/StartButtonControl"
Event.OngoingPlayer
if(
    state == State.Combat
){
     StartButtonControl(
        Button.SecondaryFire,
        secondaryFireButtonBehaivor,
        secondaryFireButtonWaitMin,
        secondaryFireButtonWaitMax,
        secondaryFireButtonHoldMin,
        secondaryFireButtonHoldMax
    );
}

rule: "Bot/ButtonControl/Ability1/StartButtonControl"
Event.OngoingPlayer
if(
    state == State.Combat
){
     StartButtonControl(
        Button.Ability1,
        ButtonBehaivor.HoldAndRelease,
        ability1ButtonWaitMin,
        ability1ButtonWaitMax,
        ability1ButtonHoldMin,
        ability1ButtonHoldMax
    );
}

rule: "Bot/ButtonControl/Ability2/StartButtonControl"
Event.OngoingPlayer
if(
    state == State.Combat
){
     StartButtonControl(
        Button.Ability2,
        ButtonBehaivor.HoldAndRelease,
        ability2ButtonWaitMin,
        ability2ButtonWaitMax,
        ability2ButtonHoldMin,
        ability2ButtonHoldMax
    );
}

rule: "Bot/ButtonControl/Ultimate/StartButtonControl"
Event.OngoingPlayer
if(
    state == State.Combat &&
    UltimateChargePercent() == 100
){
     StartButtonControl(
        Button.Ultimate,
        ButtonBehaivor.HoldAndRelease,
        0,
        10,
        0,
        1
    );
}

rule: "Bot/ButtonControl/Jump/StartButtonControl"
Event.OngoingPlayer
if(
    state == State.Combat
){
     StartButtonControl(
        Button.Jump, ButtonBehaivor.HoldAndRelease,
        0,
        5,
        0,
        5
    );
}

rule: "Bot/ButtonControl/Crouch/StartButtonControl"
Event.OngoingPlayer
if(
    state == State.Combat
){
     StartButtonControl(
        Button.Crouch, ButtonBehaivor.HoldAndRelease,
        0,
        5,
        0,
        3
    );
}

rule: "Bot/ButtonControl/WeaponSwitch/StartButtonControl"
Event.OngoingPlayer
if(
    state == State.Combat
){
    while(true){
        Wait(RandomReal(0, 30), WaitBehavior.AbortWhenFalse);
        SetWeapon(ep, RandomInteger(0, 1));
    }
}

rule: "Bot/ButtonControl/StopButtonControl"
Event.OngoingPlayer
if(
    state != State.Combat
){
    statusText2 = <"Not_Combat">;

    StopHoldingButton(ep, Button.PrimaryFire);
    StopHoldingButton(ep, Button.SecondaryFire);
    StopHoldingButton(ep, Button.Ability1);
    StopHoldingButton(ep, Button.Ability2);
    StopHoldingButton(ep, Button.Ultimate);
    StopHoldingButton(ep, Button.Jump);
    StopHoldingButton(ep, Button.Crouch);
}

// TAG Bot/Debug -----------------------------------------------
define debug: false;

disabled rule: "Bot/Debug/ShowDebugInfo"
Event.OngoingPlayer
if(
    //debug &&
    HasSpawned() &&
    IsDummyBot()
){  
    // // show status text
    // CreateInWorldText(
    //     HostPlayer(), statusText,
    //     ep + (Up() * 3), 1, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
    //     Color.White, Spectators.DefaultVisibility);
    // // show status2 text
    // CreateInWorldText(
    //     HostPlayer(), statusText2,
    //     ep + (Up() * 2), 1, Clipping.DoNotClip, InworldTextRev.VisibleToPositionAndString,
    //     Color.White, Spectators.DefaultVisibility);

    // // show frontDetector path
    // CreateBeamEffect(
    //     ep.state == State.Wandering ? HostPlayer() : null, BeamType.GoodBeam,
    //     detectorRoot, frontDetector,
    //     Color.White,
    //     EffectRev.VisibleToPositionRadiusAndColor);
    // // show upperDetector path
    // CreateBeamEffect(
    //     ep.state == State.Wandering ? HostPlayer() : null, BeamType.GoodBeam,
    //     detectorRoot, upperDetector,
    //     Color.Blue,
    //     EffectRev.VisibleToPositionRadiusAndColor);
    // // show underDetector path
    // CreateBeamEffect(
    //     ep.state == State.Wandering ? HostPlayer() : null, BeamType.GoodBeam,
    //     frontDetector, underDetector,
    //     Color.Green,
    //     EffectRev.VisibleToPositionRadiusAndColor);

    // // show targetPos path
    // CreateBeamEffect(
    //     ep.state == State.Combat || ep.state == State.Searching ? HostPlayer() : null,
    //     BeamType.GoodBeam,
    //     EyePosition(), targetPos,
    //     Color.Red,
    //     EffectRev.VisibleToPositionRadiusAndColor);
    // // show targetPos
    // CreateEffect(
    //     ep.state == State.Searching ? HostPlayer() : null,
    //     Effect.Ring, Color.Red,
    //     targetPos, targetPosRange, EffectRev.VisibleToPositionAndRadius);

    // // show stackPos
    // CreateEffect(
    //     ep.state == State.Stacked ? HostPlayer() : null,
    //     Effect.Ring, Color.White,
    //     stackPos, stackPosRange, EffectRev.VisibleToPositionAndRadius);
}

// TAG Bot/Debug/SpawnControl -----------------------------------------------

globalvar define botHero = 0;
globalvar define botSpawnPos;

rule: "Bot/Debug/SpawnControl/ChangeBotHero"
Event.OngoingPlayer
if(
    debug &&
    ep == HostPlayer() &&
    IsButtonHeld(ep, Button.Jump) &&
    IsButtonHeld(ep, Button.Interact)
){
    botHero ++;
    if(botHero >= CountOf(spawnHeroList)){
        botHero = 0;
    }
}

rule: "Bot/Debug/SpawnControl/CreateOneBot"
Event.OngoingPlayer
if(
    debug &&
    ep == HostPlayer() &&
    !IsButtonHeld(ep, Button.Jump) &&
    intaractDoublePressed
){
    botSpawnPos = AimingPosition();
    CreateOneBot(
        RandomValueInArray(
            IsButtonHeld(ep, Button.Crouch) ?
                AllHeroes() :
                spawnHeroList[botHero]
        ),
        NumberOfPlayers(botTeam)
    );
}

rule: "Debug/SpawnControl/CreateAllBot"
Event.OngoingPlayer
if(
    debug &&
    ep == HostPlayer() &&
    IsButtonHeld(ep, Button.Interact)
){
    WaitLongPressConfirm();

    botSpawnPos = AimingPosition();
    CreateAllBot(
        IsButtonHeld(ep, Button.Crouch) ?
            AllHeroes() :
            spawnHeroList[botHero]
    );
}

rule: "Debug/SpawnControl/DestroyAllBot"
Event.OngoingPlayer
if(
    debug &&
    ep == HostPlayer() &&
    IsButtonHeld(ep, Button.Interact)
){
    WaitLongPressConfirm();

    DestroyAllBot();
}

rule: "Debug/SpawnControl/ChangeBotSpawnPos"
Event.OngoingPlayer
if(
    HostPlayer() == EventPlayer() &&
    IsButtonHeld(EventPlayer(), Button.Interact) &&
    !IsButtonHeld(EventPlayer(), Button.Reload) &&
    IsButtonHeld(EventPlayer(), Button.Crouch)
){
    ChangeBotSpawnPos();
}

// TAG Debug/Builtin ----------
define changeTimeInterval: 0.2;
globalvar define tuneVal = 1;
globalvar define consecutiveChangeCount = 0;
define initialTuneUnit : 0.1;
globalvar define tuneUnit = initialTuneUnit;

rule: "Debug/Builtin/showParam"
Event.OngoingGlobal
{
    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "tune Val", tuneVal>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "Server Load", ServerLoad()>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "Server Load Average", ServerLoadAverage()>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "Server Load Peak", ServerLoadPeak()>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "spawn hero name", heroNameList[botHero]>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);   

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "Number Of Player Bot Team", NumberOfPlayers(botTeam)>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "enemy Damage Received", enemyDamageReceived>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);   
    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "enemy Damage Dealt", enemyDamageDealt>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);   
}

rule: "Debug/Builtin/startIncreaseParam"
Event.OngoingPlayer
if(
    HostPlayer() &&
    (
        IsButtonHeld(ep, Button.Interact) &&
        IsButtonHeld(ep, Button.Ability2)
    )
){
    tuneVal += tuneUnit;
    Wait(changeTimeInterval, WaitBehavior.AbortWhenFalse);
    changeTuneUnit();
    LoopIfConditionIsTrue();
}

rule: "Debug/Builtin/stopIncreaseParam"
Event.OngoingPlayer
if(
    HostPlayer() &&
    !(
        IsButtonHeld(ep, Button.Interact) &&
        IsButtonHeld(ep, Button.Ability2)
    )
){
    resetTuneUnit();
}

rule: "Debug/Builtin/startDecreaseParam"
Event.OngoingPlayer
if(
    HostPlayer() &&
    (
        IsButtonHeld(ep, Button.Interact) &&
        IsButtonHeld(ep, Button.Ability1)
    )
){
    tuneVal -= tuneUnit;
    Wait(changeTimeInterval, WaitBehavior.AbortWhenFalse);
    changeTuneUnit();
    LoopIfConditionIsTrue();
}

rule: "Debug/Builtin/stopDecreaseParam"
Event.OngoingPlayer
if(
    HostPlayer() &&
    !(
        IsButtonHeld(ep, Button.Interact) &&
        IsButtonHeld(ep, Button.Ability1)
    )
){
    resetTuneUnit();
}

void resetTuneUnit(){
    tuneUnit = initialTuneUnit;
    consecutiveChangeCount= 0;
}

void changeTuneUnit(){
    consecutiveChangeCount ++;
    if(consecutiveChangeCount < 10)
        tuneUnit =  initialTuneUnit * 1;
    else if(consecutiveChangeCount < 20 )
        tuneUnit = initialTuneUnit * 10;
    else
        tuneUnit = initialTuneUnit * 100;
}
