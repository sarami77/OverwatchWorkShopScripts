// [Detail]
// [Portal Hunt -HORDE PVE] The hell portal has been opened… Defeat enemie horde that spawn from portal and close portal!  When enter portal, start sequence of close. survive to complete.  Over time, portal grow. Grown portal spawn more enemie and get harder.  Survive using PERK dropped by enemy.  PERK has uniqe buffs, new weapon, powerful custom heroes, others.  ex) GrapplingBeam, CruisingMissile, LegendaryNinja and more than 25 types!  Unlimited rounds. How many rounds can you survive?
// [Share Code]
// YY1N2
// [ToDo]
// add optimaze hit scan by close range of Beam Sniaper
// add Perk Disarmament
// add Perk Drone Guard Dog
// add Perk Assassination

import "Lib/DamageText.ostw";
import "Lib/Regeneration.ostw";
import "Lib/Revive.ostw";
import "Lib/Perk.ostw";
import "Lib/Bot.ostw";
import "Lib/Debug.ostw";
import "Lib/ElapsedTimer.ostw";
// import "Lib/InvisibleImmortalForDebug.ostw";

// TAG duumy driver ----------
// globalvar define Revive_enableTeam;
// globalvar define Revive_timeLimit;
// globalvar define reviveTimeoutCount;

// globalvar define Regeneration_enableTeam;
// globalvar define Regeneration_needBalanceTeam1;
// globalvar define Regeneration_waitRegenTimeTeam1;
// globalvar define Regeneration_regenerationRateTeam1;
// globalvar define playerRegenerationRateTeam1;

// globalvar define DamageText_enableTeam;

//void DestroyAllBot(){}
//void CreateAllBotByAsset(){}

// TAG Signature and infomation ----------
disabled rule: "PORTAL HUNT -HORDE PVE [ver 3.0] Share code [YY1N2]"-1{}
disabled rule: "You allowed copy or modify code."-1{}
disabled rule: "This script was generated from source code by [Overwatch-Script-To-Workshop]"-1{}
disabled rule: "Check detail with https://github.com/ItsDeltin/Overwatch-Script-To-Workshop"-1{}
disabled rule: "Original source code was created by [sarami77#1868]"-1{}
disabled rule: "Check detail with https://github.com/sarami77/OverwatchWorkShopScripts"-1{}

// TAG System ----------
define WaitReduce(): WaitUntil(!isServerOverLoading, 3);

define enableOverLoadMeasures: true;
define isServerOverLoading: 255 <= ServerLoad();
globalvar define targetSlowLevel!;
globalvar define currentSlowLevel!;
define slowLevel: [100, 90, 80, 60, 40];

rule: "System/ServerOverLoadMeasures"
Event.OngoingGlobal
if(
    enableOverLoadMeasures &&
    portalState != PortalState.End
){
    // If the server is overloaded,
    //  apply slow motion every second to reduce the load to
    //  avoid shutting down due to server overload.

    // is overload
    if(isServerOverLoading){
        // can change next slow level
        if(targetSlowLevel < (CountOf(slowLevel) - 1))
            // change next slow level
            targetSlowLevel ++;
    }
    else{
        // can change next slow level
        if(targetSlowLevel > 0)
            // change next slow level
            targetSlowLevel --;
    }

    if(currentSlowLevel != targetSlowLevel){
        currentSlowLevel = targetSlowLevel;
        SetSlowMotion(slowLevel[targetSlowLevel]);
    }
    
    Wait(1, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

// TAG Game ----------
define enemyColor: Color.Purple;
globalvar define initCompleted!;
globalvar define roundNo!;

rule: "Game/initGameSetting //wait 3 _seconds because some scripts fail immediately after loading the _server"
Event.OngoingGlobal
{
    // Stop records to reduce server load
    DisableInspectorRecording();

    // for perfomance debug
    // CreateHudText(HostPlayer(),
    //     null,
    //     <"<0> <1>", "current Slow Level", currentSlowLevel>,
    //     null,
    //     Location.Left, -1,
    //     Color.White, Color.Orange, Color.White,
    //     HudTextRev.VisibleToAndString, Spectators.VisibleNever);

    // Set imported function property
    Regeneration_enableTeam = Team.Team1;
    Regeneration_needBalanceTeam1 = true;
    Regeneration_waitRegenTimeTeam1 = WorkshopSettingReal("Player Settings", "Wait Second Until Start Regeneration", 1, 0, 100, 1);
    Regeneration_regenerationRateTeam1 = WorkshopSettingReal("Player Settings", "Regeneration Rate In Per Seconds", 25, 0, 1000, 2);

    Revive_enableTeam = Team.Team1;
    Revive_timeLimit = WorkshopSettingReal("Player Settings", "Revive Time Limit", 10, 0, 100, 3);
    
    DamageText_enableTeam = Team.Team2;

    // If run it right after loading the server, some scripts fail, so wait 3 seconds
    Wait(3, WaitBehavior.AbortWhenFalse);

    // Cancel unnecessary default settings
    PauseMatchTime();
    DisableScoring();
    DisableCompletion();

    // set objective message
    SetObjectiveDescription(AllPlayers(Team.Team1), "Find portal and attack it!", HudTextRev.None);

    // Calculate the approximate center position of the map from the spawn room position.
    // Therefore, change the spawn room and then spawn the entity.
    ForceSpawnRoom(Team.Team1, 2);
    Respawn(AllPlayers(Team.All));

    // Set initial team lifes
    initialTeamLifes = WorkshopSettingInteger("Player Settings", "Initial Team Lifes", 6, 0, 1000, 0);

    // show version and share code
    CreateHudText(AllPlayers(Team.Team1),
        null, "PORTAL HUNT -HORDE PVE [ver 3.0] Share code [YY1N2]", null,
        Location.Left, -3,
        Color.White, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);

    // show hero change operation
    CreateHudText(AllPlayers(Team.Team1),
        null, <"Long hold reload button <0> to change hero", ButtonGuide(Button.Reload)>, null,
        Location.Left, -2,
        Color.Yellow, Color.Yellow, Color.Yellow,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);

    // show round number
    CreateHudText(AllPlayers(Team.All),
        <"<0> <1>", "Round", roundNo>, null, null,
        Location.Top, 2,
        enemyColor, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleAlways);

    // show objective message and elapsed time
    enableElapsedTimer = true;
    elapsedTime = 0;

    // Notify completion of init game setting and start game main logic
    initCompleted = true;

    while(true){
        // repeat action for joined player
        // set objective message
        SetObjectiveDescription(AllPlayers(Team.Team1), "find portal and attack!", HudTextRev.None);
        Wait(10, WaitBehavior.AbortWhenFalse);
    } 
}

rule: "Game/initGame"
Event.OngoingGlobal
if(
    initCompleted
){
    // reset team lifes
    teamLifes = initialTeamLifes;
    // reset round no
    roundNo = 0;
    // reset elapsed time
    elapsedTime = 0;
}

rule: "Game/startGame"
Event.OngoingGlobal
if(
    initCompleted &&
    portalState == PortalState.Init &&
    NumberOfPlayers(Team.Team1) > 0 &&
    IsTrueForAny(
        AllPlayers(Team.Team1),
        (
            !IsInSpawnRoom(ae) &&
            IsMoving(ae)
        )
    )
){
    // start portal creation
    portalState = PortalState.Calculating;
}

rule: "Game/stopGame"
Event.OngoingGlobal
if(
    initCompleted &&
    portalState != PortalState.Init &&
    NumberOfPlayers(Team.Team1) <= 0
){
    // reset team lifes
    teamLifes = initialTeamLifes;
    // reset round no
    roundNo = 0;
    // reset elapsed time
    elapsedTime = 0;
    // reset portal
    portalState = PortalState.Init;
}

rule: "Game/SpawnRoom/changeByTimer //to make the game fluid"
Event.OngoingGlobal
if(
    initCompleted
){
    // Change the spawn room regularly to keep the game fluid
    Wait(300, WaitBehavior.AbortWhenFalse); // change spawn room
    ForceSpawnRoom(Team.Team2, RandomInteger(0, 2));
    ForceSpawnRoom(Team.Team1, RandomInteger(0, 2));
    LoopIfConditionIsTrue();
}

// TAG Player ----------
playervar define isInsidePortal;

rule: "Player/InsidePortal/update"
Event.OngoingGlobal
if(
    portalEnable
){
    define players = AllPlayers(Team.Team1);
    // Set flag when player entered to portal
    // This flag is used for functions related to portal
    for(gLoopIndex = 0; gLoopIndex < CountOf(players); gLoopIndex++){
        if(
            HasSpawned(players[gLoopIndex]) &&
            IsAlive(players[gLoopIndex]) &&
            !IsInSpawnRoom(players[gLoopIndex]) &&
            DistanceBetween(players[gLoopIndex], portalPosition) <= portalSize
        ){
            players[gLoopIndex].isInsidePortal = true;
        }
        else{
            players[gLoopIndex].isInsidePortal = false;
        }
    }
    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}

rule: "Player/ReturnSpawn/returnSpawn"
Event.OngoingPlayer
Team.Team1
if(
    IsAlive() &&
    !IsInSpawnRoom() &&
    IsButtonHeld(ep, Button.Reload)
){
    // Return to spawn room with long hold on reload button
    WaitCancelPressConfirm();
    Respawn();
}

globalvar define initialTeamLifes!;
globalvar define teamLifes!;

rule: "Player/TeamLifes/showTeamLifesHUD"
Event.OngoingGlobal
if(
    initCompleted
){
    // show HUD of team lifes
    CreateHudText(AllPlayers(Team.All),
        <"<0> <1>", "Team lifes", teamLifes>, null, null,
        Location.Top, 3,
        Color.Team1, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleAlways);
}

rule: "Player/TeamLifes/consumeTeamLifes"
Event.OngoingGlobal
if(
    0 < reviveTimeoutCount
){
    WaitConditionConfirmed();
    teamLifes -= reviveTimeoutCount;
    WaitChangeState();  // wait for show big message by newest value
    if(teamLifes > 0){
        if(teamLifes > 0){
            BigMessage(AllPlayers(Team.All),
                <"<0> <1> <2>", "Our remaining team lifes is", teamLifes, "...">);
        }
        PlayEffect(
            AllPlayers(Team.All), PlayEffect.DebuffImpactSound,
            Color.White, portalPosition, MaxLength());
    }
    reviveTimeoutCount = 0;
}

rule: "Player/TeamLifes/finishGame //by team lifes out"
Event.OngoingGlobal
if(
    initCompleted &&
    teamLifes <= 0
){
    WaitConditionConfirmed();
    // When the team lifes out, the game ends
    portalState = PortalState.End;
    BigMessage(AllPlayers(Team.All), "Our team lifes is out...");
    SetSlowMotion(10);
    Wait(1, WaitBehavior.AbortWhenFalse);   // show slow
    SetSlowMotion(100);
    WaitNextPhase();

    BigMessage(AllPlayers(Team.All),
        <"We have reached <0> round... good game!", roundNo>);
    PlayRandomEmote(AllPlayers(Team.Team1));
    WaitNextPhase();

    DeclareTeamVictory(Team.Team1);
}

rule: "Player/TeamLifes/protectTeamLifesFromSucide"
Event.OnDeath
Team.Team1
if(
    Attacker() == ep &&
    DistanceBetween(ep,
        ClosestPlayerTo(ep, Team.Team2)) > 15
){
    Wait(1, WaitBehavior.AbortWhenFalse);
    Respawn();
}

globalvar define closingCount;
globalvar define closingProgress;
globalvar define closingProgressHudEntity;
globalvar define playerNumInsidePortal;

define enableClosingProgress:
    portalState == PortalState.Suspended &&
    teamLifes > 0;

rule: "Player/ClosePortal/startClosing //on enter any player"
Event.OngoingGlobal
if(
    enableClosingProgress
){
    // When a player enters a portal, set progress hud and show message
    WaitConditionConfirmed();
    // kick progress
    closingCount = RoundToInteger(portalSize, Rounding.Nearest);
    closingCount += roundNo * 2;
    closingProgress = 0;
    ChaseVariableOverTime(closingProgress, DefaultPercentage(), closingCount, TimeChaseReevaluation.DestinationAndDuration);
    // show progress hud
    if(closingProgressHudEntity == null){
        CreateProgressBarHudText(
            AllPlayers(),
            closingProgress,
            <"<0> player has surviving in portal. Until portal closes...", playerNumInsidePortal >,
            Location.Top, 4,
            Color.White,
            Color.White,
            ProgressBarEvaluation.VisibleToValuesAndColor,
            Spectators.DefaultVisibility );
        closingProgressHudEntity = LastTextID();
    }
    // get closest surviver to portal center
    define closestPlayerFromPortal = 
        FirstOf(
            SortedArray(
                FilteredArray(
                    AllPlayers(Team.Team1), IsAlive(ae)
                ),
                DistanceBetween(portalPosition, ae)
            )
        );
    // show big message
    BigMessage(
        closestPlayerFromPortal,
        <"You are closing portal... Stay inside and Survive!">);
    BigMessage(
        FilteredArray(AllPlayers(Team.Team1), (closestPlayerFromPortal != ae)),
        <"<0> <1> <2>",
            closestPlayerFromPortal,
            HeroIconString(HeroOf(closestPlayerFromPortal)),
            "closing portal... Cover one!">);
    // Wait closingCount
    Wait(closingCount, WaitBehavior.AbortWhenFalse);
    portalState = PortalState.Closing;
}

rule: "Player/ClosePortal/updatePlayerNumInsidePortal"
Event.OngoingGlobal
if(
    enableClosingProgress
){
    playerNumInsidePortal = CountOf(
        FilteredArray(
            AllPlayers(Team.Team1),
            ae.isInsidePortal
        )
    );
    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}

rule: "Player/ClosePortal/cancelClosing //on exit every player"
Event.OngoingGlobal
if(
    !enableClosingProgress
){
    StopChasingVariable(closingProgress);
    // wait hide hud when progress completed
    if(closingProgress == 100){
        Wait(1.5, WaitBehavior.AbortWhenFalse);
    }
    DestroyProgressBarHudText(closingProgressHudEntity);
    closingProgressHudEntity = null;
}

rule: "Player/ClosePortal/finishClose //on count down finished"
Event.OngoingGlobal
if(
    (
        portalState == PortalState.Closing ||
        portalState == PortalState.Closed
    ) &&
    teamLifes > 0
){
    WaitConditionConfirmed();
    // When the countdown is complete, clear the portal and give team lifes.
    // Later, we will generate a new portal and start the next round.
    WaitPlayEffect();   //wait portal closing effect
    portalState = PortalState.Closed;
    WaitNextPhase();

    // show got life sound message
    BigMessage(AllPlayers(Team.All), "We got new team lifes!");
    // play got life sound
    PlayEffect(
        AllPlayers(Team.All), PlayEffect.BuffImpactSound,
        Color.White, portalPosition, MaxLength()
    );
    // got life sound
    teamLifes += 1;
    WaitNextPhase();

    PlayRandomVoiceLine(AllPlayers(Team.Team1));
    roundNo += 1;
    portalState = PortalState.Calculating;  // start next portal create
}

playervar define inPortalEffectEntitys;

rule: "Player/FairPlay/disableStealthWhenInside //sombra's stealth for fair play"
Event.OngoingPlayer
Team.Team1
if(
    isInsidePortal &&
    HeroOf() == Hero.Sombra &&
    IsUsingAbility1()
){
    // Some abilities are disabled inside the portal to make the game fair
    // Sombra stealth is exactly that
    Wait(5.0, WaitBehavior.AbortWhenFalse); // disable ability check cycle
    SetStatus(ep, null, Status.Stunned, 0.1);
    SmallMessage(ep, "Stealth disabled by magnetic storm of portal.");
    LoopIfConditionIsTrue();
}

rule: "Player/FairPlay/disableGrappleClawWhenInside // wreckingBball's grapple claw for fair play"
Event.OngoingPlayer
Team.Team1
if(
    isInsidePortal &&
    HeroOf() == Hero.WreckingBall &&
    IsFiringSecondary()
){
    // Some abilities are disabled inside the portal to make the game fair
    // WreckingBall Grapple is exactly that
    Wait(5.0, WaitBehavior.AbortWhenFalse); // disable ability check cycle
    SetStatus(ep, null, Status.Stunned, 0.1);
    SmallMessage(ep, "Grapple claw disabled by magnetic storm of portal.");
    LoopIfConditionIsTrue();
}

// TAG Portal Function ----------
globalvar define portalState;
enum PortalState{
    Init,
    Idle,
    Calculating,
    Checking,
    Set,
    Growing,
    Suspended,
    Closing,
    Closed,
    End
}

globalvar define portalPosition;
globalvar define portalSize;
globalvar define portalEntitys;
globalvar define isFirstGrowing;

define portalEnable:
    portalState == PortalState.Checking ||
    portalState == PortalState.Set ||
    portalState == PortalState.Growing ||
    portalState == PortalState.Suspended;

rule: "Portal/State/Calculating //invisible, init param"
Event.OngoingGlobal
if(
    portalState == PortalState.Calculating
){
    // Hide Portal Entity until portal state changed to Show
    // Init param
    StopChasingVariable(portalSize);
    portalPosition = 0;
    portalSize = 0;
    isFirstGrowing = true;
    // Hide portal icon and effect
    DestroyIcon(portalEntitys[0]);
    DestroyEffect(portalEntitys[1]);
    DestroyEffect(portalEntitys[2]);
    DestroyEffect(portalEntitys[3]);
    DestroyEffect(portalEntitys[4]);
}

rule: "Portal/State/Set  // waiting for found by players"
Event.OngoingGlobal
if(
    portalState == PortalState.Set
){
    DestroyIcon(portalEntitys[0]);
    // show Portal Entity by portal state changed to Show
    // Init param
    closingCount = 0;
    // show icon
    portalEntitys = [];
    CreateIcon(AllPlayers(Team.All), portalPosition, Icon.Spiral,
        IconRev.VisibleToAndPosition, enemyColor, true);
    portalEntitys[0] = LastCreatedEntity();
    // set effect
    // sphere
    CreateEffect(AllPlayers(Team.All), Effect.Sphere, enemyColor,
        portalPosition, portalSize, EffectRev.VisibleToPositionAndRadius);
    portalEntitys[1] = LastCreatedEntity();
    // cloud
    CreateEffect(AllPlayers(Team.All), Effect.Cloud, enemyColor,
        portalPosition, portalSize * 1.5, EffectRev.VisibleToPositionAndRadius);
    portalEntitys[2] = LastCreatedEntity();
    // aura
    // Since visibility will be poor, display only in the center of the field of view
    CreateEffect(
        FilteredArray(
            AllPlayers(Team.All),
            DistanceBetween(ae, portalPosition) > portalSize / 2), Effect.BadAura, enemyColor,
        portalPosition, portalSize * 1.25, EffectRev.VisibleToPositionAndRadius);
    portalEntitys[3] = LastCreatedEntity();
    // sound
    CreateEffect(AllPlayers(Team.All), Effect.EnergySound, enemyColor,
        portalPosition, portalSize / 2, EffectRev.VisibleToPositionAndRadius);
    portalEntitys[4] = LastCreatedEntity();
    // show message
    BigMessage(AllPlayers(Team.All), "Detected more portal... find and attack!");
    // Hide icon to let the player search the portal
    Wait(6, WaitBehavior.AbortWhenFalse);
    DestroyIcon(portalEntitys[0]);
}

rule: "Portal/State/Growing"
Event.OngoingGlobal
if(
    portalState == PortalState.Growing
){
    // Start growing portal with warning message
    ChaseVariableAtRate(
        portalSize, maxPortalSize, 1 + (roundNo / 8),
        RateChaseReevaluation.DestinationAndRate);
    // If first growing, show message
    if(isFirstGrowing == true){
        isFirstGrowing = false;
        BigMessage(AllPlayers(Team.All), "Portal is growing... hurry up!");
        WaitBigMessageHide();
        BigMessage(AllPlayers(Team.All), "Growed portals spawn more enemys and get tough...");
    }
    // Hide icon to let the player search the portal
    Wait(1, WaitBehavior.AbortWhenFalse);
    DestroyIcon(portalEntitys[0]);
}

rule: "Portal/State/Suspended"
Event.OngoingGlobal
if(
    portalState == PortalState.Suspended
){
    // Hide icon to let the player search the portal
    DestroyIcon(portalEntitys[0]);
    // Stop growing portal
    StopChasingVariable(portalSize);
}

rule: "Portal/State/Closing"
Event.OngoingGlobal
if(
    portalState == PortalState.Closing
){
    // apply blast impulse
    ApplyBlastImpulse(AllPlayers(Team.Team2), portalPosition, portalSize);
    // play portal closing effect and kill enemrys
    Kill(AllPlayers(Team.Team2), null);
    // play blast sound
    PlayEffect(
        AllPlayers(Team.All), PlayEffect.RingExplosionSound,
        Color.White, portalPosition, MaxLength());
    // play blast effect
    PlayContinuousBlast(
        Color.Yellow,
        portalPosition,
        portalSize * 1.5,
        10);
}

rule: "Portal/State/Closed"
Event.OngoingGlobal
if(
    portalState == PortalState.Closed
){
    // show message
    BigMessage(AllPlayers(Team.All), "Portal closed... good job!");
    // init param
    portalPosition = 0;
    portalSize = 0;
    StopChasingVariable(portalSize);
    // Hide portal icon and effect
    DestroyIcon(portalEntitys[0]);
    DestroyEffect(portalEntitys[1]);
    DestroyEffect(portalEntitys[2]);
    DestroyEffect(portalEntitys[3]);
    DestroyEffect(portalEntitys[4]);
}

rule: "Portal/State/End"
Event.OngoingGlobal
if(
    portalState == PortalState.End
){
    // apply blast impulse
    ApplyBlastImpulse(AllPlayers(Team.Team2), portalPosition, portalSize);
    // play portal closing effect and kill enemrys
    Kill(AllPlayers(Team.Team2), null);
    // play blast sound
    PlayEffect(
        AllPlayers(Team.All), PlayEffect.RingExplosionSound,
        Color.White, portalPosition, MaxLength());
    // play blast effect
    PlayContinuousBlast(
        Color.Yellow,
        portalPosition,
        portalSize * 1.5,
        10);

    // init param
    portalPosition = 0;
    portalSize = 0;
    StopChasingVariable(portalSize);
    // Hide portal icon and effect
    DestroyIcon(portalEntitys[0]);
    DestroyEffect(portalEntitys[1]);
    DestroyEffect(portalEntitys[2]);
    DestroyEffect(portalEntitys[3]);
    DestroyEffect(portalEntitys[4]);
}

rule: "Portal/Positioner/createPortal"
Event.OngoingGlobal
if(
    teamLifes > 0 &&
    portalState == PortalState.Calculating
){
    WaitConditionConfirmed();
    define candidatePosition;
    for(define retryCount = 0; retryCount < 10; retryCount++){
        WaitReduce();
        
        // select random player as base positoon
        define basePlayer =
            RandomValueInArray(
                FilteredArray(
                    AllLivingPlayers(Team.Team1),
                    HasSpawned(ae)
                )
            );
        // select random positon from player around
        define randomPositon = 
            basePlayer +
            // add random direction
            DirectionFromAngles(
                RandomReal(0, 360),
                RandomReal(90, -90)
            ) * 
            // add random distance
            RandomReal(50, 200);
        
        // get candidate postion of portal 
        candidatePosition = NearestWalkablePosition(randomPositon);
        // move candidate postion in the direction of player for avoiding map edge
        candidatePosition += DirectionTowards(candidatePosition, basePlayer) * RandomReal(1, 5);
        // convert to walkble position
        candidatePosition = NearestWalkablePosition(candidatePosition);
        if(
            // close candidate postion than random positon
            (
                DistanceBetween(basePlayer, randomPositon) >= 
                DistanceBetween(basePlayer, candidatePosition) + 10
            )
                &&
            // far postion from previous position
            (
                DistanceBetween(prevPortalPosition, candidatePosition) >= 50
            )
                &&
            // far postion from player
            (
                DistanceBetween(
                    ClosestPlayerTo(candidatePosition, Team.Team1),
                    candidatePosition
                ) >= 50
            )
        ){
            break;
        }
        Wait(0.01, WaitBehavior.AbortWhenFalse);
    }
    // confirm as portal position
    portalPosition = candidatePosition;
    // create portal, next check position
    portalState = PortalState.Checking;
    // fail safe
    Wait(6, WaitBehavior.AbortWhenFalse);
	dbgMsg("failsafe triggered of createPortal");
    LoopIfConditionIsTrue();
}
globalvar define prevPortalPosition;

rule: "Portal/Positioner/positionChecking"
Event.OngoingGlobal
if(
    teamLifes > 0 &&
    portalState == PortalState.Checking
){
    // confirm portal position
    prevPortalPosition = portalPosition;
    portalState = PortalState.Set;
    // fail safe
    Wait(6, WaitBehavior.AbortWhenFalse);
    dbgMsg("failsafe triggered of positionChecking");
    LoopIfConditionIsTrue();
}

// TAG Portal/InvalidDetect/EnvironmentDeathCount ----------
define limitCount: 6;
globalvar define environmentDeathCount = 0;

rule: "Portal/InvalidDetect/EnvironmentDeathCount/resetCount"
Event.OngoingGlobal
if(
    !portalEnable &&
    environmentDeathCount > 0
){
    environmentDeathCount = 0;
}

rule: "Portal/InvalidDetect/EnvironmentDeathCount/countup"
Event.OnDeath
Team.Team2
if(
    portalEnable &&
    ep == Attacker()
){
    environmentDeathCount += 1;
}

rule: "Portal/InvalidDetect/EnvironmentDeathCount/countupBySpawnRoomKill"
Event.OnDeath
Team.Team2
if(
    portalEnable &&
    IsInSpawnRoom(Attacker())
){
    environmentDeathCount += limitCount;
}

rule: "Portal/InvalidDetect/EnvironmentDeathCount/reduceCount"
Event.OngoingGlobal
if(
    portalEnable &&
    0 < environmentDeathCount
){
    WaitUpdateMediumCycle();
    environmentDeathCount --;
    LoopIfConditionIsTrue();
}

rule: "Portal/InvalidDetect/EnvironmentDeathCount/resetPortal"
Event.OngoingGlobal
if(
    portalEnable &&
    limitCount <= environmentDeathCount
){
    dbgMsg("reset Portal By Environment Death Count");
    portalState = PortalState.Calculating;
}

// TAG Portal/InvalidDetect/NoContact ----------
define limitTime: 120;
globalvar define noContactTime;

rule: "Portal/InvalidDetect/NoContactTime/resetTime"
Event.OngoingGlobal
if(
    !portalEnable
){
    WaitConditionConfirmed();
    noContactTime = 0;
}

rule: "Portal/InvalidDetect/NoContactTime/countup"
Event.OngoingGlobal
if(
    portalEnable &&
    noContactTime != -1  &&
    limitTime > noContactTime
){
    WaitUpdateMediumCycle();
    noContactTime ++;
    LoopIfConditionIsTrue();
}

rule: "Portal/InvalidDetect/NoContactTime/detectContact"
Event.OngoingGlobal
if(
    portalEnable &&
    portalState == PortalState.Suspended
){
    Wait(1, WaitBehavior.AbortWhenFalse);
    noContactTime = -1;
}

rule: "Portal/InvalidDetect/NoContactTime/resetPortal"
Event.OngoingGlobal
if(
    portalEnable &&
    limitTime <= noContactTime
){
    dbgMsg("reset Portal By No Contact");
    portalState = PortalState.Calculating;
}

// TAG Portal/Growing ----------
define maxPortalSize: 70;
define portalStableTime: 40;

rule: "Portal/Growing/startGrowingByPlayerFound"
Event.OngoingGlobal
if(
    portalState == PortalState.Set
){
    if(
        IsInLineOfSight(portalPosition,
            closestPlayerToPortal,
            BarrierLOS.NoBarriersBlock)
    ){
        WaitConditionConfirmed();
        // Strat portal growing by player found
        portalState = PortalState.Growing;
    }
    else{
        WaitUpdateMediumCycle();
        LoopIfConditionIsTrue();
    }
}

rule: "Portal/Growing/startGrowingByTimeout"
Event.OngoingGlobal
if(portalState == PortalState.Set){
    // Start portal growing by search time limit out
    Wait(portalStableTime, WaitBehavior.AbortWhenFalse);  //wait time to start growing
    portalState = PortalState.Growing;
}

rule: "Portal/Growing/suspendGrowingByPlayerEntered"
Event.OngoingGlobal
if(
    portalState == PortalState.Growing &&
    IsTrueForAny(
        AllPlayers(Team.Team1), ae.isInsidePortal
    )
){
    // Suspend portal growing by player enter to portal
    WaitConditionConfirmed();
    portalState = PortalState.Suspended;
}

rule: "Portal/Growing/resumeGrowingByPlayerExited"
Event.OngoingGlobal
if(
    portalState == PortalState.Suspended &&
    !IsTrueForAny(
        AllPlayers(Team.Team1), ae.isInsidePortal
    )
){
    // Resume portal growing by player exit from portal
    WaitConditionConfirmed();
    portalState = PortalState.Growing;
}

// TAG Bot/CreateBot ----------
rule: "Portal/CreateBot/reloadBotAsset"
Event.OngoingGlobal
if(
    portalState == PortalState.Set
){
    // change bot asset by random
    if(
        0 >= NumberOfPlayers(Team.Team2) ||
        RandomInteger(1, 100) <= 70
    ){
        // destroy all bot
        DestroyAllBot();
        // create all bot
        CreateAllBotByAsset();   
    }
}

// TAG Bot/EnemyType ----------
playervar define enemyType;
enum EnemyType{
    None,
    Minion,
    Elite,
    Boss,
    GiantBoss
}

playervar define eachDealtDamageScale;
playervar define eachMaxSpawnInterval;
playervar define eachChargeUltInterval;

void SetMaxHealthWithRecover(define player, define maxHelth)"SetMaxHealthWithRecover"{
    SetMaxHealth(player, maxHelth);
    Wait(0.1, WaitBehavior.AbortWhenFalse);
    Heal(player, null, MaxValue());
}

rule: "Bot/EnemyType/setEnemyType"
Event.OngoingPlayer
Team.Team2
if(
    enemyType != EnemyType.None
){
    if(enemyType == EnemyType.Minion){ 
        StartScalingPlayer(ep, 0.75, false);
        StartModifyingHeroVoiceLines(ep, 1.25, false);
        SetMaxHealthWithRecover(ep, 50);
        SetHealingReceived(ep, 50);
        SetHealingDealt(ep, 50);
        eachDealtDamageScale = 0.5;
        eachChargeUltInterval = 80;
        eachMaxSpawnInterval = 3;
    }
    else if(enemyType == EnemyType.Elite){
        StartScalingPlayer(ep, 1.0, false);
        StartModifyingHeroVoiceLines(ep, 1.0, false);
        SetMaxHealthWithRecover(ep, 200);
        SetHealingReceived(ep, 100);
        SetHealingDealt(ep, 100);
        eachDealtDamageScale = 1.0;
        eachChargeUltInterval = 20;
        eachMaxSpawnInterval = 10;
    }
    else if(enemyType == EnemyType.Boss){
        StartScalingPlayer(ep, 1.5, false);
        StartModifyingHeroVoiceLines(ep, 0.75, false);
        SetMaxHealthWithRecover(ep, 1000);
        SetHealingReceived(ep, 200);
        SetHealingDealt(ep, 200);
        eachDealtDamageScale = 1.5;
        eachChargeUltInterval = 10;
        eachMaxSpawnInterval = 30;
    }
    else if(enemyType == EnemyType.GiantBoss){
        StartScalingPlayer(ep, 2.5, false);
        StartModifyingHeroVoiceLines(ep, 0.25, false);
        SetMaxHealthWithRecover(ep, 1000);
        SetHealingReceived(ep, 400);
        SetHealingDealt(ep, 400);
        eachDealtDamageScale = 4.0;
        eachChargeUltInterval = 10;
        eachMaxSpawnInterval = 15;
        // set pool health
        AddHealthPoolToPlayer(ep, HealthType.Armor, 2000, true, false);
    }    

    UpdateEachDealtDamage();
    UpdateEachSpawnInterval();
}

// TAG Bot/Effect ----------
playervar define botAppearanceEntitys;

rule: "Bot/Effect/showBotAppearance"
Event.OngoingPlayer
Team.Team2
if(
    enemyType != EnemyType.None &&
    IsAlive()
){
    botAppearanceEntitys = [];
    if(enemyType == EnemyType.Minion){
        CreateEffect(AllPlayers(Team.All), Effect.Cloud, enemyColor,
            ep, 1.0, EffectRev.VisibleToPositionAndRadius);
        botAppearanceEntitys[0] = LastCreatedEntity();
        CreateInWorldText(
            AllPlayers(Team.All), "Minion", 
            ep, 1.0, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            Color.White, Spectators.DefaultVisibility);
        botAppearanceEntitys[1] = LastTextID();
    }
    else if(enemyType == EnemyType.Elite){
        CreateEffect(AllPlayers(Team.All), Effect.Cloud, enemyColor,
            ep, 2.0, EffectRev.VisibleToPositionAndRadius);
        botAppearanceEntitys[0] = LastCreatedEntity();
        CreateInWorldText(
            AllPlayers(Team.All), "Elite", 
            ep, 1.5, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            Color.Yellow, Spectators.DefaultVisibility);
        botAppearanceEntitys[1] = LastTextID();
    }
    else if(enemyType == EnemyType.Boss){
        CreateEffect(AllPlayers(Team.All), Effect.Cloud, enemyColor,
            ep, 4.0, EffectRev.VisibleToPositionAndRadius);
        botAppearanceEntitys[0] = LastCreatedEntity();
        CreateInWorldText(
            AllPlayers(Team.All), "Boss", 
            ep, 2.0, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            Color.Red, Spectators.DefaultVisibility);
        botAppearanceEntitys[1] = LastTextID();
    }
 if(enemyType == EnemyType.GiantBoss){
        CreateEffect(AllPlayers(Team.All), Effect.Cloud, enemyColor,
            ep, 8.0, EffectRev.VisibleToPositionAndRadius);
        botAppearanceEntitys[0] = LastCreatedEntity();
        CreateInWorldText(
            AllPlayers(Team.All), "Giant Boss", 
            ep, 2.5, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            Color.Red, Spectators.DefaultVisibility);
        botAppearanceEntitys[1] = LastTextID();
    }
}

rule: "Bot/Effect/hideBotAppearance"
Event.OngoingPlayer
Team.Team2
if(
    enemyType != EnemyType.None &&
    !IsAlive()
){
    DestroyEffect(botAppearanceEntitys[0]);
    DestroyInWorldText(botAppearanceEntitys[1]);
}

rule: "Bot/Effect/playDeadEffect"
Event.OngoingPlayer
Team.Team2
if(
    enemyType != EnemyType.None &&
    IsDead()
){
    // Play blast effect when Bot dead
    // It's easier to understand if you killed an Bot, and you'll feel better
    if(enemyType == EnemyType.Minion){
        PlayContinuousBlast(Color.Red, PositionOf(), 2, 1);
    }
    else if(enemyType == EnemyType.Elite){
        PlayContinuousBlast(Color.Red, PositionOf(), 3, 2);
    }
    else if(enemyType == EnemyType.Boss){
        PlayContinuousBlast(Color.Red, PositionOf(), 5, 3);
    }
    else if(enemyType == EnemyType.GiantBoss){
        PlayContinuousBlast(Color.Red, PositionOf(), 7, 5);
    }
}

// TAG Bot/Teleport ----------
define teleportAreaSize: 6;
define closestPlayerToTelPos: ClosestPlayerTo(teleportPosition, Team.Team1);
define closestPlayerToPortal: ClosestPlayerTo(portalPosition, Team.Team1);
define closestPlayerToMe: ClosestPlayerTo(ep, Team.Team1);
playervar define teleportPosition;

void SetTeleportPositionToPlayerFront()"SetTeleportPositionToPlayerFront"{
    // set teleport position by blind spot from player
    // find place that will be a blind spot up to 10 times
    for(pLoopIndex = 0; pLoopIndex < 10; pLoopIndex++){
        WaitReduce();

        teleportPosition =
            NearestWalkablePosition(
                PositionOf(closestPlayerToPortal)
                    + 
                (
                    DirectionTowards(closestPlayerToPortal, portalPosition)
                        *
                    DistanceBetween(closestPlayerToPortal, portalPosition, ) * 0.5
                )
                    +
                RandomPosition(teleportAreaSize, teleportAreaSize, teleportAreaSize)
            );

        if(
            DistanceBetween(    // Not too close to player
                closestPlayerToTelPos, teleportPosition)
            > 5
                &&
            IsInLineOfSight(    // Has line
                closestPlayerToTelPos, teleportPosition, BarrierLOS.NoBarriersBlock)
        ){
            break;
        }
    }
}

void SetTeleportPositionToPlayerAround()"SetTeleportPositionToPlayerAround"{
    for(pLoopIndex = 0; pLoopIndex < 10; pLoopIndex++){
        WaitReduce();
        
        teleportPosition =
            BlockedPositon(
                closestPlayerToPortal,
                DirectionFromAngles(
                    RandomReal(0, 360), 0
                ), 30
            );
        // avoid map wall edge
        teleportPosition += (DirectionTowards(teleportPosition, closestPlayerToPortal) * 0.5);
        if(
            DistanceBetween(    // Not too close to player
                closestPlayerToTelPos, teleportPosition)
            > 5
                &&
            IsInLineOfSight(    // Has line
                closestPlayerToTelPos, teleportPosition, BarrierLOS.NoBarriersBlock)
                &&
            IsBlockedBetween(   // Has ground
                teleportPosition, ShiftedPosition(teleportPosition, Down(), 6))

        ){
            break;
        }
    }
}


void PlayTeleportEffect(define isBefore)"PlayTeleportEffect"{
    // Play blast effect when Bot teleport
    if(enemyType == EnemyType.Minion){
        PlayEffect(AllPlayers(Team.All), PlayEffect.BadExplosion, enemyColor, ep, 2);
    }
    else if(enemyType == EnemyType.Elite){
        PlayEffect(AllPlayers(Team.All), PlayEffect.BadExplosion, enemyColor, ep, 3);
    }
    else if(enemyType == EnemyType.Boss){
        PlayEffect(AllPlayers(Team.All), PlayEffect.BadExplosion, enemyColor, ep, 5);
    }
    else if(enemyType == EnemyType.GiantBoss){
        PlayEffect(AllPlayers(Team.All), PlayEffect.BadExplosion, enemyColor, ep, 7);
    }
    
    // show effect at root position
    if(isBefore)
        WaitPlayEffect();
}

rule: "Bot/Teleport/teleportByPortalDisabled"
Event.OngoingPlayer
Team.Team2
if(
    HasSpawned() &&
    !portalEnable
){
    // Teleport Bot to spawn room when portal disable
    // wait show dead effect when portal closing
    Wait(deadEffectTime, WaitBehavior.AbortWhenFalse);   
    // Teleport to spawn room
    Respawn(AllPlayers(Team.Team2));
    // set root
    SetStatus(ep, null, Status.Rooted, MaxValue());
}

rule: "Bot/Teleport/teleportByPortalEnabled"
Event.OngoingPlayer
Team.Team2
if(
    HasSpawned() &&
    portalEnable
){
    // clear root
    ClearStatus(ep, Status.Rooted);
    // set teleport position
    SetTeleportPositionToPlayerFront();
    // show pre teleport effect
    PlayTeleportEffect(true);
    // Teleport
    Teleport(ep, teleportPosition);
    // show teleport effect
    PlayTeleportEffect(false);
}

rule: "Bot/Teleport/teleportByRespawn"
Event.OngoingPlayer
Team.Team2
if(
    portalEnable &&
    IsInSpawnRoom()
){
    if(
        portalState == PortalState.Suspended
    ){
        // set teleport position to camper around
        SetTeleportPositionToPlayerAround();
    }
    else{
        // set teleport position player front
        SetTeleportPositionToPlayerFront();   
    }
    // Teleport
    Teleport(ep, teleportPosition);
    // show teleport effect
    PlayTeleportEffect(false);
}

rule: "Bot/Teleport/teleportByPlayerEntered"
Event.OngoingPlayer
Team.Team2
if(
    portalEnable &&
    IsAlive() &&
    portalState == PortalState.Suspended
){
    // Teleport bot to player front
    WaitConditionConfirmed();
    // set teleport position to player around
    SetTeleportPositionToPlayerAround();
    // show pre teleport effect
    PlayTeleportEffect(true);
    // Teleport
    Teleport(ep, teleportPosition);
    // show teleport effect
    PlayTeleportEffect(false);
}

rule: "Bot/Teleport/teleportByPlayerNotFound"
Event.OngoingPlayer
Team.Team2
if(
    portalEnable &&
    IsAlive() &&
    !IsInLineOfSight(ep,
        closestPlayerToMe,
        BarrierLOS.NoBarriersBlock)
){
    // Teleport bot to player front
    Wait(6, WaitBehavior.AbortWhenFalse);

    if(
        RandomInteger(1, 100) <= 30 ||
        portalState == PortalState.Suspended
    ){
        // set teleport position player around
        SetTeleportPositionToPlayerAround();
    }
    else{
        // set teleport position player front
        SetTeleportPositionToPlayerFront();   
    }
    // show pre teleport effect
    PlayTeleportEffect(true);
    // Teleport
    Teleport(ep, teleportPosition);
    // show pre teleport effect
    PlayTeleportEffect(false);
    
    LoopIfConditionIsTrue();
}

// TAG Bot/Ultimate ----------
rule: "Bot/Ultimate/chargeUlt"
Event.OngoingPlayer
Team.Team2
if(
    HasSpawned() &&
    enemyType != EnemyType.None &&
    !IsUsingUltimate()
){
    SetUltimateCharge(ep, UltimateChargePercent() + (100 / eachChargeUltInterval));
    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}

// TAG Bot/SpawnInterval ----------
define deadEffectTime: 1.5;
playervar define confirmSpawnInterval;

void UpdateEachSpawnInterval()"UpdateEachSpawnInterval"{
    confirmSpawnInterval = eachMaxSpawnInterval;
    confirmSpawnInterval *= (1 - (portalSize / maxPortalSize));
    confirmSpawnInterval -= (roundNo / 5);
    confirmSpawnInterval = Max(confirmSpawnInterval, 0);
    SetRespawnMaxTime(ep, confirmSpawnInterval + deadEffectTime); 
}

rule: "Bot/SpawnInterval/update"
Event.OngoingPlayer
Team.Team2
if(
    portalEnable
){
    Wait(5, WaitBehavior.AbortWhenFalse);
    UpdateEachSpawnInterval();
    LoopIf(portalSize < maxPortalSize);
}

// TAG Bot/ReceivedDamage ----------
globalvar define confirmReceiveDamage;

void UpdateEachReceivedDamage()"UpdateEachReceivedDamage"{
    // If don't enough players, adjust Bot received damage rate to make the game fair
    // Multiply damage rate
    confirmReceiveDamage = 100;
    // Apply balance multiplier
    confirmReceiveDamage *= ConvertToBalancedValue(0.7, Team.Team1);
    SetDamageReceived(AllPlayers(Team.Team2), confirmReceiveDamage);
}

rule: "Bot/ReceivedDamage/updateByBalance //for game balance, increase by missing players count"
Event.OngoingGlobal
if(
    initCompleted
){
    UpdateEachReceivedDamage();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

// TAG Bot/DealtDamage ----------
playervar define confirmDealDamage;

void UpdateEachDealtDamage()"UpdateEachDealtDamage"{
    // If don't enough players, adjust Bot dealt damage rate to make the game fair
    // And the round progresses, the Bot deal damage increases and becomes more difficult
    // Add damage rate according to the round progress
    confirmDealDamage = WorkshopSettingReal("Bot Settings", "Initial Deal Damage", 30, 0, 1000, 1);
    confirmDealDamage += roundNo * WorkshopSettingReal("Bot Settings", "Increase Deal Damage Per Round Progress", 1.5, 0, 1000, 2);
    confirmDealDamage *= eachDealtDamageScale;
    // Apply balance multiplier
    confirmDealDamage /= ConvertToBalancedValue(0.7, Team.Team1);
    SetDamageDealt(ep, confirmDealDamage);
}

rule: "Bot/DealtDamage/update"
Event.OngoingPlayer
Team.Team2
if(
    HasSpawned() &&
    enemyType != EnemyType.None
){
    UpdateEachDealtDamage();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

rule: "Bot/SpawnInterval/respawnBySucide"
Event.OnDeath
Team.Team2
if(
    Attacker() == ep
){
    Wait(1, WaitBehavior.AbortWhenFalse);
    Respawn();
}

// TAG Debug ----------
globalvar define debugMode;

enum DebugMode{
    Non,
    OverloadOnly,
    ShowParam,
    WithRecord
}

rule: "Debug/changeDebugMode"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Jump) 
){
    // change debug mode
    WaitLongPressConfirm();
    if(debugMode == DebugMode.Non){
        debugMode = DebugMode.OverloadOnly;
    }
    else if(debugMode == DebugMode.OverloadOnly){
        debugMode = DebugMode.ShowParam;
    }
    else if(debugMode == DebugMode.ShowParam){
        debugMode = DebugMode.WithRecord;
    }
    else if(debugMode == DebugMode.WithRecord){
        debugMode = DebugMode.Non;
    }

    if(debugMode == DebugMode.Non){
        DisableInspectorRecording();
        HideDebugHud();
    }
    else if(debugMode == DebugMode.OverloadOnly){
        DisableInspectorRecording();
        HideDebugHud();
        ShowDebugHud();
    }
    else if(debugMode == DebugMode.ShowParam){
        DisableInspectorRecording();
        HideDebugHud();
        ShowDebugHud();
    }
    else if(debugMode == DebugMode.WithRecord){
        EnableInspectorRecording();
        HideDebugHud();
        ShowDebugHud();
    }
}

define End(): CountOf(debugHudEntitys);
define botOfEnemyType(define enemyType): FirstOf(FilteredArray(AllPlayers(Team.Team2), ae.enemyType == enemyType));
globalvar define debugHudEntitys;

// show debug icon and hud
void ShowDebugHud()"ShowDebugHud"{

    if(
        debugMode == DebugMode.ShowParam ||
        debugMode == DebugMode.WithRecord
    ){
        if(
            debugMode == DebugMode.WithRecord
        ){
            CreateHudText(HostPlayer(),
                null,
                null,
                "● is Recording",
                Location.Left, -1,
                Color.White, Color.White, Color.Red,
                HudTextRev.VisibleToAndString, Spectators.VisibleNever);
            debugHudEntitys[End()] = LastTextID();
        }

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "revive Timeout Count", reviveTimeoutCount>,
            null,
            Location.Left, -1,
            Color.White, Color.Blue, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "Regeneration Rate", playerRegenerationRateTeam1>,
            null,
            Location.Left, -1,
            Color.White, Color.Blue, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "portal State", portalState>,
            null,
            Location.Left, -1,
            Color.White, enemyColor, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "portal Size", portalSize>,
            null,
            Location.Left, -1,
            Color.White, enemyColor, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "portal Position", portalPosition>,
            null,
            Location.Left, -1,
            Color.White, enemyColor, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "distance to protal", DistanceBetween(ep, portalPosition)>,
            null,
            Location.Left, -1,
            Color.White, enemyColor, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> RcvDmg <1> DltDmg <2> SpwItv <3> ChgUlt <4>", "Boss Status",
                confirmReceiveDamage,
                botOfEnemyType(EnemyType.Boss).confirmDealDamage,
                botOfEnemyType(EnemyType.Boss).confirmSpawnInterval,
                botOfEnemyType(EnemyType.Boss).eachChargeUltInterval
            >,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> RcvDmg <1> DltDmg <2> SpwItv <3> ChgUlt <4>", "Elite Status",
                confirmReceiveDamage,
                botOfEnemyType(EnemyType.Elite).confirmDealDamage,
                botOfEnemyType(EnemyType.Elite).confirmSpawnInterval,
                botOfEnemyType(EnemyType.Elite).eachChargeUltInterval
            >,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> RcvDmg <1> DltDmg <2> SpwItv <3> ChgUlt <4>", "Minion Status",
                confirmReceiveDamage,
                botOfEnemyType(EnemyType.Minion).confirmDealDamage,
                botOfEnemyType(EnemyType.Minion).confirmSpawnInterval,
                botOfEnemyType(EnemyType.Minion).eachChargeUltInterval
            >,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>/<2>", "environment Death Count", environmentDeathCount, limitCount>,
            null,
            Location.Left, -1,
            Color.White, Color.White, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>/<2>", "no Contact Time", noContactTime, limitTime>,
            null,
            Location.Left, -1,
            Color.White, Color.White, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "Server Load", ServerLoad()>,
            null,
            Location.Left, -1,
            Color.White, Color.Orange, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "Server Load Average", ServerLoadAverage()>,
            null,
            Location.Left, -1,
            Color.White, Color.Orange, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "Server Load Peak", ServerLoadPeak()>,
            null,
            Location.Left, -1,
            Color.White, Color.Orange, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();
    }

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "current Slow Level", targetSlowLevel>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);
    debugHudEntitys[End()] = LastTextID();
}

// Hide debug icon and hud
void HideDebugHud()"HideDebugHud"{
    for(gLoopIndex = 0; gLoopIndex < CountOf(debugHudEntitys); gLoopIndex ++){
        DestroyHudText(debugHudEntitys[gLoopIndex]);
    }
}

rule: "Debug/increaseTeamLifes"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Ability2)
){
    // Increase TeamLifes
    WaitLongPressConfirm();
    teamLifes += 1;
    LoopIfConditionIsTrue();
}

rule: "Debug/increaseRoundNo"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Ability1)
){
    // Increase RoundNo
    WaitLongPressConfirm();
    roundNo += 1;
    LoopIfConditionIsTrue();
}

rule: "Debug/resetPortal // reset portal position by random"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    !IsButtonHeld(ep, Button.Reload) &&
    IsButtonHeld(ep, Button.Crouch)
){
    // Recalculate portal
    WaitLongPressConfirm();
    portalState = PortalState.Idle;
    WaitChangeState();  // Wait for the changed status to be processed first
    portalState = PortalState.Calculating;
}

globalvar define debugAimingPosition;

rule: "Debug/setPortalPositionOnAimCenter // reset portal position by aim center"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Reload) &&
    !IsButtonHeld(ep, Button.Crouch)
){
    // Set portal position to aim center
    WaitLongPressConfirm();
    portalState = PortalState.Idle;
    debugAimingPosition = AimingPosition();
    WaitChangeState();  // Wait for the changed status to be processed first
    portalState = PortalState.Calculating;
    WaitUntil(portalState != PortalState.Calculating, 5);
    portalPosition = debugAimingPosition;
}

rule: "Debug/setPortalMaxSize // reset portal position by aim center"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Reload) &&
    IsButtonHeld(ep, Button.Crouch)
){
    // Set portal position to aim center
    WaitLongPressConfirm();
    portalSize = maxPortalSize;
}
