import "PortalHunt.setting.json";
import "Lib/Debug.del";
import "Lib/Utility.del";
import "Lib/ElapsedTimer.del";
import "Lib/DamageText.del";
import "Lib/Regeneration.del";
import "Lib/Revive.del";
import "Lib/Bot.del";
import "Lib/PerkChooser.del";

// // TAG duumy define ----------
// globalvar define perkCorePerkDropProbability;
// globalvar define eachPerkDropProbability;

// TAG Signature and infomation ----------
disabled rule: "PORTAL HUNT -HORDE PVE [ver 4.0] Share code [YY1N2]"-1{}
disabled rule: "You allowed copy or modify code."-1{}
disabled rule: "This script was generated by [Overwatch-Script-To-Workshop] tools"-1{}
disabled rule: "Check detail with https://github.com/ItsDeltin/Overwatch-Script-To-Workshop"-1{}
disabled rule: "Original source code was created by [sarami77#1868]"-1{}
disabled rule: "Check detail with https://github.com/sarami77/OverwatchWorkShopScripts"-1{}

// TAG Initialize ----------
globalvar define initCompleted!;

rule: "Initialize/initialize"
Event.OngoingGlobal
{
    // Stop records to reduce server load
    DisableInspectorRecording();

    // If run it right after loading the server, some scripts fail, so wait 3 seconds
    Wait(3, WaitBehavior.AbortWhenFalse);

    // Cancel unnecessary default settings
    PauseMatchTime();
    DisableScoring();
    DisableCompletion();

    // Set team lives property
    initialTeamLives =                      WorkshopSettingInteger("Player Settings", "Initial team lives",                     6, 0, 1000, 0);
    maxTeamLives =                          WorkshopSettingInteger("Player Settings", "Max stock team lives",                   12, 0, 1000, 1);

    // Set imported functions public property for user tuning
    // Regeneration.del
    regenerationEnableTeam = Team.Team1;
    regenerationNeedBalanceTeam1 = true;
    regenerationStartWaitSecondTeam1 =      WorkshopSettingReal("Player Settings", "Regeneration Start Wait Second",            3, 0, 100, 2);
    regenerationHealthPerSecondTeam1 =      WorkshopSettingReal("Player Settings", "Regeneration Health Per Second",            25, 0, 1000, 3);
    // Revive.del
    reviveEnableTeam = Team.Team1;
    reviveTimeLimit =                       WorkshopSettingReal("Player Settings", "Revive Time Limit",                         10, 0, 100, 4);
    reviveRange =                           WorkshopSettingReal("Player Settings", "Revive Range",                              3, 0, 100, 5);
    reviveCompleteSecond =                  WorkshopSettingReal("Player Settings", "Revive Complete Second",                    5, 0, 100, 6);
    // DamageText.del
    damageTextEnableTeam = Team.Team2;
    // ElapsedTimer.del
    elapsedTimerEnable = true;
    // PerkCore.del
    perkCorePerkDropProbability =           WorkshopSettingReal("Perk Settings", "Perk Crate Drop Rate Scale When Enemy Dead",  1.0, 0, 100, -1);

    // Start watch over load
    slowControlHandler = SlowControlHandler.ServerOverLoadMeasures;

    // show version and share code
    CreateHudText(AllPlayers(Team.Team1),
        null, "PORTAL HUNT -HORDE PVE [ver 4.0] Share code [YY1N2]", null,
        Location.Left, -3,
        Color.White, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);

    // show hero change operation
    CreateHudText(AllPlayers(Team.Team1),
        null, <"Hold reload button <0> to change hero", ButtonGuide(Button.Reload)>, null,
        Location.Left, -2,
        Color.Yellow, Color.Yellow, Color.Yellow,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);

    // show round number
    CreateHudText(AllPlayers(),
        <"<0> <1>", "Round", roundNo>, null, null,
        Location.Top, 2,
        enemyColor, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleAlways);

    // show HUD of team Lives
    CreateHudText(AllPlayers(),
        teamLives < maxTeamLives ? 
            <"Team Lives <0>", teamLives> :
            <"Team Lives <0> (Max Stock)", teamLives>,
        null, null,
        Location.Top, 3,
        Color.Team1, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleAlways);

    // show HUD of enemy team assembly
    CreateHudText(AllPlayers(),
        null,
        null,
        <"Enemy Team Assembly \"<0>\"", enemyTeamName>,
        Location.Right, -1,
        Color.White, Color.White, Color.Purple,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);

    // Notify completion of init game setting and start game main logic
    initCompleted = true;

    // failsafe action
    while(true){
        // repeat action for joined player
        // set objective message
        SetObjectiveDescription(AllPlayers(Team.Team1), "Find portal and close it!", HudTextRev.None);
        Wait(10, WaitBehavior.AbortWhenFalse);
    } 
}

// TAG ServerOverLoadMeasures ----------
define WaitUntilServerFree(){ WaitUntil(!isServerOverLoading, 5); }

define slowLevel: [100, 90, 80, 70, 50];    // 0～4
globalvar define targetSlowLevel;
globalvar define currentSlowLevel;
globalvar define slowControlHandler;
enum SlowControlHandler{
    None,
    ServerOverLoadMeasures,
    PlayerJoin,
    GameEnd
}

rule: "ServerOverLoadMeasures/increaseSlowLevel"
Event.OngoingGlobal
if(
    initCompleted &&    
    slowControlHandler == SlowControlHandler.ServerOverLoadMeasures &&
    isServerOverLoading &&
    targetSlowLevel < (CountOf(slowLevel) - 1)
){
    // If the server is overloaded,
    //  apply slow motion every second
    //  to reduce the load to avoid shutting down due to server overload.
    Wait(1, WaitBehavior.AbortWhenFalse);
    // can increase slow level
    if(targetSlowLevel < (CountOf(slowLevel) - 1)){
        // increase slow level
        targetSlowLevel ++;
        // apply slow level
        ApplySlowLevel(targetSlowLevel);
    }
    LoopIfConditionIsTrue();
}

rule: "ServerOverLoadMeasures/decreaseSlowLevel"
Event.OngoingGlobal
if(
    initCompleted &&
    slowControlHandler == SlowControlHandler.ServerOverLoadMeasures &&
    !isServerOverLoading &&
    targetSlowLevel > 0
){
    // If the server is not overloaded,
    //  reset slow motion every second
    // can decrease slow level
    Wait(0.75, WaitBehavior.AbortWhenFalse);
    if(targetSlowLevel > 0){
        // decrease slow level
        targetSlowLevel --;
        // apply slow level
        ApplySlowLevel(targetSlowLevel);
    }
    LoopIfConditionIsTrue();
}

void ApplySlowLevel(define setSlowLevel)"ApplySlowLevel"{
    // if slow level changed
    if(currentSlowLevel != setSlowLevel){
        // apply slow motion
        currentSlowLevel = setSlowLevel;
        SetSlowMotion(slowLevel[setSlowLevel]);
    }
}

// TAG Game ----------
globalvar define roundNo!;

rule: "Game/initGame"
Event.OngoingGlobal
if(
    initCompleted
){
    // reset team Lives
    teamLives = initialTeamLives;
    // reset round no 
    roundNo = 0;
    // reset elapsed time
    elapsedTime = 0;
    // reset portal
    portalState = PortalState.Init;
}

rule: "Game/startGame"
Event.OngoingGlobal
if(
    initCompleted &&
    portalState == PortalState.Init &&
    NumberOfPlayers(Team.Team1) > 0 &&
    IsTrueForAny(
        AllPlayers(Team.Team1),
        (
            !IsInSpawnRoom(ae) &&
            IsMoving(ae)
        )
    )
){
    // reset elapsed time
    elapsedTime = 0;
    // reset prevPortalPosition
    prevPortalPosition = PositionOf(FirstOf(AllPlayers(Team.Team1)));
    // start portal creation
    portalState = PortalState.Calculating;
}

rule: "Game/stopGame"
Event.OngoingGlobal
if(
    initCompleted &&
    portalState != PortalState.Init &&
    NumberOfPlayers(Team.Team1) <= 0
){
    // reset team Lives
    teamLives = initialTeamLives;
    // reset round no
    roundNo = 0;
    // reset elapsed time
    elapsedTime = 0;
    // reset portal
    portalState = PortalState.Init;
}

rule: "Game/SpawnRoom/changeByTimer"
Event.OngoingGlobal
if(
    initCompleted
){
    // Change the spawn room regularly to keep the game fluid
    ForceSpawnRoom(Team.Team1, RandomValueInArray([0, 1, 2]));
    ForceSpawnRoom(Team.Team2, RandomValueInArray([0, 1, 2]));
    Wait(300, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

// TAG Player ----------
playervar define isInsidePortal!;

// TAG Player/ReturnSpawnRoom
rule: "Player/ReturnSpawnRoom/return"
Event.OngoingPlayer
Team.Team1
if(
    IsAlive() &&
    !IsInSpawnRoom() &&
    IsButtonHeld(ep, Button.Reload)
){
    AbortIf(!IsOnGround());
    // Return to spawn room with long hold on reload button
    WaitCancelPressConfirm();
    Respawn();
}

// TAG Player/FisrtFast
playervar define nowDead;

rule: "Player/FisrtFast/setNowDead"
Event.OngoingPlayer
Team.Team1
if(
    !IsAlive()
){
    nowDead = true;
}

rule: "Player/FisrtFast/setFastSpeed"
Event.OngoingPlayer
Team.Team1
if(
    nowDead &&
    IsAlive() &&
    IsInSpawnRoom()
){
    SetMoveSpeed(ep, 150);
    while(!IsInLineOfSight(ep, ClosestPlayerTo(ep, Team.Team2))){
        Wait(1, WaitBehavior.IgnoreCondition);
    }
    SetMoveSpeed(ep, 100);
}

// TAG Player/TeamLives
globalvar define initialTeamLives!;
globalvar define teamLives!;
globalvar define maxTeamLives!;

rule: "Player/TeamLives/consumeTeamLives"
Event.OngoingGlobal
if(
    0 < reviveTimeoutCount
){
    WaitConditionConfirmed();
    teamLives -= reviveTimeoutCount;
    WaitChangeState();  // wait for show big message by newest value
    if(teamLives > 0){
        BigMessage(AllPlayers(),
            <"<0> team lives remaining...", teamLives>);

        PlayEffect(
            AllPlayers(), PlayEffect.DebuffImpactSound,
            Color.White, portalPosition, MaxLength());
    }
    reviveTimeoutCount = 0;
    LoopIfConditionIsTrue();
}

rule: "Player/TeamLives/finishGame"
Event.OngoingGlobal
if(
    initCompleted &&
    teamLives <= 0
){
    WaitConditionConfirmed();
    // play game end portal effect
    portalState = PortalState.End;
    // set slow handler
    slowControlHandler = SlowControlHandler.GameEnd;

    BigMessage(AllPlayers(), "Team lives ran out...");
    SetSlowMotion(10);
    Wait(1, WaitBehavior.AbortWhenFalse);   // show slow
    SetSlowMotion(100);
    WaitNextPhase();

    BigMessage(AllPlayers(),
        <"We reached <0> round... good game!", roundNo>);
    PlayRandomEmote(AllPlayers(Team.Team1));
    WaitNextPhase();

    DeclareTeamVictory(Team.Team1);
}

rule: "Player/TeamLives/protectTeamLifeConsumeBySucide"
Event.OnDeath
Team.Team1
if(
    Attacker() == ep
){
    if(
        DistanceBetween(ep, ClosestPlayerTo(ep, Team.Team2)) > 20
    ){
        Respawn();
    }
}

// TAG Player/InsidePortal
rule: "Player/InsidePortal/update"
Event.OngoingGlobal
if(
    portalEnable
){
    define players! = AllPlayers(Team.Team1);
    // Set flag when player entered to portal
    // This flag is used for functions related to portal
    for(gLoopIndex = 0; gLoopIndex < CountOf(players); gLoopIndex++){
        if(
            HasSpawned(players[gLoopIndex]) &&
            IsAlive(players[gLoopIndex]) &&
            !IsInSpawnRoom(players[gLoopIndex]) &&
            DistanceBetween(players[gLoopIndex], portalPosition) <= portalSize
        ){
            players[gLoopIndex].isInsidePortal = true;
        }
        else{
            players[gLoopIndex].isInsidePortal = false;
        }
    }
    WaitUntilServerFree();
    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}

// TAG Player/ClosePortal
globalvar define closingCount;
globalvar define closingProgress;
globalvar define closingProgressHudEntity;
globalvar define playerNumInsidePortal;

define enableClosingProgress:
    portalState == PortalState.UnderAttack &&
    teamLives > 0;

rule: "Player/ClosePortal/startClosing"
Event.OngoingGlobal
if(
    enableClosingProgress
){
    // When a player enters a portal, set progress hud and show message
    WaitConditionConfirmed();
    // kick progress
    closingCount = 1;
    closingCount += portalSize * 1;
    closingCount += roundNo * 5;
    closingCount = RoundToInteger(closingCount);
    closingProgress = 0;
    ChaseVariableOverTime(closingProgress, DefaultPercentage(), closingCount, TimeChaseReevaluation.DestinationAndDuration);
    // show progress hud
    if(closingProgressHudEntity == null){
        CreateProgressBarHudText(
            AllPlayers(),
            closingProgress,
            <"<0> player has surviving in portal. Until portal closes...", playerNumInsidePortal >,
            Location.Top, 4,
            Color.White,
            Color.White,
            ProgressBarHudEvaluation.Values,
            Spectators.DefaultVisibility );
        closingProgressHudEntity = LastTextID();
    }
    define closestPlayerPortal! = ClosestPlayerFromPortal();
    // show big message
    BigMessage(
        closestPlayerPortal,
        <"You are closing portal... Stay inside and Survive!">);
    BigMessage(
        FilteredArray(AllPlayers(Team.Team1), (closestPlayerPortal != ae)),
        <"<0> <1> <2>",
            closestPlayerPortal,
            HeroIconString(HeroOf(closestPlayerPortal)),
            "closing portal... Cover one!">);
    // Wait closingCount
    Wait(closingCount, WaitBehavior.AbortWhenFalse);
    portalState = PortalState.Closing;
}

rule: "Player/ClosePortal/updatePlayerNumInsidePortal"
Event.OngoingGlobal
if(
    enableClosingProgress
){
    playerNumInsidePortal = CountOf(
        FilteredArray(
            AllPlayers(Team.Team1),
            ae.isInsidePortal
        )
    );
    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}

rule: "Player/ClosePortal/cancelClosing //on exit every player"
Event.OngoingGlobal
if(
    !enableClosingProgress
){
    StopChasingVariable(closingProgress);
    // wait hide hud when progress completed
    if(closingProgress == 100){
        Wait(1.5, WaitBehavior.AbortWhenFalse);
    }
    DestroyProgressBarHudText(closingProgressHudEntity);
    closingProgressHudEntity = null;
}

rule: "Player/ClosePortal/finishClose //on count down finished"
Event.OngoingGlobal
if(
    (
        portalState == PortalState.Closing ||
        portalState == PortalState.Closed
    ) &&
    teamLives > 0
){
    WaitConditionConfirmed();
    // When the countdown is complete, clear the portal and give team Lives.
    // Later, we will generate a new portal and start the next round.
    WaitPlayEffect();   //wait portal closing effect
    portalState = PortalState.Closed;
    WaitNextPhase();

    // if lower than max
    if(teamLives < maxTeamLives){
        // play got life sound
        PlayEffect(
            AllPlayers(), PlayEffect.BuffImpactSound,
            Color.White, portalPosition, MaxLength()
        );
        // show got life sound message
        BigMessage(AllPlayers(), "We earned extra team lives!");
        // add life
        teamLives += 1;
    }
    WaitNextPhase();

    PlayRandomVoiceLine(AllPlayers(Team.Team1));
    roundNo += 1;
    BigMessage(AllPlayers(), <"Round <0>", roundNo>);
    WaitBigMessageHide();
    portalState = PortalState.Calculating;  // start next portal create
}

// TAG Player/FairPlay
rule: "Player/FairPlay/disableStealthWhenInside //sombra's stealth for fair play"
Event.OngoingPlayer
Team.Team1
if(
    isInsidePortal &&
    IsStealth(ep)
){
    // Some abilities are disabled inside the portal to make the game fair
    // Sombra stealth is exactly that
    Wait(5.0, WaitBehavior.AbortWhenFalse); // disable ability check cycle
    SetStatus(ep, null, Status.Stunned, 0.1);
    SmallMessage(ep, "Stealth has been interrupted by the portal!");
    LoopIfConditionIsTrue();
}

rule: "Player/FairPlay/disableGrappleClawWhenInside // wreckingBball's grapple claw for fair play"
Event.OngoingPlayer
Team.Team1
if(
    isInsidePortal &&
    IsGrapple(ep)
){
    // Some abilities are disabled inside the portal to make the game fair
    // WreckingBall Grapple is exactly that
    Wait(5.0, WaitBehavior.AbortWhenFalse); // disable ability check cycle
    SetStatus(ep, null, Status.Stunned, 0.1);
    SmallMessage(ep, "Grappling hook has been interrupted by the portal!");
    LoopIfConditionIsTrue();
}

// TAG Portal Function ----------
define enemyColor: Color.Purple;

globalvar define portalState;
enum PortalState{
    Non,
    Init,
    Calculating,
    Checking,
    Set,
    Growing,
    UnderAttack,
    Closing,
    Closed,
    End
}

globalvar define portalPosition;
globalvar define portalSize;
globalvar define portalEntitys;
globalvar define isFirstGrowing;

define portalEnable:
    portalState == PortalState.Checking ||
    portalState == PortalState.Set ||
    portalState == PortalState.Growing ||
    portalState == PortalState.UnderAttack;

rule: "Portal/State/Calculating"
Event.OngoingGlobal
if(
    portalState == PortalState.Calculating
){
    // Hide Portal Entity until portal state changed to Show
    // Init param
    StopChasingVariable(portalSize);
    portalPosition = 0;
    portalSize = 0;
    isFirstGrowing = true;
    // Hide portal icon and effect
    DestroyIcon(portalEntitys[0]);
    DestroyEffect(portalEntitys[1]);
    DestroyEffect(portalEntitys[2]);
    DestroyEffect(portalEntitys[3]);
    DestroyEffect(portalEntitys[4]);
}




define showPortalPlayers:
    AllPlayers();

define showPortalIconPlayers:
    FilteredArray(AllPlayers(Team.Team1), DistanceBetween(ae, portalPosition) > maxPortalSize);

define showPortalInsidePlayers:
    FilteredArray(AllPlayers(Team.Team1), !ae.isInsidePortal);

rule: "Portal/State/Set  // waiting for found by players"
Event.OngoingGlobal
if(
    portalState == PortalState.Set
){
    DestroyIcon(portalEntitys[0]);
    // show Portal Entity by portal state changed to Show
    // Init param
    closingCount = 0;
    // show icon
    portalEntitys = [];
    portalEntitys[0] = CreateIcon(showPortalIconPlayers, portalPosition, Icon.Spiral,
        IconRev.VisibleToPositionAndColor, enemyColor, true);
    // set effect
    // sphere
    portalEntitys[1] = CreateEffect(showPortalPlayers, Effect.Sphere, enemyColor,
        portalPosition, portalSize, EffectRev.VisibleToPositionAndRadius);
    // cloud
    portalEntitys[2] = CreateEffect(showPortalInsidePlayers, Effect.Cloud, enemyColor,
        portalPosition, portalSize * 1.5, EffectRev.VisibleToPositionAndRadius);
    // aura
    // Since visibility will be poor, display only in the center of the field of view
    portalEntitys[3] = CreateEffect(showPortalInsidePlayers, Effect.BadAura, enemyColor,
        portalPosition, portalSize * 1.25, EffectRev.VisibleToPositionAndRadius);
    // sound
    portalEntitys[4] = CreateEffect(AllPlayers(), Effect.EnergySound, enemyColor,
        portalPosition, portalSize / 2, EffectRev.VisibleToPositionAndRadius);
    // show message
    BigMessage(AllPlayers(), "Defeat enemies and track portal!");
}

rule: "Portal/State/Growing"
Event.OngoingGlobal
if(
    portalState == PortalState.Growing
){
    // Start growing portal with warning message
    ChaseVariableAtRate(
        portalSize, maxPortalSize, 1 + (roundNo / 6),
        RateChaseReevaluation.DestinationAndRate);  // startGrowing
    // If first growing, show message
    if(isFirstGrowing == true){
        isFirstGrowing = false;
        BigMessage(AllPlayers(), "Portal is growing... hurry!");
        WaitBigMessageHide();
        BigMessage(AllPlayers(), "Larger portals spawn more enemies and are tougher to close...");
    }
}

rule: "Portal/State/Suspended"
Event.OngoingGlobal
if(
    portalState == PortalState.UnderAttack
){
    // Stop growing portal
    Wait(1, WaitBehavior.AbortWhenFalse);
    StopChasingVariable(portalSize);
}

rule: "Portal/State/Closing"
Event.OngoingGlobal
if(
    portalState == PortalState.Closing
){
    // Hide icon
    DestroyIcon(portalEntitys[0]);
    // apply blast impulse
    ApplyBlastImpulse(AllPlayers(Team.Team2), portalPosition, portalSize);
    // play portal closing effect and kill enemrys
    Kill(AllPlayers(Team.Team2), null);
    // play blast sound
    PlayEffect(
        AllPlayers(), PlayEffect.RingExplosionSound,
        Color.White, portalPosition, MaxLength());
    // play blast effect
    PlayContinuousBlast(
        Color.Yellow,
        portalPosition,
        portalSize * 1.5,
        10);
}

rule: "Portal/State/Closed"
Event.OngoingGlobal
if(
    portalState == PortalState.Closed
){
    // show message
    BigMessage(AllPlayers(), "Portal closed... nice work!");
    // init param
    portalPosition = 0;
    portalSize = 0;
    StopChasingVariable(portalSize);
    // Hide portal icon and effect
    DestroyIcon(portalEntitys[0]);
    DestroyEffect(portalEntitys[1]);
    DestroyEffect(portalEntitys[2]);
    DestroyEffect(portalEntitys[3]);
    DestroyEffect(portalEntitys[4]);
}

rule: "Portal/State/End"
Event.OngoingGlobal
if(
    portalState == PortalState.End
){
    // apply blast impulse
    ApplyBlastImpulse(AllPlayers(Team.Team2), portalPosition, portalSize);
    // play portal closing effect and kill enemrys
    Kill(AllPlayers(Team.Team2), null);
    // play blast sound
    PlayEffect(
        AllPlayers(), PlayEffect.RingExplosionSound,
        Color.White, portalPosition, MaxLength());
    // play blast effect
    PlayContinuousBlast(
        Color.Yellow,
        portalPosition,
        portalSize * 1.5,
        10);

    // init param
    portalPosition = 0;
    portalSize = 0;
    StopChasingVariable(portalSize);
    // Hide portal icon and effect
    DestroyIcon(portalEntitys[0]);
    DestroyEffect(portalEntitys[1]);
    DestroyEffect(portalEntitys[2]);
    DestroyEffect(portalEntitys[3]);
    DestroyEffect(portalEntitys[4]);
}

rule: "Portal/Positioner/createPortal"
Event.OngoingGlobal
if(
    teamLives > 0 &&
    portalState == PortalState.Calculating
){
    WaitConditionConfirmed();
    define candidatePosition!;
    for(define retryCount = 0; retryCount < 30; retryCount++){
        // select random player as base positoon
        define basePlayer =
            RandomValueInArray(
                FilteredArray(
                    AllLivingPlayers(Team.Team1),
                    HasSpawned(ae)
                )
            );
        // select random positon from player around
        define distance! =
            DistanceBetween(
                SpawnPoints(Team.Team1)[0],
                SpawnPoints(Team.Team2)[0]
            );
        define randomPositon! = 
            basePlayer +
            // half y derection
            VectorScaledY(
                // add random direction
                DirectionFromAngles(
                    RandomReal(0, 360), RandomReal(30, -30),
                ) * 
                // add random distance
                RandomReal(distance / 2, distance),
                0.25
            );

        // convert to walkble position
        candidatePosition = NearestWalkablePosition(randomPositon);
        // move candidate postion in the direction of player for avoiding map edge
        candidatePosition += DirectionTowards(candidatePosition, basePlayer) * RandomReal(1, distance / 3);
        // convert to walkble position
        candidatePosition = NearestWalkablePosition(candidatePosition);

        if(
            // close candidate postion than random positon
            (
                DistanceBetween(basePlayer, randomPositon) >= 
                DistanceBetween(basePlayer, candidatePosition) + 10
            )
                &&
            // far postion from previous position
            (
                DistanceBetween(prevPortalPosition, candidatePosition) >= 50
            )
                &&
            // far postion from player
            (
                DistanceBetween(
                    ClosestPlayerTo(candidatePosition, Team.Team1),
                    candidatePosition
                ) >= 50
            )
        ){
            break;
        }
        Wait(0.1, WaitBehavior.AbortWhenFalse);
        WaitUntilServerFree();
    }
    // confirm as portal position
    portalPosition = candidatePosition;
    // create portal, next check position
    portalState = PortalState.Checking;
    // fail safe
    Wait(5, WaitBehavior.AbortWhenFalse);
	dbgMsg("failsafe triggered of createPortal");
    LoopIfConditionIsTrue();
}
globalvar define prevPortalPosition;

rule: "Portal/Positioner/positionChecking"
Event.OngoingGlobal
if(
    teamLives > 0 &&
    portalState == PortalState.Checking
){
    // wait
    Wait(1, WaitBehavior.AbortWhenFalse);
    // confirm portal position
    prevPortalPosition = portalPosition;
    portalState = PortalState.Set;
    // fail safe
    Wait(5, WaitBehavior.AbortWhenFalse);
    dbgMsg("failsafe triggered of positionChecking");
    LoopIfConditionIsTrue();
}

// TAG Portal/InvalidDetect/InsideRespawnRoom ----------
rule: "Portal/InvalidDetect/InsideRespawnRoom/resetPortal"
Event.OngoingGlobal
if(
    portalEnable &&
    IsTrueForAny(
        SpawnPoints(Team.Team1),
        (
            IsInLineOfSight(ae + Up(), portalPosition)
        )
    )
){
    WaitConditionConfirmed();
    dbgMsg("reset Portal By Inside Respawn Room");
    portalState = PortalState.Calculating;
}

// TAG Portal/InvalidDetect/EnvironmentDeathCount ----------
define environmentDeathLimit: NumberOfPlayers(Team.Team2) + 1;
globalvar define environmentDeathCount!;

rule: "Portal/InvalidDetect/EnvironmentDeathCount/resetCount"
Event.OngoingGlobal
if(
    !portalEnable &&
    environmentDeathCount > 0
){
    environmentDeathCount = 0;
}

rule: "Portal/InvalidDetect/EnvironmentDeathCount/countup"
Event.OnDeath
Team.Team2
if(
    portalEnable &&
    (
        Attacker() == ep ||         // sucide
        IsInSpawnRoom(Attacker())   // killer in res room
    )
){
    // change room for avoid kill in res room
    ForceSpawnRoom(Team.Team1, RandomValueInArray([0, 1, 2]));
    // sucide
    if(Attacker() == ep)
        environmentDeathCount += 1;
    // killer in res room
    else if(IsInSpawnRoom(Attacker()))
        environmentDeathCount += 3;
}

rule: "Portal/InvalidDetect/EnvironmentDeathCount/reduceCount"
Event.OngoingGlobal
if(
    portalEnable &&
    0 < environmentDeathCount
){
    Wait(3, WaitBehavior.AbortWhenFalse);
    environmentDeathCount --;
    LoopIfConditionIsTrue();
}

rule: "Portal/InvalidDetect/EnvironmentDeathCount/resetPortal"
Event.OngoingGlobal
if(
    portalEnable &&
    environmentDeathLimit <= environmentDeathCount
){
    WaitConditionConfirmed();
    dbgMsg("reset Portal By Environment Death Count");
    portalState = PortalState.Calculating;
}

// TAG Portal/InvalidDetect/CantContact ----------
define limitTime: 100;
globalvar define notContactTime!;

rule: "Portal/InvalidDetect/NotContactTime/resetTime"
Event.OngoingGlobal
if(
    !portalEnable
){
    WaitConditionConfirmed();
    notContactTime = 0;
}

rule: "Portal/InvalidDetect/NotContactTime/countup"
Event.OngoingGlobal
if(
    portalEnable &&
    notContactTime != -1  &&
    limitTime > notContactTime
){
    WaitUpdateMediumCycle();
    notContactTime ++;
    LoopIfConditionIsTrue();
}

rule: "Portal/InvalidDetect/NotContactTime/detectContact"
Event.OngoingGlobal
if(
    portalState == PortalState.UnderAttack
){
    notContactTime = -1;
}

rule: "Portal/InvalidDetect/NotContactTime/resetPortal"
Event.OngoingGlobal
if(
    portalEnable &&
    limitTime <= notContactTime
){
    WaitConditionConfirmed();
    dbgMsg("reset Portal By No Contact");
    portalState = PortalState.Calculating;
}

// TAG Portal/Growing ----------
define maxPortalSize: 70;
define portalStableTime: 40;

rule: "Portal/Growing/startGrowingByPlayerFound"
Event.OngoingGlobal
if(
    portalState == PortalState.Set
){
    if(
        IsInLineOfSight(portalPosition,
            ClosestPlayerFromPortal(),
            BarrierLOS.NoBarriersBlock)
    ){
        WaitConditionConfirmed();
        // start portal growing by player found
        portalState = PortalState.Growing;
    }
    else{
        WaitUpdateMediumCycle();
        WaitUntilServerFree();
        LoopIfConditionIsTrue();
    }
}

rule: "Portal/Growing/startGrowingByTimeout"
Event.OngoingGlobal
if(portalState == PortalState.Set){
    // Start portal growing by search time limit out
    Wait(portalStableTime, WaitBehavior.AbortWhenFalse);  //wait time to start growing
    portalState = PortalState.Growing;
}

rule: "Portal/Growing/suspendGrowingByPlayerEntered"
Event.OngoingGlobal
if(
    portalState == PortalState.Growing &&
    IsTrueForAny(
        AllPlayers(Team.Team1), ae.isInsidePortal
    )
){
    // Suspend portal growing by player enter to portal
    WaitConditionConfirmed();
    portalState = PortalState.UnderAttack;
}

rule: "Portal/Growing/resumeGrowingByPlayerExited"
Event.OngoingGlobal
if(
    portalState == PortalState.UnderAttack &&
    !IsTrueForAny(
        AllPlayers(Team.Team1), ae.isInsidePortal
    )
){
    // Resume portal growing by player exit from portal
    WaitConditionConfirmed();
    portalState = PortalState.Growing;
}

// TAG EnemyBot ----------
define assetList:
    [

        [
            "tank boss",
            [EnemyType.Boss,        RandomTankHero,     1],
            [EnemyType.Elite,       RandomDamageHero,   1],
            [EnemyType.Elite,       RandomDamageHero,   1],
            [EnemyType.Minion,      RandomSupportHero,  3]
        ],
        [
            "support boss",
            [EnemyType.Boss,        RandomSupportHero,  1],
            [EnemyType.Elite,       RandomTankHero,     1],
            [EnemyType.Elite,       RandomTankHero,     1],
            [EnemyType.Minion,      RandomDamageHero,   3]
        ],
        [
            "damage boss",
            [EnemyType.Boss,        RandomDamageHero,   1],
            [EnemyType.Elite,       RandomSupportHero,  1],
            [EnemyType.Elite,       RandomSupportHero,  1],
            [EnemyType.Minion,      RandomTankHero,     3]
        ],
        [
            "damage boss",
            [EnemyType.Boss,        RandomDamageHero,   1],
            [EnemyType.Elite,       RandomTankHero,     1],
            [EnemyType.Elite,       RandomTankHero,     1],
            [EnemyType.Minion,      RandomSupportHero,  3]
        ],
        [
            "five minions",
            [EnemyType.Boss,        RandomDamageHero,   1],
            [EnemyType.Minion,      RandomDamageHero,   5]
        ],
        [
            "four elites",
            [EnemyType.Elite,       RandomTankHero,     1],
            [EnemyType.Elite,       RandomTankHero,     1],
            [EnemyType.Elite,       RandomDamageHero,   1],
            [EnemyType.Elite,       RandomDamageHero,   1],
            [EnemyType.Minion,      RandomSupportHero,  1],
            [EnemyType.Minion,      RandomSupportHero,  1]
        ],
        [
            "four elites",
            [EnemyType.Elite,       RandomSupportHero,  1],
            [EnemyType.Elite,       RandomSupportHero,  1],
            [EnemyType.Elite,       RandomTankHero,     1],
            [EnemyType.Elite,       RandomTankHero,     1],
            [EnemyType.Minion,      RandomDamageHero,   1],
            [EnemyType.Minion,      RandomDamageHero,   1]
        ],
        [
            "four elites",
            [EnemyType.Elite,       RandomDamageHero,   1],
            [EnemyType.Elite,       RandomDamageHero,   1],
            [EnemyType.Elite,       RandomSupportHero,  1],
            [EnemyType.Elite,       RandomSupportHero,  1],
            [EnemyType.Minion,      RandomTankHero,     1],
            [EnemyType.Minion,      RandomTankHero,     1]
        ],        
        [
            "double bosses",
            [EnemyType.Boss,        RandomTankHero,     1],
            [EnemyType.Boss,        RandomDamageHero,   1],
            [EnemyType.Minion,      RandomSupportHero,  4]
        ],
        [
            "double bosses",
            [EnemyType.Boss,        RandomSupportHero,  1],
            [EnemyType.Boss,        RandomTankHero,     1],
            [EnemyType.Minion,      RandomDamageHero,   4]
        ],
        [
            "double bosses",
            [EnemyType.Boss,        RandomDamageHero,   1],
            [EnemyType.Boss,        RandomSupportHero,  1],
            [EnemyType.Minion,      RandomTankHero,     4]
        ],

        [
            "clones",
            [EnemyType.Boss,        someHero, 		    1],
            [EnemyType.Elite,       someHero, 		    2],
            [EnemyType.Minion,      someHero, 		    3]
        ],
        [
            "double boss clones",
            [EnemyType.Boss,        someHero, 		    1],
            [EnemyType.Boss,        someHero, 		    1],
            [EnemyType.Elite,       someHero, 		    2]
        ],
        [
            "four elite clones",
            [EnemyType.Elite,       someHero, 		    4],
            [EnemyType.Minion,      someHero, 		    2]
        ],

        [
            "giant boss",
            [EnemyType.GiantBoss,   RandomTankHero,     1]
        ],
        [
            "giant boss",
            [EnemyType.GiantBoss,   RandomDamageHero,   1]
        ],		
        [
            "giant boss",
            [EnemyType.GiantBoss,   RandomSupportHero,  1],
            [EnemyType.Minion,      RandomSupportHero,  2]
        ],

        [
            "giant boss",
            [EnemyType.GiantBoss,   Hero.Pharah,  1]
        ],
        [
            "giant boss",
            [EnemyType.GiantBoss,   Hero.Reinhardt,  1]
        ],
        [
            "giant boss",
            [EnemyType.GiantBoss,   Hero.Sigma,     1]
        ],
        [
            "giant boss",
            [EnemyType.GiantBoss,   Hero.Doomfist,  1]
        ],

        [
            "close range",
            [EnemyType.Boss,        Hero.Reaper,        1],
            [EnemyType.Elite,       Hero.Roadhog,       2],
            [EnemyType.Elite,       Hero.Doomfist,      1],
            [EnemyType.Minion,      Hero.Mei,           2]
        ],
        [
            "close range",
            [EnemyType.Boss,        Hero.Mei,           1],
            [EnemyType.Elite,       Hero.Doomfist,      2],
            [EnemyType.Elite,       Hero.Roadhog,       1],
            [EnemyType.Minion,      Hero.Reaper,        2]
        ],
        [
            "close range",
            [EnemyType.Boss,        Hero.Doomfist,      1],
            [EnemyType.Elite,       Hero.Mei,           2],
            [EnemyType.Elite,       Hero.Reaper,        1],
            [EnemyType.Minion,      Hero.Roadhog,       2]
        ],
        [
            "melees",
            [EnemyType.Boss,        Hero.Reinhardt,     1],
            [EnemyType.Elite,       Hero.Doomfist,      2],
            [EnemyType.Elite,       Hero.Mercy,         1],
            [EnemyType.Minion,      Hero.Brigitte,      2]
        ],
        [
            "melees",
            [EnemyType.Boss,        Hero.Doomfist,      1],
            [EnemyType.Elite,       Hero.Reinhardt,     1],
            [EnemyType.Elite,       Hero.Brigitte,      2],
            [EnemyType.Minion,      Hero.Mercy,         2]
        ],
        [
            "flankers",
            [EnemyType.Boss,        Hero.Soldier76,     1],
            [EnemyType.Elite,       Hero.Doomfist,      1],
            [EnemyType.Elite,       Hero.Genji,         1],
            [EnemyType.Minion,      Hero.Tracer,        3]
        ],
        [
            "flankers",
            [EnemyType.Boss,        Hero.Genji,         1],
            [EnemyType.Elite,       Hero.Doomfist,      1],
            [EnemyType.Elite,       Hero.Tracer,        1],
            [EnemyType.Minion,      Hero.Soldier76,     3]
        ],
        [
            "long range",
            [EnemyType.Boss,        Hero.Orisa, 		1],
            [EnemyType.Elite,       Hero.Bastion, 		1],
            [EnemyType.Elite,       Hero.Ana, 	        2],
            [EnemyType.Minion,      Hero.Soldier76, 	2]
        ],
        [
            "long range",
            [EnemyType.Boss,        Hero.Bastion, 		1],
            [EnemyType.Elite,       Hero.Orisa, 		1],
            [EnemyType.Elite,       Hero.Soldier76, 	2],
            [EnemyType.Minion,      Hero.Ana, 	        2]
        ],
        [
            "air forces",
            [EnemyType.Elite,       Hero.Echo, 			2],
            [EnemyType.Elite,       Hero.Pharah, 		2],
            [EnemyType.Minion,      Hero.Mercy, 		2]
        ],
        [
            "sky queen",
            [EnemyType.Boss,        Hero.Pharah, 		1],
            [EnemyType.Elite,       Hero.Mercy, 		3],
            [EnemyType.Minion,      Hero.Mercy, 		2]
        ],
        [
            "sky queen",
            [EnemyType.Boss,        Hero.Echo, 		    1],
            [EnemyType.Elite,       Hero.Mercy, 		3],
            [EnemyType.Minion,      Hero.Mercy, 		2]
        ],
        [
            "sky queen",
            [EnemyType.Boss,        Hero.Mercy, 		1],
            [EnemyType.Elite,       Hero.Pharah, 		3],
            [EnemyType.Minion,      Hero.Echo, 		    2]
        ],
        [
            "snipers",
            [EnemyType.Boss,        Hero.Hanzo,			1],
            [EnemyType.Boss,        Hero.Widowmaker,	1],
            [EnemyType.Elite,       Hero.Ashe, 			2],
            [EnemyType.Minion,      Hero.Ana, 			2]
        ],
        [
            "snipers",
            [EnemyType.Boss,        Hero.Widowmaker,	1],
            [EnemyType.Boss,        Hero.Ana,	        1],
            [EnemyType.Elite,       Hero.Hanzo, 		2],
            [EnemyType.Minion,      Hero.Ashe, 	        2]
        ],
        [
            "snipers",
            [EnemyType.Boss,        Hero.Ashe,			1],
            [EnemyType.Boss,        Hero.Hanzo,	        1],
            [EnemyType.Elite,       Hero.Ana, 		    2],
            [EnemyType.Minion,      Hero.Widowmaker, 	2]
        ],
        [
            "machines",
            [EnemyType.Boss,        Hero.Orisa, 		1],
            [EnemyType.Elite,       Hero.Bastion, 		2],
            [EnemyType.Elite,       Hero.Echo,          2],
            [EnemyType.Minion,      Hero.Zenyatta,      1]
        ],
        [
            "machines",
            [EnemyType.Boss,        Hero.Bastion, 		1],
            [EnemyType.Elite,       Hero.Zenyatta, 		2],
            [EnemyType.Elite,       Hero.Orisa,         2],
            [EnemyType.Minion,      Hero.Echo,          1]
        ],
        [
            "machines",
            [EnemyType.Boss,        Hero.Echo, 		    1],
            [EnemyType.Elite,       Hero.Zenyatta, 		2],
            [EnemyType.Elite,       Hero.Bastion,       2],
            [EnemyType.Minion,      Hero.Orisa,         1]
        ],
        [
            "machines",
            [EnemyType.Boss,        Hero.Zenyatta, 		1],
            [EnemyType.Elite,       Hero.Bastion, 		2],
            [EnemyType.Elite,       Hero.Orisa,         2],
            [EnemyType.Minion,      Hero.Echo,          1]
        ],
        [
            "Reinhardt army",
            [EnemyType.Boss,        Hero.Reinhardt, 	1],
            [EnemyType.Minion,      Hero.Reinhardt, 	5]
        ],
        [
            "Brigitte army",
            [EnemyType.Boss,        Hero.Reinhardt, 	1],
            [EnemyType.Minion,      Hero.Brigitte,   	5]
        ],
        [
            "turrets",
            [EnemyType.Boss,        Hero.Torbjorn, 		1],
            [EnemyType.Elite,       Hero.Symmetra, 		2],
            [EnemyType.Minion,      Hero.Symmetra, 		3]
        ],
        [
            "turrets",
            [EnemyType.Boss,        Hero.Symmetra, 		1],
            [EnemyType.Elite,       Hero.Torbjorn, 		2],
            [EnemyType.Minion,      Hero.Torbjorn, 		3]
        ]

    ];

globalvar define someHero!;

rule: "EnemyBot/reloadBotAsset"
Event.OngoingGlobal
if(
    portalEnable
){
    // change bot asset by random
    if(
        0 >= NumberOfPlayers(Team.Team2) ||
        ProbabilityTrue(70)
    ){
        someHero = RandomHero;
        // create all bot
        CreateEnemyBotsByAssetList(assetList, Team.Team2);   
    }
}

// TAG EnemyBot/EnemyType ----------
playervar define eachDealtDamageScale!;
playervar define eachMaxSpawnInterval!;
playervar define eachMinSpawnInterval!;
playervar define eachChargeUltInterval!;
playervar define eachEffectTextSize!;
playervar define eachNameText!;
playervar define eachNameColor!;

rule: "EnemyBot/EnemyType/setEnemyType"
Event.OngoingPlayer
Team.Team2
if(
    enemyType != EnemyType.None
){
    if(enemyType == EnemyType.Minion){
        StartScalingPlayer(ep, 0.75, false);
        StartModifyingHeroVoiceLines(ep, 1.5, false);

        SetMaxHealth(ep, 50);

        SetHealingDealt(ep, 50);
        SetHealingReceived(ep, 75);
        
        eachDealtDamageScale = 0.5;
        eachChargeUltInterval = 60;
        eachMaxSpawnInterval = 5;
        eachMinSpawnInterval = 0;

        eachNameText = "Minion";
        eachNameColor = Color.White;
        eachEffectTextSize = 1;

        eachPerkDropProbability = 3;
    }
    else if(enemyType == EnemyType.Elite){
        StartScalingPlayer(ep, 1.0, false);
        StartModifyingHeroVoiceLines(ep, 1.0, false);

        SetMaxHealth(ep, 200);

        SetHealingDealt(ep, 100);
        SetHealingReceived(ep, 150);

        eachDealtDamageScale = 1.0;
        eachChargeUltInterval = 20;
        eachMaxSpawnInterval = 10;
        eachMinSpawnInterval = 5;

        eachNameText = "Elite";
        eachNameColor = Color.Yellow;
        eachEffectTextSize = 2;

        eachPerkDropProbability = 12;
    }
    else if(enemyType == EnemyType.Boss){
        StartScalingPlayer(ep, 1.5, false);
        StartModifyingHeroVoiceLines(ep, 0.5, false);

        SetMaxHealth(ep, 1000);

        SetHealingDealt(ep, 200);
        SetHealingReceived(ep, 300);

        eachDealtDamageScale = 2.0;
        eachChargeUltInterval = 10;
        eachMaxSpawnInterval = 20;
        eachMinSpawnInterval = 10;

        eachNameText = "Boss";
        eachNameColor = Color.Red;
        eachEffectTextSize = 3;

        eachPerkDropProbability = 50;
    }
    else if(enemyType == EnemyType.GiantBoss){
        StartScalingPlayer(ep, 2.5, false);
        StartModifyingHeroVoiceLines(ep, 0.1, false);

        SetMaxHealth(ep, 1000);

        SetHealingDealt(ep, 200);
        SetHealingReceived(ep, 300);

        eachDealtDamageScale = 3.0;
        eachChargeUltInterval = 5;
        eachMaxSpawnInterval = 10;
        eachMinSpawnInterval = 5;

        eachNameText = "Giant Boss";
        eachNameColor = Color.Purple;
        eachEffectTextSize = 4;

        eachPerkDropProbability = 100;

        // set addtinal health
        AddHealthPoolToPlayer(ep, HealthType.Armor, 2500, true, false);
        AddHealthPoolToPlayer(ep, HealthType.Shields, 2500, true, false);
    }

    UpdateEachDealtDamage();
    UpdateEachSpawnInterval();

    // heal to max health
    while(Health() < MaxHealth()){
        Heal(ep, null, MaxValue());
        Wait(0.1, WaitBehavior.AbortWhenFalse);
    }
}

// TAG EnemyBot/Effect ----------
playervar define botAppearanceEntitys!;

rule: "EnemyBot/Effect/showBotAppearance"
Event.OngoingPlayer
Team.Team2
if(
    enemyType != EnemyType.None &&
    IsAlive()
){
    botAppearanceEntitys = [];
    // show evil aura
    botAppearanceEntitys[0] = 
        CreateEffect(AllPlayers(), Effect.Cloud, enemyColor,
            ep, eachEffectTextSize, EffectRev.VisibleToPositionAndRadius);
    // show name text
    botAppearanceEntitys[1] = 
        CreateInWorldText(
            AllPlayers(), eachNameText, 
            ep, eachEffectTextSize, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            eachNameColor, Spectators.DefaultVisibility);
}

rule: "EnemyBot/Effect/hideBotAppearanceAndReek"
Event.OnDeath
Team.Team2
if(
    enemyType != EnemyType.None &&
    !IsAlive()
){
    // hide evil aura
    DestroyEffect(botAppearanceEntitys[0]);
    // hide name text
    DestroyInWorldText(botAppearanceEntitys[1]);
    // play dead effect
    PlayContinuousBlast(Color.Red, PositionOf(),
        eachEffectTextSize * 1.5, eachEffectTextSize);
}

// TAG EnemyBot/Teleport ----------
define teleportAreaSize: 7;
define ClosestPlayerToTelPos: ClosestPlayerTo(teleportPosition, Team.Team1);
define ClosestPlayerToComTelPos: ClosestPlayerTo(commonTeleportPosition, Team.Team1);
define ClosestPlayerToMe: ClosestPlayerTo(ep, Team.Team1);

Player ClosestPlayerFromPortal()"ClosestPlayerFromPortal"{
    return FirstOf(
        SortedArray(
            FilteredArray(
                AllPlayers(Team.Team1),
                (
                    HasSpawned(ae) &&
                    IsAlive(ae) &&
                    !IsInSpawnRoom(ae)
                )
            ),
            DistanceBetween(ae, portalPosition)
        )
    );
}

playervar define teleportPosition!;
globalvar define commonTeleportPosition!;

Boolean SetTeleportPositionToPlayerFront()"SetTeleportPositionToPlayerFront"{
    // set teleportToTarget at closest player from portal
    define teleportToTarget! = ClosestPlayerFromPortal();
    if(teleportToTarget == null){
        teleportPosition = portalPosition;
        return true;
    }
    for(pLoopIndex = 0; pLoopIndex < 10; pLoopIndex++){
        // select teleportPosition from middle of portal and teleportToTarget
        teleportPosition =
            NearestWalkablePosition(
                PositionOf(teleportToTarget)
                    + 
                (
                    DirectionTowards(teleportToTarget, portalPosition)
                        *
                    DistanceBetween(teleportToTarget, portalPosition) * 0.5
                )
                    +
                RandomPosition(teleportAreaSize, teleportAreaSize, teleportAreaSize)
            );

        define telPosNearTarget! = ClosestPlayerToTelPos;
        if(
            // target not inside teleport area
            DistanceBetween(telPosNearTarget, teleportPosition) >= teleportAreaSize
                &&
            // Has line to target
            IsInLineOfSight(telPosNearTarget, teleportPosition, BarrierLOS.NoBarriersBlock)
        ){
            break;
        }
        Wait(0.1, WaitBehavior.AbortWhenFalse);
        WaitUntilServerFree();
    }
    return true;
}

Boolean SetTeleportPositionToPlayerAround()"SetTeleportPositionToPlayerAround"{
    // set teleportToTarget at closest player from portal
    define teleportToTarget! = ClosestPlayerFromPortal();
    if(teleportToTarget == null){
        teleportPosition = portalPosition;
        return true;
    }
    for(pLoopIndex = 0; pLoopIndex < 10; pLoopIndex++){
        // select teleportPosition from teleportToTarget around
        teleportPosition =
            BlockedPositon(
                teleportToTarget,
                DirectionFromAngles(
                    RandomReal(0, 360), RandomReal(30, -30),
                ),
                RandomReal(teleportAreaSize, 50)
            );
        // slide teleportPosition to targer for avoid map surface edge
        teleportPosition += DirectionTowards(teleportPosition, teleportToTarget);
        
        define telPosNearTarget! = ClosestPlayerToTelPos;
        if(
            // target not inside teleport area
            DistanceBetween(telPosNearTarget, teleportPosition) >= teleportAreaSize
                &&
            // Has line to target
            IsInLineOfSight(telPosNearTarget, teleportPosition, BarrierLOS.NoBarriersBlock)
                &&
            // Has ground of teleport position
            IsBlockedBetween(teleportPosition, ShiftedPosition(teleportPosition, Down(), 6))

        ){
            break;
        }
        Wait(0.1, WaitBehavior.AbortWhenFalse);
        WaitUntilServerFree();
    }
    teleportPosition -= PositionOffset();
    return true;
}

define forceUpdateCommonPositionProb: 5;

Boolean SetTeleportPositionToCommonPosition()"SetTeleportPositionToCommonPosition"{
    // set telPosNearTarget at closest player from commonTeleportPosition
    define telPosNearTarget! = ClosestPlayerToComTelPos;
    if(telPosNearTarget == null){
        teleportPosition = portalPosition;
        return true;
    }
    if(
        // invalid commonTeleportPosition
        commonTeleportPosition ==  0 ||
        // Probability
        ProbabilityTrue(forceUpdateCommonPositionProb) ||
        // has not line closest player from commonTeleportPosition
        !IsInLineOfSight(commonTeleportPosition, telPosNearTarget) ||                      
        // target inside teleport area
        DistanceBetween(commonTeleportPosition, telPosNearTarget) < teleportAreaSize 
    ){
        // new select common position
        // set teleport position to player around
        if(SetTeleportPositionToPlayerAround()){
            // save teleport position as common position
            commonTeleportPosition = teleportPosition;
        }
        else{
            // set teleport position from common position
            teleportPosition = commonTeleportPosition;
        }
    }
    else{
        // set teleport position from common position
        teleportPosition = commonTeleportPosition;
    }
    return true;
}

void PlayTeleportEffect(define isBefore!)"PlayTeleportEffect"{
    // if before teleport
    if(isBefore){
        if(portalEnable){
            // play teleport shadow of own
            PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, enemyColor, ep, 1);
            // play teleport shadow of dest
            PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, enemyColor, teleportPosition, 1);
        }
        // wait for show teleport shadow of before
        Wait(0.4, WaitBehavior.IgnoreCondition);
    }
    else{
        if(portalEnable){
            // play teleport blast
            PlayEffect(AllPlayers(), PlayEffect.BadExplosion, enemyColor, ep, eachEffectTextSize);
        }
    }
}

void TeleportWithEffect()"TeleportWithEffect"{
    Wait(SlotOf(ep) * 0.1, WaitBehavior.AbortWhenFalse);
    // show pre teleport effect
    PlayTeleportEffect(true);
    // Teleport
    Teleport(ep, teleportPosition);
    // show teleport effect
    PlayTeleportEffect(false);
}

rule: "EnemyBot/Teleport/teleportByPortalDisabled"
Event.OngoingPlayer
Team.Team2
if(
    HasSpawned() &&
    !portalEnable
){
    // Teleport Bot to spawn room when portal disable
    // wait show dead effect when portal closing
    Wait(showDeadEffectTime, WaitBehavior.AbortWhenFalse);

    // reset teleport position
    teleportPosition = InvalidPosition();
    // set root
    SetStatus(ep, null, Status.Rooted, MaxValue());
    // show pre teleport effect
    PlayTeleportEffect(true);
    // Teleport to spawn room
    Respawn(AllPlayers(Team.Team2));
    // show teleport effect
    PlayTeleportEffect(false);
}

rule: "EnemyBot/Teleport/teleportByPortalEnabled"
Event.OngoingPlayer
Team.Team2
if(
    HasSpawned() &&
    portalEnable
){
    AbortIf(DistanceBetween(ep, ClosestPlayerFromPortal()) <= 5);
    // clear root
    ClearStatus(ep, Status.Rooted);
    // set teleport position
    if(SetTeleportPositionToPlayerFront()){
        // teleport
        TeleportWithEffect();
    }
}

rule: "EnemyBot/Teleport/teleportByPlayerEntered"
Event.OngoingPlayer
Team.Team2
if(
    IsAlive() &&
    portalEnable &&
    portalState == PortalState.UnderAttack
){
    AbortIf(DistanceBetween(ep, ClosestPlayerFromPortal()) <= 5);
    // set teleport position to player around
    if(SetTeleportPositionToPlayerAround()){
        // teleport
        TeleportWithEffect();
    }
}

define forceTeleportToPlayerAroundProb: 50 / NumberOfPlayers(Team.Team2);
define teleportToCommonPositionProb: 90;

rule: "EnemyBot/Teleport/teleportByRespawn"
Event.OngoingPlayer
Team.Team2
if(
    IsAlive() &&
    portalEnable &&
    IsInSpawnRoom()
){
    if(
        // during portal attacks
        portalState == PortalState.UnderAttack ||
        // probability
        ProbabilityTrue(forceTeleportToPlayerAroundProb)
    ){
        if(
            // probability
            ProbabilityTrue(teleportToCommonPositionProb)
        ){
            // set teleport position to common position
            if(SetTeleportPositionToCommonPosition()){
                // teleport
                TeleportWithEffect();
            }
        }
        else{
            // set teleport position to player around
            if(SetTeleportPositionToPlayerAround()){
                // teleport
                TeleportWithEffect();
            }
        }
    }
    else{
        // set teleport position to player front
        if(SetTeleportPositionToPlayerFront()){
            // teleport
            TeleportWithEffect();
        }
    }
}

define hasLine:
    IsInLineOfSight(ep,
            ClosestPlayerToMe,
            BarrierLOS.NoBarriersBlock);

rule: "EnemyBot/Teleport/teleportByPlayerNotFound"
Event.OngoingPlayer
Team.Team2
if(
    IsAlive() &&
    portalEnable &&
    !IsInSpawnRoom()
){
    for(define notHasLineSecond! = 0; notHasLineSecond < 3; notHasLineSecond ++){
        Wait(1, WaitBehavior.AbortWhenFalse);
        if(hasLine){
            LoopIfConditionIsTrue();
        }
    }

    if(
        // during portal attacks
        portalState == PortalState.UnderAttack ||
        // probability
        ProbabilityTrue(forceTeleportToPlayerAroundProb)
    ){
        if(
            // probability
            ProbabilityTrue(teleportToCommonPositionProb)
        ){
            // set teleport position to common position
            if(SetTeleportPositionToCommonPosition()){
                // teleport
                TeleportWithEffect();
            }
        }
        else{
            // set teleport position to player around
            if(SetTeleportPositionToPlayerAround()){
                // teleport
                TeleportWithEffect();
            }
        }
    }
    else{
        // set teleport position to player front
        if(SetTeleportPositionToPlayerFront()){
            // teleport
            TeleportWithEffect();
        }
    }

    LoopIfConditionIsTrue();
}

rule: "EnemyBot/Teleport/clearCommonTeleportPosition"
Event.OnDeath
Team.Team2
if(
    Attacker() == ep &&
    portalEnable
){
    commonTeleportPosition = 0;
}

// TAG EnemyBot/EnemyAbility
rule: "EnemyBot/EnemyAbility/shotCall"
Event.OngoingGlobal
if(
    portalState == PortalState.UnderAttack
){
    Wait(RandomReal(10, 30), WaitBehavior.AbortWhenFalse);
    SetUltimateCharge(AllPlayers(Team.Team2), 100);
    PressButton(AllPlayers(Team.Team2), Button.Ultimate);
}

rule: "EnemyBot/EnemyAbility/combatTeleport"
Event.OngoingPlayer
Team.Team2
if(
    enemyType == EnemyType.GiantBoss &&
    IsAlive() &&
    portalEnable &&
    actionState == ActionState.Attack
){
    define teleportWaitSecond! = NormalizedHealth() * 10;
    Wait(RandomReal(teleportWaitSecond, teleportWaitSecond + 3), WaitBehavior.AbortWhenFalse);
    // set teleport position to player around
    if(SetTeleportPositionToPlayerAround()){
        define telBeam!;
        // teleport with beam effect
        DestroyEffect(telBeam);
        telBeam = CreateBeamEffect(AllPlayers(),
            BeamType.BadBeam, EyePosition(ep) + Down(), teleportPosition,
            Color.Purple, EffectRev.VisibleToPositionAndRadius);
        TeleportWithEffect();
        DestroyEffect(telBeam);
    }
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/chargeUltimate ----------
rule: "EnemyBot/chargeUltimate"
Event.OngoingPlayer
Team.Team2
if(
    HasSpawned() &&
    enemyType != EnemyType.None &&
    !IsUsingUltimate()
){
    SetUltimateCharge(ep, UltimateChargePercent() + (100 / eachChargeUltInterval));
    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/SpawnInterval ----------
define showDeadEffectTime: 1.5;
playervar define confirmSpawnInterval!;

void UpdateEachSpawnInterval()"UpdateEachSpawnInterval"{
    confirmSpawnInterval = eachMaxSpawnInterval;
    confirmSpawnInterval *= (1 - (portalSize / maxPortalSize));
    confirmSpawnInterval -= (roundNo / 5);
    confirmSpawnInterval = Max(confirmSpawnInterval, 0);
    confirmSpawnInterval += eachMinSpawnInterval;
    SetRespawnMaxTime(ep, confirmSpawnInterval + showDeadEffectTime); 
}

rule: "EnemyBot/SpawnInterval/update"
Event.OngoingPlayer
Team.Team2
if(
    portalEnable &&
    enemyType != EnemyType.None
){
    UpdateEachSpawnInterval();
    WaitUpdateLongCycle();
    LoopIf(portalSize < maxPortalSize);
}

rule: "EnemyBot/SpawnInterval/fastRespawnBySucide"
Event.OnDeath
Team.Team2
if(
    Attacker() == ep &&
    portalEnable
){
    Wait(showDeadEffectTime, WaitBehavior.AbortWhenFalse);
    Respawn();
}

// TAG EnemyBot/ReceivedDamage ----------
globalvar define confirmReceiveDamage!;

void UpdateEachReceivedDamage()"UpdateEachReceivedDamage"{
    // set base damage
    confirmReceiveDamage = 100;
    // apply team balance
    confirmReceiveDamage *= ConvertToBalancedValue(0.6, Team.Team1);
    SetDamageReceived(AllPlayers(Team.Team2), confirmReceiveDamage);
}

rule: "EnemyBot/ReceivedDamage/update"
Event.OngoingGlobal
if(
    initCompleted
){
    UpdateEachReceivedDamage();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/DealtDamage ----------
playervar define confirmDealtDamage!;
globalvar define threatLevel!;

void UpdateEachDealtDamage()"UpdateEachDealtDamage"{
    // set base damage
    confirmDealtDamage = WorkshopSettingReal("Enemy Bot Settings", "Base Deal Damage", 10, 0, 1000, 1);
    // add round progress
    confirmDealtDamage += roundNo * WorkshopSettingReal("Enemy Bot Settings", "Increase Deal Damage Per Round", 1.5, 0, 1000, 1);
    // add team lives balance
    //confirmDealtDamage += teamLives * WorkshopSettingReal("Enemy Bot Settings", "Increase Deal Damage Per Team lives", 2, 0, 1000, 1);
    // add team health balance
    confirmDealtDamage += GetTeamNormalizedHealth() * WorkshopSettingReal("Enemy Bot Settings", "Increase Deal Damage By Player Team Health", 20, 0, 1000, 1);
    // apply team balance
    confirmDealtDamage /= ConvertToBalancedValue(0.6, Team.Team1);
        // set strengthScore
        threatLevel = confirmDealtDamage;
    // apply enemy type scale
    confirmDealtDamage *= eachDealtDamageScale;
    SetDamageDealt(ep, confirmDealtDamage);
}

rule: "EnemyBot/DealtDamage/update"
Event.OngoingPlayer
Team.Team2
if(
    portalEnable &&
    enemyType != EnemyType.None
){
    UpdateEachDealtDamage();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

Number GetTeamNormalizedHealth()"UpdateEachDealtDamage"{
    define teamHealth = 0;
    define teamList! = AllPlayers(Team.Team1);
    for(define idx! = 0; idx < CountOf(teamList); idx++){
        teamHealth += NormalizedHealth(teamList[idx]);
    }
    teamHealth /= CountOf(teamList);
    return teamHealth;
}

// TAG Debug ----------
disabled rule: "Debug/builtin"
Event.OngoingGlobal
if(
    initCompleted
){
    CreateEffect(HostPlayer(), Effect.Sphere, Color.Yellow,
        commonTeleportPosition, teleportAreaSize, EffectRev.PositionAndRadius);
}

globalvar define debugMode!;

enum DebugMode{
    Non,
    SlowLevelOnly,
    ShowParam,
    WithRecord
}

rule: "Debug/changeDebugMode"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Jump) 
){
    // change debug mode
    WaitLongPressConfirm();
    if(debugMode == DebugMode.Non){
        debugMode = DebugMode.SlowLevelOnly;
    }
    else if(debugMode == DebugMode.SlowLevelOnly){
        debugMode = DebugMode.ShowParam;
    }
    else if(debugMode == DebugMode.ShowParam){
        debugMode = DebugMode.WithRecord;
    }
    else if(debugMode == DebugMode.WithRecord){
        debugMode = DebugMode.Non;
    }

    if(debugMode == DebugMode.Non){
        DisableInspectorRecording();
        HideDebugHud();
    }
    else if(debugMode == DebugMode.SlowLevelOnly){
        DisableInspectorRecording();
        HideDebugHud();
        ShowDebugHud(HostPlayer());
    }
    else if(debugMode == DebugMode.ShowParam){
        DisableInspectorRecording();
        HideDebugHud();
        ShowDebugHud(HostPlayer());
    }
    else if(debugMode == DebugMode.WithRecord){
        EnableInspectorRecording();
        HideDebugHud();
        ShowDebugHud(HostPlayer());
    }
}

define End(): CountOf(debugHudEntitys);
define botOfEnemyType(define enemyType): FirstOf(FilteredArray(AllPlayers(Team.Team2), ae.enemyType == enemyType));
globalvar define debugHudEntitys!;

// show debug icon and hud
void ShowDebugHud(define player!)"ShowDebugHud"{
    if(
        debugMode == DebugMode.ShowParam ||
        debugMode == DebugMode.WithRecord
    ){
        if(
            debugMode == DebugMode.WithRecord
        ){
            CreateHudText(player,
                null,
                null,
                "● is Recording",
                Location.Left, -1,
                Color.White, Color.White, Color.Red,
                HudTextRev.VisibleToAndString, Spectators.VisibleNever);
            debugHudEntitys[End()] = LastTextID();
        }

        CreateHudText(player,
            null,
            <"<0> <1>", "Regeneration Rate", regenRateTeam1>,
            null,
            Location.Left, -1,
            Color.White, Color.Blue, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(player,
            null,
            <"<0> <1>", "portal State", portalState>,
            null,
            Location.Left, -1,
            Color.White, enemyColor, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(player,
            null,
            <"<0> <1>", "portal Size", portalSize>,
            null,
            Location.Left, -1,
            Color.White, enemyColor, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(player,
            null,
            <"<0> <1>", "portal Position", portalPosition>,
            null,
            Location.Left, -1,
            Color.White, enemyColor, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(player,
            null,
            <"<0> <1>", "distance to protal", DistanceBetween(ep, portalPosition)>,
            null,
            Location.Left, -1,
            Color.White, enemyColor, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(player,
            null,
            <"<0> RcvDmg <1> DltDmg <2> SpwItv <3> ChgUlt <4>", "Giant Boss Status",
                confirmReceiveDamage,
                botOfEnemyType(EnemyType.GiantBoss).confirmDealtDamage,
                botOfEnemyType(EnemyType.GiantBoss).confirmSpawnInterval,
                botOfEnemyType(EnemyType.GiantBoss).eachChargeUltInterval
            >,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(player,
            null,
            <"<0> RcvDmg <1> DltDmg <2> SpwItv <3> ChgUlt <4>", "Boss Status",
                confirmReceiveDamage,
                botOfEnemyType(EnemyType.Boss).confirmDealtDamage,
                botOfEnemyType(EnemyType.Boss).confirmSpawnInterval,
                botOfEnemyType(EnemyType.Boss).eachChargeUltInterval
            >,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(player,
            null,
            <"<0> RcvDmg <1> DltDmg <2> SpwItv <3> ChgUlt <4>", "Elite Status",
                confirmReceiveDamage,
                botOfEnemyType(EnemyType.Elite).confirmDealtDamage,
                botOfEnemyType(EnemyType.Elite).confirmSpawnInterval,
                botOfEnemyType(EnemyType.Elite).eachChargeUltInterval
            >,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(player,
            null,
            <"<0> RcvDmg <1> DltDmg <2> SpwItv <3> ChgUlt <4>", "Minion Status",
                confirmReceiveDamage,
                botOfEnemyType(EnemyType.Minion).confirmDealtDamage,
                botOfEnemyType(EnemyType.Minion).confirmSpawnInterval,
                botOfEnemyType(EnemyType.Minion).eachChargeUltInterval
            >,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(player,
            null,
            <"<0> <1>", "threat Level", threatLevel>,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(player,
            null,
            <"<0> <1>/<2>", "environment Death Count", environmentDeathCount, environmentDeathLimit>,
            null,
            Location.Left, -1,
            Color.White, Color.White, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(player,
            null,
            <"<0> <1>/<2>", "no Contact Time", notContactTime, limitTime>,
            null,
            Location.Left, -1,
            Color.White, Color.White, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();
    }

        CreateHudText(player,
            null,
            <"<0> <1>", "Server Load", ServerLoad()>,
            null,
            Location.Left, -1,
            Color.White, Color.Orange, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

    if(
        debugMode == DebugMode.ShowParam ||
        debugMode == DebugMode.WithRecord
    ){
        CreateHudText(player,
            null,
            <"<0> <1>", "Server Load Average", ServerLoadAverage()>,
            null,
            Location.Left, -1,
            Color.White, Color.Orange, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(player,
            null,
            <"<0> <1>", "Server Load Peak", ServerLoadPeak()>,
            null,
            Location.Left, -1,
            Color.White, Color.Orange, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();
    }

        CreateHudText(player,
            null,
            <"<0> <1>", "current Slow Level", currentSlowLevel>,
            null,
            Location.Left, -1,
            Color.White, Color.Orange, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();
}

// Hide debug icon and hud
void HideDebugHud()"HideDebugHud"{
    for(gLoopIndex = 0; gLoopIndex < CountOf(debugHudEntitys); gLoopIndex ++){
        DestroyHudText(debugHudEntitys[gLoopIndex]);
    }
}

rule: "Debug/increaseTeamLives"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Ability2)
){
    // Increase TeamLives
    WaitLongPressConfirm();
    teamLives += 1;
    LoopIfConditionIsTrue();
}

rule: "Debug/increaseRoundNo"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Ability1)
){
    // Increase RoundNo
    WaitLongPressConfirm();
    roundNo += 1;
    LoopIfConditionIsTrue();
}

rule: "Debug/resetPortal // reset portal position by random"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    !IsButtonHeld(ep, Button.Reload) &&
    IsButtonHeld(ep, Button.Crouch)
){
    // Recalculate portal
    WaitLongPressConfirm();
    portalState = PortalState.Non;
    WaitChangeState();  // Wait for the changed status to be processed first
    portalState = PortalState.Calculating;
}

globalvar define debugAimingPosition!;

rule: "Debug/setPortalPositionOnAimCenter // reset portal position by aim center"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Reload) &&
    !IsButtonHeld(ep, Button.Crouch)
){
    // Set portal position to aim center
    WaitLongPressConfirm();
    portalState = PortalState.Non;
    debugAimingPosition = AimingPosition();
    WaitChangeState();  // Wait for the changed status to be processed first
    portalState = PortalState.Calculating;
    WaitUntil(portalState != PortalState.Calculating, 5);
    portalPosition = debugAimingPosition;
}

rule: "Debug/setPortalMaxSize // reset portal position by aim center"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Reload) &&
    IsButtonHeld(ep, Button.Crouch)
){
    // Set portal position to aim center
    WaitLongPressConfirm();
    portalSize = maxPortalSize;
}
