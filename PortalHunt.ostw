// [Detail]
// -The player achieves objective while enduring many BOT attacks.
// -The objective of the game is to find and close portals that appear somewhere on the map.
// -The countdown to close when one or more players enter the portal begins. Survive at least one person until it reaches zero.
// -Perk can be obtained by picking up the crate that the enemy sometimes drops.
// -Some are powerful enough to reverse a difficult battle situation.
// -Fight against enormous amounts of enemies with teamwork and perks!
// [Share Code]
// YY1N2
// [ToDo]
// add optimaze hit scan by close range of Beam Sniaper

// add Orbital Lazer
// add Missile Barrage
// add Disarmament
// add Drone Guard Dog
// add Assassination
// add Drop Perk

import "Lib/Utility.ostw";
import "Lib/ElapsedTimer.ostw";
import "Lib/Regeneration.ostw";
import "Lib/Revive.ostw";
import "Lib/Perk.ostw";
import "Lib/DamageText.ostw";
import "Lib/Debug.ostw";

// TAG Signature and infomation ----------
disabled rule: "PORTAL HUNT -HORDE PVE [ver 2.0] Share code [YY1N2]"-1{}
disabled rule: "You allowed copy or modify code."-1{}
disabled rule: "This script was generated from source code by [Overwatch-Script-To-Workshop]"-1{}
disabled rule: "Check detail with https://github.com/ItsDeltin/Overwatch-Script-To-Workshop"-1{}
disabled rule: "Original source code was created by [sarami77#1868]"-1{}
disabled rule: "Check detail with https://github.com/sarami77/OverwatchWorkShopScripts"-1{}

// TAG System ----------
rule: "System/ServerLoadFullMeasures"
Event.OngoingGlobal
if(
    ServerLoad() >= 255
){
    Wait(4, WaitBehavior.AbortWhenFalse);
    portalState = PortalState.Idle;   // abort portal
    dbgMsg("!!! Enemy's portal was force reset by server over load !!!");
    Wait(4, WaitBehavior.IgnoreCondition);
    portalState = PortalState.Calculating;   // restart portal
    
}

// TAG Game Function ----------
globalvar define initCompleted;
globalvar define gameInProgress;

rule: "Game/initGameSetting //wait 3 _seconds because some scripts fail immediately after loading the _server"
Event.OngoingGlobal
{
    // Stop records to reduce server load
    DisableInspectorRecording();

    // Set game not in progress
    gameInProgress = false;

    // Set imported function property
    Regeneration_enableTeam = Team.Team1;
    Regeneration_needTeamBalance = true;
    Regeneration_regenerationRate = 25;
    Regeneration_waitRegenTime = 1.0;

    Revive_enableTeam = Team.Team1;
    Revive_timeLimit = 10;

    DamageText_enableTeam = Team.Team2;

    // If run it right after loading the server, some scripts fail, so wait 3 seconds
    Wait(3, WaitBehavior.AbortWhenFalse);

    // Cancel unnecessary default settings
    PauseMatchTime();
    DisableScoring();
    DisableCompletion();

    // Calculate the approximate center position of the map from the spawn room position.
    // Therefore, change the spawn room and then spawn the entity.
    ForceSpawnRoom(Team.Team1, 2);
    Respawn(AllPlayers(Team.All));

    // Notify completion of init game setting and start game main logic
    initCompleted = true;
    // WARNING
    // If you set setMatchTime right after the game starts, the server becomes unstable and ReturnToLobby and Restart stop working.
    // StartElapsedTimer should be true after a delay of about 5 seconds.
    startElapsedTimer = true;
}

rule: "Game/startGame // by start game of first respawn room exit "
Event.OngoingPlayer
Team.Team1
Player.All
if(
    !gameInProgress &&
    initCompleted &&
    createRange != 0 &&
    HasSpawned() &&
    !IsInSpawnRoom()
){
    WaitConditionConfirmed();
    elapsedTime = 0;
    // If player exit spawn room, portal recreate.
    portalState = PortalState.Calculating;
    gameInProgress = true;
}

rule: "Game/resetGame // by no player"
Event.OngoingGlobal
if(
    0 >= NumberOfPlayers(Team.Team1)
){
    WaitConditionConfirmed();
    elapsedTime = 0;
    roundNo = 0;
    teamLifes = initalTeamLifes;
    Heal(AllPlayers(Team.Team2), null, MaxValue());
    gameInProgress = false;
}

rule: "Game/ShareCode/showGameCode"
Event.OngoingGlobal
{
    // show ver and share code
    CreateHudText(AllPlayers(Team.Team1),
        null, "PORTAL HUNT -HORDE PVE [ver 2.0] Share code [YY1N2]", null,
        Location.Left, -3,
        Color.White, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);
}

globalvar define roundNo;

rule: "Game/RoundNo/showObjectMessageHUD //with update message by state"
Event.OngoingPlayer
Team.Team1
Player.All
if(
    initCompleted
){
    // Change the message of the target HUD at the top of the screen according to the state of the game
    WaitUpdateMediumCycle();
    if(
        !portalEnable
    ){
        SetObjectiveDescription(EventPlayer(), "Stand by...", ObjectiveRev.VisibleToSortOrderAndString);
    }
    else if(isInsidePortal){
        SetObjectiveDescription(EventPlayer(), "Stay inside and survive!", ObjectiveRev.VisibleToSortOrderAndString);
    }
    else{
        SetObjectiveDescription(EventPlayer(), "Find portal and attack it.", ObjectiveRev.VisibleToSortOrderAndString);
    }
    LoopIfConditionIsTrue();
}

rule: "Game/RoundNo/showRoundHUD"
Event.OngoingGlobal
if(
    initCompleted
){
    // show HUD of round number
    CreateHudText(AllPlayers(Team.All),
        <"<0> <1>", "Round", roundNo>, null, null,
        Location.Top, 2,
        Color.Purple, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleAlways);
}
rule: "Game/SpawnRoom/changeByTimer //to make the game fluid"
Event.OngoingGlobal
if(
    initCompleted &&
    centerPosition != 0
){
    // Change the spawn room regularly to keep the game fluid
    Wait(300, WaitBehavior.AbortWhenFalse); // change spawn room
    ForceSpawnRoom(Team.Team2, RandomInteger(0, 2));
    ForceSpawnRoom(Team.Team1, RandomInteger(0, 2));
    LoopIfConditionIsTrue();
}

// TAG Player Function ----------
playervar define isInsidePortal;

rule: "Player/InsidePortal/enable"
Event.OngoingPlayer
Team.Team1
Player.All
if(
    (
        portalEnable &&
        DistanceBetween(EventPlayer(), portalPosition) <= portalSize &&
        HasSpawned() &&
        IsAlive() &&
        !IsInSpawnRoom()
    )
){
    // Set flag when player entered to portal
    // This flag is used for functions related to portal
    WaitConditionConfirmed();
    isInsidePortal = true;
}
rule: "Player/InsidePortal/disable"
Event.OngoingPlayer
Team.Team1
Player.All
if(
    !(
        portalEnable &&
        DistanceBetween(EventPlayer(), portalPosition) <= portalSize &&
        HasSpawned() &&
        IsAlive() &&
        !IsInSpawnRoom()
    )
){
    // Release flag when player exited from portal
    // This flag is used for functions related to portal
    WaitConditionConfirmed();
    isInsidePortal = false;
}

rule: "Player/ReturnSpawn/showOperationHUD"
Event.OngoingGlobal
{
    // show HUD of hero change operation
    CreateHudText(AllPlayers(Team.Team1),
        null, <"Long hold reload button <0> to change hero", ButtonGuide(Button.Reload)>, null,
        Location.Left, -2,
        Color.Yellow, Color.Yellow, Color.Yellow,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);
}

rule: "Player/ReturnSpawn/returnSpawn"
Event.OngoingPlayer
Team.Team1
Player.All
if(
    IsAlive() &&
    !IsInSpawnRoom() &&
    IsButtonHeld(EventPlayer(), Button.Reload)
){
    // Return to spawn room with long hold on reload button
    WaitCancelPressConfirm();
    Respawn();
}

define initalTeamLifes: 6;
globalvar define teamLifes;

rule: "Player/TeamLifes/initalCount"
Event.OngoingGlobal
{
    // Set initial team lifes number
    teamLifes = initalTeamLifes;
}

rule: "Player/TeamLifes/showTeamLifesHUD"
Event.OngoingGlobal
{
    // show HUD of team lifes number
    CreateHudText(AllPlayers(Team.All),
        <"<0> <1>", "Team lifes", teamLifes>, null, null,
        Location.Top, 1,
        Color.Team1, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleAlways);
}

rule: "Player/TeamLifes/consumeTeamLifes"
Event.OnDeath
Team.Team1
Player.All
if(
    IsDead()
){
    // Remaining lifes reduced by spawn of downed player
    Wait(10, WaitBehavior.AbortWhenFalse);  // wait player spawn
    teamLifes -= 1;
    WaitChangeState();  // wait for show big message by newest value
    if(teamLifes > 0){
        if(teamLifes > 0){
            BigMessage(AllPlayers(Team.All),
                <"<0> <1> <2>", "Our remaining team lifes is", teamLifes, "...">);
        }
        PlayEffect(
            AllPlayers(Team.All), PlayEffect.DebuffImpactSound,
            Color.White, AllPlayers(Team.All), MaxLength());
    }
}

rule: "Player/TeamLifes/finishGame //by team lifes out"
Event.OngoingGlobal
if(
    teamLifes <= 0
){
    // When the team lifes out, the game ends
    portalState = PortalState.Idle;
    PlayEffect(
        AllPlayers(Team.All), PlayEffect.RingExplosionSound,
        Color.White, AllPlayers(Team.All), MaxLength());
    BigMessage(AllPlayers(Team.All), "Our team lifes is out...");
    SetSlowMotion(10);
    Wait(1, WaitBehavior.AbortWhenFalse);   // show slow
    SetSlowMotion(100);
    WaitNextPhase();

    BigMessage(AllPlayers(Team.All),
        <"<0> <1> <2>", "We have reached", roundNo, "round... good game!">);
    PlayRandomEmote(AllPlayers(Team.Team1));
    Wait(1, WaitBehavior.AbortWhenFalse);
    PlayRandomVoiceLine(AllPlayers(Team.Team1));
    WaitNextPhase();

    DeclareTeamVictory(Team.Team1);
}

globalvar define portalClosingCount;
globalvar define closestPlayerToPortal;

rule: "Player/ClosePortal/startClosing //on enter any player"
Event.OngoingGlobal
if(
    portalState == PortalState.Suspended &&
    teamLifes > 0
){
    // When a player enters a portal, show message
    portalClosingCount = RoundToInteger(portalSize, Rounding.Nearest);  // TAG portal closing count
    portalClosingCount += roundNo * 2;
    WaitConditionConfirmed();
    // get closest surviver to portal center
    closestPlayerToPortal = 
        FirstOf(
            SortedArray(
                FilteredArray(
                    AllPlayers(Team.Team1), IsAlive(ArrayElement())
                ),
                DistanceBetween(portalPosition, ArrayElement())
            )
        );

    BigMessage(closestPlayerToPortal,
        <"<0> <1> <2>", 
            closestPlayerToPortal,
            HeroIconString(HeroOf(closestPlayerToPortal)),
            "Closing portal ... stay inside and Survive!">);
    BigMessage(FilteredArray(AllPlayers(Team.Team1), (closestPlayerToPortal != ArrayElement())),
        <"<0> <1> <2>",    
            closestPlayerToPortal,
            HeroIconString(HeroOf(closestPlayerToPortal)),
            "Closing portal ... Cover one!">);     
}

rule: "Player/ClosePortal/countDownClosing //while enter any player"
Event.OngoingGlobal
if(
    portalState == PortalState.Suspended &&
    portalClosingCount > 0 &&
    teamLifes > 0
){
    // When a player enters a portal, start the countdown to close the portal
    WaitUpdateMediumCycle();
    portalClosingCount -= 1;
    SmallMessage(AllPlayers(Team.All), portalClosingCount);
    if(portalClosingCount <= 5){
        PlayEffect(
            AllPlayers(Team.All), PlayEffect.DebuffImpactSound,
            Color.White, AllPlayers(Team.All), MaxLength());
    }
    LoopIfConditionIsTrue();
}

rule: "Player/ClosePortal/finishClose //on count down finished"
Event.OngoingGlobal
if(
    (
        portalState == PortalState.Suspended ||
        portalState == PortalState.Closing ||
        portalState == PortalState.Closed
    ) &&
    portalClosingCount <= 0 &&
    teamLifes > 0
){
    // When the countdown is complete, clear the portal and give team lifes.
    // Later, we will generate a new portal and start the next round.
    portalState = PortalState.Closing;
    WaitPlayEffect();   //wait portal closing effect
    portalState = PortalState.Closed;
    WaitNextPhase();

    BigMessage(AllPlayers(Team.All), "We got new team lifes!");
    PlayEffect(
        AllPlayers(Team.All), PlayEffect.BuffImpactSound,
        Color.White, AllPlayers(Team.All), MaxLength()
    );
    teamLifes += 1;
    WaitNextPhase();

    PlayRandomVoiceLine(AllPlayers(Team.Team1));
    roundNo += 1;
    portalState = PortalState.Calculating;  // start next portal create
}

rule: "Player/ClosePortal/disableStealthWhenInside //sombra's stealth for fair play"
Event.OngoingPlayer
Team.Team1
Player.All
if(
    isInsidePortal &&
    HeroOf() == Hero.Sombra &&
    IsUsingAbility1()
){
    // Some abilities are disabled inside the portal to make the game fair
    // Sombra stealth is exactly that
    Wait(5.0, WaitBehavior.AbortWhenFalse); // disable ability check cycle
    SetStatus(EventPlayer(), null, Status.Stunned, 0.1);
    SmallMessage(EventPlayer(), "Stealth disabled by magnetic storm of portal.");
    LoopIfConditionIsTrue();
}

rule: "Player/ClosePortal/disableGrappleClawWhenInside //sombra's stealth for fair play"
Event.OngoingPlayer
Team.Team1
Player.All
if(
    isInsidePortal &&
    HeroOf() == Hero.WreckingBall &&
    IsFiringSecondary()
){
    // Some abilities are disabled inside the portal to make the game fair
    // WreckingBall Grapple is exactly that
    Wait(5.0, WaitBehavior.AbortWhenFalse); // disable ability check cycle
    SetStatus(EventPlayer(), null, Status.Stunned, 0.1);
    SmallMessage(EventPlayer(), "Grapple claw disabled by magnetic storm of portal.");
    LoopIfConditionIsTrue();
}

playervar define inPortalEffectEntitys;

rule: "Player/ClosePortal/showInsidePortalEffect //heavy fog and energy sound in the portal"
Event.OngoingPlayer
Team.Team1
Player.All
if(
    isInsidePortal
){
    // When a player enters the portal, show purple smoke in the player view
    // To make it easier for players to understand that they are inside the portal and to create an atmosphere
    inPortalEffectEntitys = [];
    CreateEffect(EventPlayer(), Effect.EnergySound, Color.White,
        EventPlayer(), 30, EffectRev.VisibleToPositionAndRadius);
    inPortalEffectEntitys[0] = LastCreatedEntity();

    CreateEffect(EventPlayer(), Effect.Cloud, Color.Purple,
        EventPlayer(), 5, EffectRev.VisibleToPositionAndRadius);
    inPortalEffectEntitys[1] = LastCreatedEntity();

    CreateEffect(EventPlayer(), Effect.Cloud, Color.Purple,
        EventPlayer(), 10, EffectRev.VisibleToPositionAndRadius);
    inPortalEffectEntitys[2] = LastCreatedEntity();
}

rule: "Player/ClosePortal/hideInsidePortalEffect"
Event.OngoingPlayer
Team.Team1
Player.All
if(
    !isInsidePortal
){
    // When a player exits the portal, hide purple smoke in the player view
    DestroyEffect(inPortalEffectEntitys[0]);
    DestroyEffect(inPortalEffectEntitys[1]);
    DestroyEffect(inPortalEffectEntitys[2]);
}

// TAG Enemy Function ----------
enum EnemyType{
    NotSet,
    Minion,
    Elite,
    Boss
}

playervar define enemyType;

rule: "Enemy/Effect/setEnemyType"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    HasSpawned(EventPlayer())
){
    // Set class text
    switch(HeroOf(EventPlayer())){
        case Hero.Ana:
        case Hero.Lucio:
        case Hero.Torbjorn:
        case Hero.Zenyatta:
            enemyType = EnemyType.Minion;
            break;
        case Hero.Soldier76:
        case Hero.Reaper:
        case Hero.Mei:
        case Hero.Mccree:
        case Hero.Sombra:
            enemyType = EnemyType.Elite;
            break;
        case Hero.Roadhog:
        case Hero.Zarya:
        case Hero.Bastion:
            enemyType = EnemyType.Boss;
            break;
        default:
            break;
    }
}

rule: "Enemy/Effect/setEnemyPropety"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    enemyType != EnemyType.NotSet
){
    if(enemyType == EnemyType.Minion){
        StartScalingPlayer(EventPlayer(), 1.0, false);
        StartModifyingHeroVoiceLines(EventPlayer(), 0.8, false);
        maxSpawnInterval = 3;       // TAG maxSpawnInterval
    }
    else if(enemyType == EnemyType.Elite){
        StartScalingPlayer(EventPlayer(), 1.3, false);
        StartModifyingHeroVoiceLines(EventPlayer(), 0.6, false);
        maxSpawnInterval = 10;
    }
    else if(enemyType == EnemyType.Boss){
        StartScalingPlayer(EventPlayer(), 1.6, false);
        StartModifyingHeroVoiceLines(EventPlayer(), 0.4, false);
        maxSpawnInterval = 15;
    }
}

playervar define enemyAppearanceEntitys;

rule: "Enemy/Effect/showEnemyAppearance"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    enemyType != EnemyType.NotSet &&
    IsAlive()
){
    enemyAppearanceEntitys = [];
    if(enemyType == EnemyType.Minion){
        CreateEffect(AllPlayers(Team.All), Effect.Cloud, Color.Purple,
            EventPlayer(), 1.0, EffectRev.VisibleToPositionAndRadius);
        enemyAppearanceEntitys[0] = LastCreatedEntity();
        CreateInWorldText(
            AllPlayers(Team.All), "Minion", 
            EventPlayer(), 0.8, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            Color.White, Spectators.DefaultVisibility);
        enemyAppearanceEntitys[1] = LastTextID();
    }
    else if(enemyType == EnemyType.Elite){
        CreateEffect(AllPlayers(Team.All), Effect.Cloud, Color.Purple,
            EventPlayer(), 2.0, EffectRev.VisibleToPositionAndRadius);
        enemyAppearanceEntitys[0] = LastCreatedEntity();
        CreateInWorldText(
            AllPlayers(Team.All), "Elite", 
            EventPlayer(), 1.4, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            Color.Yellow, Spectators.DefaultVisibility);
        enemyAppearanceEntitys[1] = LastTextID();
    }
    else if(enemyType == EnemyType.Boss){
        CreateEffect(AllPlayers(Team.All), Effect.Cloud, Color.Purple,
            EventPlayer(), 4.0, EffectRev.VisibleToPositionAndRadius);
        enemyAppearanceEntitys[0] = LastCreatedEntity();
        CreateInWorldText(
            AllPlayers(Team.All), "Boss", 
            EventPlayer(), 2.0, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            Color.Red, Spectators.DefaultVisibility);
        enemyAppearanceEntitys[1] = LastTextID();
    }
}

rule: "Enemy/Effect/hideEnemyAppearance"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    enemyType != EnemyType.NotSet &&
    !IsAlive()
){
    DestroyEffect(enemyAppearanceEntitys[0]);
    DestroyInWorldText(enemyAppearanceEntitys[1]);
}

rule: "Enemy/Effect/playDeadEffect"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    IsDead()
){
    // Play blast effect when enemy dead
    // It's easier to understand if you killed an enemy, and you'll feel better
    if(enemyType == EnemyType.Minion){
        PlayContinuousBlast(PositionOf(), 2, 1, Color.Red);
    }
    else if(enemyType == EnemyType.Elite){
        PlayContinuousBlast(PositionOf(), 3, 2, Color.Red);
    }
    else if(enemyType == EnemyType.Boss){
        PlayContinuousBlast(PositionOf(), 5, 3, Color.Red);
    }
}

rule: "Enemy/RandomJump/jump"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    IsAlive() &&
    IsInLineOfSight(EventPlayer(),
        ClosestPlayerTo(EventPlayer(), Team.Team1),
        BarrierLOS.NoBarriersBlock)
){
    WaitConditionConfirmed();
    if(IsMoving() && IsOnGround()){
        ApplyImpulse(EventPlayer(),
            Vector(
                RandomReal(-1, 1),
                RandomReal( 1, 1),
                RandomReal(-1, 1)
            ),
            6, Relative.ToPlayer, ContraryMotion.Cancel);
    }
    Wait(RandomInteger(1, 4), WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

playervar define teleportBeamEntity;
playervar define teleportPosition;

void PlayTeleportBeam()"Subroutine/PlayTeleportBeam"{
    DestroyEffect(teleportBeamEntity);
    // show beam
    CreateBeamEffect(AllPlayers(Team.All), BeamType.BadBeam,
        EventPlayer(), teleportPosition,
        Color.Purple, EffectRev.VisibleToPositionAndRadius);
    teleportBeamEntity = LastCreatedEntity();
    // show beam effect
    WaitPlayEffect();
    // hide beam
    DestroyEffect(teleportBeamEntity);
}

void SetTeleportPositionToBlindSpot()"Subroutine/SetTeleportPositionToBlindSpot"{
    // set teleport position by blind spot from player
    // find place that will be a blind spot up to 10 times
    for(loopIndex = 0; loopIndex < 10; loopIndex++){
        teleportPosition = NearestWalkablePosition(
            portalPosition + 
            RandomPosition(portalSize * 1.0, portalSize * 1.0, portalSize * 1.0)
        );
        if(
            DistanceBetween(    // Within the portal
                portalPosition, teleportPosition + PositionOffset())
                <= portalSize * 1.0
                    &&
            !IsInLineOfSight(   // Blind spot from the player 
                teleportPosition + PositionOffset(),
                ClosestPlayerTo(EventPlayer(), Team.Team1),
                BarrierLOS.NoBarriersBlock)
        ){
            break;
        }
    }
}

void SetTeleportPositionToCamper()"Subroutine/SetTeleportPositionToCamper"{
    // set teleport position by blind spot from player
    // find place that will be a blind spot up to 10 times
    for(loopIndex = 0; loopIndex < 10; loopIndex++){
        teleportPosition = ClosestPlayerTo(
            portalPosition, Team.Team1) +
            RandomPosition(1.0, 0, 1.0);
        if(
            IsInLineOfSight(    // Not buried in the wall
                teleportPosition + PositionOffset(),
                ClosestPlayerTo(EventPlayer(), Team.Team1),
                BarrierLOS.NoBarriersBlock)
                    &&
            !IsInViewAngle(    // Out of the player's field of view
                ClosestPlayerTo(EventPlayer(), Team.Team1),
                teleportPosition + PositionOffset(), 90)
        ){
            break;
        }
    }
}

rule: "Enemy/Teleport/teleportToSpawnRoomWhenPortalDisabled"
Event.OngoingGlobal
if(
    initCompleted &&
    !portalEnable
){
    // Teleport Enemy to spawn room when portal disable
    Wait(1, WaitBehavior.AbortWhenFalse);   // wait show dead effect
    // Teleport to spawn room
    Respawn(AllPlayers(Team.Team2));
}

rule: "Enemy/Teleport/teleportToSpawnRoomWhenPortalEnabled"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    initCompleted &&
    portalEnable
){
    // Teleport Enemy to portal when spawn

    // set teleport position tp blind spot from player
    SetTeleportPositionToBlindSpot();
    // Teleport
    Teleport(EventPlayer(), teleportPosition);
}

rule: "Enemy/Teleport/teleportToPortalBySpawn //when exist portal"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    portalEnable &&
    IsInSpawnRoom()
){
    // Teleport Enemy to portal when spawn

    // set teleport position tp blind spot from player
    SetTeleportPositionToBlindSpot();
    // Teleport
    Teleport(EventPlayer(), teleportPosition);
}

rule: "Enemy/Teleport/teleportToPortalByPlayerEntered //for protect portal"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    portalState == PortalState.Suspended &&
    IsAlive(EventPlayer())
){
    WaitConditionConfirmed();
    if(
        DistanceBetween(EventPlayer(), portalPosition) > portalSize &&
        DistanceBetween(EventPlayer(), ClosestPlayerTo(portalPosition, Team.Team1)) >= 10
    ){
        // Teleport Enemy to portal when player enter to portal
        // To protect the portal with the enemy

        // set teleport position tp blind spot from player
        SetTeleportPositionToBlindSpot();
        // show teleport beam
        PlayTeleportBeam();
        // Teleport
        Teleport(EventPlayer(), teleportPosition);
    }
}

rule: "Enemy/Teleport/teleportToPortalByCamperDetected //when player not found"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    portalState == PortalState.Suspended &&
    IsAlive() &&
    !IsInLineOfSight(EventPlayer(),
        ClosestPlayerTo(portalPosition, Team.Team1),
        BarrierLOS.NoBarriersBlock)
){
    // Teleport an enemy to camping player
    Wait(10 - (roundNo / 7), WaitBehavior.AbortWhenFalse); // player not found timer
    // set teleport position to camper
    SetTeleportPositionToCamper();
    // show teleport beam
    PlayTeleportBeam();
    // Teleport
    Teleport(EventPlayer(), teleportPosition);

    LoopIfConditionIsTrue();
}

rule: "Enemy/Standby/enable //standby enemy bot when not exist portal"
Event.OngoingGlobal
if(
    !portalEnable
){
    // Lock enemies when portal is disable so they can't leave the spawn room
    WaitConditionConfirmed();
    SetStatus(AllPlayers(Team.Team2), null, Status.Rooted, MaxValue());
}

rule: "Enemy/Standby/disable //not standby enemy bot when exist portal"
Event.OngoingGlobal
if(
    portalEnable
){
    // Release lock enemies when portal is enable
    WaitConditionConfirmed();
    ClearStatus(AllPlayers(Team.Team2), Status.Rooted);
}

globalvar define enemyReceivedDamageRate;

rule: "Enemy/ReceivedDamage/updateByBalance //for game balance, increase by missing players count"
Event.OngoingGlobal
{
    WaitUpdateLongCycle();
    // If don't enough players, adjust enemy received damage rate to make the game fair
    // Multiply damage rate
    enemyReceivedDamageRate = 100;
    // Apply balance multiplier
    enemyReceivedDamageRate *= ConvertToBalancedValue(0.75, Team.Team1);     // TAG enemy received damage scale
    SetDamageReceived(AllPlayers(Team.Team2), enemyReceivedDamageRate);
    LoopIfConditionIsTrue();
}

globalvar define enemyDealtDamageRate;
rule: "Enemy/DealtDamage/updateByBalance //for game progress, increase by round no, decrease by missing players count"
Event.OngoingGlobal
{
    WaitUpdateLongCycle();
    // If don't enough players, adjust enemy dealt damage rate to make the game fair
    // And the round progresses, the enemy deal damage increases and becomes more difficult
    // Add damage rate according to the round progress
    enemyDealtDamageRate = 25;                    // basic enemy dealt damage
    enemyDealtDamageRate += (roundNo * 1.5);      // Add damage depending on the number of rounds for progress
    // Apply balance multiplier
    enemyDealtDamageRate /= ConvertToBalancedValue(0.75, Team.Team1);     // TAG enemy dealt damage scale
    SetDamageDealt(AllPlayers(Team.Team2), enemyDealtDamageRate);

    LoopIfConditionIsTrue();
}

define maxHiddenSpeed: 600;
globalvar define _EnemySpeedScale;
globalvar define enemyHiddenSpeedRate;
playervar define isHiddenSpeed;

rule: "Enemy/HiddenSpeed/updateByPortalSize //for round harder, increase by growing portal size"
Event.OngoingGlobal
if(
    portalState == PortalState.Growing
){
    WaitUpdateMediumCycle();
    // Increase enemy hidden speed depending on portal size
    // Portals that have grown significantly over time will send quickly more enemies.
    _EnemySpeedScale = portalSize;
    _EnemySpeedScale /= maxPortalSize;
    enemyHiddenSpeedRate = maxHiddenSpeed;
    enemyHiddenSpeedRate *= _EnemySpeedScale;
    enemyHiddenSpeedRate += 100;
    LoopIf(portalSize < maxPortalSize);
}

rule: "Enemy/HiddenSpeed/enableByGetInSight //when not visible from players, quickly approach the player and hunt down"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    !IsInLineOfSight(EventPlayer(),
        ClosestPlayerTo(EventPlayer(), Team.Team1),
        BarrierLOS.NoBarriersBlock
    )
){
    // Hidden Speed is active when the player can't see the enemy
    // Players are surrounded by many enemies, making the game more chaotic and fluid
    WaitConditionConfirmed();
    SetMoveSpeed(EventPlayer(), enemyHiddenSpeedRate);
    // The portal may growing and changing in size, so repeat speed changes
    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}

rule: "Enemy/HiddenSpeed/disableByGetOutOfSight //when visible from players, fight at basic speed"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    IsInLineOfSight(EventPlayer(),
        ClosestPlayerTo(EventPlayer(), Team.Team1),
        BarrierLOS.NoBarriersBlock
    )
){
    // Hidden Speed is deactive when the player can see the enemy
    // Enemies move at normal speed, making it easier for players to attack enemies
    Wait(0.1, WaitBehavior.AbortWhenFalse); // wait disable hidden speed
    SetMoveSpeed(EventPlayer(), 100);
}

playervar define maxSpawnInterval;
globalvar define _EnemySpawnScale;
playervar define enemySpawnInterval;

rule: "Enemy/SpawnInterval/updateByPortalSizeAndRoundNo //portal get bigger, interval get shorter and game getter harder"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    portalState == PortalState.Growing
){
    WaitUpdateMediumCycle();
    // Shortens enemy spawn interval depending on portal size
    // Portals that have grown significantly over time will spawn more enemies.
    _EnemySpawnScale = maxPortalSize;
    _EnemySpawnScale -= portalSize;
    _EnemySpawnScale /= maxPortalSize;

    enemySpawnInterval = maxSpawnInterval;
    enemySpawnInterval *= _EnemySpawnScale;// TAG enemy spawn interval

    enemySpawnInterval -= (roundNo / 10);
    if(0 > enemySpawnInterval){
        enemySpawnInterval = 0;
    }
    
    // set +1 enemySpawnInterval for show dead effect
    SetRespawnMaxTime(EventPlayer(), enemySpawnInterval + 1);
    LoopIf(portalSize < maxPortalSize);
}

rule: "Enemy/SpawnInterval/resetByPortalReset"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    portalState == PortalState.Calculating
){
    // Shortens enemy spawn interval depending on portal size
    enemySpawnInterval = maxSpawnInterval;
    SetRespawnMaxTime(EventPlayer(), enemySpawnInterval);
}

rule: "Enemy/SpawnInterval/respawnBySucide"
Event.OnDeath
Team.Team2
Player.All
if(
    Attacker() == EventPlayer()
){
    Wait(1, WaitBehavior.AbortWhenFalse);
    Respawn();
}

// TAG Portal Function ----------
globalvar define portalState;
enum PortalState{
    Idle,
    Calculating,
    Set,
    Growing,
    Suspended,
    Closing,
    Closed
}

globalvar define portalPosition;
globalvar define portalSize;
globalvar define portalEntitys;
globalvar define isFirstGrowing;

define portalEnable:
    portalState == PortalState.Set ||
    portalState == PortalState.Growing ||
    portalState == PortalState.Suspended;

rule: "Portal/State/Calculating //invisible, init param"
Event.OngoingGlobal
if(
    portalState == PortalState.Calculating
){
    // Hide Portal Entity until portal state changed to Show
    // Init param
    portalPosition = 0;
    portalSize = 0;
    StopChasingVariable(portalSize);
    enemyHiddenSpeedRate = 100;
    isFirstGrowing = true;
    // Hide portal icon and effect
    DestroyIcon(portalEntitys[0]);
    DestroyEffect(portalEntitys[1]);
    DestroyEffect(portalEntitys[2]);
    DestroyEffect(portalEntitys[3]);
    DestroyEffect(portalEntitys[4]);
}

rule: "Portal/State/Set  // waiting for found by players"
Event.OngoingGlobal
if(
    portalState == PortalState.Set
){
    DestroyIcon(portalEntitys[0]);
    // show Portal Entity by portal state changed to Show
    // Init param
    portalClosingCount = MaxValue();
    // show icon
    portalEntitys = [];
    CreateIcon(AllPlayers(Team.All), portalPosition, Icon.Spiral,
        IconRev.VisibleToAndPosition, Color.Purple, true);
    portalEntitys[0] = LastCreatedEntity();
    // set effect
    // sphere
    CreateEffect(AllPlayers(Team.All), Effect.Sphere, Color.Purple,
        portalPosition, portalSize, EffectRev.VisibleToPositionAndRadius);
    portalEntitys[1] = LastCreatedEntity();
    // cloud
    CreateEffect(AllPlayers(Team.All), Effect.Cloud, Color.Purple,
        portalPosition, portalSize * 1.5, EffectRev.VisibleToPositionAndRadius);
    portalEntitys[2] = LastCreatedEntity();
    // aura
    // Since visibility will be poor, display only in the center of the field of view
    CreateEffect(
        FilteredArray(
            AllPlayers(Team.All),
            DistanceBetween(ArrayElement(), portalPosition) > portalSize / 2), Effect.BadAura, Color.Purple,
        portalPosition, portalSize * 1.25, EffectRev.VisibleToPositionAndRadius);
    portalEntitys[3] = LastCreatedEntity();
    // sound
    CreateEffect(AllPlayers(Team.All), Effect.EnergySound, Color.Purple,
        portalPosition, portalSize / 2, EffectRev.VisibleToPositionAndRadius);
    portalEntitys[4] = LastCreatedEntity();

    // show message
    BigMessage(AllPlayers(Team.All), "Detected more portal... find and attack it!");
    // Hide icon to let the player search the portal
    Wait(6, WaitBehavior.AbortWhenFalse);
    DestroyIcon(portalEntitys[0]);
}

rule: "Portal/State/Growing //start growing when found by players"
Event.OngoingGlobal
if(
    portalState == PortalState.Growing
){
    // Start growing portal with warning message
    ChaseVariableAtRate(
        portalSize, maxPortalSize, 1 + (roundNo / 10),   //TAG portal grow speed
        RateChaseReevaluation.DestinationAndRate);
    // If first growing, show message
    if(isFirstGrowing == true){
        isFirstGrowing = false;
        BigMessage(AllPlayers(Team.All), "Portal is growing... hurry up!");
        WaitBigMessageHide();
        BigMessage(AllPlayers(Team.All), "Growed portals spawn more enemys and got tough ...");
    }
    // Hide icon to let the player search the portal
    Wait(1, WaitBehavior.AbortWhenFalse);
    DestroyIcon(portalEntitys[0]);
}

rule: "Portal/State/Suspended //when player entered, stop growing and count down start"
Event.OngoingGlobal
if(
    portalState == PortalState.Suspended
){
    // Hide icon to let the player search the portal
    DestroyIcon(portalEntitys[0]);
    // Stop growing portal
    StopChasingVariable(portalSize);
}

rule: "Portal/State/Closing //play closing effect"
Event.OngoingGlobal
if(
    portalState == PortalState.Closing
){
    // play portal closing effect and kill enemrys
    Kill(AllPlayers(Team.Team2), null);
    // play blast sound
    PlayEffect(
        AllPlayers(Team.All), PlayEffect.RingExplosionSound,
        Color.White, AllPlayers(Team.All), MaxLength());
    // contraction portal
    ChaseVariableOverTime(portalSize, 0,
        0.65, TimeChaseReevaluation.DestinationAndDuration);
    // play blast effect
    PlayContinuousBlast(portalPosition, portalSize * 1.5,
        10, Color.Yellow);
}

rule: "Portal/State/Closed //waiting state after closing. another script displays the round end message and adds teamlifes"
Event.OngoingGlobal
if(
    portalState == PortalState.Closed
){
    // show message
    BigMessage(AllPlayers(Team.All), "Portal closed... good job!");
    // init param
    portalPosition = 0;
    portalSize = 0;
    StopChasingVariable(portalSize);
    // Hide portal icon and effect
    DestroyIcon(portalEntitys[0]);
    DestroyEffect(portalEntitys[1]);
    DestroyEffect(portalEntitys[2]);
    DestroyEffect(portalEntitys[3]);
    DestroyEffect(portalEntitys[4]);
}

globalvar define spawnPosition1;
globalvar define spawnPosition2;
globalvar define centerPosition;
globalvar define createRange;
globalvar define candidatePosition;

rule: "Portal/Positioner/setSpawnPosition1 //a starting point for understanding the approximate center of the map"
Event.OngoingPlayer
Team.Team1
Player.All
if(
    initCompleted &&
    spawnPosition1 == 0 &&
    !IsInSpawnRoom()
){
    WaitConditionConfirmed();
    // Set Team1's spawn points as spawnPosition1
    spawnPosition1 = PositionOf();
}

rule: "Portal/Positioner/setSpawnPosition2 //a starting point for understanding the approximate center of the map"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    initCompleted &&
    spawnPosition2 == 0 &&
    !IsInSpawnRoom()
){
    WaitConditionConfirmed();
    // Set Team2's spawn points as spawnPosition2
    spawnPosition2 = PositionOf();
}

rule: "Portal/Positioner/setCenterPosition //approximate center of the map. _set between two spawn position"
Event.OngoingGlobal
if(
    spawnPosition1 != 0 &&
    spawnPosition2 != 0
){
    // Set midway between two spawn points as centerPosition
    centerPosition = (spawnPosition1 + spawnPosition2) / 2;
}

rule: "Portal/Positioner/createRange //distance range from the center of the map that create portal"
Event.OngoingGlobal
if(
    centerPosition != 0
){
    // Set the range to generate portal based on the central position
    // Use a factor times the distance between two spawn points to cover the map
    createRange = DistanceBetween(spawnPosition1, spawnPosition2) * 1.0;   // TAG create range
}

rule: "Portal/Positioner/createPortalInRange //repeat random positioning until close to map surface"
Event.OngoingGlobal
if(
    createRange != 0 &&
    portalState == PortalState.Calculating
){
    // Create portal in createRange
    // Get candidate position by random position within the create range from the center of the map
    // reduce coordinateY for will not select a different location than the player's location in control map
    candidatePosition = centerPosition + RandomPosition(createRange, createRange / 4, createRange);
    MinWait();   // calculale location cycle
    // Repeat random position determination until within 10 meters of the map's walkable surface
    LoopIf(
        DistanceBetween(
            candidatePosition,
            NearestWalkablePosition(candidatePosition)
        ) > 15
    ); 
    // change to walkable position
    portalPosition = NearestWalkablePosition(candidatePosition) + PositionOffset();
    // create portal entity
    portalState = PortalState.Set;
}

globalvar define countOfInvalidArea;

rule: "Portal/Positioner/DetectInvalidArea/countdownSuicides"
Event.OnDeath 
Team.Team2
Player.All
if(
    portalEnable &&
    Attacker() == EventPlayer()
){
    // Count the number of enemy suicides caused by invalid areas
    // Player team spawn areas and instability at cliffs, etc.
    countOfInvalidArea --;
}

rule: "Portal/Positioner/DetectInvalidArea/resetCount"
Event.OngoingGlobal
if(
    !portalEnable
){
    // Reset count by portal reset
    countOfInvalidArea = (NumberOfPlayers(Team.Team2) / 2);
}

rule: "Portal/Positioner/DetectInvalidArea/reduceCount"
Event.OngoingGlobal
if(
    countOfInvalidArea < (NumberOfPlayers(Team.Team2) / 2)
){
    // Reduce over time to avoid over detection
    Wait(1, WaitBehavior.AbortWhenFalse);   // wait reduce sucide count
    countOfInvalidArea ++;
    LoopIfConditionIsTrue();
}

rule: "Portal/Positioner/DetectInvalidArea/resetPortal"
Event.OngoingGlobal
if(
    countOfInvalidArea <= 0
){
    // If the suicide count reaches 0,
    //  it is determined that the portal position is incorrect and the portal is recreate
    dbgMsg("resetPortal by Detect Invalid Area");
    portalState = PortalState.Calculating;
}

rule: "Portal/Positioner/DetectSpawnArea/resetPortal"
Event.OngoingGlobal
if(
    portalEnable
){
    // If the portal position is in the enemy spawn area,
    //  it is determined that the portal position is incorrect and the portal is recreate
    Wait(1, WaitBehavior.AbortWhenFalse);   // wait teleport to portal
    if(IsInSpawnRoom(ClosestPlayerTo(portalPosition, Team.Team2))){
        dbgMsg("resetPortal by Detect Spawn Area");
        portalState = PortalState.Calculating;
    }
}

globalvar define timerOfRemoteArea;
globalvar define contactHappened;

rule: "Portal/Positioner/DetectRemoteArea/countdownNonContactTimer"
Event.OngoingGlobal
if(
    portalEnable &&
    !contactHappened
){
    // start count down
    timerOfRemoteArea --;
    Wait(1, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

rule: "Portal/Positioner/DetectRemoteArea/resetTimer"
Event.OngoingGlobal
if(
    !portalEnable
){
    // stop count down and reset timer
    contactHappened = false;
    timerOfRemoteArea = portalStableTime - 1;
}

rule: "Portal/Positioner/DetectRemoteArea/stopTimer"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    portalEnable &&
    IsInLineOfSight(EventPlayer(),
        ClosestPlayerTo(EventPlayer(), Team.Team1),
        BarrierLOS.NoBarriersBlock
    )
){
    // If the player and enemy have been met, stop count down
    WaitConditionConfirmed();
    contactHappened = true;
}

rule: "Portal/Positioner/DetectRemoteArea/resetPortal"
Event.OngoingGlobal
if(
    timerOfRemoteArea <= 0
){
    // If the player and enemy haven't been met for some time,
    //  it is determined that the portal position is incorrect and the portal is recreate
    dbgMsg("resetPortal by Detect Remote Area");
    portalState = PortalState.Calculating;
}

globalvar define isCheckingNotMoving;
globalvar define countOfClosedArea;

rule: "Portal/Positioner/DetectClosedArea/startChecking"
Event.OngoingGlobal
if(
    portalEnable
){
    countOfClosedArea = MaxValue();
    isCheckingNotMoving = true;
}

rule: "Portal/Positioner/DetectClosedArea/resetChecking"
Event.OngoingGlobal
if(
    !portalEnable ||
    contactHappened
){
    countOfClosedArea = MaxValue();
    isCheckingNotMoving = false;
}

rule: "Portal/Positioner/DetectClosedArea/countdownNotMovingEnemys"
Event.OngoingGlobal
if(
    portalEnable &&
    isCheckingNotMoving
){
    // Count the number of moving enemy caused by closed areas
    // non activated respawn room, etc.
    countOfClosedArea =
        NumberOfPlayers(Team.Team2) - CountOf(
            FilteredArray(
                AllPlayers(Team.Team2),
                (
                    IsAlive(ArrayElement()) &&
                    !IsMoving(ArrayElement())
                )
            )
    );
    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue()
}

rule: "Portal/Positioner/DetectClosedArea/resetPortal"
Event.OngoingGlobal
if(
    countOfClosedArea <= 3
){
    // If the portal position is in the cloased area,
    //  it is determined that the portal position is incorrect and the portal is recreate
    Wait(3, WaitBehavior.AbortWhenFalse);
    dbgMsg("resetPortal by Detect Closed Area");
    portalState = PortalState.Calculating;
}

define maxPortalSize: 70;
define portalStableTime: 40;

rule: "Portal/Growing/startGrowingByPlayerFound"
Event.OngoingGlobal
if(
    portalState == PortalState.Set &&
    IsInLineOfSight(portalPosition,
        ClosestPlayerTo(portalPosition, Team.Team1),
        BarrierLOS.NoBarriersBlock
    )
){
    // Strat portal growing by player found
    WaitConditionConfirmed();
    portalState = PortalState.Growing;
}

rule: "Portal/Growing/startGrowingByTimeout"
Event.OngoingGlobal
if(portalState == PortalState.Set){
    // Start portal growing by search time limit out
    Wait(portalStableTime, WaitBehavior.AbortWhenFalse);  //wait time to start growing
    portalState = PortalState.Growing;
}

rule: "Portal/Growing/suspendGrowingByPlayerEntered"
Event.OngoingGlobal
if(
    portalState == PortalState.Growing &&
    IsTrueForAny(
        AllPlayers(Team.Team1), ArrayElement().isInsidePortal
    )
){
    // Suspend portal growing by player enter to portal
    WaitConditionConfirmed();
    portalState = PortalState.Suspended;
}

rule: "Portal/Growing/resumeGrowingByPlayerExited"
Event.OngoingGlobal
if(
    portalState == PortalState.Suspended &&
    !IsTrueForAny(
        AllPlayers(Team.Team1), ArrayElement().isInsidePortal
    )
){
    // Resume portal growing by player exit from portal
    WaitConditionConfirmed();
    portalState = PortalState.Growing;
}

// TAG Debug ----------
// debugmode
globalvar define isDebugMode;
globalvar define debugIconHudEntitys;

// show debug icon and hud
void ShowDebugHud()"Subroutine/ShowDebugHud"{
    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "player Regeneration Rate", playerRegenerationRate1>,
        null,
        Location.Left, -1,
        Color.White, Color.Blue, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);
    debugIconHudEntitys[0] = LastTextID();

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "enemy Spawn Interval (boss)", PlayersInSlot(0, Team.Team2).enemySpawnInterval>,
        null,
        Location.Left, -1,
        Color.White, Color.Red, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);
    debugIconHudEntitys[2] = LastTextID();

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "enemy Spawn Interval (elite)", PlayersInSlot(1, Team.Team2).enemySpawnInterval>,
        null,
        Location.Left, -1,
        Color.White, Color.Red, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);
    debugIconHudEntitys[3] = LastTextID();

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "enemy Spawn Interval (minion)", PlayersInSlot(3, Team.Team2).enemySpawnInterval>,
        null,
        Location.Left, -1,
        Color.White, Color.Red, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);
    debugIconHudEntitys[4] = LastTextID();

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "enemy Hidden Speed Rate", enemyHiddenSpeedRate>,
        null,
        Location.Left, -1,
        Color.White, Color.Red, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);
    debugIconHudEntitys[5] = LastTextID();

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "enemy Dealt Damage Rate", enemyDealtDamageRate>,
        null,
        Location.Left, -1,
        Color.White, Color.Red, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);
    debugIconHudEntitys[6] = LastTextID();

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "enemy Received Damage Rate", enemyReceivedDamageRate>,
        null,
        Location.Left, -1,
        Color.White, Color.Red, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);
    debugIconHudEntitys[7] = LastTextID();

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "portal State", portalState>,
        null,
        Location.Left, -1,
        Color.White, Color.Purple, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);
    debugIconHudEntitys[8] = LastTextID();

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "portal Size", portalSize>,
        null,
        Location.Left, -1,
        Color.White, Color.Purple, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);
    debugIconHudEntitys[9] = LastTextID();

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "portal Position", portalPosition>,
        null,
        Location.Left, -1,
        Color.White, Color.Purple, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);
    debugIconHudEntitys[10] = LastTextID();

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "distance to protal", DistanceBetween(EventPlayer(), portalPosition)>,
        null,
        Location.Left, -1,
        Color.White, Color.Purple, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);
    debugIconHudEntitys[11] = LastTextID();

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "count Of Invalid Area", countOfInvalidArea>,
        null,
        Location.Left, -1,
        Color.White, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);
    debugIconHudEntitys[12] = LastTextID();

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "timer Of Remote Area", timerOfRemoteArea>,
        null,
        Location.Left, -1,
        Color.White, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);
    debugIconHudEntitys[13] = LastTextID();

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "count Of Closed Area", countOfClosedArea>,
        null,
        Location.Left, -1,
        Color.White, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);
    debugIconHudEntitys[14] = LastTextID();

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "perk Effect Status", perkEffectStatus>,
        null,
        Location.Left, -1,
        Color.White, Color.Turquoise, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);
    debugIconHudEntitys[15] = LastTextID();

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "perk Targets", perkTargets>,
        null,
        Location.Left, -1,
        Color.White, Color.Turquoise, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);
    debugIconHudEntitys[16] = LastTextID();

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "perk Position", perkPosition>,
        null,
        Location.Left, -1,
        Color.White, Color.Turquoise, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);
    debugIconHudEntitys[17] = LastTextID();

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "Server Load", ServerLoad()>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);
    debugIconHudEntitys[18] = LastTextID();

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "Server Load Average", ServerLoadAverage()>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);
    debugIconHudEntitys[19] = LastTextID();

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "Server Load Peak", ServerLoadPeak()>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);
    debugIconHudEntitys[20] = LastTextID();
}

// Hide debug icon and hud
void HideDebugHud()"Subroutine/HideDebugHud"{
    DestroyHudText(debugIconHudEntitys[0]);
    DestroyHudText(debugIconHudEntitys[2]);
    DestroyHudText(debugIconHudEntitys[3]);
    DestroyHudText(debugIconHudEntitys[4]);
    DestroyHudText(debugIconHudEntitys[5]);
    DestroyHudText(debugIconHudEntitys[6]);
    DestroyHudText(debugIconHudEntitys[7]);
    DestroyHudText(debugIconHudEntitys[8]);
    DestroyHudText(debugIconHudEntitys[9]);
    DestroyHudText(debugIconHudEntitys[10]);
    DestroyHudText(debugIconHudEntitys[11]);
    DestroyHudText(debugIconHudEntitys[12]);
    DestroyHudText(debugIconHudEntitys[13]);
    DestroyHudText(debugIconHudEntitys[14]);
    DestroyHudText(debugIconHudEntitys[15]);
    DestroyHudText(debugIconHudEntitys[16]);
    DestroyHudText(debugIconHudEntitys[17]);
    DestroyHudText(debugIconHudEntitys[18]);
    DestroyHudText(debugIconHudEntitys[19]);
    DestroyHudText(debugIconHudEntitys[20]);
}

rule: "Debug/changeDebugMode"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == EventPlayer() &&
    IsButtonHeld(EventPlayer(), Button.Interact) &&
    IsButtonHeld(EventPlayer(), Button.Jump) 
){
    // change debug mode
    WaitLongPressConfirm();
    if(isDebugMode){
        HideDebugHud();
        DisableInspectorRecording();
        isDebugMode = false;
    }
    else{
        ShowDebugHud();
        EnableInspectorRecording();
        isDebugMode = true;
    }
}

rule: "Debug/increaseTeamLifes"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == EventPlayer() &&
    IsButtonHeld(EventPlayer(), Button.Interact) &&
    IsButtonHeld(EventPlayer(), Button.Ability2)
){
    // Increase TeamLifes
    WaitLongPressConfirm();
    teamLifes += 1;
    LoopIfConditionIsTrue();
}

rule: "Debug/increaseRoundNo"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == EventPlayer() &&
    IsButtonHeld(EventPlayer(), Button.Interact) &&
    IsButtonHeld(EventPlayer(), Button.Ability1)
){
    // Increase RoundNo
    WaitLongPressConfirm();
    roundNo += 1;
    LoopIfConditionIsTrue();
}

rule: "Debug/resetPortal // reset portal position by random"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == EventPlayer() &&
    IsButtonHeld(EventPlayer(), Button.Interact) &&
    IsButtonHeld(EventPlayer(), Button.Crouch)
){
    // Recalculate portal
    WaitLongPressConfirm();
    portalState = PortalState.Idle;
    Wait(0.5, WaitBehavior.IgnoreCondition);  // Wait for the changed status to be processed first
    portalState = PortalState.Calculating;
}

globalvar define debugAimingPosition;

rule: "Debug/setPortalPositionOnAimCenter // reset portal position by aim center"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == EventPlayer() &&
    IsButtonHeld(EventPlayer(), Button.Interact) &&
    IsButtonHeld(EventPlayer(), Button.Reload)
){
    // Set portal position to aim center
    WaitLongPressConfirm();
    portalState = PortalState.Idle;
    debugAimingPosition = AimingPosition();
    Wait(0.5, WaitBehavior.IgnoreCondition);  // Wait for the changed status to be processed first
    portalState = PortalState.Calculating;
    while(portalState == PortalState.Calculating){Wait(0.1, WaitBehavior.IgnoreCondition)}
    portalPosition = debugAimingPosition;
    Respawn(AllPlayers(Team.Team2));
}
