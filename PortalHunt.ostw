// [Detail]
// [Portal Hunt -HORDE PVE] The hell portal has been opened… Defeat enemie horde that spawn from portal and close portal!  When enter portal, start sequence of close. survive to complete.  Over time, portal grow. Grown portal spawn more enemie and get harder.  Survive using PERK dropped by enemy.  PERK has uniqe buffs, new weapon, powerful custom heroes, others.  ex) GrapplingBeam, CruisingMissile, LegendaryNinja and more than 25 types!  Unlimited rounds. How many rounds can you survive?
// [Share Code]
// YY1N2
// [ToDo]
// add Perk Disarmament
// add Perk Drone Friend Dog
// add Perk Assassination

import "Lib/Debug.del";
import "Lib/Utility.del";
import "Lib/ElapsedTimer.del";
import "Lib/DamageText.del";
import "Lib/Regeneration.del";
import "Lib/Revive.del";
import "Lib/PerkChooser.del";
import "Lib/Bot.del";

// TAG duumy define ----------
// globalvar define Revive_enableTeam;
// globalvar define Revive_timeLimit;
// globalvar define reviveTimeoutCount;
// globalvar define Regeneration_enableTeam;
// globalvar define Regeneration_needBalanceTeam1;
// globalvar define Regeneration_waitRegenTimeTeam1;
// globalvar define Regeneration_regenerationRateTeam1;
// globalvar define playerRegenerationRateTeam1;
// globalvar define DamageText_enableTeam;
// void DestroyBots(){}
// void CreateEnemyBotsByAssetList(){}

// TAG Signature and infomation ----------
disabled rule: "PORTAL HUNT -HORDE PVE [ver 4.0] Share code [YY1N2]"-1{}
disabled rule: "You allowed copy or modify code."-1{}
disabled rule: "This script was generated from source code by [Overwatch-Script-To-Workshop]"-1{}
disabled rule: "Check detail with https://github.com/ItsDeltin/Overwatch-Script-To-Workshop"-1{}
disabled rule: "Original source code was created by [sarami77#1868]"-1{}
disabled rule: "Check detail with https://github.com/sarami77/OverwatchWorkShopScripts"-1{}

// TAG System ----------
define WaitUntilServerFree(): WaitUntil(!isServerOverLoading, 5);

define slowLevel: [100, 95, 90, 80, 50];    // 0～4
globalvar define targetSlowLevel!;
globalvar define currentSlowLevel!;
globalvar define slowControlHandler!;
enum SlowControlHandler{
    None,
    ServerOverLoadMeasures,
    PlayerJoin,
    GameEnd
}

rule: "System/ServerOverLoadMeasures/increaseSlowLevel"
Event.OngoingGlobal
if(
    initCompleted &&    
    slowControlHandler == SlowControlHandler.ServerOverLoadMeasures &&
    isServerOverLoading &&
    targetSlowLevel < (CountOf(slowLevel) - 1)
){
    // If the server is overloaded,
    //  apply slow motion every second
    //  to reduce the load to avoid shutting down due to server overload.
    Wait(1, WaitBehavior.AbortWhenFalse);
    // can increase slow level
    if(targetSlowLevel < (CountOf(slowLevel) - 1)){
        // increase slow level
        targetSlowLevel ++;
        // apply slow level
        ApplySlowLevel(targetSlowLevel);
    }
    LoopIfConditionIsTrue();
}

rule: "System/ServerOverLoadMeasures/decreaseSlowLevel"
Event.OngoingGlobal
if(
    initCompleted &&    
    slowControlHandler == SlowControlHandler.ServerOverLoadMeasures &&
    !isServerOverLoading &&
    targetSlowLevel > 0
){
    // If the server is not overloaded,
    //  reset slow motion every second
    // can decrease slow level
    Wait(0.25, WaitBehavior.AbortWhenFalse);
    if(targetSlowLevel > 0){
        // decrease slow level
        targetSlowLevel --;
        // apply slow level
        ApplySlowLevel(targetSlowLevel);
    }
    LoopIfConditionIsTrue();
}

rule: "System/ServerOverLoadMeasures/reduceOverLoadOnPlayerJoin"
Event.OnPlayerJoin
Team.Team1
if(
    initCompleted &&
    slowControlHandler == SlowControlHandler.ServerOverLoadMeasures
){
    // apply slow level
    ApplySlowLevel(3);
    slowControlHandler = SlowControlHandler.PlayerJoin;
}

rule: "System/ServerOverLoadMeasures/restartOverLoadWatching"
Event.OngoingGlobal
if(
    slowControlHandler == SlowControlHandler.PlayerJoin
){
    Wait(3.0, WaitBehavior.IgnoreCondition);
    // reset slow level
    ApplySlowLevel(0);
    slowControlHandler = SlowControlHandler.ServerOverLoadMeasures;
}

void ApplySlowLevel(define setSlowLevel!)"ApplySlowLevel"{
    // if slow level changed
    if(currentSlowLevel != setSlowLevel){
        // apply slow motion
        currentSlowLevel = setSlowLevel;
        SetSlowMotion(slowLevel[setSlowLevel]);
    }
}

// TAG Game ----------
define enemyColor: Color.Purple;
globalvar define initCompleted!;
globalvar define roundNo!;

rule: "Game/initSetting"
Event.OngoingGlobal
{
    // Stop records to reduce server load
    DisableInspectorRecording();

    // If run it right after loading the server, some scripts fail, so wait 3 seconds
    Wait(3, WaitBehavior.AbortWhenFalse);

    // Set imported function property
    // Regeneration
    Regeneration_enableTeam = Team.Team1;
    Regeneration_needBalanceTeam1 = true;
    Regeneration_waitRegenTimeTeam1 = WorkshopSettingReal("Player Settings", "Wait Second Until Start Regeneration", 3, 0, 100, 1);
    Regeneration_regenerationRateTeam1 = WorkshopSettingReal("Player Settings", "Regeneration Rate In Per Seconds", 25, 0, 1000, 2);
    // Revive
    Revive_enableTeam = Team.Team1;
    Revive_timeLimit = WorkshopSettingReal("Player Settings", "Revive Accept Second", 10, 0, 100, 3);
    // DamageText
    DamageText_enableTeam = Team.Team2;
    // ElapsedTimer
    ElapsedTimer_enable = true;

    // Cancel unnecessary default settings
    PauseMatchTime();
    DisableScoring();
    DisableCompletion();

    // Set initial team lifes
    initialTeamLifes = WorkshopSettingInteger("Player Settings", "Initial Team Lifes", 6, 0, 1000, 0);

    // show version and share code
    CreateHudText(AllPlayers(Team.Team1),
        null, "PORTAL HUNT -HORDE PVE [ver 4.0] Share code [YY1N2]", null,
        Location.Left, -3,
        Color.White, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);

    // show hero change operation
    CreateHudText(AllPlayers(Team.Team1),
        null, <"Long hold reload button <0> to change hero", ButtonGuide(Button.Reload)>, null,
        Location.Left, -2,
        Color.Yellow, Color.Yellow, Color.Yellow,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);

    // show round number
    CreateHudText(AllPlayers(),
        <"<0> <1>", "Round", roundNo>, null, null,
        Location.Top, 2,
        enemyColor, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleAlways);

    // Start watch over load
    slowControlHandler = SlowControlHandler.ServerOverLoadMeasures;

    // Notify completion of init game setting and start game main logic
    initCompleted = true;

    // failsade action
    while(true){
        // repeat action for joined player
        // set objective message
        SetObjectiveDescription(AllPlayers(Team.Team1), "find portal and attack!", HudTextRev.None);
        Wait(10, WaitBehavior.AbortWhenFalse);
    } 
}

rule: "Game/initGame"
Event.OngoingGlobal
if(
    initCompleted
){
    // reset team lifes
    teamLifes = initialTeamLifes;
    // reset round no 
    roundNo = 0;
    // reset elapsed time
    elapsedTime = 0;
    // reset portal
    portalState = PortalState.Init;
}

rule: "Game/startGame"
Event.OngoingGlobal
if(
    initCompleted &&
    portalState == PortalState.Init &&
    NumberOfPlayers(Team.Team1) > 0 &&
    IsTrueForAny(
        AllPlayers(Team.Team1),
        (
            !IsInSpawnRoom(ae) &&
            IsMoving(ae)
        )
    )
){
    // reset elapsed time
    elapsedTime = 0;
    // reset prevPortalPosition
    prevPortalPosition = PositionOf(FirstOf(AllPlayers(Team.Team1)));
    // start portal creation
    portalState = PortalState.Calculating;
}

rule: "Game/stopGame"
Event.OngoingGlobal
if(
    initCompleted &&
    portalState != PortalState.Init &&
    NumberOfPlayers(Team.Team1) <= 0
){
    // reset team lifes
    teamLifes = initialTeamLifes;
    // reset round no
    roundNo = 0;
    // reset elapsed time
    elapsedTime = 0;
    // reset portal
    portalState = PortalState.Init;
}

rule: "Game/SpawnRoom/changeByTimer"
Event.OngoingGlobal
if(
    initCompleted
){
    // Change the spawn room regularly to keep the game fluid
    ForceSpawnRoom(Team.Team1, RandomValueInArray([0]));
    ForceSpawnRoom(Team.Team2, RandomValueInArray([0, 1, 2]));
    Wait(60, WaitBehavior.AbortWhenFalse); // change spawn room    
    LoopIfConditionIsTrue();
}

// TAG Player ----------
playervar define isInsidePortal!;

rule: "Player/InsidePortal/update"
Event.OngoingGlobal
if(
    portalEnable
){
    define players! = AllPlayers(Team.Team1);
    // Set flag when player entered to portal
    // This flag is used for functions related to portal
    for(gLoopIndex = 0; gLoopIndex < CountOf(players); gLoopIndex++){
        if(
            HasSpawned(players[gLoopIndex]) &&
            IsAlive(players[gLoopIndex]) &&
            !IsInSpawnRoom(players[gLoopIndex]) &&
            DistanceBetween(players[gLoopIndex], portalPosition) <= portalSize
        ){
            players[gLoopIndex].isInsidePortal = true;
        }
        else{
            players[gLoopIndex].isInsidePortal = false;
        }
    }
    WaitUntilServerFree();
    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}

rule: "Player/ReturnSpawn/returnSpawn"
Event.OngoingPlayer
Team.Team1
if(
    IsAlive() &&
    !IsInSpawnRoom() &&
    IsButtonHeld(ep, Button.Reload)
){
    // Return to spawn room with long hold on reload button
    WaitCancelPressConfirm();
    Respawn();
}

globalvar define initialTeamLifes!;
globalvar define teamLifes!;
define maxTeamLifes: 12;

rule: "Player/TeamLifes/showTeamLifesHUD"
Event.OngoingGlobal
if(
    initCompleted
){
    // show HUD of team lifes
    CreateHudText(AllPlayers(),
        teamLifes < maxTeamLifes ? 
            <"Team lifes <0>", teamLifes> :
            <"Team lifes <0> (Max Stock)", teamLifes>,
        null, null,
        Location.Top, 3,
        Color.Team1, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleAlways);
}

rule: "Player/TeamLifes/consumeTeamLifes"
Event.OngoingGlobal
if(
    0 < reviveTimeoutCount
){
    WaitConditionConfirmed();
    teamLifes -= reviveTimeoutCount;
    WaitChangeState();  // wait for show big message by newest value
    if(teamLifes > 0){
        BigMessage(AllPlayers(),
            <"<0> <1> <2>", "Our remaining team lifes is", teamLifes, "...">);

        PlayEffect(
            AllPlayers(), PlayEffect.DebuffImpactSound,
            Color.White, portalPosition, MaxLength());
    }
    reviveTimeoutCount = 0;
    LoopIfConditionIsTrue();
}

rule: "Player/TeamLifes/finishGame"
Event.OngoingGlobal
if(
    initCompleted &&
    teamLifes <= 0
){
    WaitConditionConfirmed();
    // play game end portal effect
    portalState = PortalState.End;
    // set slow handler
    slowControlHandler = SlowControlHandler.GameEnd;

    BigMessage(AllPlayers(), "Our team lifes is out...");
    SetSlowMotion(10);
    Wait(1, WaitBehavior.AbortWhenFalse);   // show slow
    SetSlowMotion(100);
    WaitNextPhase();

    BigMessage(AllPlayers(),
        <"We have reached <0> round... good game!", roundNo>);
    PlayRandomEmote(AllPlayers(Team.Team1));
    WaitNextPhase();

    DeclareTeamVictory(Team.Team1);
}

rule: "Player/TeamLifes/protectTeamLifeConsumeBySucide"
Event.OnDeath
Team.Team1
if(
    Attacker() == ep &&
    DistanceBetween(ep,
        ClosestPlayerTo(ep, Team.Team2)) > 15
){
    Respawn();
}

globalvar define closingCount!;
globalvar define closingProgress;
globalvar define closingProgressHudEntity!;
globalvar define playerNumInsidePortal!;

define enableClosingProgress:
    portalState == PortalState.UnderAttack &&
    teamLifes > 0;

rule: "Player/ClosePortal/startClosing"
Event.OngoingGlobal
if(
    enableClosingProgress
){
    // When a player enters a portal, set progress hud and show message
    WaitConditionConfirmed();
    // kick progress
    closingCount = 1;
    closingCount += portalSize * 1;
    closingCount += roundNo * 5;
    closingCount = RoundToInteger(closingCount);
    closingProgress = 0;
    ChaseVariableOverTime(closingProgress, DefaultPercentage(), closingCount, TimeChaseReevaluation.DestinationAndDuration);
    // show progress hud
    if(closingProgressHudEntity == null){
        CreateProgressBarHudText(
            AllPlayers(),
            closingProgress,
            <"<0> player has surviving in portal. Until portal closes...", playerNumInsidePortal >,
            Location.Top, 4,
            Color.White,
            Color.White,
            ProgressBarEvaluation.VisibleToValuesAndColor,
            Spectators.DefaultVisibility );
        closingProgressHudEntity = LastTextID();
    }
    define closestPlayerPortal! = ClosestPlayerToPortal();
    // show big message
    BigMessage(
        closestPlayerPortal,
        <"You are closing the portal... Stay inside and Survive!">);
    BigMessage(
        FilteredArray(AllPlayers(Team.Team1), (closestPlayerPortal != ae)),
        <"<0> <1> <2>",
            closestPlayerPortal,
            HeroIconString(HeroOf(closestPlayerPortal)),
            "closing portal... Cover one!">);
    // Wait closingCount
    Wait(closingCount, WaitBehavior.AbortWhenFalse);
    portalState = PortalState.Closing;
}

rule: "Player/ClosePortal/updatePlayerNumInsidePortal"
Event.OngoingGlobal
if(
    enableClosingProgress
){
    playerNumInsidePortal = CountOf(
        FilteredArray(
            AllPlayers(Team.Team1),
            ae.isInsidePortal
        )
    );
    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}

rule: "Player/ClosePortal/cancelClosing //on exit every player"
Event.OngoingGlobal
if(
    !enableClosingProgress
){
    StopChasingVariable(closingProgress);
    // wait hide hud when progress completed
    if(closingProgress == 100){
        Wait(1.5, WaitBehavior.AbortWhenFalse);
    }
    DestroyProgressBarHudText(closingProgressHudEntity);
    closingProgressHudEntity = null;
}

rule: "Player/ClosePortal/finishClose //on count down finished"
Event.OngoingGlobal
if(
    (
        portalState == PortalState.Closing ||
        portalState == PortalState.Closed
    ) &&
    teamLifes > 0
){
    WaitConditionConfirmed();
    // When the countdown is complete, clear the portal and give team lifes.
    // Later, we will generate a new portal and start the next round.
    WaitPlayEffect();   //wait portal closing effect
    portalState = PortalState.Closed;
    WaitNextPhase();

    // if lower than max
    if(teamLifes < maxTeamLifes){
        // play got life sound
        PlayEffect(
            AllPlayers(), PlayEffect.BuffImpactSound,
            Color.White, portalPosition, MaxLength()
        );
        // show got life sound message
        BigMessage(AllPlayers(), "We earned new team lifes!");
        // add life
        teamLifes += 1;
    }
    WaitNextPhase();

    PlayRandomVoiceLine(AllPlayers(Team.Team1));
    roundNo += 1;
    portalState = PortalState.Calculating;  // start next portal create
}

playervar define inPortalEffectEntitys!;

rule: "Player/FairPlay/disableStealthWhenInside //sombra's stealth for fair play"
Event.OngoingPlayer
Team.Team1
if(
    isInsidePortal &&
    HeroOf() == Hero.Sombra &&
    IsUsingAbility1()
){
    // Some abilities are disabled inside the portal to make the game fair
    // Sombra stealth is exactly that
    Wait(5.0, WaitBehavior.AbortWhenFalse); // disable ability check cycle
    SetStatus(ep, null, Status.Stunned, 0.1);
    SmallMessage(ep, "Stealth has been interrupted by the portal's magnetic field!");
    LoopIfConditionIsTrue();
}

rule: "Player/FairPlay/disableGrappleClawWhenInside // wreckingBball's grapple claw for fair play"
Event.OngoingPlayer
Team.Team1
if(
    isInsidePortal &&
    HeroOf() == Hero.WreckingBall &&
    IsFiringSecondary()
){
    // Some abilities are disabled inside the portal to make the game fair
    // WreckingBall Grapple is exactly that
    Wait(5.0, WaitBehavior.AbortWhenFalse); // disable ability check cycle
    SetStatus(ep, null, Status.Stunned, 0.1);
    SmallMessage(ep, "Grappling hook has been interrupted by the portal's magnetic field!");
    LoopIfConditionIsTrue();
}

// TAG Portal Function ----------
globalvar define portalState!;
enum PortalState{
    Init,
    Calculating,
    Checking,
    Set,
    Growing,
    UnderAttack,
    Closing,
    Closed,
    End
}

globalvar define portalPosition!;
globalvar define portalSize;
globalvar define portalEntitys!;
globalvar define isFirstGrowing!;

define portalEnable:
    portalState == PortalState.Checking ||
    portalState == PortalState.Set ||
    portalState == PortalState.Growing ||
    portalState == PortalState.UnderAttack;

rule: "Portal/State/Calculating"
Event.OngoingGlobal
if(
    portalState == PortalState.Calculating
){
    // Hide Portal Entity until portal state changed to Show
    // Init param
    StopChasingVariable(portalSize);
    portalPosition = 0;
    portalSize = 0;
    isFirstGrowing = true;
    // Hide portal icon and effect
    DestroyIcon(portalEntitys[0]);
    DestroyEffect(portalEntitys[1]);
    DestroyEffect(portalEntitys[2]);
    DestroyEffect(portalEntitys[3]);
    DestroyEffect(portalEntitys[4]);
}

define showPortalIconOutRange: 50;

rule: "Portal/State/Set  // waiting for found by players"
Event.OngoingGlobal
if(
    portalState == PortalState.Set
){
    DestroyIcon(portalEntitys[0]);
    // show Portal Entity by portal state changed to Show
    // Init param
    closingCount = 0;
    // show icon
    portalEntitys = [];
    portalEntitys[0] = CreateIcon(
        FilteredArray(
            AllPlayers(Team.Team1),
            (
                !ae.isInsidePortal &&
                DistanceBetween(ae, portalPosition) > showPortalIconOutRange
            )
        ),
        portalPosition, Icon.Spiral,
        IconRev.VisibleToAndPosition, enemyColor, true);
    // set effect
    // sphere
    portalEntitys[1] = CreateEffect(AllPlayers(), Effect.Sphere, enemyColor,
        portalPosition, portalSize, EffectRev.VisibleToPositionAndRadius);
    // cloud
    portalEntitys[2] = CreateEffect(AllPlayers(), Effect.Cloud, enemyColor,
        portalPosition, portalSize * 1.5, EffectRev.VisibleToPositionAndRadius);
    // aura
    // Since visibility will be poor, display only in the center of the field of view
    portalEntitys[3] = CreateEffect(
        FilteredArray(
            AllPlayers(),
            DistanceBetween(ae, portalPosition) > portalSize / 2), Effect.BadAura, enemyColor,
        portalPosition, portalSize * 1.25, EffectRev.VisibleToPositionAndRadius);
    // sound
    portalEntitys[4] = CreateEffect(AllPlayers(), Effect.EnergySound, enemyColor,
        portalPosition, portalSize / 2, EffectRev.VisibleToPositionAndRadius);
    // show message
    BigMessage(AllPlayers(), "Detected more portal... find and attack!");
}

rule: "Portal/State/Growing"
Event.OngoingGlobal
if(
    portalState == PortalState.Growing
){
    // Start growing portal with warning message
    ChaseVariableAtRate(
        portalSize, maxPortalSize, 1 + (roundNo / 8),
        RateChaseReevaluation.DestinationAndRate);  // startGrowing
    // If first growing, show message
    if(isFirstGrowing == true){
        isFirstGrowing = false;
        BigMessage(AllPlayers(), "Portal is growing... hurry up!");
        WaitBigMessageHide();
        BigMessage(AllPlayers(), "Growed portals spawn more enemys and get tough...");
    }
}

rule: "Portal/State/Suspended"
Event.OngoingGlobal
if(
    portalState == PortalState.UnderAttack
){
    // Stop growing portal
    Wait(1, WaitBehavior.AbortWhenFalse);
    StopChasingVariable(portalSize);
}

rule: "Portal/State/Closing"
Event.OngoingGlobal
if(
    portalState == PortalState.Closing
){
    // Hide icon
    DestroyIcon(portalEntitys[0]);
    // apply blast impulse
    ApplyBlastImpulse(AllPlayers(Team.Team2), portalPosition, portalSize);
    // play portal closing effect and kill enemrys
    Kill(AllPlayers(Team.Team2), null);
    // play blast sound
    PlayEffect(
        AllPlayers(), PlayEffect.RingExplosionSound,
        Color.White, portalPosition, MaxLength());
    // play blast effect
    PlayContinuousBlast(
        Color.Yellow,
        portalPosition,
        portalSize * 1.5,
        10);
}

rule: "Portal/State/Closed"
Event.OngoingGlobal
if(
    portalState == PortalState.Closed
){
    // show message
    BigMessage(AllPlayers(), "Portal closed... good job!");
    // init param
    portalPosition = 0;
    portalSize = 0;
    StopChasingVariable(portalSize);
    // Hide portal icon and effect
    DestroyIcon(portalEntitys[0]);
    DestroyEffect(portalEntitys[1]);
    DestroyEffect(portalEntitys[2]);
    DestroyEffect(portalEntitys[3]);
    DestroyEffect(portalEntitys[4]);
}

rule: "Portal/State/End"
Event.OngoingGlobal
if(
    portalState == PortalState.End
){
    // apply blast impulse
    ApplyBlastImpulse(AllPlayers(Team.Team2), portalPosition, portalSize);
    // play portal closing effect and kill enemrys
    Kill(AllPlayers(Team.Team2), null);
    // play blast sound
    PlayEffect(
        AllPlayers(), PlayEffect.RingExplosionSound,
        Color.White, portalPosition, MaxLength());
    // play blast effect
    PlayContinuousBlast(
        Color.Yellow,
        portalPosition,
        portalSize * 1.5,
        10);

    // init param
    portalPosition = 0;
    portalSize = 0;
    StopChasingVariable(portalSize);
    // Hide portal icon and effect
    DestroyIcon(portalEntitys[0]);
    DestroyEffect(portalEntitys[1]);
    DestroyEffect(portalEntitys[2]);
    DestroyEffect(portalEntitys[3]);
    DestroyEffect(portalEntitys[4]);
}

rule: "Portal/Positioner/createPortal"
Event.OngoingGlobal
if(
    teamLifes > 0 &&
    portalState == PortalState.Calculating
){
    WaitConditionConfirmed();
    define candidatePosition;
    for(define retryCount = 0; retryCount < 30; retryCount++){
        // select random player as base positoon
        define basePlayer =
            RandomValueInArray(
                FilteredArray(
                    AllLivingPlayers(Team.Team1),
                    HasSpawned(ae)
                )
            );
        // select random positon from player around
        define randomPositon = 
            basePlayer +
            // half y derection
            VectorScaledY(
                // add random direction
                DirectionFromAngles(
                    RandomReal(0, 360), RandomReal(30, -30),
                ) * 
                // add random distance
                RandomReal(25, 150), 
                0.33
            );

        // convert to walkble position
        candidatePosition = NearestWalkablePosition(randomPositon);
        // move candidate postion in the direction of player for avoiding map edge
        candidatePosition += DirectionTowards(candidatePosition, basePlayer) * RandomReal(1, 10);
        // convert to walkble position
        candidatePosition = NearestWalkablePosition(candidatePosition);

        if(
            // close candidate postion than random positon
            (
                DistanceBetween(basePlayer, randomPositon) >= 
                DistanceBetween(basePlayer, candidatePosition) + 10
            )
                &&
            // far postion from previous position
            (
                DistanceBetween(prevPortalPosition, candidatePosition) >= 50
            )
                &&
            // far postion from player
            (
                DistanceBetween(
                    ClosestPlayerTo(candidatePosition, Team.Team1),
                    candidatePosition
                ) >= 50
            )
        ){
            break;
        }
        Wait(0.1, WaitBehavior.AbortWhenFalse);
        WaitUntilServerFree();
    }
    // confirm as portal position
    portalPosition = candidatePosition;
    // create portal, next check position
    portalState = PortalState.Checking;
    // fail safe
    Wait(6, WaitBehavior.AbortWhenFalse);
	dbgMsg("failsafe triggered of createPortal");
    LoopIfConditionIsTrue();
}
globalvar define prevPortalPosition!;

rule: "Portal/Positioner/positionChecking"
Event.OngoingGlobal
if(
    teamLifes > 0 &&
    portalState == PortalState.Checking
){
    // wait
    Wait(1, WaitBehavior.AbortWhenFalse);
    // confirm portal position
    prevPortalPosition = portalPosition;
    portalState = PortalState.Set;
    // fail safe
    Wait(5, WaitBehavior.AbortWhenFalse);
    dbgMsg("failsafe triggered of positionChecking");
    LoopIfConditionIsTrue();
}

// TAG Portal/InvalidDetect/InsideRespawnRoom ----------
rule: "Portal/InvalidDetect/InsideRespawnRoom/resetPortal"
Event.OngoingGlobal
if(
    portalEnable &&
    IsTrueForAny(
        SpawnPoints(Team.Team1),
        (
            IsInLineOfSight(ae + Up(), portalPosition)
        )
    )
){
    WaitConditionConfirmed();
    dbgMsg("reset Portal By Inside Respawn Room");
    portalState = PortalState.Calculating;
}

// TAG Portal/InvalidDetect/EnvironmentDeathCount ----------
define environmentDeathLimit: NumberOfPlayers(Team.Team2) + 1;
globalvar define environmentDeathCount!;

rule: "Portal/InvalidDetect/EnvironmentDeathCount/resetCount"
Event.OngoingGlobal
if(
    !portalEnable &&
    environmentDeathCount > 0
){
    environmentDeathCount = 0;
}

rule: "Portal/InvalidDetect/EnvironmentDeathCount/countup"
Event.OnDeath
Team.Team2
if(
    portalEnable &&
    (
        ep == Attacker() ||         // sucide
        IsInSpawnRoom(Attacker())   // killer in res room
    )
){
    // change room for avoid kill in res room
    ForceSpawnRoom(Team.Team1, RandomValueInArray([0, 1, 2]));
    // sucide
    if(ep == Attacker())
        environmentDeathCount += 1;
    // killer in res room
    else if(IsInSpawnRoom(Attacker()))
        environmentDeathCount += 3;
}

rule: "Portal/InvalidDetect/EnvironmentDeathCount/reduceCount"
Event.OngoingGlobal
if(
    portalEnable &&
    0 < environmentDeathCount
){
    Wait(3, WaitBehavior.AbortWhenFalse);
    environmentDeathCount --;
    LoopIfConditionIsTrue();
}

rule: "Portal/InvalidDetect/EnvironmentDeathCount/resetPortal"
Event.OngoingGlobal
if(
    portalEnable &&
    environmentDeathLimit <= environmentDeathCount
){
    WaitConditionConfirmed();
    dbgMsg("reset Portal By Environment Death Count");
    portalState = PortalState.Calculating;
}

// TAG Portal/InvalidDetect/NoContact ----------
define limitTime: 100;
globalvar define noContactTime!;

rule: "Portal/InvalidDetect/NoContactTime/resetTime"
Event.OngoingGlobal
if(
    !portalEnable
){
    WaitConditionConfirmed();
    noContactTime = 0;
}

rule: "Portal/InvalidDetect/NoContactTime/countup"
Event.OngoingGlobal
if(
    portalEnable &&
    noContactTime != -1  &&
    limitTime > noContactTime
){
    WaitUpdateMediumCycle();
    noContactTime ++;
    LoopIfConditionIsTrue();
}

rule: "Portal/InvalidDetect/NoContactTime/detectContact"
Event.OngoingGlobal
if(
    portalState == PortalState.UnderAttack
){
    Wait(1, WaitBehavior.AbortWhenFalse);
    noContactTime = -1;
}

rule: "Portal/InvalidDetect/NoContactTime/resetPortal"
Event.OngoingGlobal
if(
    portalEnable &&
    limitTime <= noContactTime
){
    WaitConditionConfirmed();
    dbgMsg("reset Portal By No Contact");
    portalState = PortalState.Calculating;
}

// TAG Portal/Growing ----------
define maxPortalSize: 70;
define portalStableTime: 40;

rule: "Portal/Growing/startGrowingByPlayerFound"
Event.OngoingGlobal
if(
    portalState == PortalState.Set
){
    if(
        IsInLineOfSight(portalPosition,
            ClosestPlayerToPortal(),
            BarrierLOS.NoBarriersBlock)
    ){
        WaitConditionConfirmed();
        // start portal growing by player found
        portalState = PortalState.Growing;
    }
    else{
        WaitUpdateMediumCycle();
        WaitUntilServerFree();
        LoopIfConditionIsTrue();
    }
}

rule: "Portal/Growing/startGrowingByTimeout"
Event.OngoingGlobal
if(portalState == PortalState.Set){
    // Start portal growing by search time limit out
    Wait(portalStableTime, WaitBehavior.AbortWhenFalse);  //wait time to start growing
    portalState = PortalState.Growing;
}

rule: "Portal/Growing/suspendGrowingByPlayerEntered"
Event.OngoingGlobal
if(
    portalState == PortalState.Growing &&
    IsTrueForAny(
        AllPlayers(Team.Team1), ae.isInsidePortal
    )
){
    // Suspend portal growing by player enter to portal
    WaitConditionConfirmed();
    portalState = PortalState.UnderAttack;
}

rule: "Portal/Growing/resumeGrowingByPlayerExited"
Event.OngoingGlobal
if(
    portalState == PortalState.UnderAttack &&
    !IsTrueForAny(
        AllPlayers(Team.Team1), ae.isInsidePortal
    )
){
    // Resume portal growing by player exit from portal
    WaitConditionConfirmed();
    portalState = PortalState.Growing;
}

// TAG EnemBot/CreateBot ----------
define assetList:
    [
        // balanced
        [
            [EnemyType.Boss,        RandomTankHero,     1],
            [EnemyType.Elite,       RandomDamageHero,   1],
            [EnemyType.Elite,       RandomDamageHero,   1],
            [EnemyType.Minion,      RandomSupportHero,  3]
        ],
        [
            [EnemyType.Boss,        RandomSupportHero,  1],
            [EnemyType.Elite,       RandomTankHero,     1],
            [EnemyType.Elite,       RandomTankHero,     1],
            [EnemyType.Minion,      RandomDamageHero,   3]
        ],
        [
            [EnemyType.Boss,        RandomDamageHero,   1],
            [EnemyType.Elite,       RandomSupportHero,  1],
            [EnemyType.Elite,       RandomSupportHero,  1],
            [EnemyType.Minion,      RandomTankHero,     3]
        ],
        [
            [EnemyType.Boss,        RandomDamageHero,   1],
            [EnemyType.Elite,       RandomTankHero,     1],
            [EnemyType.Elite,       RandomTankHero,     1],
            [EnemyType.Minion,      RandomSupportHero,  3]
        ],
        // five minion
        [
            [EnemyType.Boss,        RandomTankHero,     1],
            [EnemyType.Minion,      RandomSupportHero,  5]
        ],
        [
            [EnemyType.Boss,        RandomDamageHero,   1],
            [EnemyType.Minion,      RandomSupportHero,  5]
        ],
        // four elite
        [
            [EnemyType.Elite,       RandomTankHero,     1],
            [EnemyType.Elite,       RandomTankHero,     1],
            [EnemyType.Elite,       RandomDamageHero,   1],
            [EnemyType.Elite,       RandomDamageHero,   1],
            [EnemyType.Minion,      RandomSupportHero,  1],
            [EnemyType.Minion,      RandomSupportHero,  1]
        ],
        [
            [EnemyType.Elite,       RandomSupportHero,  1],
            [EnemyType.Elite,       RandomSupportHero,  1],
            [EnemyType.Elite,       RandomTankHero,     1],
            [EnemyType.Elite,       RandomTankHero,     1],
            [EnemyType.Minion,      RandomDamageHero,   1],
            [EnemyType.Minion,      RandomDamageHero,   1]
        ],
        [
            [EnemyType.Elite,       RandomDamageHero,   1],
            [EnemyType.Elite,       RandomDamageHero,   1],
            [EnemyType.Elite,       RandomSupportHero,  1],
            [EnemyType.Elite,       RandomSupportHero,  1],
            [EnemyType.Minion,      RandomTankHero,     1],
            [EnemyType.Minion,      RandomTankHero,     1]
        ],        
        // double boss
        [
            [EnemyType.Boss,        RandomTankHero,     1],
            [EnemyType.Boss,        RandomDamageHero,   1],
            [EnemyType.Minion,      RandomSupportHero,  2]
        ],
        [
            [EnemyType.Boss,        RandomSupportHero,  1],
            [EnemyType.Boss,        RandomTankHero,     1],
            [EnemyType.Minion,      RandomDamageHero,   2]
        ],
        [
            [EnemyType.Boss,        RandomDamageHero,   1],
            [EnemyType.Boss,        RandomSupportHero,  1],
            [EnemyType.Minion,      RandomTankHero,     2]
        ],
        // giant boss
        [
            [EnemyType.GiantBoss,   RandomTankHero,     1]
        ],
        [
            [EnemyType.GiantBoss,   RandomDamageHero,   1]
        ],		
        [
            [EnemyType.GiantBoss,   RandomSupportHero,  1]
        ],
        // close range
        [
            [EnemyType.Boss,        Hero.Reaper,        1],
            [EnemyType.Elite,       Hero.Roadhog,       2],
            [EnemyType.Elite,       Hero.Doomfist,      1],
            [EnemyType.Minion,      Hero.Mei,           2]
        ],
        [
            [EnemyType.Boss,        Hero.Mei,           1],
            [EnemyType.Elite,       Hero.Doomfist,      2],
            [EnemyType.Elite,       Hero.Roadhog,       1],
            [EnemyType.Minion,      Hero.Reaper,        2]
        ],
        [
            [EnemyType.Boss,        Hero.Reaper,        1],
            [EnemyType.Elite,       Hero.Mei,           2],
            [EnemyType.Elite,       Hero.Roadhog,       1],
            [EnemyType.Minion,      Hero.Doomfist,      2]
        ],
        // melees
        [
            [EnemyType.Boss,        Hero.Reinhardt,     1],
            [EnemyType.Elite,       Hero.Doomfist,      2],
            [EnemyType.Elite,       Hero.Mercy,         1],
            [EnemyType.Minion,      Hero.Brigitte,      2]
        ],
        [
            [EnemyType.Boss,        Hero.Doomfist,      1],
            [EnemyType.Elite,       Hero.Reinhardt,     1],
            [EnemyType.Elite,       Hero.Brigitte,      2],
            [EnemyType.Minion,      Hero.Mercy,         2]
        ],
        // flankers
        [
            [EnemyType.Boss,        Hero.Soldier76,     1],
            [EnemyType.Elite,       Hero.Doomfist,      1],
            [EnemyType.Elite,       Hero.Genji,         1],
            [EnemyType.Minion,      Hero.Tracer,        3]
        ],
        [
            [EnemyType.Boss,        Hero.Genji,         1],
            [EnemyType.Elite,       Hero.Doomfist,      1],
            [EnemyType.Elite,       Hero.Tracer,        1],
            [EnemyType.Minion,      Hero.Soldier76,     3]
        ],
        // long range
        [
            [EnemyType.Boss,        Hero.Orisa, 		1],
            [EnemyType.Elite,       Hero.Bastion, 		1],
            [EnemyType.Elite,       Hero.Ana, 	        2],
            [EnemyType.Minion,      Hero.Soldier76, 	2]
        ],
        [
            [EnemyType.Boss,        Hero.Bastion, 		1],
            [EnemyType.Elite,       Hero.Orisa, 		1],
            [EnemyType.Elite,       Hero.Soldier76, 	2],
            [EnemyType.Minion,      Hero.Ana, 	        2]
        ],
        // airforce
        [
            [EnemyType.Elite,       Hero.Echo, 			2],
            [EnemyType.Elite,       Hero.Pharah, 		2],
            [EnemyType.Minion,      Hero.Mercy, 		2]
        ],
        // air boss
        [
            [EnemyType.Boss,        Hero.Pharah, 		1],
            [EnemyType.Elite,       Hero.Mercy, 		5]
        ],
        [
            [EnemyType.Boss,        Hero.Echo, 		    1],
            [EnemyType.Elite,       Hero.Mercy, 		5]
        ],
        // snipers
        [
            [EnemyType.Boss,        Hero.Hanzo,			1],
            [EnemyType.Boss,        Hero.Widowmaker,	1],
            [EnemyType.Elite,       Hero.Ashe, 			2],
            [EnemyType.Minion,      Hero.Ana, 			2]
        ],
        [
            [EnemyType.Boss,        Hero.Widowmaker,	1],
            [EnemyType.Boss,        Hero.Ana,	        1],
            [EnemyType.Elite,       Hero.Hanzo, 		2],
            [EnemyType.Minion,      Hero.Widowmaker, 	2]
        ],
        [
            [EnemyType.Boss,        Hero.Ashe,			1],
            [EnemyType.Boss,        Hero.Hanzo,	        1],
            [EnemyType.Elite,       Hero.Ana, 		    2],
            [EnemyType.Minion,      Hero.Widowmaker, 	2]
        ],
        // machines
        [
            [EnemyType.Boss,        Hero.Orisa, 		1],
            [EnemyType.Elite,       Hero.Bastion, 		2],
            [EnemyType.Minion,      Hero.Zenyatta,      3]
        ],
        [
            [EnemyType.Boss,        Hero.Bastion, 		1],
            [EnemyType.Elite,       Hero.Orisa, 		2],
            [EnemyType.Minion,      Hero.Zenyatta,      3]
        ],
        // mini melees
        [
            [EnemyType.Boss,        Hero.Reinhardt, 	1],
            [EnemyType.Minion,      Hero.Reinhardt, 	5]
        ],
        [
            [EnemyType.Boss,        Hero.Reinhardt, 	1],
            [EnemyType.Minion,      Hero.Brigitte,   	5]
        ],
        // turrets
        [
            [EnemyType.Boss,        Hero.Torbjorn, 		1],
            [EnemyType.Elite,       Hero.Symmetra, 		2],
            [EnemyType.Minion,      Hero.Symmetra, 		3]
        ],
        [
            [EnemyType.Boss,        Hero.Symmetra, 		1],
            [EnemyType.Elite,       Hero.Torbjorn, 		2],
            [EnemyType.Minion,      Hero.Torbjorn, 		3]
        ],
        // some hero
        [
            [EnemyType.Boss,        someHero, 		    1],
            [EnemyType.Elite,       someHero, 		    2],
            [EnemyType.Minion,      someHero, 		    3]
        ],
        [
            [EnemyType.Boss,        someHero, 		    1],
            [EnemyType.Boss,        someHero, 		    1],
            [EnemyType.Elite,       someHero, 		    1]
        ],
        [
            [EnemyType.Elite,       someHero, 		    4],
            [EnemyType.Minion,       someHero, 		    2]
        ]
    ];

globalvar define someHero!;

rule: "Portal/CreateEnemBot/reloadBotAsset"
Event.OngoingGlobal
if(
    portalEnable
){
    // change bot asset by random
    if(
        0 >= NumberOfPlayers(Team.Team2) ||
        ProbabilityTrue(70)
    ){
        someHero = RandomHero;
        // create all bot
        CreateEnemyBotsByAssetList(assetList);   
    }
}

// TAG EnemBot/EnemyType ----------
playervar define eachDealtDamageScale!;
playervar define eachMaxSpawnInterval!;
playervar define eachChargeUltInterval!;
playervar define eachEffectTextSize!;
playervar define eachNameText!;
playervar define eachNameColor!;
playervar define eachPerkDropProbability!;

rule: "EnemBot/EnemyType/setEnemyType"
Event.OngoingPlayer
Team.Team2
if(
    enemyType != EnemyType.None
){
    if(enemyType == EnemyType.Minion){
        StartScalingPlayer(ep, 0.75, false);
        StartModifyingHeroVoiceLines(ep, 1.5, false);

        SetMaxHealth(ep, 50);
        SetHealingDealt(ep, 50);
        //SetHealingReceived(ep, 100);
        
        eachDealtDamageScale = 0.5;
        eachChargeUltInterval = 80;
        eachMaxSpawnInterval = 3;

        eachNameText = "Minion";
        eachNameColor = Color.White;
        eachEffectTextSize = 1;

        eachPerkDropProbability = 2;
    }
    else if(enemyType == EnemyType.Elite){
        StartScalingPlayer(ep, 1.0, false);
        StartModifyingHeroVoiceLines(ep, 1.0, false);

        SetMaxHealth(ep, 250);
        SetHealingDealt(ep, 250);
        //SetHealingReceived(ep, 100);

        eachDealtDamageScale = 1.0;
        eachChargeUltInterval = 20;
        eachMaxSpawnInterval = 10;

        eachNameText = "Elite";
        eachNameColor = Color.Yellow;
        eachEffectTextSize = 2;

        eachPerkDropProbability = 10;
    }
    else if(enemyType == EnemyType.Boss){
        StartScalingPlayer(ep, 1.5, false);
        StartModifyingHeroVoiceLines(ep, 0.5, false);

        SetMaxHealth(ep, 1000);
        SetHealingDealt(ep, 1000);
        //SetHealingReceived(ep, 100);

        eachDealtDamageScale = 2.0;
        eachChargeUltInterval = 10;
        eachMaxSpawnInterval = 30;

        eachNameText = "Boss";
        eachNameColor = Color.Red;
        eachEffectTextSize = 3;

        eachPerkDropProbability = 40;
    }
    else if(enemyType == EnemyType.GiantBoss){
        StartScalingPlayer(ep, 2.5, false);
        StartModifyingHeroVoiceLines(ep, 0.1, false);

        SetMaxHealth(ep, 1000);
        SetHealingDealt(ep, 1000);
        //SetHealingReceived(ep, 100);

        eachDealtDamageScale = 4.0;
        eachChargeUltInterval = 10;
        eachMaxSpawnInterval = 15;

        eachNameText = "Giant Boss";
        eachNameColor = Color.Purple;
        eachEffectTextSize = 4;

        eachPerkDropProbability = 100;

        // set addtinal health
        AddHealthPoolToPlayer(ep, HealthType.Armor, 2500, true, false);
        AddHealthPoolToPlayer(ep, HealthType.Shields, 2500, true, false);
    }

    UpdateEachDealtDamage();
    UpdateEachSpawnInterval();

    // heal to max health
    while(Health() < MaxHealth()){
        Heal(ep, null, MaxValue());
        Wait(0.1, WaitBehavior.AbortWhenFalse);
    }
}

// TAG EnemBot/Effect ----------
playervar define botAppearanceEntitys!;

rule: "EnemBot/Effect/showBotAppearance"
Event.OngoingPlayer
Team.Team2
if(
    enemyType != EnemyType.None &&
    IsAlive()
){
    botAppearanceEntitys = [];
    // show evil aura
    botAppearanceEntitys[0] = 
        CreateEffect(AllPlayers(), Effect.Cloud, enemyColor,
            ep, eachEffectTextSize * 1.5, EffectRev.VisibleToPositionAndRadius);
    // show name text
    botAppearanceEntitys[1] = 
        CreateInWorldText(
            AllPlayers(), eachNameText, 
            ep, eachEffectTextSize, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            eachNameColor, Spectators.DefaultVisibility);
}

rule: "EnemBot/Effect/hideBotAppearance"
Event.OngoingPlayer
Team.Team2
if(
    enemyType != EnemyType.None &&
    !IsAlive()
){
    // hide evil aura
    DestroyEffect(botAppearanceEntitys[0]);
    // hide name text
    DestroyInWorldText(botAppearanceEntitys[1]);
    // play dead effect
    PlayContinuousBlast(Color.Red, PositionOf(),
        eachEffectTextSize * 1.5, eachEffectTextSize);
}

// TAG EnemBot/Teleport ----------
define teleportAreaSize: 6;
define minDistanceToPlayerWhenTeleport: 10;
define ClosestPlayerToTelPos: ClosestPlayerTo(teleportPosition, Team.Team1);
define ClosestPlayerToComTelPos: ClosestPlayerTo(commonTeleportPosition, Team.Team1);
define ClosestPlayerToMe: ClosestPlayerTo(ep, Team.Team1);

Player ClosestPlayerToPortal()"ClosestPlayerToPortal"{
    return FirstOf(
        SortedArray(
            FilteredArray(
                AllPlayers(Team.Team1),
                (
                    HasSpawned(ae) &&
                    IsAlive(ae) &&
                    !IsInSpawnRoom(ae)
                )
            ),
            DistanceBetween(ae, portalPosition)
        )
    );
}

playervar define teleportPosition!;
globalvar define commonTeleportPosition!;

Boolean SetTeleportPositionToPlayerFront()"SetTeleportPositionToPlayerFront"{
    // set teleport position by blind spot from player
    // find place that will be a blind spot up to 10 times
    define teleportToTarget! = ClosestPlayerToPortal();
    if(teleportToTarget == null){
        teleportPosition = portalPosition;
        return true;
    }
    for(pLoopIndex = 0; pLoopIndex < 30; pLoopIndex++){
        teleportPosition =
            NearestWalkablePosition(
                PositionOf(teleportToTarget)
                    + 
                (
                    DirectionTowards(teleportToTarget, portalPosition)
                        *
                    DistanceBetween(teleportToTarget, portalPosition) * 0.5
                )
                    +
                RandomPosition(teleportAreaSize, teleportAreaSize, teleportAreaSize)
            );

        define telPosNearTarget! = ClosestPlayerToTelPos;
        if(
            DistanceBetween(    // Not too close to player
                telPosNearTarget, teleportPosition)
            >= minDistanceToPlayerWhenTeleport
                &&
            IsInLineOfSight(    // Has line
                telPosNearTarget, teleportPosition, BarrierLOS.NoBarriersBlock)
        ){
            break;
        }
        Wait(0.1, WaitBehavior.AbortWhenFalse);
        WaitUntilServerFree();
    }
    return true;
}

Boolean SetTeleportPositionToPlayerAround()"SetTeleportPositionToPlayerAround"{
    // set teleportPosition to player around
    define teleportToTarget! = ClosestPlayerToPortal();
    if(teleportToTarget == null){
        teleportPosition = portalPosition;
        return true;
    }
    for(pLoopIndex = 0; pLoopIndex < 30; pLoopIndex++){
        teleportPosition =
            // BelowPosition(
                BlockedPositon(
                    teleportToTarget,
                    DirectionFromAngles(
                        RandomReal(0, 360), RandomReal(30, -30),
                    ), RandomReal(5, 50)
                );
            // );
        // move teleportPosition for avoid map surface edge
        teleportPosition += (DirectionTowards(teleportPosition, teleportToTarget) * 1);
        
        define telPosNearTarget! = ClosestPlayerToTelPos;
        if(
            DistanceBetween(    // Not too close to player
                telPosNearTarget, teleportPosition)
            >= minDistanceToPlayerWhenTeleport
                &&
            IsInLineOfSight(    // Has line
                telPosNearTarget, teleportPosition, BarrierLOS.NoBarriersBlock)
                &&
            IsBlockedBetween(   // Has ground
                teleportPosition, ShiftedPosition(teleportPosition, Down(), 6))

        ){
            break;
        }
        Wait(0.1, WaitBehavior.AbortWhenFalse);
        WaitUntilServerFree();
    }
    teleportPosition -= PositionOffset();
    return true;
}

Boolean SetTeleportPositionToCommonPosition()"SetTeleportPositionToCommonPosition"{
    define telPosNearTarget! = ClosestPlayerToComTelPos;
    if(telPosNearTarget == null){
        teleportPosition = portalPosition;
        return true;
    }
    if(
        commonTeleportPosition ==  0 ||
        ProbabilityTrue(20) ||
        !IsInLineOfSight(commonTeleportPosition, ClosestPlayerToPortal()) ||                        // has not line closest player to portal
        DistanceBetween(commonTeleportPosition, telPosNearTarget) < minDistanceToPlayerWhenTeleport // too close to player
    ){
        // new select common position
        // set teleport position to player around
        if(SetTeleportPositionToPlayerAround()){
            // save teleport position as common position
            commonTeleportPosition = teleportPosition;
            // dbgEft(commonTeleportPosition);
            // dbgIcn(commonTeleportPosition);
            // dbgPlySud(commonTeleportPosition);
        }
        else{
            // set teleport position from common position
            teleportPosition = commonTeleportPosition;
        }
    }
    else{
        // set teleport position from common position
        teleportPosition = commonTeleportPosition;
    }
    return true;
}

void PlayTeleportEffect(define isBefore)"PlayTeleportEffect"{
    // if before teleport
    if(isBefore){
        // play teleport shadow
        PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, enemyColor, ep, 1);
        // play teleport shadow
        PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, enemyColor, teleportPosition, 1);
        // wait for show teleport shadow of before
        Wait(0.4, WaitBehavior.IgnoreCondition);
    }
    else{
        // play teleport blast
        PlayEffect(AllPlayers(), PlayEffect.BadExplosion, enemyColor, ep, eachEffectTextSize);
    }
}

void TeleportWithEffect()"TeleportWithEffect"{
    Wait(SlotOf(ep) * 0.1, WaitBehavior.AbortWhenFalse);
    // show pre teleport effect
    PlayTeleportEffect(true);
    // Teleport
    Teleport(ep, teleportPosition);
    // show teleport effect
    PlayTeleportEffect(false);
}

rule: "EnemBot/Teleport/teleportByPortalDisabled"
Event.OngoingPlayer
Team.Team2
if(
    HasSpawned() &&
    !portalEnable
){
    // Teleport Bot to spawn room when portal disable
    // wait show dead effect when portal closing
    Wait(deadEffectTime, WaitBehavior.AbortWhenFalse);

    // reset teleport position
    teleportPosition = InvalidPosition();
    // set root
    SetStatus(ep, null, Status.Rooted, MaxValue());
    // show pre teleport effect
    PlayTeleportEffect(true);
    // Teleport to spawn room
    Respawn(AllPlayers(Team.Team2));
    // show teleport effect
    PlayTeleportEffect(false);
}

rule: "EnemBot/Teleport/teleportByPortalEnabled"
Event.OngoingPlayer
Team.Team2
if(
    HasSpawned() &&
    portalEnable
){
    AbortIf(IsDead());

    // clear root
    ClearStatus(ep, Status.Rooted);
    // set teleport position
    if(SetTeleportPositionToPlayerFront()){
        // teleport
        TeleportWithEffect();
    }
}

rule: "EnemBot/Teleport/teleportByRespawn"
Event.OngoingPlayer
Team.Team2
if(
    portalEnable &&
    IsInSpawnRoom()
){
    AbortIf(IsDead());
    
    if(
        // during portal attacks
        portalState == PortalState.UnderAttack ||
        // probability
        ProbabilityTrue(10)
    ){
        if(
            // probability
            ProbabilityTrue(70)
        ){
            // set teleport position to common position
            if(SetTeleportPositionToCommonPosition()){
                // teleport
                TeleportWithEffect();
            }
        }
        else{
            // set teleport position to player around
            if(SetTeleportPositionToPlayerAround()){
                // teleport
                TeleportWithEffect();
            }       
        }
    }
    else{
        // set teleport position to player front
        if(SetTeleportPositionToPlayerFront()){
            // teleport
            TeleportWithEffect();
        }
    }
}

rule: "EnemBot/Teleport/teleportByPlayerEntered"
Event.OngoingPlayer
Team.Team2
if(
    // (NormalizedHealth() > 0.5) &&
    portalEnable &&
    portalState == PortalState.UnderAttack
){
    AbortIf(IsDead());
    AbortIf(DistanceBetween(ep, ClosestPlayerToPortal()) <= 10);

    // set teleport position to player around
    if(SetTeleportPositionToPlayerAround()){
        // teleport
        TeleportWithEffect();
    }
}

rule: "EnemBot/Teleport/teleportByPlayerNotFound"
Event.OngoingPlayer
Team.Team2
if(
    // (NormalizedHealth() > 0.5) &&
    portalEnable &&
    !IsInLineOfSight(ep,
        ClosestPlayerToMe,
        BarrierLOS.NoBarriersBlock)
){
    Wait(3, WaitBehavior.AbortWhenFalse);
    AbortIf(IsDead());    

    // Teleport bot to player front
    if(
        // during portal attacks
        portalState == PortalState.UnderAttack ||
        // probability
        ProbabilityTrue(10)
    ){
        if(
            // probability
            ProbabilityTrue(70)
        ){
            // set teleport position to common position
            if(SetTeleportPositionToCommonPosition()){
                // teleport
                TeleportWithEffect();
            }
        }
        else{
            // set teleport position to player around
            if(SetTeleportPositionToPlayerAround()){
                // teleport
                TeleportWithEffect();
            }                         
        }
    }
    else{
        // set teleport position to player front
        if(SetTeleportPositionToPlayerFront()){
            // teleport
            TeleportWithEffect();
        }
    }

    LoopIfConditionIsTrue();
}

// TAG EnemBot/chargeUltimate ----------
rule: "EnemBot/chargeUltimate"
Event.OngoingPlayer
Team.Team2
if(
    HasSpawned() &&
    enemyType != EnemyType.None &&
    !IsUsingUltimate()
){
    SetUltimateCharge(ep, UltimateChargePercent() + (100 / eachChargeUltInterval));
    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}

// TAG EnemBot/SpawnInterval ----------
define deadEffectTime: 3;
playervar define confirmSpawnInterval!;

void UpdateEachSpawnInterval()"UpdateEachSpawnInterval"{
    confirmSpawnInterval = eachMaxSpawnInterval;
    confirmSpawnInterval *= (1 - (portalSize / maxPortalSize));
    confirmSpawnInterval -= (roundNo / 5);
    confirmSpawnInterval = Max(confirmSpawnInterval, 0);
    SetRespawnMaxTime(ep, confirmSpawnInterval + deadEffectTime); 
}

rule: "EnemBot/SpawnInterval/update"
Event.OngoingPlayer
Team.Team2
if(
    portalEnable
){
    Wait(5, WaitBehavior.AbortWhenFalse);
    UpdateEachSpawnInterval();
    LoopIf(portalSize < maxPortalSize);
}

// TAG EnemBot/ReceivedDamage ----------
globalvar define confirmReceiveDamage!;

void UpdateEachReceivedDamage()"UpdateEachReceivedDamage"{
    // If don't enough players, adjust Bot received damage rate to make the game fair
    // Multiply damage rate
    confirmReceiveDamage = 100;
    // Apply balance multiplier
    confirmReceiveDamage *= ConvertToBalancedValue(0.6, Team.Team1);
    SetDamageReceived(AllPlayers(Team.Team2), confirmReceiveDamage);
}

rule: "EnemBot/ReceivedDamage/updateByBalance //for game balance, increase by missing players count"
Event.OngoingGlobal
if(
    initCompleted
){
    UpdateEachReceivedDamage();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

// TAG EnemBot/DealtDamage ----------
playervar define confirmDealDamage!;

void UpdateEachDealtDamage()"UpdateEachDealtDamage"{
    // If don't enough players, adjust Bot dealt damage rate to make the game fair
    // And the round progresses, the Bot deal damage increases and becomes more difficult
    // Add damage rate according to the round progress
    confirmDealDamage = WorkshopSettingReal("Bot Settings", "Initial Deal Damage", 25, 0, 1000, 1);
    confirmDealDamage += roundNo * WorkshopSettingReal("Bot Settings", "Increase Deal Damage Per Round Progress", 2.0, 0, 1000, 2);
    confirmDealDamage *= eachDealtDamageScale;
    // Apply balance multiplier
    confirmDealDamage /= ConvertToBalancedValue(0.6, Team.Team1);
    SetDamageDealt(ep, confirmDealDamage);
}

rule: "EnemBot/DealtDamage/update"
Event.OngoingPlayer
Team.Team2
if(
    HasSpawned() &&
    enemyType != EnemyType.None
){
    UpdateEachDealtDamage();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

rule: "EnemBot/SpawnInterval/fastRespawnBySucide"
Event.OnDeath
Team.Team2
if(
    Attacker() == ep &&
    portalEnable
){
    Wait(1, WaitBehavior.AbortWhenFalse);
    Respawn();
}

// TAG FriendBot ----------
/*
define enableFriendBot: true;
playervar define leader; 
define HumanList:
    FilteredArray(
        AllPlayers(Team.Team1),
        (
            !IsDummyBot(ae) &&
            HasSpawned(ae)
        )
    );

define FriendBotList:
    FilteredArray(
        AllPlayers(Team.Team1),
        (
            IsDummyBot(ae) &&
            HasSpawned(ae)
        )
    );

Number AddFriendBotBot(define team, define hero)"AddFriendBotBot"{
    AbortIf(CountOf(HumanList) >= 6);

    define slot = GetEmptySlot(team);
    if(slot != -1){
        define human = RandomValueInArray(
            HumanList
        );

        // create bot
        CreateDummyBot(
            hero, team, slot,
            human + RandomPosition(1, 0, 1),
            RandomDirection()
        );
        Wait(0.1, WaitBehavior.IgnoreCondition);
        WaitUntil(!isServerOverLoading, 3);

        define bot! = PlayersInSlot(slot, team);
        // choice leader from human
        bot.leader = human;
        // apply Leader's name
        StartForcingDummyBotName(bot, <"<0>'s Guard <1>", human, CountOf(FriendBotList)>);
    }
    return slot;
}

rule: "FriendBot/fillFriendBotTeam"
Event.OngoingGlobal
if(
    enableFriendBot &&
    initCompleted &&
    CountOf(HumanList) > 0 &&
    NumberOfPlayers(Team.Team1) < 6
){
    dbgMsg("fill FriendBot Team");
    define FriendBotHeroList = [
        RandomSupportHero,
        RandomSupportHero,
        RandomTankHero,
        RandomTankHero,
        RandomDamageHero,
        RandomDamageHero
    ];
    for(define idx! = 0; idx < 6; idx++){
        AddFriendBotBot(Team.Team1, FriendBotHeroList[idx]);
    }
    
    Wait(60, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

rule: "FriendBot/clearFriendBotTeam"
Event.OngoingGlobal
if(
    enableFriendBot &&
    initCompleted &&
    CountOf(HumanList) <= 0
){
    DestroyBots(Team.Team1);
}

rule: "FriendBot/rebindLeader"
Event.OnPlayerLeave
Team.Team1
if(
    enableFriendBot &&
    !IsDummyBot()
){
    define bots! = FilteredArray(
        AllPlayers(Team.Team1), ae.leader == ep);
    dbgHudTxt(CountOf(bots));

    for(pLoopIndex = 0; pLoopIndex < CountOf(bots); pLoopIndex ++){
        define newLeader! = RandomValueInArray(AllPlayers(Team.Team1));
        dbgHudTxt(newLeader);
        bots[pLoopIndex].leader = newLeader;
    }
}

rule: "FriendBot/returnToLeader"
Event.OngoingPlayer
Team.Team1
if(
    enableFriendBot &&
    IsDummyBot() &&
    !IsInLineOfSight(ep, leader)
){
    Wait(5, WaitBehavior.AbortWhenFalse);   
    Wait(SlotOf(ep) * 0.1, WaitBehavior.AbortWhenFalse);
    Teleport(
        ep, NearestWalkablePosition(leader + RandomPosition(1, 0, 1))
    );
    LoopIfConditionIsTrue();
}

rule: "FriendBot/fastRespawn"
Event.OngoingPlayer
Team.Team1
if(
    enableFriendBot &&
    IsDummyBot() &&
    !IsAlive()
){
    Wait(0.1, WaitBehavior.AbortWhenFalse);
    Respawn(ep);
}
*/

// TAG Debug ----------
globalvar define debugMode!;

enum DebugMode{
    Non,
    SlowLevelOnly,
    ShowParam,
    WithRecord
}

rule: "Debug/changeDebugMode"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Jump) 
){
    // change debug mode
    WaitLongPressConfirm();
    if(debugMode == DebugMode.Non){
        debugMode = DebugMode.SlowLevelOnly;
    }
    else if(debugMode == DebugMode.SlowLevelOnly){
        debugMode = DebugMode.ShowParam;
    }
    else if(debugMode == DebugMode.ShowParam){
        debugMode = DebugMode.WithRecord;
    }
    else if(debugMode == DebugMode.WithRecord){
        debugMode = DebugMode.Non;
    }

    if(debugMode == DebugMode.Non){
        DisableInspectorRecording();
        HideDebugHud();
    }
    else if(debugMode == DebugMode.SlowLevelOnly){
        DisableInspectorRecording();
        HideDebugHud();
        ShowDebugHud();
    }
    else if(debugMode == DebugMode.ShowParam){
        DisableInspectorRecording();
        HideDebugHud();
        ShowDebugHud();
    }
    else if(debugMode == DebugMode.WithRecord){
        EnableInspectorRecording();
        HideDebugHud();
        ShowDebugHud();
    }
}

define End(): CountOf(debugHudEntitys);
define botOfEnemyType(define enemyType): FirstOf(FilteredArray(AllPlayers(Team.Team2), ae.enemyType == enemyType));
globalvar define debugHudEntitys!;

// show debug icon and hud
void ShowDebugHud()"ShowDebugHud"{
    if(
        debugMode == DebugMode.ShowParam ||
        debugMode == DebugMode.WithRecord
    ){
        if(
            debugMode == DebugMode.WithRecord
        ){
            CreateHudText(HostPlayer(),
                null,
                null,
                "● is Recording",
                Location.Left, -1,
                Color.White, Color.White, Color.Red,
                HudTextRev.VisibleToAndString, Spectators.VisibleNever);
            debugHudEntitys[End()] = LastTextID();
        }

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "revive Timeout Count", reviveTimeoutCount>,
            null,
            Location.Left, -1,
            Color.White, Color.Blue, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "Regeneration Rate", playerRegenerationRateTeam1>,
            null,
            Location.Left, -1,
            Color.White, Color.Blue, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "portal State", portalState>,
            null,
            Location.Left, -1,
            Color.White, enemyColor, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "portal Size", portalSize>,
            null,
            Location.Left, -1,
            Color.White, enemyColor, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "portal Position", portalPosition>,
            null,
            Location.Left, -1,
            Color.White, enemyColor, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "distance to protal", DistanceBetween(ep, portalPosition)>,
            null,
            Location.Left, -1,
            Color.White, enemyColor, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();
    
        CreateHudText(HostPlayer(),
            null,
            <"<0> RcvDmg <1> DltDmg <2> SpwItv <3> ChgUlt <4>", "Giant Boss Status",
                confirmReceiveDamage,
                botOfEnemyType(EnemyType.GiantBoss).confirmDealDamage,
                botOfEnemyType(EnemyType.GiantBoss).confirmSpawnInterval,
                botOfEnemyType(EnemyType.GiantBoss).eachChargeUltInterval
            >,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> RcvDmg <1> DltDmg <2> SpwItv <3> ChgUlt <4>", "Boss Status",
                confirmReceiveDamage,
                botOfEnemyType(EnemyType.Boss).confirmDealDamage,
                botOfEnemyType(EnemyType.Boss).confirmSpawnInterval,
                botOfEnemyType(EnemyType.Boss).eachChargeUltInterval
            >,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> RcvDmg <1> DltDmg <2> SpwItv <3> ChgUlt <4>", "Elite Status",
                confirmReceiveDamage,
                botOfEnemyType(EnemyType.Elite).confirmDealDamage,
                botOfEnemyType(EnemyType.Elite).confirmSpawnInterval,
                botOfEnemyType(EnemyType.Elite).eachChargeUltInterval
            >,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> RcvDmg <1> DltDmg <2> SpwItv <3> ChgUlt <4>", "Minion Status",
                confirmReceiveDamage,
                botOfEnemyType(EnemyType.Minion).confirmDealDamage,
                botOfEnemyType(EnemyType.Minion).confirmSpawnInterval,
                botOfEnemyType(EnemyType.Minion).eachChargeUltInterval
            >,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>/<2>", "environment Death Count", environmentDeathCount, environmentDeathLimit>,
            null,
            Location.Left, -1,
            Color.White, Color.White, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>/<2>", "no Contact Time", noContactTime, limitTime>,
            null,
            Location.Left, -1,
            Color.White, Color.White, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();
    }

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "Server Load", ServerLoad()>,
            null,
            Location.Left, -1,
            Color.White, Color.Orange, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

    if(
        debugMode == DebugMode.ShowParam ||
        debugMode == DebugMode.WithRecord
    ){
        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "Server Load Average", ServerLoadAverage()>,
            null,
            Location.Left, -1,
            Color.White, Color.Orange, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "Server Load Peak", ServerLoadPeak()>,
            null,
            Location.Left, -1,
            Color.White, Color.Orange, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();
    }

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "current Slow Level", currentSlowLevel>,
            null,
            Location.Left, -1,
            Color.White, Color.Orange, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();
}

// Hide debug icon and hud
void HideDebugHud()"HideDebugHud"{
    for(gLoopIndex = 0; gLoopIndex < CountOf(debugHudEntitys); gLoopIndex ++){
        DestroyHudText(debugHudEntitys[gLoopIndex]);
    }
}

rule: "Debug/increaseTeamLifes"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Ability2)
){
    // Increase TeamLifes
    WaitLongPressConfirm();
    teamLifes += 1;
    LoopIfConditionIsTrue();
}

rule: "Debug/increaseRoundNo"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Ability1)
){
    // Increase RoundNo
    WaitLongPressConfirm();
    roundNo += 1;
    LoopIfConditionIsTrue();
}

rule: "Debug/resetPortal // reset portal position by random"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    !IsButtonHeld(ep, Button.Reload) &&
    IsButtonHeld(ep, Button.Crouch)
){
    // Recalculate portal
    WaitLongPressConfirm();
    portalState = PortalState.Init;
    WaitChangeState();  // Wait for the changed status to be processed first
    portalState = PortalState.Calculating;
}

globalvar define debugAimingPosition!;

rule: "Debug/setPortalPositionOnAimCenter // reset portal position by aim center"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Reload) &&
    !IsButtonHeld(ep, Button.Crouch)
){
    // Set portal position to aim center
    WaitLongPressConfirm();
    portalState = PortalState.Init;
    debugAimingPosition = AimingPosition();
    WaitChangeState();  // Wait for the changed status to be processed first
    portalState = PortalState.Calculating;
    WaitUntil(portalState != PortalState.Calculating, 5);
    portalPosition = debugAimingPosition;
}

rule: "Debug/setPortalMaxSize // reset portal position by aim center"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Reload) &&
    IsButtonHeld(ep, Button.Crouch)
){
    // Set portal position to aim center
    WaitLongPressConfirm();
    portalSize = maxPortalSize;
}
