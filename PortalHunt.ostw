// [Detail]
// [Portal Hunt -HORDE PVE]
// -The evil portal has been opened…
// -Defeat enemie horde that spawn from portal and close it!
// -When you enter portal, count until closing starts. Survive to 0.
// -Over time, portal begin to grow. Grown portal spawn more enemie and get tough.
// -Survive using PERK dropped by the enemy. PERK has convenient buffs, new weapon, powerful custom heroes.
// -[Grappling beam] [Cruise missile] [Legendary ninja] and more than 25 types!
// -Unlimited rounds. How many rounds can your team survive?
// [Share Code]
// YY1N2
// [ToDo]
// add optimaze hit scan by close range of Beam Sniaper
// add Perk Disarmament
// add Perk Drone Guard Dog
// add Perk Assassination

import "Lib/ElapsedTimer.ostw";
import "Lib/DamageText.ostw";
import "Lib/Regeneration.ostw";
import "Lib/Revive.ostw";
import "Lib/Perk.ostw";
import "Lib/Bot.ostw";
import "Lib/Debug.ostw";
// import "Lib/InvisibleImmortalForDebug.ostw";

// TAG duumy driver ----------
// globalvar define Revive_enableTeam;
// globalvar define Revive_timeLimit;
// globalvar define reviveTimeoutCount;

// TAG Signature and infomation ----------
disabled rule: "PORTAL HUNT -HORDE PVE [ver 3.0] Share code [YY1N2]"-1{}
disabled rule: "You allowed copy or modify code."-1{}
disabled rule: "This script was generated from source code by [Overwatch-Script-To-Workshop]"-1{}
disabled rule: "Check detail with https://github.com/ItsDeltin/Overwatch-Script-To-Workshop"-1{}
disabled rule: "Original source code was created by [sarami77#1868]"-1{}
disabled rule: "Check detail with https://github.com/sarami77/OverwatchWorkShopScripts"-1{}

// TAG System ----------
define enableOverLoadMeasures: true;
define overloadDuringLimit: 5;
globalvar define overloadDuring;

rule: "System/ServerOverLoadMeasures"
Event.OngoingGlobal
if(
    enableOverLoadMeasures &&
    teamLifes > 0
){
    // If the server is overloaded,
    //  apply slow motion every second to reduce the load to
    //  avoid shutting down due to server overload.
   
    // Because the value of ServerLoad () changes frequently
    //  Do not bind it to a "condition" and monitor it by polling every second.
    if(255 <= ServerLoadAverage()){
        if(overloadDuringLimit > overloadDuring){
            overloadDuring ++;
        }
    }
    else{
        if(0 < overloadDuring){
            overloadDuring --;
        }
    }

    if(overloadDuring == 0){
        SetSlowMotion(100);
    }
    else if(overloadDuring == 1){
        SetSlowMotion(90);
    }
    else if(overloadDuring == 2){
        SetSlowMotion(80);
    }
    else if(overloadDuring == 3){
        SetSlowMotion(70);
    }
    else if(overloadDuring == 4){
        SetSlowMotion(60);
    }
    else if(overloadDuring == 5){
        SetSlowMotion(25);
    }

    Wait(1, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

// TAG Game ----------
globalvar define initCompleted;

rule: "Game/initGameSetting //wait 3 _seconds because some scripts fail immediately after loading the _server"
Event.OngoingGlobal
{
    // Stop records to reduce server load
    DisableInspectorRecording();

    // for perfomance debug
//    CreateHudText(HostPlayer(),
//        null,
//        <"<0> <1>", "over load during", overloadDuring>,
//        null,
//        Location.Left, -1,
//        Color.White, Color.Orange, Color.White,
//        HudTextRev.VisibleToAndString, Spectators.VisibleNever);

    // Set imported function property
    Regeneration_enableTeam = Team.Team1;
    Regeneration_needBalanceTeam1 = true;
    Regeneration_waitRegenTimeTeam1 = WorkshopSettingReal("Player Settings", "Wait Second Until Start Regeneration", 1, 0, 100, 1);
    Regeneration_regenerationRateTeam1 = WorkshopSettingReal("Player Settings", "Regeneration Rate In Per Seconds", 25, 0, 1000, 2);

    Revive_enableTeam = Team.Team1;
    Revive_timeLimit = WorkshopSettingReal("Player Settings", "Revive Time Limit", 10, 0, 100, 3);
    
    DamageText_enableTeam = Team.Team2;

    // If run it right after loading the server, some scripts fail, so wait 3 seconds
    Wait(3, WaitBehavior.AbortWhenFalse);

    // Cancel unnecessary default settings
    PauseMatchTime();
    DisableScoring();
    DisableGameModeInworldUI(AllPlayers());
    DisableCompletion();

    // Calculate the approximate center position of the map from the spawn room position.
    // Therefore, change the spawn room and then spawn the entity.
    ForceSpawnRoom(Team.Team1, 2);
    Respawn(AllPlayers(Team.All));

    // Set initial team lifes
    initialTeamLifes = WorkshopSettingInteger("Player Settings", "Initial Team Lifes", 6, 0, 1000, 0);

    // Notify completion of init game setting and start game main logic
    initCompleted = true;
}

rule: "Game/initGame"
Event.OngoingGlobal
if(
    initCompleted
){
    // reset team lifes
    teamLifes = initialTeamLifes;
    // reset round no
    roundNo = 0;
    // reset elapsed time
    enableElapsedTimer = false;
    elapsedTime = 0;
}

rule: "Game/startGame"
Event.OngoingGlobal
if(
    initCompleted &&
    NumberOfPlayers(Team.Team1) > 0 &&
    IsTrueForAny(
        AllPlayers(Team.Team1),
        !IsInSpawnRoom(ae))
){
    // start elapsed time
    enableElapsedTimer = true;
    // start portal creation
    portalState = PortalState.Calculating;
}

rule: "Game/stopGame"
Event.OngoingGlobal
if(
    initCompleted &&
    NumberOfPlayers(Team.Team1) <= 0
){
    // reset team lifes
    teamLifes = initialTeamLifes;
    // reset round no
    roundNo = 0;
    // reset elapsed time
    enableElapsedTimer = false;
    elapsedTime = 0;
    // reset portal
    portalState = PortalState.Init;
}

rule: "Game/ShareCode/showGameCode"
Event.OngoingGlobal
if(
    initCompleted
){
    // show ver and share code
    CreateHudText(AllPlayers(Team.Team1),
        null, "PORTAL HUNT -HORDE PVE [ver 3.0] Share code [YY1N2]", null,
        Location.Left, -3,
        Color.White, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);
}

rule: "Game/RoundNo/showObjectMessageHUD //with update message by state"
Event.OngoingPlayer
if(
    initCompleted &&
    HasSpawned()
){
    SetObjectiveDescription(ep, "Find portal and attack it.", HudTextRev.String);
}

define enemyColor: Color.Purple;
globalvar define roundNo;

rule: "Game/RoundNo/showRoundHUD"
Event.OngoingGlobal
if(
    initCompleted
){
    // show HUD of round number
    CreateHudText(AllPlayers(Team.All),
        <"<0> <1>", "Round", roundNo>, null, null,
        Location.Top, 2,
        enemyColor, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleAlways);
}

rule: "Game/SpawnRoom/changeByTimer //to make the game fluid"
Event.OngoingGlobal
if(
    initCompleted
){
    // Change the spawn room regularly to keep the game fluid
    Wait(300, WaitBehavior.AbortWhenFalse); // change spawn room
    ForceSpawnRoom(Team.Team2, RandomInteger(0, 2));
    ForceSpawnRoom(Team.Team1, RandomInteger(0, 2));
    LoopIfConditionIsTrue();
}

// TAG Player ----------
playervar define isInsidePortal;

rule: "Player/InsidePortal/update"
Event.OngoingGlobal
Player.All
if(
    portalEnable
){
    define players = AllPlayers(Team.Team1);
    // Set flag when player entered to portal
    // This flag is used for functions related to portal
    for(gLoopIndex = 0; gLoopIndex < CountOf(players); gLoopIndex++){
        if(
            IsAlive(players[gLoopIndex]) &&
            !IsInSpawnRoom(players[gLoopIndex]) &&
            DistanceBetween(players[gLoopIndex], portalPosition) <= portalSize
        ){
            players[gLoopIndex].isInsidePortal = true;
        }
        else{
            players[gLoopIndex].isInsidePortal = false;
        }
    }
    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}

rule: "Player/ReturnSpawn/showOperationHUD"
Event.OngoingGlobal
if(
    initCompleted
){
    // show HUD of hero change operation
    CreateHudText(AllPlayers(Team.Team1),
        null, <"Long hold reload button <0> to change hero", ButtonGuide(Button.Reload)>, null,
        Location.Left, -2,
        Color.Yellow, Color.Yellow, Color.Yellow,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);
}

rule: "Player/ReturnSpawn/returnSpawn"
Event.OngoingPlayer
Team.Team1
Player.All
if(
    IsAlive() &&
    !IsInSpawnRoom() &&
    IsButtonHeld(ep, Button.Reload)
){
    // Return to spawn room with long hold on reload button
    WaitCancelPressConfirm();
    Respawn();
}

globalvar define initialTeamLifes;
globalvar define teamLifes;

rule: "Player/TeamLifes/showTeamLifesHUD"
Event.OngoingGlobal
if(
    initCompleted
){
    // show HUD of team lifes
    CreateHudText(AllPlayers(Team.All),
        <"<0> <1>", "Team lifes", teamLifes>, null, null,
        Location.Top, 1,
        Color.Team1, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleAlways);
}

rule: "Player/TeamLifes/consumeTeamLifes"
Event.OngoingGlobal
if(
    0 < reviveTimeoutCount
){
    WaitConditionConfirmed();
    teamLifes -= reviveTimeoutCount;
    WaitChangeState();  // wait for show big message by newest value
    if(teamLifes > 0){
        if(teamLifes > 0){
            BigMessage(AllPlayers(Team.All),
                <"<0> <1> <2>", "Our remaining team lifes is", teamLifes, "...">);
        }
        PlayEffect(
            AllPlayers(Team.All), PlayEffect.DebuffImpactSound,
            Color.White, portalPosition, MaxLength());
    }
    reviveTimeoutCount = 0;
}

rule: "Player/TeamLifes/finishGame //by team lifes out"
Event.OngoingGlobal
if(
    initCompleted &&
    teamLifes <= 0
){
    WaitConditionConfirmed();
    // When the team lifes out, the game ends
    portalState = PortalState.End;
    BigMessage(AllPlayers(Team.All), "Our team lifes is out...");
    SetSlowMotion(10);
    Wait(1, WaitBehavior.AbortWhenFalse);   // show slow
    SetSlowMotion(100);
    WaitNextPhase();

    BigMessage(AllPlayers(Team.All),
        <"We have reached <0> round... good game!", roundNo>);
    PlayRandomEmote(AllPlayers(Team.Team1));
    WaitNextPhase();

    DeclareTeamVictory(Team.Team1);
}

rule: "Player/TeamLifes/protectTeamLifesFromSucide"
Event.OnDeath
Team.Team1
Player.All
if(
    Attacker() == ep &&
    DistanceBetween(ep,
        ClosestPlayerTo(ep, Team.Team2)) > 15
){
    Wait(1, WaitBehavior.AbortWhenFalse);
    Respawn();
}

globalvar define closingCount;
globalvar define closingProgress;
globalvar define closingProgressHudEntity;
globalvar define playerNumInsidePortal;

define enableClosingProgress:
    portalState == PortalState.Suspended &&
    teamLifes > 0;

rule: "Player/ClosePortal/startClosing //on enter any player"
Event.OngoingGlobal
if(
    enableClosingProgress
){
    // When a player enters a portal, set progress hud and show message
    WaitConditionConfirmed();
    // kick progress
    closingCount = RoundToInteger(portalSize, Rounding.Nearest);
    closingCount += roundNo * 2;
    closingProgress = 0;
    ChaseVariableOverTime(closingProgress, DefaultPercentage(), closingCount, TimeChaseReevaluation.DestinationAndDuration);
    // show progress hud
    if(closingProgressHudEntity == null){
        CreateProgressBarHudText(
            AllPlayers(),
            closingProgress,
            <"<0> player has surviving in portal. Until portal closes...", playerNumInsidePortal >,
            Location.Top, 3,
            Color.White,
            Color.White,
            ProgressBarEvaluation.VisibleToValuesAndColor,
            Spectators.DefaultVisibility );
        closingProgressHudEntity = LastTextID();
    }
    // get closest surviver to portal center
    define closestPlayerFromPortal = 
        FirstOf(
            SortedArray(
                FilteredArray(
                    AllPlayers(Team.Team1), IsAlive(ae)
                ),
                DistanceBetween(portalPosition, ae)
            )
        );
    // show big message
    BigMessage(
        closestPlayerFromPortal,
        <"You are closing portal... Stay inside and Survive!">);
    BigMessage(
        FilteredArray(AllPlayers(Team.Team1), (closestPlayerFromPortal != ae)),
        <"<0> <1> <2>",
            closestPlayerFromPortal,
            HeroIconString(HeroOf(closestPlayerFromPortal)),
            "closing portal... Cover one!">);
    // Wait closingCount
    Wait(closingCount, WaitBehavior.AbortWhenFalse);
    portalState = PortalState.Closing;
}

rule: "Player/ClosePortal/updatePlayerNumInsidePortal"
Event.OngoingGlobal
if(
    enableClosingProgress
){
    playerNumInsidePortal = CountOf(
        FilteredArray(
            AllPlayers(Team.Team1),
            ae.isInsidePortal
        )
    );
    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}

rule: "Player/ClosePortal/cancelClosing //on exit every player"
Event.OngoingGlobal
if(
    !enableClosingProgress
){
    StopChasingVariable(closingProgress);
    // wait hide hud when progress completed
    if(closingProgress == 100){
        Wait(1.5, WaitBehavior.AbortWhenFalse);
    }
    DestroyProgressBarHudText(closingProgressHudEntity);
    closingProgressHudEntity = null;
}

rule: "Player/ClosePortal/finishClose //on count down finished"
Event.OngoingGlobal
if(
    (
        portalState == PortalState.Closing ||
        portalState == PortalState.Closed
    ) &&
    teamLifes > 0
){
    WaitConditionConfirmed();
    // When the countdown is complete, clear the portal and give team lifes.
    // Later, we will generate a new portal and start the next round.
    WaitPlayEffect();   //wait portal closing effect
    portalState = PortalState.Closed;
    WaitNextPhase();

    // show got life sound message
    BigMessage(AllPlayers(Team.All), "We got new team lifes!");
    // play got life sound
    PlayEffect(
        AllPlayers(Team.All), PlayEffect.BuffImpactSound,
        Color.White, portalPosition, MaxLength()
    );
    // got life sound
    teamLifes += 1;
    WaitNextPhase();

    PlayRandomVoiceLine(AllPlayers(Team.Team1));
    roundNo += 1;
    portalState = PortalState.Calculating;  // start next portal create
}

playervar define inPortalEffectEntitys;

rule: "Player/FairPlay/disableStealthWhenInside //sombra's stealth for fair play"
Event.OngoingPlayer
Team.Team1
Player.All
if(
    isInsidePortal &&
    HeroOf() == Hero.Sombra &&
    IsUsingAbility1()
){
    // Some abilities are disabled inside the portal to make the game fair
    // Sombra stealth is exactly that
    Wait(5.0, WaitBehavior.AbortWhenFalse); // disable ability check cycle
    SetStatus(ep, null, Status.Stunned, 0.1);
    SmallMessage(ep, "Stealth disabled by magnetic storm of portal.");
    LoopIfConditionIsTrue();
}

rule: "Player/FairPlay/disableGrappleClawWhenInside // wreckingBball's grapple claw for fair play"
Event.OngoingPlayer
Team.Team1
Player.All
if(
    isInsidePortal &&
    HeroOf() == Hero.WreckingBall &&
    IsFiringSecondary()
){
    // Some abilities are disabled inside the portal to make the game fair
    // WreckingBall Grapple is exactly that
    Wait(5.0, WaitBehavior.AbortWhenFalse); // disable ability check cycle
    SetStatus(ep, null, Status.Stunned, 0.1);
    SmallMessage(ep, "Grapple claw disabled by magnetic storm of portal.");
    LoopIfConditionIsTrue();
}

// TAG Portal Function ----------
globalvar define portalState;
enum PortalState{
    Init,
    Idle,
    Calculating,
    Checking,
    Set,
    Growing,
    Suspended,
    Closing,
    Closed,
    End
}

globalvar define portalPosition;
globalvar define portalSize;
globalvar define portalEntitys;
globalvar define isFirstGrowing;

define portalEnable:
    portalState == PortalState.Checking ||
    portalState == PortalState.Set ||
    portalState == PortalState.Growing ||
    portalState == PortalState.Suspended;

rule: "Portal/State/Calculating //invisible, init param"
Event.OngoingGlobal
if(
    portalState == PortalState.Calculating
){
    // Hide Portal Entity until portal state changed to Show
    // Init param
    StopChasingVariable(portalSize);
    portalPosition = 0;
    portalSize = 0;
    isFirstGrowing = true;
    // Hide portal icon and effect
    DestroyIcon(portalEntitys[0]);
    DestroyEffect(portalEntitys[1]);
    DestroyEffect(portalEntitys[2]);
    DestroyEffect(portalEntitys[3]);
    DestroyEffect(portalEntitys[4]);
}

rule: "Portal/State/Set  // waiting for found by players"
Event.OngoingGlobal
if(
    portalState == PortalState.Set
){
    DestroyIcon(portalEntitys[0]);
    // show Portal Entity by portal state changed to Show
    // Init param
    closingCount = 0;
    // show icon
    portalEntitys = [];
    CreateIcon(AllPlayers(Team.All), portalPosition, Icon.Spiral,
        IconRev.VisibleToAndPosition, enemyColor, true);
    portalEntitys[0] = LastCreatedEntity();
    // set effect
    // sphere
    CreateEffect(AllPlayers(Team.All), Effect.Sphere, enemyColor,
        portalPosition, portalSize, EffectRev.VisibleToPositionAndRadius);
    portalEntitys[1] = LastCreatedEntity();
    // cloud
    CreateEffect(AllPlayers(Team.All), Effect.Cloud, enemyColor,
        portalPosition, portalSize * 1.5, EffectRev.VisibleToPositionAndRadius);
    portalEntitys[2] = LastCreatedEntity();
    // aura
    // Since visibility will be poor, display only in the center of the field of view
    CreateEffect(
        FilteredArray(
            AllPlayers(Team.All),
            DistanceBetween(ae, portalPosition) > portalSize / 2), Effect.BadAura, enemyColor,
        portalPosition, portalSize * 1.25, EffectRev.VisibleToPositionAndRadius);
    portalEntitys[3] = LastCreatedEntity();
    // sound
    CreateEffect(AllPlayers(Team.All), Effect.EnergySound, enemyColor,
        portalPosition, portalSize / 2, EffectRev.VisibleToPositionAndRadius);
    portalEntitys[4] = LastCreatedEntity();
    // show message
    BigMessage(AllPlayers(Team.All), "Detected more portal... find and attack it!");
    // change bot asset by random
    if(
        0 >= NumberOfPlayers(Team.Team2) ||
        RandomInteger(1, 100) <= 70
    ){
        // destroy all bot
        DestroyAllBot();
        // create all bot
        CreateAllBotByAsset();   
    }
    // Hide icon to let the player search the portal
    Wait(6, WaitBehavior.AbortWhenFalse);
    DestroyIcon(portalEntitys[0]);
}

rule: "Portal/State/Growing"
Event.OngoingGlobal
if(
    portalState == PortalState.Growing
){
    // Start growing portal with warning message
    ChaseVariableAtRate(
        portalSize, maxPortalSize, 1 + (roundNo / 8),
        RateChaseReevaluation.DestinationAndRate);
    // If first growing, show message
    if(isFirstGrowing == true){
        isFirstGrowing = false;
        BigMessage(AllPlayers(Team.All), "Portal is growing... hurry up!");
        WaitBigMessageHide();
        BigMessage(AllPlayers(Team.All), "Growed portals spawn more enemys and get tough...");
    }
    // Hide icon to let the player search the portal
    Wait(1, WaitBehavior.AbortWhenFalse);
    DestroyIcon(portalEntitys[0]);
}

rule: "Portal/State/Suspended"
Event.OngoingGlobal
if(
    portalState == PortalState.Suspended
){
    // Hide icon to let the player search the portal
    DestroyIcon(portalEntitys[0]);
    // Stop growing portal
    StopChasingVariable(portalSize);
}

rule: "Portal/State/Closing"
Event.OngoingGlobal
if(
    portalState == PortalState.Closing
){
    // apply blast impulse
    ApplyBlastImpulse(AllPlayers(Team.Team2), portalPosition, portalSize);
    // play portal closing effect and kill enemrys
    Kill(AllPlayers(Team.Team2), null);
    // play blast sound
    PlayEffect(
        AllPlayers(Team.All), PlayEffect.RingExplosionSound,
        Color.White, portalPosition, MaxLength());
    // play blast effect
    PlayContinuousBlast(
        Color.Yellow,
        portalPosition,
        portalSize * 1.5,
        10);
}

rule: "Portal/State/Closed"
Event.OngoingGlobal
if(
    portalState == PortalState.Closed
){
    // show message
    BigMessage(AllPlayers(Team.All), "Portal closed... good job!");
    // init param
    portalPosition = 0;
    portalSize = 0;
    StopChasingVariable(portalSize);
    // Hide portal icon and effect
    DestroyIcon(portalEntitys[0]);
    DestroyEffect(portalEntitys[1]);
    DestroyEffect(portalEntitys[2]);
    DestroyEffect(portalEntitys[3]);
    DestroyEffect(portalEntitys[4]);
}

rule: "Portal/State/End"
Event.OngoingGlobal
if(
    portalState == PortalState.End
){
    // apply blast impulse
    ApplyBlastImpulse(AllPlayers(Team.Team2), portalPosition, portalSize);
    // play portal closing effect and kill enemrys
    Kill(AllPlayers(Team.Team2), null);
    // play blast sound
    PlayEffect(
        AllPlayers(Team.All), PlayEffect.RingExplosionSound,
        Color.White, portalPosition, MaxLength());
    // play blast effect
    PlayContinuousBlast(
        Color.Yellow,
        portalPosition,
        portalSize * 1.5,
        10);

    // init param
    portalPosition = 0;
    portalSize = 0;
    StopChasingVariable(portalSize);
    // Hide portal icon and effect
    DestroyIcon(portalEntitys[0]);
    DestroyEffect(portalEntitys[1]);
    DestroyEffect(portalEntitys[2]);
    DestroyEffect(portalEntitys[3]);
    DestroyEffect(portalEntitys[4]);
}

rule: "Portal/Positioner/createPortal"
Event.OngoingGlobal
if(
    teamLifes > 0 &&
    portalState == PortalState.Calculating
){
    WaitConditionConfirmed();
    define candidatePosition;
    for(define retryCount = 0; retryCount < 10; retryCount++){
        // select random player as base positoon
        define basePlayer =
            RandomValueInArray(
                FilteredArray(
                    AllLivingPlayers(Team.Team1),
                    HasSpawned(ae)
                )
            );
        // select random positon from player around
        define randomPositon = 
            basePlayer +
            // add random direction
            DirectionFromAngles(
                RandomReal(0, 360),
                RandomReal(90, -90)
            ) * 
            // add random distance
            RandomReal(50, 200);
        // get candidate postion of portal 
        candidatePosition = NearestWalkablePosition(randomPositon);
        // move candidate postion in the direction of player for avoiding map edge
        candidatePosition += DirectionTowards(candidatePosition, basePlayer) * RandomReal(5, 25);
        // convert to walkble position
        candidatePosition = NearestWalkablePosition(candidatePosition);
        if(
            // close candidate postion than random positon
            (
                DistanceBetween(basePlayer, randomPositon) >= 
                DistanceBetween(basePlayer, candidatePosition) + 10
            )
                &&
            // far postion from previous position
            (
                DistanceBetween(prevPortalPosition, candidatePosition) >= 50
            )
                &&
            // far postion from player
            (
                DistanceBetween(
                    ClosestPlayerTo(candidatePosition, Team.Team1),
                    candidatePosition
                ) >= 50
            )
        ){
            break;
        }
        Wait(0.01, WaitBehavior.AbortWhenFalse);
    }
    // confirm as portal position
    portalPosition = candidatePosition;
    // create portal, next check position
    portalState = PortalState.Checking;
    // fail safe
    Wait(6, WaitBehavior.AbortWhenFalse);
	dbgMsg("failsafe triggered of createPortal");
    LoopIfConditionIsTrue();
}

define positionCheckTime: 2.0;
globalvar define prevPortalPosition;

rule: "Portal/Positioner/positionChecking"
Event.OngoingGlobal
if(
    teamLifes > 0 &&
    portalState == PortalState.Checking
){
    // Waiting for Positioner/DetectXXX judgment described later
    Wait(positionCheckTime, WaitBehavior.AbortWhenFalse);
    // confirm portal position
    prevPortalPosition = portalPosition;
    portalState = PortalState.Set;
    // fail safe
    Wait(6, WaitBehavior.AbortWhenFalse);
    dbgMsg("failsafe triggered of positionChecking");
    LoopIfConditionIsTrue();
}

// TAG Portal/InvalidDetect/InvalidAreaScore ----------
define limitCount: 3;
globalvar define invalidAreaScore = 0;

rule: "Portal/InvalidDetect/EnvironmentDamage/resetCount"
Event.OngoingGlobal
if(
    !portalEnable &&
    invalidAreaScore > 0
){
    invalidAreaScore = 0;
}

rule: "Portal/InvalidDetect/EnvironmentDamage/countupBySuside"
Event.OnDeath
Team.Team2
if(
    portalEnable &&
    ep == Attacker()
){
    invalidAreaScore += 1;
}

rule: "Portal/InvalidDetect/EnvironmentDamage/countupByKilledFromSpawnRoom"
Event.OnDeath
Team.Team2
if(
    portalEnable &&
    IsInSpawnRoom(Attacker())
){
    invalidAreaScore += 3;
}

rule: "Portal/InvalidDetect/EnvironmentDamage/reduceCount"
Event.OngoingGlobal
if(
    portalEnable &&
    0 < invalidAreaScore
){
    WaitUpdateMediumCycle();
    invalidAreaScore --;
    LoopIfConditionIsTrue();
}

rule: "Portal/InvalidDetect/EnvironmentDamage/resetPortal"
Event.OngoingGlobal
if(
    portalEnable &&
    limitCount <= invalidAreaScore
){
    dbgMsg("reset Portal By Environment Damage Count");
    portalState = PortalState.Calculating;
}

// TAG Portal/InvalidDetect/NoContact ----------
define limitTime: 40;
globalvar define noContact;

rule: "Portal/InvalidDetect/NoContact/resetNoContact"
Event.OngoingGlobal
if(
    !portalEnable &&
    !noContact
){
    WaitConditionConfirmed();
    noContact = true;
}

rule: "Portal/InvalidDetect/NoContact/detectContact"
Event.OngoingGlobal
if(
    portalEnable &&
    noContact &&
    IsTrueForAny(
        AllPlayers(Team.Team1),
        IsInLineOfSight(
            ae,
            ClosestPlayerTo(ae, Team.Team2)))
){
    Wait(1, WaitBehavior.AbortWhenFalse);
    noContact = false;
}

rule: "Portal/InvalidDetect/NoContact/resetPortal"
Event.OngoingGlobal
if(
    portalEnable &&
    noContact
){
    Wait(limitTime, WaitBehavior.AbortWhenFalse);
    dbgMsg("reset Portal By No Countact");
    portalState = PortalState.Calculating;
}

// TAG Portal/Growing ----------
define maxPortalSize: 70;
define portalStableTime: 40;

rule: "Portal/Growing/startGrowingByPlayerFound"
Event.OngoingGlobal
if(
    portalState == PortalState.Set
){
    if(
        IsInLineOfSight(portalPosition,
            closestPlayerPortal,
            BarrierLOS.NoBarriersBlock)
    ){
        WaitConditionConfirmed();
        // Strat portal growing by player found
        portalState = PortalState.Growing;
    }
    else{
        WaitUpdateMediumCycle();
        LoopIfConditionIsTrue();
    }
}

rule: "Portal/Growing/startGrowingByTimeout"
Event.OngoingGlobal
if(portalState == PortalState.Set){
    // Start portal growing by search time limit out
    Wait(portalStableTime, WaitBehavior.AbortWhenFalse);  //wait time to start growing
    portalState = PortalState.Growing;
}

rule: "Portal/Growing/suspendGrowingByPlayerEntered"
Event.OngoingGlobal
if(
    portalState == PortalState.Growing &&
    IsTrueForAny(
        AllPlayers(Team.Team1), ae.isInsidePortal
    )
){
    // Suspend portal growing by player enter to portal
    WaitConditionConfirmed();
    portalState = PortalState.Suspended;
}

rule: "Portal/Growing/resumeGrowingByPlayerExited"
Event.OngoingGlobal
if(
    portalState == PortalState.Suspended &&
    !IsTrueForAny(
        AllPlayers(Team.Team1), ae.isInsidePortal
    )
){
    // Resume portal growing by player exit from portal
    WaitConditionConfirmed();
    portalState = PortalState.Growing;
}

// TAG Bot/EnemyType ----------
playervar define enemyType;
enum EnemyType{
    None,
    Minion,
    Elite,
    Boss,
    GiantBoss
}

playervar define eachDealtDamageScale;
playervar define eachMaxSpawnInterval;
playervar define eachChargeUltInterval;

rule: "Bot/EnemyType/setEnemyType"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    enemyType != EnemyType.None
){
    if(enemyType == EnemyType.Minion){ 
        SetMaxHealth(ep, 50);
        Wait(0.1, WaitBehavior.AbortWhenFalse);
        Heal(ep, null, MaxValue());

        SetHealingReceived(ep, 50);
        StartScalingPlayer(ep, 0.75, false);
        StartModifyingHeroVoiceLines(ep, 1.25, false);
        eachDealtDamageScale = 0.5;
        eachMaxSpawnInterval = 3;
        eachChargeUltInterval = 80;
    }
    else if(enemyType == EnemyType.Elite){
        SetMaxHealth(ep, 200);
        Wait(0.1, WaitBehavior.AbortWhenFalse);
        Heal(ep, null, MaxValue());

        SetHealingReceived(ep, 200);
        StartScalingPlayer(ep, 1.0, false);
        StartModifyingHeroVoiceLines(ep, 1.0, false);
        eachDealtDamageScale = 1.0;
        eachMaxSpawnInterval = 9;
        eachChargeUltInterval = 20;
    }
    else if(enemyType == EnemyType.Boss){
        SetMaxHealth(ep, 1500);
        Wait(0.1, WaitBehavior.AbortWhenFalse);
        Heal(ep, null, MaxValue());

        SetHealingReceived(ep, 1500);
        StartScalingPlayer(ep, 1.5, false);
        StartModifyingHeroVoiceLines(ep, 0.75, false);
        eachDealtDamageScale = 1.5;
        eachMaxSpawnInterval = 27;
        eachChargeUltInterval = 10;
    }
    else if(enemyType == EnemyType.GiantBoss){
        SetMaxHealth(ep, 10000);
        Wait(0.1, WaitBehavior.AbortWhenFalse);
        Heal(ep, null, MaxValue());

        SetHealingReceived(ep, 10000);
        StartScalingPlayer(ep, 2.5, false);
        StartModifyingHeroVoiceLines(ep, 0.5, false);
        eachDealtDamageScale = 5.0;
        eachMaxSpawnInterval = 10;
        eachChargeUltInterval = 10;
    }    

    UpdateEachDealtDamage();
    UpdateEachSpawnInterval();
}

// TAG Bot/Effect ----------
playervar define botAppearanceEntitys;

rule: "Bot/Effect/showBotAppearance"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    enemyType != EnemyType.None &&
    IsAlive()
){
    botAppearanceEntitys = [];
    if(enemyType == EnemyType.Minion){
        CreateEffect(AllPlayers(Team.All), Effect.Cloud, enemyColor,
            ep, 1.0, EffectRev.VisibleToPositionAndRadius);
        botAppearanceEntitys[0] = LastCreatedEntity();
        CreateInWorldText(
            AllPlayers(Team.All), "Minion", 
            ep, 1.0, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            Color.White, Spectators.DefaultVisibility);
        botAppearanceEntitys[1] = LastTextID();
    }
    else if(enemyType == EnemyType.Elite){
        CreateEffect(AllPlayers(Team.All), Effect.Cloud, enemyColor,
            ep, 2.0, EffectRev.VisibleToPositionAndRadius);
        botAppearanceEntitys[0] = LastCreatedEntity();
        CreateInWorldText(
            AllPlayers(Team.All), "Elite", 
            ep, 1.5, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            Color.Yellow, Spectators.DefaultVisibility);
        botAppearanceEntitys[1] = LastTextID();
    }
    else if(enemyType == EnemyType.Boss){
        CreateEffect(AllPlayers(Team.All), Effect.Cloud, enemyColor,
            ep, 4.0, EffectRev.VisibleToPositionAndRadius);
        botAppearanceEntitys[0] = LastCreatedEntity();
        CreateInWorldText(
            AllPlayers(Team.All), "Boss", 
            ep, 2.0, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            Color.Red, Spectators.DefaultVisibility);
        botAppearanceEntitys[1] = LastTextID();
    }
 if(enemyType == EnemyType.GiantBoss){
        CreateEffect(AllPlayers(Team.All), Effect.Cloud, enemyColor,
            ep, 8.0, EffectRev.VisibleToPositionAndRadius);
        botAppearanceEntitys[0] = LastCreatedEntity();
        CreateInWorldText(
            AllPlayers(Team.All), "Giant Boss", 
            ep, 2.5, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            Color.Red, Spectators.DefaultVisibility);
        botAppearanceEntitys[1] = LastTextID();
    }
}

rule: "Bot/Effect/hideBotAppearance"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    enemyType != EnemyType.None &&
    !IsAlive()
){
    DestroyEffect(botAppearanceEntitys[0]);
    DestroyInWorldText(botAppearanceEntitys[1]);
}

rule: "Bot/Effect/playDeadEffect"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    enemyType != EnemyType.None &&
    IsDead()
){
    // Play blast effect when Bot dead
    // It's easier to understand if you killed an Bot, and you'll feel better
    if(enemyType == EnemyType.Minion){
        PlayContinuousBlast(Color.Red, PositionOf(), 2, 1);
    }
    else if(enemyType == EnemyType.Elite){
        PlayContinuousBlast(Color.Red, PositionOf(), 3, 2);
    }
    else if(enemyType == EnemyType.Boss){
        PlayContinuousBlast(Color.Red, PositionOf(), 5, 3);
    }
    else if(enemyType == EnemyType.GiantBoss){
        PlayContinuousBlast(Color.Red, PositionOf(), 7, 5);
    }
}

// TAG Bot/Teleport ----------
define teleportAreaSize: 6;
define closestPlayerTeleportPosition: ClosestPlayerTo(teleportPosition, Team.Team1);
define closestPlayerPortal: ClosestPlayerTo(portalPosition, Team.Team1);
define closestPlayerMe: ClosestPlayerTo(ep, Team.Team1);
playervar define teleportPosition;

void SetTeleportPositionToPlayerFront()"SetTeleportPositionToPlayerFront"{
    // set teleport position by blind spot from player
    // find place that will be a blind spot up to 10 times
    for(pLoopIndex = 0; pLoopIndex < 10; pLoopIndex++){
        teleportPosition =
            NearestWalkablePosition(
                PositionOf(closestPlayerPortal)
                    + 
                (
                    DirectionTowards(
                        closestPlayerPortal,
                        portalPosition
                    )
                        *
                    (DistanceBetween(portalPosition, closestPlayerPortal) * 0.5)
                )
                    +
                RandomPosition(teleportAreaSize, teleportAreaSize, teleportAreaSize)
            );

        if(
            DistanceBetween(    // Not too close to player
                closestPlayerTeleportPosition, teleportPosition)
            > 5
                &&
            IsInLineOfSight(    // Has line
                closestPlayerTeleportPosition, teleportPosition, BarrierLOS.NoBarriersBlock)
        ){
            break;
        }
    }
}

void SetTeleportPositionToCamper()"SetTeleportPositionToCamper"{
    // set teleport position by blind spot from player
    // find place that will be a blind spot up to 10 times
    for(pLoopIndex = 0; pLoopIndex < 10; pLoopIndex++){
        teleportPosition =
            NearestWalkablePosition(
                PositionOf(closestPlayerPortal)
                    + 
                RandomPosition(teleportAreaSize / 2, teleportAreaSize / 2, teleportAreaSize / 2)
            );

        if(
            IsInLineOfSight(    // Has line
                closestPlayerTeleportPosition, teleportPosition, BarrierLOS.NoBarriersBlock)
        ){
            break;
        }
    }
}

void PlayTeleportEffect()"PlayTeleportEffect"{
    if(enemyType == EnemyType.Minion){
        PlayEffect(AllPlayers(Team.All), PlayEffect.BadExplosion, enemyColor, ep, 2);
    }
    else if(enemyType == EnemyType.Elite){
        PlayEffect(AllPlayers(Team.All), PlayEffect.BadExplosion, enemyColor, ep, 3);
    }
    else if(enemyType == EnemyType.Boss){
        PlayEffect(AllPlayers(Team.All), PlayEffect.BadExplosion, enemyColor, ep, 5);
    }
    else if(enemyType == EnemyType.GiantBoss){
        PlayEffect(AllPlayers(Team.All), PlayEffect.BadExplosion, enemyColor, ep, 7);
    }
    // Play blast effect when Bot teleport
    
    // show effect at root position
    WaitPlayEffect();
}

rule: "Bot/Teleport/teleportToSpawnRoomByPortalDisabled"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    HasSpawned() &&
    !portalEnable
){
    // Teleport Bot to spawn room when portal disable
    // wait show dead effect when portal closing
    Wait(deadEffectTime, WaitBehavior.AbortWhenFalse);   
    // Teleport to spawn room
    Respawn(AllPlayers(Team.Team2));
    // set root
    SetStatus(ep, null, Status.Rooted, MaxValue());
}

rule: "Bot/Teleport/teleportToPortalByPortalEnabled"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    HasSpawned() &&
    portalEnable
){
    // clear root
    ClearStatus(ep, Status.Rooted);
    // set teleport position
    SetTeleportPositionToPlayerFront();
    // show pre teleport effect
    PlayTeleportEffect();
    // Teleport
    Teleport(ep, teleportPosition);
    // show teleport effect
    PlayTeleportEffect();
}

rule: "Bot/Teleport/teleportToPlayerFrontBySpawn"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    portalEnable &&
    IsInSpawnRoom()
){
    // Teleport Bot to player front
    // set teleport position
    SetTeleportPositionToPlayerFront();
    // Teleport
    Teleport(ep, teleportPosition);
    // show teleport effect
    PlayTeleportEffect();
}

rule: "Bot/Teleport/teleportToPlayerFrontByPlayerNotFound"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    portalEnable &&
    IsAlive() &&
    !IsInLineOfSight(ep,
        closestPlayerMe,
        BarrierLOS.NoBarriersBlock)
){
    // Teleport bot to player front
    Wait(6, WaitBehavior.AbortWhenFalse);

    if(portalState != PortalState.Suspended)
        // set teleport position player front
        SetTeleportPositionToPlayerFront();   
    else
        // set teleport position to camper around
        SetTeleportPositionToCamper();
    // show pre teleport effect
    PlayTeleportEffect();
    // Teleport
    Teleport(ep, teleportPosition);
    // show pre teleport effect
    PlayTeleportEffect();
    
    LoopIfConditionIsTrue();
}

rule: "Bot/Teleport/teleportToPlayerFrontByPlayerEntered"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    portalEnable &&
    IsAlive() &&
    portalState == PortalState.Suspended
){
    // Teleport bot to player front
    WaitConditionConfirmed();
    // set teleport position to player front
    SetTeleportPositionToPlayerFront();
    // show pre teleport effect
    PlayTeleportEffect();
    // Teleport
    Teleport(ep, teleportPosition);
    // show teleport effect
    PlayTeleportEffect();
}

// TAG Bot/Ultimate ----------
rule: "Bot/Ultimate/chargeUlt"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    HasSpawned() &&
    enemyType != EnemyType.None &&
    !IsUsingUltimate()
){
    SetUltimateCharge(ep, UltimateChargePercent() + (100 / eachChargeUltInterval));
    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}

// TAG Bot/SpawnInterval ----------
define deadEffectTime: 1.5;
playervar define confirmSpawnInterval;

void UpdateEachSpawnInterval()"UpdateEachSpawnInterval"{
    confirmSpawnInterval = eachMaxSpawnInterval;
    confirmSpawnInterval *= (1 - (portalSize / maxPortalSize));
    confirmSpawnInterval -= (roundNo / 5);
    confirmSpawnInterval = Max(confirmSpawnInterval, 0);
    SetRespawnMaxTime(ep, confirmSpawnInterval + deadEffectTime); 
}

rule: "Bot/SpawnInterval/update"
Event.OngoingPlayer
Team.Team2
if(
    portalState == PortalState.Growing
){
    UpdateEachSpawnInterval();
    Wait(3, WaitBehavior.AbortWhenFalse);
    LoopIf(portalSize < maxPortalSize);
}

// TAG Bot/ReceivedDamage ----------
globalvar define confirmReceiveDamage;

void UpdateEachReceivedDamage()"UpdateEachReceivedDamage"{
    // If don't enough players, adjust Bot received damage rate to make the game fair
    // Multiply damage rate
    confirmReceiveDamage = 100;
    // Apply balance multiplier
    confirmReceiveDamage *= ConvertToBalancedValue(0.7, Team.Team1);
    SetDamageReceived(AllPlayers(Team.Team2), confirmReceiveDamage);
}

rule: "Bot/ReceivedDamage/updateByBalance //for game balance, increase by missing players count"
Event.OngoingGlobal
if(
    initCompleted
){
    UpdateEachReceivedDamage();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

// TAG Bot/DealtDamage ----------
playervar define confirmDealDamage;

void UpdateEachDealtDamage()"UpdateEachDealtDamage"{
    // If don't enough players, adjust Bot dealt damage rate to make the game fair
    // And the round progresses, the Bot deal damage increases and becomes more difficult
    // Add damage rate according to the round progress
    confirmDealDamage = WorkshopSettingReal("Bot Settings", "Initial Deal Damage", 30, 0, 1000, 1);
    confirmDealDamage += roundNo * WorkshopSettingReal("Bot Settings", "Increase Deal Damage Per Round Progress", 2.0, 0, 1000, 2);
    confirmDealDamage *= eachDealtDamageScale;
    // Apply balance multiplier
    confirmDealDamage /= ConvertToBalancedValue(0.7, Team.Team1);
    SetDamageDealt(ep, confirmDealDamage);
}

rule: "Bot/DealtDamage/update"
Event.OngoingPlayer
Team.Team2
Player.All
if(
    HasSpawned() &&
    enemyType != EnemyType.None
){
    UpdateEachDealtDamage();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

rule: "Bot/SpawnInterval/respawnBySucide"
Event.OnDeath
Team.Team2
Player.All
if(
    Attacker() == ep
){
    Wait(1, WaitBehavior.AbortWhenFalse);
    Respawn();
}

// TAG Debug ----------
globalvar define debugMode;

enum DebugMode{
    Non,
    OverloadOnly,
    ShowParam,
    WithRecord
}

rule: "Debug/changeDebugMode"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Jump) 
){
    // change debug mode
    WaitLongPressConfirm();
    if(debugMode == DebugMode.Non){
        debugMode = DebugMode.OverloadOnly;
    }
    else if(debugMode == DebugMode.OverloadOnly){
        debugMode = DebugMode.ShowParam;
    }
    else if(debugMode == DebugMode.ShowParam){
        debugMode = DebugMode.WithRecord;
    }
    else if(debugMode == DebugMode.WithRecord){
        debugMode = DebugMode.Non;
    }

    if(debugMode == DebugMode.Non){
        DisableInspectorRecording();
        HideDebugHud();
    }
    else if(debugMode == DebugMode.OverloadOnly){
        DisableInspectorRecording();
        HideDebugHud();
        ShowDebugHud();
    }
    else if(debugMode == DebugMode.ShowParam){
        DisableInspectorRecording();
        HideDebugHud();
        ShowDebugHud();
    }
    else if(debugMode == DebugMode.WithRecord){
        EnableInspectorRecording();
        HideDebugHud();
        ShowDebugHud();
    }
}

define End(): CountOf(debugHudEntitys);
define botOfEnemyType(define enemyType): FirstOf(FilteredArray(AllPlayers(Team.Team2), ae.enemyType == enemyType));
globalvar define debugHudEntitys;

// show debug icon and hud
void ShowDebugHud()"ShowDebugHud"{

    if(
        debugMode == DebugMode.ShowParam ||
        debugMode == DebugMode.WithRecord
    ){
        if(
            debugMode == DebugMode.WithRecord
        ){
            CreateHudText(HostPlayer(),
                null,
                null,
                "● is Recording",
                Location.Left, -1,
                Color.White, Color.White, Color.Red,
                HudTextRev.VisibleToAndString, Spectators.VisibleNever);
            debugHudEntitys[End()] = LastTextID();
        }

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "revive Timeout Count", reviveTimeoutCount>,
            null,
            Location.Left, -1,
            Color.White, Color.Blue, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "Regeneration Rate", playerRegenerationRateTeam1>,
            null,
            Location.Left, -1,
            Color.White, Color.Blue, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "portal State", portalState>,
            null,
            Location.Left, -1,
            Color.White, enemyColor, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "portal Size", portalSize>,
            null,
            Location.Left, -1,
            Color.White, enemyColor, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "portal Position", portalPosition>,
            null,
            Location.Left, -1,
            Color.White, enemyColor, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "distance to protal", DistanceBetween(ep, portalPosition)>,
            null,
            Location.Left, -1,
            Color.White, enemyColor, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> DelDmg=<1> RcvDmg=<2> SpwInt=<3> ChgUlt=<4>", "Boss Status",
                botOfEnemyType(EnemyType.Boss).confirmDealDamage,
                confirmReceiveDamage,
                botOfEnemyType(EnemyType.Boss).confirmSpawnInterval,
                botOfEnemyType(EnemyType.Boss).eachChargeUltInterval
            >,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> DelDmg=<1> RcvDmg=<2> SpwInt=<3> ChgUlt=<4>", "Elite Status",
                botOfEnemyType(EnemyType.Elite).confirmDealDamage,
                confirmReceiveDamage,
                botOfEnemyType(EnemyType.Elite).confirmSpawnInterval,
                botOfEnemyType(EnemyType.Elite).eachChargeUltInterval
            >,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> DelDmg=<1> RcvDmg=<2> SpwInt=<3> ChgUlt=<4>", "Minion Status",
                botOfEnemyType(EnemyType.Minion).confirmDealDamage,
                confirmReceiveDamage,
                botOfEnemyType(EnemyType.Minion).confirmSpawnInterval,
                botOfEnemyType(EnemyType.Minion).eachChargeUltInterval
            >,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "invalid Area Score", invalidAreaScore>,
            null,
            Location.Left, -1,
            Color.White, Color.White, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "no Contact", noContact>,
            null,
            Location.Left, -1,
            Color.White, Color.White, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "Server Load", ServerLoad()>,
            null,
            Location.Left, -1,
            Color.White, Color.Orange, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "Server Load Average", ServerLoadAverage()>,
            null,
            Location.Left, -1,
            Color.White, Color.Orange, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "Server Load Peak", ServerLoadPeak()>,
            null,
            Location.Left, -1,
            Color.White, Color.Orange, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();
    }

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "over load during", overloadDuring>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);
    debugHudEntitys[End()] = LastTextID();
}

// Hide debug icon and hud
void HideDebugHud()"HideDebugHud"{
    for(gLoopIndex = 0; gLoopIndex < CountOf(debugHudEntitys); gLoopIndex ++){
        DestroyHudText(debugHudEntitys[gLoopIndex]);
    }
}

rule: "Debug/increaseTeamLifes"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Ability2)
){
    // Increase TeamLifes
    WaitLongPressConfirm();
    teamLifes += 1;
    LoopIfConditionIsTrue();
}

rule: "Debug/increaseRoundNo"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Ability1)
){
    // Increase RoundNo
    WaitLongPressConfirm();
    roundNo += 1;
    LoopIfConditionIsTrue();
}

rule: "Debug/resetPortal // reset portal position by random"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    !IsButtonHeld(ep, Button.Reload) &&
    IsButtonHeld(ep, Button.Crouch)
){
    // Recalculate portal
    WaitLongPressConfirm();
    portalState = PortalState.Idle;
    WaitChangeState();  // Wait for the changed status to be processed first
    portalState = PortalState.Calculating;
}

globalvar define debugAimingPosition;

rule: "Debug/setPortalPositionOnAimCenter // reset portal position by aim center"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Reload) &&
    !IsButtonHeld(ep, Button.Crouch)
){
    // Set portal position to aim center
    WaitLongPressConfirm();
    portalState = PortalState.Idle;
    debugAimingPosition = AimingPosition();
    WaitChangeState();  // Wait for the changed status to be processed first
    portalState = PortalState.Calculating;
    WaitUntil(portalState != PortalState.Calculating, 5);
    portalPosition = debugAimingPosition;
}

rule: "Debug/setPortalMaxSize // reset portal position by aim center"
Event.OngoingPlayer
Team.All
Player.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Reload) &&
    IsButtonHeld(ep, Button.Crouch)
){
    // Set portal position to aim center
    WaitLongPressConfirm();
    portalSize = maxPortalSize;
}