// [Detail]
// [Portal Hunt -HORDE PVE] The hell portal has been opened… Defeat enemie horde that spawn from portal and close portal!  When enter portal, start sequence of close. survive to complete.  Over time, portal grow. Grown portal spawn more enemie and get harder.  Survive using PERK dropped by enemy.  PERK has uniqe buffs, new weapon, powerful custom heroes, others.  ex) GrapplingBeam, CruisingMissile, LegendaryNinja and more than 25 types!  Unlimited rounds. How many rounds can you survive?
// [Share Code]
// YY1N2
// [ToDo]
// add Perk Disarmament
// add Perk Drone Friend Dog
// add Perk Assassination

import "Lib/Debug.del";
import "Lib/Utility.del";
import "Lib/ElapsedTimer.del";
import "Lib/DamageText.del";
import "Lib/Regeneration.del";
import "Lib/Revive.del";
import "Lib/PerkMain.del";
import "Lib/Bot.del";

// TAG duumy define ----------
// globalvar define Revive_enableTeam;
// globalvar define Revive_timeLimit;
// globalvar define reviveTimeoutCount;
// globalvar define Regeneration_enableTeam;
// globalvar define Regeneration_needBalanceTeam1;
// globalvar define Regeneration_waitRegenTimeTeam1;
// globalvar define Regeneration_regenerationRateTeam1;
// globalvar define playerRegenerationRateTeam1;
// globalvar define DamageText_enableTeam;
// void DestroyBots(){}
// void CreateEnemyBotsByAssetList(){}

// TAG Signature and infomation ----------
disabled rule: "PORTAL HUNT -HORDE PVE [ver 4.0] Share code [YY1N2]"-1{}
disabled rule: "You allowed copy or modify code."-1{}
disabled rule: "This script was generated from source code by [Overwatch-Script-To-Workshop]"-1{}
disabled rule: "Check detail with https://github.com/ItsDeltin/Overwatch-Script-To-Workshop"-1{}
disabled rule: "Original source code was created by [sarami77#1868]"-1{}
disabled rule: "Check detail with https://github.com/sarami77/OverwatchWorkShopScripts"-1{}

// TAG System ----------
define WaitUntilServerFree(): WaitUntil(!isServerOverLoading, 5);

define slowLevel: [100, 90, 80, 70, 50];    // 0～4
globalvar define targetSlowLevel!;
globalvar define currentSlowLevel!;
globalvar define watchingOverLoad!;

rule: "System/ServerOverLoadMeasures/increaseSlowLevel"
Event.OngoingGlobal
if(
    initCompleted &&    
    portalState != PortalState.End &&
    watchingOverLoad &&
    isServerOverLoading &&
    targetSlowLevel < (CountOf(slowLevel) - 1)
){
    // If the server is overloaded,
    //  apply slow motion every second
    //  to reduce the load to avoid shutting down due to server overload.
    Wait(1, WaitBehavior.AbortWhenFalse);
    // can increase slow level
    if(targetSlowLevel < (CountOf(slowLevel) - 1)){
        // increase slow level
        targetSlowLevel ++;
        // apply slow level
        ApplySlowLevel(targetSlowLevel);
    }
    LoopIfConditionIsTrue();
}

rule: "System/ServerOverLoadMeasures/decreaseSlowLevel"
Event.OngoingGlobal
if(
    initCompleted &&    
    portalState != PortalState.End &&
    watchingOverLoad &&
    !isServerOverLoading &&
    targetSlowLevel > 0
){
    // If the server is not overloaded,
    //  reset slow motion every second
    // can decrease slow level
    Wait(0.5, WaitBehavior.AbortWhenFalse);
    if(targetSlowLevel > 0){
        // decrease slow level
        targetSlowLevel --;
        // apply slow level
        ApplySlowLevel(targetSlowLevel);
    }
    LoopIfConditionIsTrue();
}

rule: "System/ServerOverLoadMeasures/reduceOverLoadOnPlayerJoin"
Event.OnPlayerJoin
Team.Team1
if(
    initCompleted &&
    portalState != PortalState.End
){
    // apply slow level
    ApplySlowLevel(3);
    watchingOverLoad = false;
}

rule: "System/ServerOverLoadMeasures/restartOverLoadWatching"
Event.OngoingGlobal
if(
    !watchingOverLoad
){
    Wait(2.5, WaitBehavior.IgnoreCondition);
    // reset slow level
    ApplySlowLevel(0);
    watchingOverLoad = true;
}

void ApplySlowLevel(define setSlowLevel!)"ApplySlowLevel"{
    // if slow level changed
    if(currentSlowLevel != setSlowLevel){
        // apply slow motion
        currentSlowLevel = setSlowLevel;
        SetSlowMotion(slowLevel[setSlowLevel]);
    }
}

// TAG Game ----------
define enemyColor: Color.Purple;
globalvar define initCompleted!;
globalvar define roundNo!;

rule: "Game/initSetting"
Event.OngoingGlobal
{
    // Stop records to reduce server load
    DisableInspectorRecording();

    // for perfomance debug
    // CreateHudText(HostPlayer(),
    //     null,
    //     <"<0> <1>", "current Slow Level", currentSlowLevel>,
    //     null,
    //     Location.Left, -1,
    //     Color.White, Color.Orange, Color.White,
    //     HudTextRev.VisibleToAndString, Spectators.VisibleNever);

    // Set imported function property
    Regeneration_enableTeam = Team.Team1;
    Regeneration_needBalanceTeam1 = true;
    Regeneration_waitRegenTimeTeam1 = WorkshopSettingReal("Player Settings", "Wait Second Until Start Regeneration", 3, 0, 100, 1);
    Regeneration_regenerationRateTeam1 = WorkshopSettingReal("Player Settings", "Regeneration Rate In Per Seconds", 25, 0, 1000, 2);

    Revive_enableTeam = Team.Team1;
    Revive_timeLimit = WorkshopSettingReal("Player Settings", "Revive Time Limit", 10, 0, 100, 3);
    
    DamageText_enableTeam = Team.Team2;

    // If run it right after loading the server, some scripts fail, so wait 3 seconds
    Wait(3, WaitBehavior.AbortWhenFalse);

    // Cancel unnecessary default settings
    PauseMatchTime();
    DisableScoring();
    DisableCompletion();

    // set objective message
    SetObjectiveDescription(AllPlayers(Team.Team1), "Find portal and attack it!", HudTextRev.None);

    // Set initial team lifes
    initialTeamLifes = WorkshopSettingInteger("Player Settings", "Initial Team Lifes", 6, 0, 1000, 0);

    // show version and share code
    CreateHudText(AllPlayers(Team.Team1),
        null, "PORTAL HUNT -HORDE PVE [ver 4.0] Share code [YY1N2]", null,
        Location.Left, -3,
        Color.White, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);

    // show hero change operation
    CreateHudText(AllPlayers(Team.Team1),
        null, <"Long hold reload button <0> to change hero", ButtonGuide(Button.Reload)>, null,
        Location.Left, -2,
        Color.Yellow, Color.Yellow, Color.Yellow,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);

    // show round number
    CreateHudText(AllPlayers(),
        <"<0> <1>", "Round", roundNo>, null, null,
        Location.Top, 2,
        enemyColor, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleAlways);

    // show objective message and elapsed time
    enableElapsedTimer = true;
    elapsedTime = 0;

    // Start watch over load
    watchingOverLoad = true;

    // Notify completion of init game setting and start game main logic
    initCompleted = true;

    // failsade action
    while(true){
        // repeat action for joined player
        // set objective message
        SetObjectiveDescription(AllPlayers(Team.Team1), "find portal and attack!", HudTextRev.None);
        Wait(10, WaitBehavior.AbortWhenFalse);
    } 
}

rule: "Game/initGame"
Event.OngoingGlobal
if(
    initCompleted
){
    // reset team lifes
    teamLifes = initialTeamLifes;
    // reset round no
    roundNo = 0;
    // reset elapsed time
    elapsedTime = 0;
}

rule: "Game/startGame"
Event.OngoingGlobal
if(
    initCompleted &&
    portalState == PortalState.Init &&
    NumberOfPlayers(Team.Team1) > 0 &&
    IsTrueForAny(
        AllPlayers(Team.Team1),
        (
            !IsInSpawnRoom(ae) &&
            IsMoving(ae)
        )
    )
){
    // reset prevPortalPosition
    prevPortalPosition = PositionOf(FirstOf(AllPlayers(Team.Team1)));
    // start portal creation
    portalState = PortalState.Calculating;
}

rule: "Game/stopGame"
Event.OngoingGlobal
if(
    initCompleted &&
    portalState != PortalState.Init &&
    NumberOfPlayers(Team.Team1) <= 0
){
    // reset team lifes
    teamLifes = initialTeamLifes;
    // reset round no
    roundNo = 0;
    // reset elapsed time
    elapsedTime = 0;
    // reset portal
    portalState = PortalState.Init;
}

rule: "Game/SpawnRoom/changeByTimer //to make the game fluid"
Event.OngoingGlobal
if(
    initCompleted
){
    // Change the spawn room regularly to keep the game fluid
    Wait(300, WaitBehavior.AbortWhenFalse); // change spawn room
    ForceSpawnRoom(Team.Team2, RandomInteger(0, 2));
    ForceSpawnRoom(Team.Team1, RandomInteger(0, 2));
    LoopIfConditionIsTrue();
}

// TAG Player ----------
playervar define isInsidePortal!;

rule: "Player/InsidePortal/update"
Event.OngoingGlobal
if(
    portalEnable
){
    define players = AllPlayers(Team.Team1);
    // Set flag when player entered to portal
    // This flag is used for functions related to portal
    for(gLoopIndex = 0; gLoopIndex < CountOf(players); gLoopIndex++){
        if(
            HasSpawned(players[gLoopIndex]) &&
            IsAlive(players[gLoopIndex]) &&
            !IsInSpawnRoom(players[gLoopIndex]) &&
            DistanceBetween(players[gLoopIndex], portalPosition) <= portalSize
        ){
            players[gLoopIndex].isInsidePortal = true;
        }
        else{
            players[gLoopIndex].isInsidePortal = false;
        }
    }
    WaitUntilServerFree();
    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}

rule: "Player/ReturnSpawn/returnSpawn"
Event.OngoingPlayer
Team.Team1
if(
    IsAlive() &&
    !IsInSpawnRoom() &&
    IsButtonHeld(ep, Button.Reload)
){
    // Return to spawn room with long hold on reload button
    WaitCancelPressConfirm();
    Respawn();
}

globalvar define initialTeamLifes!;
globalvar define teamLifes!;

rule: "Player/TeamLifes/showTeamLifesHUD"
Event.OngoingGlobal
if(
    initCompleted
){
    // show HUD of team lifes
    CreateHudText(AllPlayers(),
        <"<0> <1>", "Team lifes", teamLifes>, null, null,
        Location.Top, 3,
        Color.Team1, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleAlways);
}

rule: "Player/TeamLifes/consumeTeamLifes"
Event.OngoingGlobal
if(
    0 < reviveTimeoutCount
){
    WaitConditionConfirmed();
    teamLifes -= reviveTimeoutCount;
    WaitChangeState();  // wait for show big message by newest value
    if(teamLifes > 0){
        if(teamLifes > 0){
            BigMessage(AllPlayers(),
                <"<0> <1> <2>", "Our remaining team lifes is", teamLifes, "...">);
        }
        PlayEffect(
            AllPlayers(), PlayEffect.DebuffImpactSound,
            Color.White, portalPosition, MaxLength());
    }
    reviveTimeoutCount = 0;
}

rule: "Player/TeamLifes/finishGame //by team lifes out"
Event.OngoingGlobal
if(
    initCompleted &&
    teamLifes <= 0
){
    WaitConditionConfirmed();
    // When the team lifes out, the game ends
    portalState = PortalState.End;
    BigMessage(AllPlayers(), "Our team lifes is out...");
    SetSlowMotion(10);
    Wait(1, WaitBehavior.AbortWhenFalse);   // show slow
    SetSlowMotion(100);
    WaitNextPhase();

    BigMessage(AllPlayers(),
        <"We have reached <0> round... good game!", roundNo>);
    PlayRandomEmote(AllPlayers(Team.Team1));
    WaitNextPhase();

    DeclareTeamVictory(Team.Team1);
}

rule: "Player/TeamLifes/protectTeamLifesFromSucide"
Event.OnDeath
Team.Team1
if(
    Attacker() == ep &&
    DistanceBetween(ep,
        ClosestPlayerTo(ep, Team.Team2)) > 15
){
    Wait(1, WaitBehavior.AbortWhenFalse);
    Respawn();
}

globalvar define closingCount!;
globalvar define closingProgress;
globalvar define closingProgressHudEntity!;
globalvar define playerNumInsidePortal!;

define enableClosingProgress:
    portalState == PortalState.Suspended &&
    teamLifes > 0;

rule: "Player/ClosePortal/startClosing //on enter any player"
Event.OngoingGlobal
if(
    enableClosingProgress
){
    // When a player enters a portal, set progress hud and show message
    WaitConditionConfirmed();
    // kick progress
    closingCount = 5;
    closingCount += RoundToInteger(portalSize, Rounding.Nearest);
    closingCount += roundNo * 2;
    closingProgress = 0;
    ChaseVariableOverTime(closingProgress, DefaultPercentage(), closingCount, TimeChaseReevaluation.DestinationAndDuration);
    // show progress hud
    if(closingProgressHudEntity == null){
        CreateProgressBarHudText(
            AllPlayers(),
            closingProgress,
            <"<0> player has surviving in portal. Until portal closes...", playerNumInsidePortal >,
            Location.Top, 4,
            Color.White,
            Color.White,
            ProgressBarEvaluation.VisibleToValuesAndColor,
            Spectators.DefaultVisibility );
        closingProgressHudEntity = LastTextID();
    }
    // get closest surviver to portal center
    define portalClosingPlayer! = 
        FirstOf(
            SortedArray(
                FilteredArray(
                    AllPlayers(Team.Team1),
                    (
                        IsAlive(ae) &&
                        !IsInSpawnRoom(ae)
                    )
                ),
                DistanceBetween(portalPosition, ae)
            )
        );
    // show big message
    BigMessage(
        portalClosingPlayer,
        <"You are closing portal... Stay inside and Survive!">);
    BigMessage(
        FilteredArray(AllPlayers(Team.Team1), (portalClosingPlayer != ae)),
        <"<0> <1> <2>",
            portalClosingPlayer,
            HeroIconString(HeroOf(portalClosingPlayer)),
            "closing portal... Cover one!">);
    // Wait closingCount
    Wait(closingCount, WaitBehavior.AbortWhenFalse);
    portalState = PortalState.Closing;
}

rule: "Player/ClosePortal/updatePlayerNumInsidePortal"
Event.OngoingGlobal
if(
    enableClosingProgress
){
    playerNumInsidePortal = CountOf(
        FilteredArray(
            AllPlayers(Team.Team1),
            ae.isInsidePortal
        )
    );
    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}

rule: "Player/ClosePortal/cancelClosing //on exit every player"
Event.OngoingGlobal
if(
    !enableClosingProgress
){
    StopChasingVariable(closingProgress);
    // wait hide hud when progress completed
    if(closingProgress == 100){
        Wait(1.5, WaitBehavior.AbortWhenFalse);
    }
    DestroyProgressBarHudText(closingProgressHudEntity);
    closingProgressHudEntity = null;
}

rule: "Player/ClosePortal/finishClose //on count down finished"
Event.OngoingGlobal
if(
    (
        portalState == PortalState.Closing ||
        portalState == PortalState.Closed
    ) &&
    teamLifes > 0
){
    WaitConditionConfirmed();
    // When the countdown is complete, clear the portal and give team lifes.
    // Later, we will generate a new portal and start the next round.
    WaitPlayEffect();   //wait portal closing effect
    portalState = PortalState.Closed;
    WaitNextPhase();

    // show got life sound message
    BigMessage(AllPlayers(), "We got new team lifes!");
    // play got life sound
    PlayEffect(
        AllPlayers(), PlayEffect.BuffImpactSound,
        Color.White, portalPosition, MaxLength()
    );
    // got life sound
    teamLifes += 1;
    WaitNextPhase();

    PlayRandomVoiceLine(AllPlayers(Team.Team1));
    roundNo += 1;
    portalState = PortalState.Calculating;  // start next portal create
}

playervar define inPortalEffectEntitys!;

rule: "Player/FairPlay/disableStealthWhenInside //sombra's stealth for fair play"
Event.OngoingPlayer
Team.Team1
if(
    isInsidePortal &&
    HeroOf() == Hero.Sombra &&
    IsUsingAbility1()
){
    // Some abilities are disabled inside the portal to make the game fair
    // Sombra stealth is exactly that
    Wait(5.0, WaitBehavior.AbortWhenFalse); // disable ability check cycle
    SetStatus(ep, null, Status.Stunned, 0.1);
    SmallMessage(ep, "Stealth disabled by magnetic storm of portal.");
    LoopIfConditionIsTrue();
}

rule: "Player/FairPlay/disableGrappleClawWhenInside // wreckingBball's grapple claw for fair play"
Event.OngoingPlayer
Team.Team1
if(
    isInsidePortal &&
    HeroOf() == Hero.WreckingBall &&
    IsFiringSecondary()
){
    // Some abilities are disabled inside the portal to make the game fair
    // WreckingBall Grapple is exactly that
    Wait(5.0, WaitBehavior.AbortWhenFalse); // disable ability check cycle
    SetStatus(ep, null, Status.Stunned, 0.1);
    SmallMessage(ep, "Grapple claw disabled by magnetic storm of portal.");
    LoopIfConditionIsTrue();
}

// TAG Portal Function ----------
globalvar define portalState!;
enum PortalState{
    Init,
    Idle,
    Calculating,
    Checking,
    Set,
    Growing,
    Suspended,
    Closing,
    Closed,
    End
}

globalvar define portalPosition!;
globalvar define portalSize;
globalvar define portalEntitys!;
globalvar define isFirstGrowing!;

define portalEnable:
    portalState == PortalState.Checking ||
    portalState == PortalState.Set ||
    portalState == PortalState.Growing ||
    portalState == PortalState.Suspended;

rule: "Portal/State/Calculating //invisible, init param"
Event.OngoingGlobal
if(
    portalState == PortalState.Calculating
){
    // Hide Portal Entity until portal state changed to Show
    // Init param
    StopChasingVariable(portalSize);
    portalPosition = 0;
    portalSize = 0;
    isFirstGrowing = true;
    // Hide portal icon and effect
    DestroyIcon(portalEntitys[0]);
    DestroyEffect(portalEntitys[1]);
    DestroyEffect(portalEntitys[2]);
    DestroyEffect(portalEntitys[3]);
    DestroyEffect(portalEntitys[4]);
}

rule: "Portal/State/Set  // waiting for found by players"
Event.OngoingGlobal
if(
    portalState == PortalState.Set
){
    DestroyIcon(portalEntitys[0]);
    // show Portal Entity by portal state changed to Show
    // Init param
    closingCount = 0;
    // show icon
    portalEntitys = [];
    CreateIcon(AllPlayers(), portalPosition, Icon.Spiral,
        IconRev.VisibleToAndPosition, enemyColor, true);
    portalEntitys[0] = LastCreatedEntity();
    // set effect
    // sphere
    CreateEffect(AllPlayers(), Effect.Sphere, enemyColor,
        portalPosition, portalSize, EffectRev.VisibleToPositionAndRadius);
    portalEntitys[1] = LastCreatedEntity();
    // cloud
    CreateEffect(AllPlayers(), Effect.Cloud, enemyColor,
        portalPosition, portalSize * 1.5, EffectRev.VisibleToPositionAndRadius);
    portalEntitys[2] = LastCreatedEntity();
    // aura
    // Since visibility will be poor, display only in the center of the field of view
    CreateEffect(
        FilteredArray(
            AllPlayers(),
            DistanceBetween(ae, portalPosition) > portalSize / 2), Effect.BadAura, enemyColor,
        portalPosition, portalSize * 1.25, EffectRev.VisibleToPositionAndRadius);
    portalEntitys[3] = LastCreatedEntity();
    // sound
    CreateEffect(AllPlayers(), Effect.EnergySound, enemyColor,
        portalPosition, portalSize / 2, EffectRev.VisibleToPositionAndRadius);
    portalEntitys[4] = LastCreatedEntity();
    // show message
    BigMessage(AllPlayers(), "Detected more portal... find and attack!");
    // Hide icon to let the player search the portal
    Wait(6, WaitBehavior.AbortWhenFalse);
    DestroyIcon(portalEntitys[0]);
}

rule: "Portal/State/Growing"
Event.OngoingGlobal
if(
    portalState == PortalState.Growing
){
    // Start growing portal with warning message
    ChaseVariableAtRate(
        portalSize, maxPortalSize, 1 + (roundNo / 8),
        RateChaseReevaluation.DestinationAndRate);
    // If first growing, show message
    if(isFirstGrowing == true){
        isFirstGrowing = false;
        BigMessage(AllPlayers(), "Portal is growing... hurry up!");
        WaitBigMessageHide();
        BigMessage(AllPlayers(), "Growed portals spawn more enemys and get tough...");
    }
    // Hide icon to let the player search the portal
    Wait(1, WaitBehavior.AbortWhenFalse);
    DestroyIcon(portalEntitys[0]);
}

rule: "Portal/State/Suspended"
Event.OngoingGlobal
if(
    portalState == PortalState.Suspended
){
    // Hide icon to let the player search the portal
    DestroyIcon(portalEntitys[0]);
    // Stop growing portal
    Wait(2, WaitBehavior.AbortWhenFalse);
    StopChasingVariable(portalSize);
}

rule: "Portal/State/Closing"
Event.OngoingGlobal
if(
    portalState == PortalState.Closing
){
    // apply blast impulse
    ApplyBlastImpulse(AllPlayers(Team.Team2), portalPosition, portalSize);
    // play portal closing effect and kill enemrys
    Kill(AllPlayers(Team.Team2), null);
    // play blast sound
    PlayEffect(
        AllPlayers(), PlayEffect.RingExplosionSound,
        Color.White, portalPosition, MaxLength());
    // play blast effect
    PlayContinuousBlast(
        Color.Yellow,
        portalPosition,
        portalSize * 1.5,
        10);
}

rule: "Portal/State/Closed"
Event.OngoingGlobal
if(
    portalState == PortalState.Closed
){
    // show message
    BigMessage(AllPlayers(), "Portal closed... good job!");
    // init param
    portalPosition = 0;
    portalSize = 0;
    StopChasingVariable(portalSize);
    // Hide portal icon and effect
    DestroyIcon(portalEntitys[0]);
    DestroyEffect(portalEntitys[1]);
    DestroyEffect(portalEntitys[2]);
    DestroyEffect(portalEntitys[3]);
    DestroyEffect(portalEntitys[4]);
}

rule: "Portal/State/End"
Event.OngoingGlobal
if(
    portalState == PortalState.End
){
    // apply blast impulse
    ApplyBlastImpulse(AllPlayers(Team.Team2), portalPosition, portalSize);
    // play portal closing effect and kill enemrys
    Kill(AllPlayers(Team.Team2), null);
    // play blast sound
    PlayEffect(
        AllPlayers(), PlayEffect.RingExplosionSound,
        Color.White, portalPosition, MaxLength());
    // play blast effect
    PlayContinuousBlast(
        Color.Yellow,
        portalPosition,
        portalSize * 1.5,
        10);

    // init param
    portalPosition = 0;
    portalSize = 0;
    StopChasingVariable(portalSize);
    // Hide portal icon and effect
    DestroyIcon(portalEntitys[0]);
    DestroyEffect(portalEntitys[1]);
    DestroyEffect(portalEntitys[2]);
    DestroyEffect(portalEntitys[3]);
    DestroyEffect(portalEntitys[4]);
}

rule: "Portal/Positioner/createPortal"
Event.OngoingGlobal
if(
    teamLifes > 0 &&
    portalState == PortalState.Calculating
){
    WaitConditionConfirmed();
    define candidatePosition;
    for(define retryCount = 0; retryCount < 10; retryCount++){
        // select random player as base positoon
        define basePlayer =
            RandomValueInArray(
                FilteredArray(
                    AllLivingPlayers(Team.Team1),
                    HasSpawned(ae)
                )
            );
        // select random positon from player around
        define randomPositon = 
            basePlayer +
            // add random direction
            DirectionFromAngles(
                RandomReal(0, 360), RandomReal(30, -30),
            ) * 
            // add random distance
            RandomReal(40, 160);

        // convert to walkble position
        candidatePosition = NearestWalkablePosition(randomPositon);
        // move candidate postion in the direction of player for avoiding map edge
        candidatePosition += DirectionTowards(candidatePosition, basePlayer) * RandomReal(1, 5);
        // convert to walkble position
        candidatePosition = NearestWalkablePosition(candidatePosition);

        if(
            // close candidate postion than random positon
            (
                DistanceBetween(basePlayer, randomPositon) >= 
                DistanceBetween(basePlayer, candidatePosition) + 10
            )
                &&
            // far postion from previous position
            (
                DistanceBetween(prevPortalPosition, candidatePosition) >= 50
            )
                &&
            // far postion from player
            (
                DistanceBetween(
                    ClosestPlayerTo(candidatePosition, Team.Team1),
                    candidatePosition
                ) >= 50
            )
        ){
            break;
        }
        Wait(0.1, WaitBehavior.AbortWhenFalse);
        WaitUntilServerFree();
    }
    // confirm as portal position
    portalPosition = candidatePosition;
    // create portal, next check position
    portalState = PortalState.Checking;
    // fail safe
    Wait(6, WaitBehavior.AbortWhenFalse);
	dbgMsg("failsafe triggered of createPortal");
    LoopIfConditionIsTrue();
}
globalvar define prevPortalPosition!;

rule: "Portal/Positioner/positionChecking"
Event.OngoingGlobal
if(
    teamLifes > 0 &&
    portalState == PortalState.Checking
){
    // wait
    Wait(2, WaitBehavior.AbortWhenFalse);
    // confirm portal position
    prevPortalPosition = portalPosition;
    portalState = PortalState.Set;
    // fail safe
    Wait(6, WaitBehavior.AbortWhenFalse);
    dbgMsg("failsafe triggered of positionChecking");
    LoopIfConditionIsTrue();
}

// TAG Portal/InvalidDetect/EnvironmentDeathCount ----------
define environmentDeathLimit: NumberOfPlayers(Team.Team2) + 1;
globalvar define environmentDeathCount!;

rule: "Portal/InvalidDetect/EnvironmentDeathCount/resetCount"
Event.OngoingGlobal
if(
    !portalEnable &&
    environmentDeathCount > 0
){
    environmentDeathCount = 0;
}

rule: "Portal/InvalidDetect/EnvironmentDeathCount/countup"
Event.OnDeath
Team.Team2
if(
    portalEnable &&
    (
        ep == Attacker() ||         // sucide
        IsInSpawnRoom(Attacker())   // killer in res room
    )
){
    // change room for avoid kill in res room
    ForceSpawnRoom(Team.Team1, RandomInteger(0, 2));
    ForceSpawnRoom(Team.Team2, RandomInteger(0, 2));
    // sucide
    if(ep == Attacker())
        environmentDeathCount += 1;
    // killer in res room
    else if(IsInSpawnRoom(Attacker()))
        environmentDeathCount += 3;
}

rule: "Portal/InvalidDetect/EnvironmentDeathCount/reduceCount"
Event.OngoingGlobal
if(
    portalEnable &&
    0 < environmentDeathCount
){
    Wait(2, WaitBehavior.AbortWhenFalse);
    environmentDeathCount --;
    LoopIfConditionIsTrue();
}

rule: "Portal/InvalidDetect/EnvironmentDeathCount/resetPortal"
Event.OngoingGlobal
if(
    portalEnable &&
    environmentDeathLimit <= environmentDeathCount
){
    dbgMsg("reset Portal By Environment Death Count");
    portalState = PortalState.Calculating;
}

// TAG Portal/InvalidDetect/NoContact ----------
define limitTime: 100;
globalvar define noContactTime!;

rule: "Portal/InvalidDetect/NoContactTime/resetTime"
Event.OngoingGlobal
if(
    !portalEnable
){
    WaitConditionConfirmed();
    noContactTime = 0;
}

rule: "Portal/InvalidDetect/NoContactTime/countup"
Event.OngoingGlobal
if(
    portalEnable &&
    noContactTime != -1  &&
    limitTime > noContactTime
){
    WaitUpdateMediumCycle();
    noContactTime ++;
    LoopIfConditionIsTrue();
}

rule: "Portal/InvalidDetect/NoContactTime/detectContact"
Event.OngoingGlobal
if(
    portalEnable &&
    portalState == PortalState.Suspended
){
    Wait(1, WaitBehavior.AbortWhenFalse);
    noContactTime = -1;
}

rule: "Portal/InvalidDetect/NoContactTime/resetPortal"
Event.OngoingGlobal
if(
    portalEnable &&
    limitTime <= noContactTime
){
    dbgMsg("reset Portal By No Contact");
    portalState = PortalState.Calculating;
}

// TAG Portal/Growing ----------
define maxPortalSize: 70;
define portalStableTime: 40;

rule: "Portal/Growing/startGrowingByPlayerFound"
Event.OngoingGlobal
if(
    portalState == PortalState.Set
){
    if(
        IsInLineOfSight(portalPosition,
            closestPlayerToPortal,
            BarrierLOS.NoBarriersBlock)
    ){
        WaitConditionConfirmed();
        // Strat portal growing by player found
        portalState = PortalState.Growing;
    }
    else{
        WaitUpdateMediumCycle();
        LoopIfConditionIsTrue();
    }
}

rule: "Portal/Growing/startGrowingByTimeout"
Event.OngoingGlobal
if(portalState == PortalState.Set){
    // Start portal growing by search time limit out
    Wait(portalStableTime, WaitBehavior.AbortWhenFalse);  //wait time to start growing
    portalState = PortalState.Growing;
}

rule: "Portal/Growing/suspendGrowingByPlayerEntered"
Event.OngoingGlobal
if(
    portalState == PortalState.Growing &&
    IsTrueForAny(
        AllPlayers(Team.Team1), ae.isInsidePortal
    )
){
    // Suspend portal growing by player enter to portal
    WaitConditionConfirmed();
    portalState = PortalState.Suspended;
}

rule: "Portal/Growing/resumeGrowingByPlayerExited"
Event.OngoingGlobal
if(
    portalState == PortalState.Suspended &&
    !IsTrueForAny(
        AllPlayers(Team.Team1), ae.isInsidePortal
    )
){
    // Resume portal growing by player exit from portal
    WaitConditionConfirmed();
    portalState = PortalState.Growing;
}

// TAG EnemBot/CreateBot ----------
define assetList:
    [
        
        // basic tank boss
        [
            [EnemyType.Boss,        RandomTankHero,     1],
            [EnemyType.Elite,       RandomDamageHero,   1],
            [EnemyType.Elite,       RandomDamageHero,   1],
            [EnemyType.Minion,      RandomSupportHero,  3]
        ],
        // basic damage boss
        [
            [EnemyType.Boss,        RandomDamageHero,   1],
            [EnemyType.Elite,       RandomTankHero,     1],
            [EnemyType.Elite,       RandomTankHero,     1],
            [EnemyType.Minion,      RandomSupportHero,  3]
        ],
        // five minion
        [
            [EnemyType.Boss,        RandomTankHero,     1],
            [EnemyType.Minion,      RandomSupportHero,  5]
        ],
        // four elite
        [
            [EnemyType.Elite,       RandomTankHero,     1],
            [EnemyType.Elite,       RandomTankHero,     1],
            [EnemyType.Elite,       RandomDamageHero,   1],
            [EnemyType.Elite,       RandomDamageHero,   1],
            [EnemyType.Minion,      RandomSupportHero,  1],
            [EnemyType.Minion,      RandomSupportHero,  1]
        ],
        // double boss
        [
            [EnemyType.Boss,        RandomTankHero,     1],
            [EnemyType.Boss,        RandomDamageHero,   1],
            [EnemyType.Elite,       RandomSupportHero, 	2],
            [EnemyType.Minion,      RandomSupportHero, 	2]
        ],
        // giant boss
        [
            [EnemyType.GiantBoss,   RandomHero,         1]
        ],
		
        // melees
        [
            [EnemyType.Boss,        Hero.Reinhardt,     1],
            [EnemyType.Elite,       Hero.Doomfist,      2],
            [EnemyType.Elite,       Hero.Mercy,         1],
            [EnemyType.Minion,      Hero.Brigitte,      2]
        ],
        // flankers
        [
            [EnemyType.Boss,        Hero.Reinhardt,     1],
            [EnemyType.Elite,       Hero.Doomfist,      1],
            [EnemyType.Elite,       Hero.Genji,         1],
            [EnemyType.Minion,      Hero.Tracer,        3]
        ],
        // long range
        [
            [EnemyType.Boss,        Hero.Orisa, 		1],
            [EnemyType.Elite,       Hero.Bastion, 		1],
            [EnemyType.Elite,       Hero.Ana, 	        2],
            [EnemyType.Minion,      Hero.Soldier76, 	2]
        ],
        // airforce
        [
            [EnemyType.Elite,       Hero.Echo, 			2],
            [EnemyType.Elite,       Hero.Pharah, 		2],
            [EnemyType.Minion,      Hero.Mercy, 		2]
        ],
        // snipers
        [
            [EnemyType.Boss,        Hero.Hanzo,			1],
            [EnemyType.Boss,        Hero.Widowmaker,	1],
            [EnemyType.Elite,       Hero.Ashe, 			2],
            [EnemyType.Minion,       Hero.Ana, 			2]
        ],
        // fortress
        [
            [EnemyType.Boss,        Hero.Orisa, 		1],
            [EnemyType.Elite,       Hero.Bastion, 		2],
            [EnemyType.Minion,      Hero.Zenyatta,      3]
        ],
        // turrets
        [
            [EnemyType.Boss,        Hero.Bastion, 		1],
            [EnemyType.Elite,       Hero.Symmetra, 		2],
            [EnemyType.Minion,      Hero.Torbjorn, 		3]
        ]
        /*
        [
            [EnemyType.Boss,        Hero.Mercy, 		1],
            [EnemyType.ZeroGravity, Hero.Bastion, 		2],
            [EnemyType.ZeroGravity, Hero.Soldier76, 	3]
        ]
        */
    ];

rule: "Portal/CreateEnemBot/reloadBotAsset"
Event.OngoingGlobal
if(
    portalEnable
){
    // change bot asset by random
    if(
        0 >= NumberOfPlayers(Team.Team2) ||
        ProbabilityTrue(70)
    ){
        // create all bot
        CreateEnemyBotsByAssetList(assetList);   
    }
}

// TAG EnemBot/EnemyType ----------
playervar define eachDealtDamageScale!;
playervar define eachMaxSpawnInterval!;
playervar define eachChargeUltInterval!;
playervar define eachEffectTextSize!;
playervar define eachNameText!;
playervar define eachNameColor!;

rule: "EnemBot/EnemyType/setEnemyType"
Event.OngoingPlayer
Team.Team2
if(
    enemyType != EnemyType.None
){
    if(enemyType == EnemyType.Minion){ 
        StartScalingPlayer(ep, 0.75, false);
        StartModifyingHeroVoiceLines(ep, 1.25, false);
        SetMaxHealth(ep, 50);
        SetHealingReceived(ep, 50);
        SetHealingDealt(ep, 30);
        eachDealtDamageScale = 0.5;
        eachChargeUltInterval = 80;
        eachMaxSpawnInterval = 3;

        eachNameText = "Minion";
        eachNameColor = Color.White;
        eachEffectTextSize = 1;
    }
    else if(enemyType == EnemyType.Elite){
        StartScalingPlayer(ep, 1.0, false);
        StartModifyingHeroVoiceLines(ep, 1.0, false);
        SetMaxHealth(ep, 300);
        SetHealingReceived(ep, 300);
        SetHealingDealt(ep, 60);
        eachDealtDamageScale = 1.0;
        eachChargeUltInterval = 20;
        eachMaxSpawnInterval = 10;

        eachNameText = "Elite";
        eachNameColor = Color.Yellow;
        eachEffectTextSize = 2;
    }
    else if(enemyType == EnemyType.Boss){
        StartScalingPlayer(ep, 1.5, false);
        StartModifyingHeroVoiceLines(ep, 0.75, false);
        SetMaxHealth(ep, 1000);
        SetHealingReceived(ep, 500);
        SetHealingDealt(ep, 120);
        eachDealtDamageScale = 2.0;
        eachChargeUltInterval = 10;
        eachMaxSpawnInterval = 30;

        eachNameText = "Boss";
        eachNameColor = Color.Red;
        eachEffectTextSize = 3;
    }
    else if(enemyType == EnemyType.GiantBoss){
        StartScalingPlayer(ep, 2.5, false);
        StartModifyingHeroVoiceLines(ep, 0.25, false);
        SetMaxHealth(ep, 1000);
        SetHealingReceived(ep, 500);
        SetHealingDealt(ep, 120);
        eachDealtDamageScale = 4.0;
        eachChargeUltInterval = 10;
        eachMaxSpawnInterval = 15;

        eachNameText = "Giant Boss";
        eachNameColor = Color.Purple;
        eachEffectTextSize = 4;
        // set pool health
        AddHealthPoolToPlayer(ep, HealthType.Armor, 2000, true, false);
    }
    else{
        StartScalingPlayer(ep, 1.0, false);
        StartModifyingHeroVoiceLines(ep, 1.0, false);
        SetMaxHealth(ep, 300);
        SetHealingReceived(ep, 300);
        SetHealingDealt(ep, 60);
        eachDealtDamageScale = 1.0;
        eachChargeUltInterval = 20;
        eachMaxSpawnInterval = 10;

        if(enemyType == EnemyType.ZeroGravity){
            SetGravity(ep, 1);
            eachNameText = "Zero Gravity";
        }
        eachNameColor = Color.Yellow;
        eachEffectTextSize = 2;
    }

    UpdateEachDealtDamage();
    UpdateEachSpawnInterval();

    // heal to max health
    while(Health() < MaxHealth()){
        Heal(ep, null, MaxValue());
        Wait(0.1, WaitBehavior.AbortWhenFalse);
    }
}

// TAG EnemBot/Effect ----------
playervar define botAppearanceEntitys!;

rule: "EnemBot/Effect/showBotAppearance"
Event.OngoingPlayer
Team.Team2
if(
    enemyType != EnemyType.None &&
    IsAlive()
){
    botAppearanceEntitys = [];
    // show evil aura
    botAppearanceEntitys[0] = 
        CreateEffect(AllPlayers(), Effect.Cloud, enemyColor,
            ep, eachEffectTextSize * 1.5, EffectRev.VisibleToPositionAndRadius);
    // show name text
    botAppearanceEntitys[1] = 
        CreateInWorldText(
            AllPlayers(), eachNameText, 
            ep, eachEffectTextSize, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString,
            eachNameColor, Spectators.DefaultVisibility);
}

rule: "EnemBot/Effect/hideBotAppearance"
Event.OngoingPlayer
Team.Team2
if(
    enemyType != EnemyType.None &&
    !IsAlive()
){
    // hide evil aura
    DestroyEffect(botAppearanceEntitys[0]);
    // hide name text
    DestroyInWorldText(botAppearanceEntitys[1]);
    // play dead effect
    PlayContinuousBlast(Color.Red, PositionOf(),
        eachEffectTextSize * 1.5, eachEffectTextSize);
}

// TAG EnemBot/Teleport ----------
define teleportAreaSize: 6;
define minDistanceToPlayerWhenTeleport: 6;
define closestPlayerToTelPos: ClosestPlayerTo(teleportPosition, Team.Team1);
define closestPlayerToComTelPos: ClosestPlayerTo(commonTeleportPosition, Team.Team1);
define closestPlayerToPortal: ClosestPlayerTo(portalPosition, Team.Team1);
define closestPlayerToMe: ClosestPlayerTo(ep, Team.Team1);
playervar define teleportPosition!;
globalvar define commonTeleportPosition!;

void SetTeleportPositionToPlayerFront()"SetTeleportPositionToPlayerFront"{
    // set teleport position by blind spot from player
    // find place that will be a blind spot up to 10 times
    for(pLoopIndex = 0; pLoopIndex < 10; pLoopIndex++){
        teleportPosition =
            NearestWalkablePosition(
                PositionOf(closestPlayerToPortal)
                    + 
                (
                    DirectionTowards(closestPlayerToPortal, portalPosition)
                        *
                    DistanceBetween(closestPlayerToPortal, portalPosition, ) * 0.5
                )
                    +
                RandomPosition(teleportAreaSize, teleportAreaSize, teleportAreaSize)
            );

        if(
            DistanceBetween(    // Not too close to player
                closestPlayerToTelPos, teleportPosition)
            >= minDistanceToPlayerWhenTeleport
                &&
            IsInLineOfSight(    // Has line
                closestPlayerToTelPos, teleportPosition, BarrierLOS.NoBarriersBlock)
        ){
            break;
        }
        Wait(0.1, WaitBehavior.AbortWhenFalse);
        WaitUntilServerFree();
    }
}

void SetTeleportPositionToPlayerAround()"SetTeleportPositionToPlayerAround"{
    // set teleportPosition to player around
    for(pLoopIndex = 0; pLoopIndex < 10; pLoopIndex++){
        teleportPosition =
            // BelowPosition(
                BlockedPositon(
                    closestPlayerToPortal,
                    DirectionFromAngles(
                        RandomReal(0, 360), RandomReal(30, -30),
                    ), RandomReal(5, 50)
                );
            // );
        // move teleportPosition for avoid map surface edge
        teleportPosition += (DirectionTowards(teleportPosition, closestPlayerToPortal) * 1);
        if(
            DistanceBetween(    // Not too close to player
                closestPlayerToTelPos, teleportPosition)
            >= minDistanceToPlayerWhenTeleport
                &&
            IsInLineOfSight(    // Has line
                closestPlayerToTelPos, teleportPosition, BarrierLOS.NoBarriersBlock)
                &&
            IsBlockedBetween(   // Has ground
                teleportPosition, ShiftedPosition(teleportPosition, Down(), 6))

        ){
            break;
        }
        Wait(0.1, WaitBehavior.AbortWhenFalse);
        WaitUntilServerFree();
    }
    teleportPosition -= PositionOffset();
}

void SetTeleportPositionToCommonPosition()"SetTeleportPositionToCommonPosition"{
    if(
        commonTeleportPosition ==  0 ||
        ProbabilityTrue(10) ||
        !IsInLineOfSight(commonTeleportPosition, closestPlayerToComTelPos) ||   
        DistanceBetween(commonTeleportPosition, closestPlayerToComTelPos) < minDistanceToPlayerWhenTeleport
    ){
        // new select common position
        // set teleport position to player around
        SetTeleportPositionToPlayerAround();
        // save teleport position as common position
        commonTeleportPosition = teleportPosition;
    }
    else{
        // set teleport position from common position
        teleportPosition = commonTeleportPosition;
    }
}

void PlayTeleportEffect(define isBefore)"PlayTeleportEffect"{
    // if before teleport
    if(isBefore){
        // play teleport shadow
        PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, enemyColor, ep, 1);
        // play teleport shadow
        PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, enemyColor, teleportPosition, 1);
        // wait for show teleport shadow of before
        Wait(0.4, WaitBehavior.IgnoreCondition);
    }
    else{
        // play teleport blast
        PlayEffect(AllPlayers(), PlayEffect.BadExplosion, enemyColor, ep, eachEffectTextSize);
    }
}

void TeleportWithEffect()"DoTeleportWithEffect"{
    Wait(SlotOf(ep) * 0.2, WaitBehavior.AbortWhenFalse);
    // show pre teleport effect
    PlayTeleportEffect(true);
    // Teleport
    Teleport(ep, teleportPosition);
    // show teleport effect
    PlayTeleportEffect(false);
}

rule: "EnemBot/Teleport/teleportByPortalDisabled"
Event.OngoingPlayer
Team.Team2
if(
    HasSpawned() &&
    !portalEnable
){
    // Teleport Bot to spawn room when portal disable
    // wait show dead effect when portal closing
    Wait(deadEffectTime, WaitBehavior.AbortWhenFalse);

    // reset teleport position
    teleportPosition = InvalidPosition();
    // show pre teleport effect
    PlayTeleportEffect(true);
    // Teleport to spawn room
    Respawn(AllPlayers(Team.Team2));
    // show teleport effect
    PlayTeleportEffect(false);
    // set root
    SetStatus(ep, null, Status.Rooted, MaxValue());
}

rule: "EnemBot/Teleport/teleportByPortalEnabled"
Event.OngoingPlayer
Team.Team2
if(
    HasSpawned() &&
    portalEnable
){
    AbortIf(IsDead());

    // clear root
    ClearStatus(ep, Status.Rooted);
    // set teleport position
    SetTeleportPositionToPlayerFront();
    // teleport
    TeleportWithEffect();
}

rule: "EnemBot/Teleport/teleportByPlayerEntered"
Event.OngoingPlayer
Team.Team2
if(
    portalEnable &&
    portalState == PortalState.Suspended
){
    AbortIf(IsDead());
    AbortIf(DistanceBetween(ep, closestPlayerToPortal) <= 10);

    // set teleport position to player around
    SetTeleportPositionToPlayerAround();
    // teleport
    TeleportWithEffect();
}

rule: "EnemBot/Teleport/teleportByRespawn"
Event.OngoingPlayer
Team.Team2
if(
    portalEnable &&
    IsInSpawnRoom()
){
    AbortIf(IsDead());
    
    if(
        // during portal attacks
        portalState == PortalState.Suspended ||
        // probability
        ProbabilityTrue(15)
    ){
        if(
            // probability
            ProbabilityTrue(70)
        ){
            // set teleport position to common position
            SetTeleportPositionToCommonPosition();
        }
        else{
            // set teleport position to player around
            SetTeleportPositionToPlayerAround();                        
        }
    }
    else{
        // set teleport position to player front
        SetTeleportPositionToPlayerFront();   
    }
    // teleport
    TeleportWithEffect();
}

rule: "EnemBot/Teleport/teleportByPlayerNotFound"
Event.OngoingPlayer
Team.Team2
if(
    portalEnable &&
    !IsInLineOfSight(ep,
        closestPlayerToMe,
        BarrierLOS.NoBarriersBlock)
){
    Wait(3, WaitBehavior.AbortWhenFalse);
    AbortIf(IsDead());    

    // Teleport bot to player front
    if(
        // during portal attacks
        portalState == PortalState.Suspended ||
        // probability
        ProbabilityTrue(15)
    ){
        if(
            // probability
            ProbabilityTrue(70)
        ){
            // set teleport position to common position
            SetTeleportPositionToCommonPosition();
        }
        else{
            // set teleport position to player around
            SetTeleportPositionToPlayerAround();                        
        }
    }
    else{
        // set teleport position to player front
        SetTeleportPositionToPlayerFront();   
    }
    // teleport
    TeleportWithEffect();
    
    LoopIfConditionIsTrue();
}

// TAG EnemBot/chargeUltimate ----------
rule: "EnemBot/chargeUltimate"
Event.OngoingPlayer
Team.Team2
if(
    HasSpawned() &&
    enemyType != EnemyType.None &&
    !IsUsingUltimate()
){
    SetUltimateCharge(ep, UltimateChargePercent() + (100 / eachChargeUltInterval));
    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}

// TAG EnemBot/SpawnInterval ----------
define deadEffectTime: 2;
playervar define confirmSpawnInterval!;

void UpdateEachSpawnInterval()"UpdateEachSpawnInterval"{
    confirmSpawnInterval = eachMaxSpawnInterval;
    confirmSpawnInterval *= (1 - (portalSize / maxPortalSize));
    confirmSpawnInterval -= (roundNo / 5);
    confirmSpawnInterval = Max(confirmSpawnInterval, 0);
    SetRespawnMaxTime(ep, confirmSpawnInterval + deadEffectTime); 
}

rule: "EnemBot/SpawnInterval/update"
Event.OngoingPlayer
Team.Team2
if(
    portalEnable
){
    Wait(5, WaitBehavior.AbortWhenFalse);
    UpdateEachSpawnInterval();
    LoopIf(portalSize < maxPortalSize);
}

// TAG EnemBot/ReceivedDamage ----------
globalvar define confirmReceiveDamage!;

void UpdateEachReceivedDamage()"UpdateEachReceivedDamage"{
    // If don't enough players, adjust Bot received damage rate to make the game fair
    // Multiply damage rate
    confirmReceiveDamage = 100;
    // Apply balance multiplier
    confirmReceiveDamage *= ConvertToBalancedValue(0.7, Team.Team1);
    SetDamageReceived(AllPlayers(Team.Team2), confirmReceiveDamage);
}

rule: "EnemBot/ReceivedDamage/updateByBalance //for game balance, increase by missing players count"
Event.OngoingGlobal
if(
    initCompleted
){
    UpdateEachReceivedDamage();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

// TAG EnemBot/DealtDamage ----------
playervar define confirmDealDamage!;

void UpdateEachDealtDamage()"UpdateEachDealtDamage"{
    // If don't enough players, adjust Bot dealt damage rate to make the game fair
    // And the round progresses, the Bot deal damage increases and becomes more difficult
    // Add damage rate according to the round progress
    confirmDealDamage = WorkshopSettingReal("Bot Settings", "Initial Deal Damage", 25, 0, 1000, 1);
    confirmDealDamage += roundNo * WorkshopSettingReal("Bot Settings", "Increase Deal Damage Per Round Progress", 1.75, 0, 1000, 2);
    confirmDealDamage *= eachDealtDamageScale;
    // Apply balance multiplier
    confirmDealDamage /= ConvertToBalancedValue(0.7, Team.Team1);
    SetDamageDealt(ep, confirmDealDamage);
}

rule: "EnemBot/DealtDamage/update"
Event.OngoingPlayer
Team.Team2
if(
    HasSpawned() &&
    enemyType != EnemyType.None
){
    UpdateEachDealtDamage();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

rule: "EnemBot/SpawnInterval/respawnBySucide"
Event.OnDeath
Team.Team2
if(
    Attacker() == ep
){
    Wait(deadEffectTime, WaitBehavior.AbortWhenFalse);
    Respawn();
}

// TAG FriendBot ----------
define enableFriendBot: true;
playervar define leader;
define HumanList:
    FilteredArray(
        AllPlayers(Team.Team1),
        (
            !IsDummyBot(ae) &&
            HasSpawned(ae)
        )
    );

define FriendBotList:
    FilteredArray(
        AllPlayers(Team.Team1),
        (
            IsDummyBot(ae) &&
            HasSpawned(ae)
        )
    );

Number AddFriendBotBot(define team, define hero)"AddFriendBotBot"{
    AbortIf(CountOf(HumanList) >= 6);

    define slot = GetEmptySlot(team);
    if(slot != -1){
        define human = RandomValueInArray(
            HumanList
        );

        // create bot
        CreateDummyBot(
            hero, team, slot,
            human + RandomPosition(1, 0, 1),
            RandomDirection()
        );
        Wait(0.1, WaitBehavior.IgnoreCondition);
        WaitUntil(!isServerOverLoading, 3);

        define bot! = PlayersInSlot(slot, team);
        // choice leader from human
        bot.leader = human;
        // apply Leader's name
        StartForcingDummyBotName(bot, <"<0>'s Guard <1>", human, CountOf(FriendBotList)>);
    }
    return slot;
}

rule: "FriendBot/reloadFriendBotTeam"
Event.OngoingGlobal
if(
    enableFriendBot &&
    initCompleted &&
    CountOf(HumanList) > 0 &&
    portalEnable
){
    Wait(1, WaitBehavior.AbortWhenFalse);
    // change bot asset by random
    if(
        CountOf(FriendBotList) <= 0 ||
        ProbabilityTrue(50)        
    ){
        dbgMsg("reload FriendBot Team");
        DestroyBots(Team.Team1);
        define FriendBotHeroList = [
            RandomSupportHero,
            RandomSupportHero,
            RandomTankHero,
            RandomTankHero,
            RandomDamageHero,
            RandomDamageHero
        ];
        for(define idx! = 0; idx < 6; idx++){
            AddFriendBotBot(Team.Team1, FriendBotHeroList[idx]);
        }
    }
}


rule: "FriendBot/clearFriendBotTeam"
Event.OngoingGlobal
if(
    enableFriendBot &&
    initCompleted &&
    CountOf(HumanList) <= 0
){
    DestroyBots(Team.Team1);
}

rule: "FriendBot/returnToLeader"
Event.OngoingPlayer
Team.Team1
if(
    enableFriendBot &&
    IsDummyBot() &&
    !IsInLineOfSight(ep, leader)
){
    Wait(5, WaitBehavior.AbortWhenFalse);   
    Wait(SlotOf(ep) * 0.2, WaitBehavior.AbortWhenFalse);
    Teleport(
        ep, NearestWalkablePosition(leader + RandomPosition(1, 0, 1))
    );
    LoopIfConditionIsTrue();
}

rule: "FriendBot/fastRespawn"
Event.OngoingPlayer
Team.Team1
if(
    enableFriendBot &&
    IsDummyBot() &&
    !IsAlive()
){
    Wait(0.1, WaitBehavior.AbortWhenFalse);
    Respawn(ep);
}

// TAG Debug ----------
globalvar define debugMode!;

enum DebugMode{
    Non,
    SlowLevelOnly,
    ShowParam,
    WithRecord
}

rule: "Debug/changeDebugMode"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Jump) 
){
    // change debug mode
    WaitLongPressConfirm();
    if(debugMode == DebugMode.Non){
        debugMode = DebugMode.SlowLevelOnly;
    }
    else if(debugMode == DebugMode.SlowLevelOnly){
        debugMode = DebugMode.ShowParam;
    }
    else if(debugMode == DebugMode.ShowParam){
        debugMode = DebugMode.WithRecord;
    }
    else if(debugMode == DebugMode.WithRecord){
        debugMode = DebugMode.Non;
    }

    if(debugMode == DebugMode.Non){
        DisableInspectorRecording();
        HideDebugHud();
    }
    else if(debugMode == DebugMode.SlowLevelOnly){
        DisableInspectorRecording();
        HideDebugHud();
        ShowDebugHud();
    }
    else if(debugMode == DebugMode.ShowParam){
        DisableInspectorRecording();
        HideDebugHud();
        ShowDebugHud();
    }
    else if(debugMode == DebugMode.WithRecord){
        EnableInspectorRecording();
        HideDebugHud();
        ShowDebugHud();
    }
}

define End(): CountOf(debugHudEntitys);
define botOfEnemyType(define enemyType): FirstOf(FilteredArray(AllPlayers(Team.Team2), ae.enemyType == enemyType));
globalvar define debugHudEntitys!;

// show debug icon and hud
void ShowDebugHud()"ShowDebugHud"{
    if(
        debugMode == DebugMode.ShowParam ||
        debugMode == DebugMode.WithRecord
    ){
        if(
            debugMode == DebugMode.WithRecord
        ){
            CreateHudText(HostPlayer(),
                null,
                null,
                "● is Recording",
                Location.Left, -1,
                Color.White, Color.White, Color.Red,
                HudTextRev.VisibleToAndString, Spectators.VisibleNever);
            debugHudEntitys[End()] = LastTextID();
        }

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "revive Timeout Count", reviveTimeoutCount>,
            null,
            Location.Left, -1,
            Color.White, Color.Blue, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "Regeneration Rate", playerRegenerationRateTeam1>,
            null,
            Location.Left, -1,
            Color.White, Color.Blue, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "portal State", portalState>,
            null,
            Location.Left, -1,
            Color.White, enemyColor, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "portal Size", portalSize>,
            null,
            Location.Left, -1,
            Color.White, enemyColor, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "portal Position", portalPosition>,
            null,
            Location.Left, -1,
            Color.White, enemyColor, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "distance to protal", DistanceBetween(ep, portalPosition)>,
            null,
            Location.Left, -1,
            Color.White, enemyColor, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();
    
        CreateHudText(HostPlayer(),
            null,
            <"<0> RcvDmg <1> DltDmg <2> SpwItv <3> ChgUlt <4>", "Giant Boss Status",
                confirmReceiveDamage,
                botOfEnemyType(EnemyType.GiantBoss).confirmDealDamage,
                botOfEnemyType(EnemyType.GiantBoss).confirmSpawnInterval,
                botOfEnemyType(EnemyType.GiantBoss).eachChargeUltInterval
            >,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> RcvDmg <1> DltDmg <2> SpwItv <3> ChgUlt <4>", "Boss Status",
                confirmReceiveDamage,
                botOfEnemyType(EnemyType.Boss).confirmDealDamage,
                botOfEnemyType(EnemyType.Boss).confirmSpawnInterval,
                botOfEnemyType(EnemyType.Boss).eachChargeUltInterval
            >,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> RcvDmg <1> DltDmg <2> SpwItv <3> ChgUlt <4>", "Elite Status",
                confirmReceiveDamage,
                botOfEnemyType(EnemyType.Elite).confirmDealDamage,
                botOfEnemyType(EnemyType.Elite).confirmSpawnInterval,
                botOfEnemyType(EnemyType.Elite).eachChargeUltInterval
            >,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> RcvDmg <1> DltDmg <2> SpwItv <3> ChgUlt <4>", "Minion Status",
                confirmReceiveDamage,
                botOfEnemyType(EnemyType.Minion).confirmDealDamage,
                botOfEnemyType(EnemyType.Minion).confirmSpawnInterval,
                botOfEnemyType(EnemyType.Minion).eachChargeUltInterval
            >,
            null,
            Location.Left, -1,
            Color.White, Color.Red, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>/<2>", "environment Death Count", environmentDeathCount, environmentDeathLimit>,
            null,
            Location.Left, -1,
            Color.White, Color.White, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>/<2>", "no Contact Time", noContactTime, limitTime>,
            null,
            Location.Left, -1,
            Color.White, Color.White, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();
    }

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "Server Load", ServerLoad()>,
            null,
            Location.Left, -1,
            Color.White, Color.Orange, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

    if(
        debugMode == DebugMode.ShowParam ||
        debugMode == DebugMode.WithRecord
    ){
        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "Server Load Average", ServerLoadAverage()>,
            null,
            Location.Left, -1,
            Color.White, Color.Orange, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "Server Load Peak", ServerLoadPeak()>,
            null,
            Location.Left, -1,
            Color.White, Color.Orange, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();
    }

        CreateHudText(HostPlayer(),
            null,
            <"<0> <1>", "current Slow Level", currentSlowLevel>,
            null,
            Location.Left, -1,
            Color.White, Color.Orange, Color.White,
            HudTextRev.VisibleToAndString, Spectators.VisibleNever);
        debugHudEntitys[End()] = LastTextID();
}

// Hide debug icon and hud
void HideDebugHud()"HideDebugHud"{
    for(gLoopIndex = 0; gLoopIndex < CountOf(debugHudEntitys); gLoopIndex ++){
        DestroyHudText(debugHudEntitys[gLoopIndex]);
    }
}

rule: "Debug/increaseTeamLifes"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Ability2)
){
    // Increase TeamLifes
    WaitLongPressConfirm();
    teamLifes += 1;
    LoopIfConditionIsTrue();
}

rule: "Debug/increaseRoundNo"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Ability1)
){
    // Increase RoundNo
    WaitLongPressConfirm();
    roundNo += 1;
    LoopIfConditionIsTrue();
}

rule: "Debug/resetPortal // reset portal position by random"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    !IsButtonHeld(ep, Button.Reload) &&
    IsButtonHeld(ep, Button.Crouch)
){
    // Recalculate portal
    WaitLongPressConfirm();
    portalState = PortalState.Idle;
    WaitChangeState();  // Wait for the changed status to be processed first
    portalState = PortalState.Calculating;
    
    ApplySlowLevel(0);
    watchingOverLoad = true;
}

globalvar define debugAimingPosition!;

rule: "Debug/setPortalPositionOnAimCenter // reset portal position by aim center"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Reload) &&
    !IsButtonHeld(ep, Button.Crouch)
){
    // Set portal position to aim center
    WaitLongPressConfirm();
    portalState = PortalState.Idle;
    debugAimingPosition = AimingPosition();
    WaitChangeState();  // Wait for the changed status to be processed first
    portalState = PortalState.Calculating;
    WaitUntil(portalState != PortalState.Calculating, 5);
    portalPosition = debugAimingPosition;
}

rule: "Debug/setPortalMaxSize // reset portal position by aim center"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Reload) &&
    IsButtonHeld(ep, Button.Crouch)
){
    // Set portal position to aim center
    WaitLongPressConfirm();
    portalSize = maxPortalSize;
}

