import "PortalHunt.setting.json";
import "../Lib/Debug.del";
import "../Lib/Utility.del";
import "../Lib/ServerOverLoadMeasures.del";
import "../Lib/ElapsedTimer.del";
// import "../Lib/DamageText.del";
import "../Lib/Regeneration.del";
import "../Lib/Revive.del";
import "../Lib/Bot.del";
import "../Lib/Buddy.del";
import "../Lib/PerkChooser.del";

// // TAG duumy define ----------
// globalvar define perkCorePerkDropProbability;
// globalvar define eachPerkDropProbability;

// TAG Signature and infomation ----------
disabled rule: "PORTAL HUNT -HORDE PVE [ver 4.0] Share code [YY1N2]"-1{}
disabled rule: "You allowed copy or modify code."-1{}
disabled rule: "This script was generated by [Overwatch-Script-To-Workshop] tools"-1{}
disabled rule: "Check detail with https://github.com/ItsDeltin/Overwatch-Script-To-Workshop"-1{}
disabled rule: "Original source code was created by [sarami77#1868]"-1{}
disabled rule: "Check detail with https://github.com/sarami77/OverwatchWorkShopScripts"-1{}

// TAG Initialize ----------
define playerTeam: Team.Team1;
define enemyTeam: Team.Team2;

globalvar define initCompleted!;

rule: "Initialize/initialize"
Event.OngoingGlobal
{
    // Stop records to reduce server load
    DisableInspectorRecording();

    // If run it right after loading the server, some scripts fail, so wait few seconds
    Wait(5, WaitBehavior.AbortWhenFalse);

    // Cancel unnecessary default settings
    DisableScoring();
    DisableCompletion();

    // Set team lives property
    initialTeamLives =                      WorkshopSettingInteger("Player Settings", "Initial team lives",                     5, 0, 1000, 0);
    maxTeamLives =                          WorkshopSettingInteger("Player Settings", "Max stock team lives",                   10, 0, 1000, 1);

    // Set imported functions public property for user tuning
    // Regeneration.del
    regenerationEnableTeams = [playerTeam];
    regenerationNeedBalanceTeam1 = true;
    regenerationStartWaitSecond =      WorkshopSettingReal("Player Settings", "Regeneration Start Wait Second",            3, 0, 100, 2);

    // Revive.del
    reviveEnableTeams = [playerTeam];
    reviveTimeLimit =                       WorkshopSettingReal("Player Settings", "Revive Time Limit",                         10, 0, 100, 4);
    reviveRange =                           WorkshopSettingReal("Player Settings", "Revive Range",                              3, 0, 100, 5);
    reviveCompleteSecond =                  WorkshopSettingReal("Player Settings", "Revive Complete Second",                    5, 0, 100, 6);

    // DamageText.del
    // damageTextEnableTeam = enemyTeam;

    // ElapsedTimer.del
    elapsedTimerEnable = true;
    
    // PerkCore.del
    perkCorePerkDropProbability =           WorkshopSettingReal("Perk Settings", "Perk Crate Drop Rate Scale (When Enemy Dead)",  1.0, 0, 100, -1);

    // Start watch over load
    slowControlHandler = SlowControlHandler.ServerOverLoadMeasures;

    // set game HUD
    // show version and share code
    CreateHudText(AllPlayers(playerTeam),
        null, "PORTAL HUNT -HORDE PVE [ver 4.0] Share code [YY1N2]", null,
        Location.Left, -3,
        Color.White, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);

    // show hero change operation
    CreateHudText(AllPlayers(playerTeam),
        null, <"Hold reload button <0> to change hero", ButtonGuide(Button.Reload)>, null,
        Location.Left, -2,
        Color.Yellow, Color.Yellow, Color.Yellow,
        HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);

    // show round number
    CreateHudText(AllPlayers(),
        <"<0> <1>", "Round", roundNo>, null, null,
        Location.Top, 2,
        enemyColor, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleAlways);

    // show HUD of team Lives
    CreateHudText(AllPlayers(),
        teamLives < maxTeamLives ? 
            <"Team Lives <0>", teamLives> :
            <"Team Lives <0> (Max Stock)", teamLives>,
        null, null,
        Location.Top, 3,
        Color.Team1, Color.White, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleAlways);

    // reset player position
    Respawn(AllPlayers());

    // Notify completion of init game setting and start game main logic
    initCompleted = true;
}

// TAG Game ----------
globalvar define roundNo!;

rule: "Game/initGame"
Event.OngoingGlobal
if(
    initCompleted
){
    // reset team Lives
    teamLives = initialTeamLives;
    // reset round no 
    roundNo = 0;
    // reset elapsed time
    elapsedTime = 0;
    // reset portal
    portalState = PortalState.Init;
}

rule: "Game/startGame"
Event.OngoingGlobal
if(
    initCompleted &&
    portalState == PortalState.Init &&
    NumberOfPlayers(playerTeam) > 0 &&
    IsTrueForAny(
        AllPlayers(playerTeam),
        (
            !IsInSpawnRoom(ae) &&
            IsMoving(ae)
        )
    )
){
    // reset elapsed time
    elapsedTime = 0;
    // reset prevPortalPosition
    prevPortalPosition = PositionOf(FirstOf(AllPlayers(playerTeam)));
    // start portal creation
    portalState = PortalState.Calculating;
}

rule: "Game/stopGame"
Event.OngoingGlobal
if(
    initCompleted &&
    portalState != PortalState.Init &&
    NumberOfPlayers(playerTeam) <= 0
){
    // reset team Lives
    teamLives = initialTeamLives;
    // reset round no
    roundNo = 0;
    // reset elapsed time
    elapsedTime = 0;
    // reset portal
    portalState = PortalState.Init;
}

rule: "Game/SpawnRoom/changeByTimer"
Event.OngoingGlobal
if(
    initCompleted
){
    // Change the spawn room regularly to keep the game fluid
    ForceSpawnRoom(playerTeam, RandomValueInArray([0, 1, 1, 1, 2]));
    ForceSpawnRoom(enemyTeam, RandomValueInArray([0, 1, 1, 1, 2]));
    Wait(300, WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

// TAG Buddy ----------
rule: "Buddy/BuddyContorl"
Event.OngoingGlobal
if(
    initCompleted
){
    define buddyList! = 
    WorkshopSettingToggle("Follower AI Settings (Join as behalf when absent player)", "Random Hero", true, -101) ?
        // random list
        [
            RandomSupportHero,
            RandomTankHero,
            RandomDamageHero,
            RandomSupportHero,
            RandomTankHero
        ]
    :
        // fix list
        [
            Hero.Mercy,
            Hero.Reinhardt,
            Hero.Genji,
            Hero.Ana,
            Hero.Orisa
        ];

        // // fix list
        // [
        //     Hero.Reinhardt,
        //     Hero.Reinhardt,
        //     Hero.Reinhardt,
        //     Hero.Reinhardt,
        //     Hero.Reinhardt
        // ];

    // slice buddy list by setting
    buddyList = ArraySlice(buddyList, 0,
        WorkshopSettingInteger("Follower AI Settings (Join as behalf when absent player)", "Follower Max Num", 5, 0, 5, -100)
    );

    define prevPlayerNum! = -1;
    define maxSlotNum! = NumberOfSlots(playerTeam);
    define maxBuddyNum! = CountOf(buddyList);

    while(true){
        define playerNum! =
            CountOf(
                FilteredArray(
                    AllPlayers(playerTeam),
                    !IsDummyBot(ae)));

        define needBuddyNum! = 
            Min(
                maxSlotNum - playerNum,
                maxBuddyNum);

        define buddyNum! = 
            CountOf(
                FilteredArray(
                    AllPlayers(playerTeam),
                    IsDummyBot(ae)));

        if(
            // player number changed
            prevPlayerNum != playerNum ||
            // not filed buddy number
            buddyNum != needBuddyNum
        ){
            // save player num
            prevPlayerNum = playerNum;
            // relaod buddy list
            DestroyBots(playerTeam);
            define emptySlotNum! = maxSlotNum - playerNum;
            define addList! = ArraySlice(buddyList, 0, emptySlotNum);
            for(define buddyAddIndex! = 0; buddyAddIndex < CountOf(addList); buddyAddIndex++){
                CreateBotsByHeroInput(addList[buddyAddIndex], 1, playerTeam);
            }

            addList = FilteredArray(
                AllPlayers(playerTeam),
                IsDummyBot(ae)
            );
            for(define buddyAddIndex! = 0; buddyAddIndex < CountOf(addList); buddyAddIndex++){
                if(IsProbabilityTrue(50)){
                    addList[buddyAddIndex].perkType = RandomValueInArray(lotteryPerkList);
                    addList[buddyAddIndex].perkState = PerkState.Ready;
                }
            }
        }
    
        Wait(10, WaitBehavior.IgnoreCondition);
    }
}

rule: "Buddy/Teleport/init"
Event.OngoingPlayer
if(
    TeamOf() == playerTeam &&
    IsDummyBot() &&
    HasSpawned()
){
    SetUltimateCharge(ep, 50);

    // teleport to player near object
    Teleport(ep, ClosestPlayerTo(portalPosition, playerTeam));
}

playervar define buddyOriginalHero!;

globalvar define botPerkUseScale! =
    WorkshopSettingReal("Follower AI Settings (Join as behalf when absent player)", "Perk Use Probability Scale", 1.0, 0, 1000, -102);

rule: "Buddy/ActionControl"
Event.OngoingPlayer
if(
    TeamOf() == playerTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    IsAlive()
){
    Wait(RandomReal(4, 6), WaitBehavior.AbortWhenFalse);

    // SetHeroButtonControlPropety
    if(buddyOriginalHero != HeroOf()){
        SetHeroButtonControlPropety();
    }
    buddyOriginalHero = HeroOf();

    // perk action
    if(actionState != ActionState.Non){
        define enemyNum! = CountOf(
            PlayersWithinRadius(
                ep, 30, enemyTeam, RadiusLOS.Off)
            );

        // get perk
        if(
            IsProbabilityTrue((enemyNum * 1) * botPerkUseScale) &&
            perkState == PerkState.Non
        ){
            perkType = RandomValueInArray(lotteryPerkList);
            perkState = PerkState.Ready;
        }

        // use perk
        if(
            IsProbabilityTrue((enemyNum * 3) * botPerkUseScale) &&
            perkState == PerkState.Ready
        ){
            StartHoldingButton(ep, Button.Interact);
            Wait(0.5, WaitBehavior.IgnoreCondition);
            StopHoldingButton(ep, Button.Interact);
        }

        // use perk ability
        if(
            IsProbabilityTrue((enemyNum * 6) * botPerkUseScale) &&
            perkState == PerkState.Using
        ){
            StartHoldingButton(ep, Button.Melee);
            Wait(RandomReal(0.5, 2), WaitBehavior.IgnoreCondition);
            StopHoldingButton(ep, Button.Melee);
        }
    }

    // revive action
    define downPlayer! = RandomValueInArray(
        FilteredArray(
            AllDeadPlayers(playerTeam), 
            (
                ae != ep
            )
        )
    );
    if(downPlayer != null){
        // has down player
        if(
            // has line to down player
            IsInLineOfSight(EyePosition(), downPlayer + PositionOffset()) &&
            (
                // non state
                actionState == ActionState.Non ||
                // near to down player (max range 30m)
                IsProbabilityTrue(DefaultPercentage() - ((DistanceBetween(ep, downPlayer) / 30) * DefaultPercentage()))
            )
        ){
            // can revive both status
            while(
                IsAlive(ep) &&
                !IsAlive(downPlayer)
            ){
                define distDownPlayer! = DistanceBetween(ep, downPlayer);  
                // is in revive range
                if(
                    distDownPlayer > reviveRange
                ){
                    // hop to down position
                    ApplyImpulse(ep, 
                        VectorTowards(ep, downPlayer + Vector(0, distDownPlayer / 2, 0)),
                        distDownPlayer * 2,
                        Relative.ToWorld, ContraryMotion.Cancel);
                }
                // hold position
                SetStatus(ep, null, Status.Rooted, 0.5);
                Wait(0.5, WaitBehavior.AbortWhenFalse);        
            }
        }
    }

    LoopIfConditionIsTrue();
}

rule: "Buddy/fastRespawnBySucide"
Event.OnDeath
if(
    TeamOf() == playerTeam &&
    IsDummyBot() &&
    Attacker() == ep
){
    Wait(0.1, WaitBehavior.AbortWhenFalse);
    Respawn();
}

// TAG Player ----------
// TAG Player/ReturnSpawnRoom
rule: "Player/ReturnSpawnRoom/manualReturn"
Event.OngoingPlayer
if(
    TeamOf() == playerTeam &&
    IsAlive() &&
    !IsInSpawnRoom() &&
    IsButtonHeld(ep, Button.Reload)
){
    AbortIf(!IsOnGround());
    // Return to spawn room with long hold on reload button
    WaitCancelPressConfirm();
    Respawn();
}

rule: "Player/ReturnSpawnRoom/setFastSpeed"
Event.OngoingPlayer
if(
    TeamOf() == playerTeam &&
    initCompleted &&
    IsAlive() &&
    IsInSpawnRoom()
){
    SetMoveSpeed(ep, 150);
    while(!IsInLineOfSight(ep, ClosestPlayerTo(ep, enemyTeam))){
        Wait(1, WaitBehavior.IgnoreCondition);
    }
    SetMoveSpeed(ep, DefaultPercentage());
}

// TAG Player/TeamLives
globalvar define initialTeamLives!;
globalvar define teamLives!;
globalvar define maxTeamLives!;

rule: "Player/TeamLives/consumeTeamLives"
Event.OngoingGlobal
if(
    0 < reviveTimeoutCount
){
    WaitConditionConfirmed();
    teamLives -= reviveTimeoutCount;
    WaitChangeState();  // wait for show big message by newest value
    if(teamLives > 0){
        BigMessage(AllPlayers(),
            <"<0> team lives remaining.", teamLives>);

        PlayEffect(
            AllPlayers(), PlayEffect.DebuffImpactSound,
            Color.White, portalPosition, MaxLength());
    }
    reviveTimeoutCount = 0;
    LoopIfConditionIsTrue();
}

rule: "Player/TeamLives/finishGame"
Event.OngoingGlobal
if(
    initCompleted &&
    teamLives <= 0
){
    WaitConditionConfirmed();
    // play game end portal effect
    portalState = PortalState.End;
    // set slow handler
    slowControlHandler = SlowControlHandler.GameLogic;

    BigMessage(AllPlayers(), "Team lives ran out.");
    SetSlowMotion(10);
    Wait(1, WaitBehavior.AbortWhenFalse);   // show slow
    SetSlowMotion(DefaultPercentage());
    WaitNextPhase();

    BigMessage(AllPlayers(),
        <"We reached <0> round. good game!", roundNo>);
    PlayRandomEmote(AllPlayers(playerTeam));
    WaitNextPhase();

    DeclareTeamVictory(playerTeam);
}

rule: "Player/TeamLives/protectTeamLifeConsumeBySucide"
Event.OnDeath
if(
    TeamOf() == playerTeam &&
    Attacker() == ep
){
    if(
        DistanceBetween(ep, ClosestPlayerTo(ep, enemyTeam)) > 30
    ){
        Respawn();
    }
}

// TAG Player/InsidePortal
playervar define contactPortalState!;
enum ContactPortalStatus{
    MaxOutSide,
    OutSide,
    InSide,    
    HalfInSide
}

playervar define isInSidePortal!;

rule: "Player/InsidePortal/update"
Event.OngoingGlobal
if(
    portalEnable
){
    define players! = AllPlayers(playerTeam);
    // Set flag when player entered to portal
    // This flag is used for functions related to portal
    for(gLoopIndex = 0; gLoopIndex < CountOf(players); gLoopIndex++){
        define player! = players[gLoopIndex];
        if(
            HasSpawned(player) &&
            IsAlive(player) &&
            !IsInSpawnRoom(player)
        ){
            define distToPortal! = DistanceBetween(player, portalPosition);
            if(
                distToPortal < portalSize / 2
            ){
                player.contactPortalState = ContactPortalStatus.HalfInSide;
                player.isInSidePortal = true;
            }
            else if(
                distToPortal < portalSize
            ){
                player.contactPortalState = ContactPortalStatus.InSide;
                player.isInSidePortal = true;
            }
            else if(
                distToPortal < maxPortalSize
            ){
                player.contactPortalState = ContactPortalStatus.OutSide;
                player.isInSidePortal = false;
            }
            else{
                player.contactPortalState = ContactPortalStatus.MaxOutSide;
                player.isInSidePortal = false;
            }
        }
        else{
            player.contactPortalState = ContactPortalStatus.MaxOutSide;
            player.isInSidePortal = false;
        }
    }
    WaitUpdateMediumCycle();
    WaitReleaseServerLoad(ServerLoadType.GameMain);
    LoopIfConditionIsTrue();
}

// TAG Player/ObjectiveDescription
rule: "Player/ObjectiveDescription/update"
Event.OngoingGlobal
if(
    initCompleted
){
    if(
        portalState == PortalState.Set ||
        portalState == PortalState.Growing
    ){
        SetObjectiveDescription(AllPlayers(playerTeam), "Find and attack portal!", HudTextRev.VisibleToSortOrderStringAndColor);
    }
    else if(
        portalState == PortalState.UnderAttack
    ){
        SetObjectiveDescription(AllPlayers(playerTeam), "Attacking portal. Stay inside and Survive!", HudTextRev.VisibleToSortOrderStringAndColor);
    }
    else if(portalState == PortalState.Closed){
        SetObjectiveDescription(AllPlayers(playerTeam), "Portal closed. Nice work!", HudTextRev.VisibleToSortOrderStringAndColor);
    }
    else if(portalState == PortalState.End){
        SetObjectiveDescription(AllPlayers(playerTeam), "Team lives ran out. good game!", HudTextRev.VisibleToSortOrderStringAndColor);
    }
    else if(portalState == PortalState.Calculating){
        SetObjectiveDescription(AllPlayers(playerTeam), "Scanning portal... Stand by.", HudTextRev.VisibleToSortOrderStringAndColor);
    }
    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}


// TAG Player/ClosePortal
globalvar define closingCount;
globalvar define closingProgress;
globalvar define closingProgressHudEntity;
globalvar define playerNumInsidePortal;

define enableClosingProgress:
    portalState == PortalState.UnderAttack &&
    teamLives > 0;

define maxClosingCount: 180;

rule: "Player/ClosePortal/startClosing"
Event.OngoingGlobal
if(
    enableClosingProgress
){
    // When a player enters a portal, set progress hud and show message
    WaitConditionConfirmed();
    // kick progress
    closingCount = 10;
    closingCount += portalSize * 1;
    closingCount += roundNo * 10;
    closingCount = RoundToInteger(closingCount, Rounding.Up);
    closingCount = Min(maxClosingCount, closingCount);

    dbgMsg(<"closing count <0> <1> <2>", closingCount, closingProgress, playerNumInsidePortal>);

    // show progress hud
    ChaseVariableOverTime(closingProgress, DefaultPercentage(), closingCount, TimeChaseReevaluation.DestinationAndDuration);
    DestroyProgressBarHudText(closingProgressHudEntity);
    closingProgressHudEntity = CreateProgressBarHudText(
            AllPlayers(),
            closingProgress,
            <"<0> players attacking portal. Until portal closes <1>", playerNumInsidePortal,
                RoundToInteger((100 - closingProgress) * closingCount / 100, Rounding.Down)>,
            Location.Top, 4,
            Color.Yellow,
            Color.Yellow,
            ProgressBarHudEvaluation.Values,
            Spectators.DefaultVisibility);
    // show big message
    define closestPlayerPortal! = ClosestPlayerFromPortal();
    BigMessage(
        closestPlayerPortal,
        <"You are attacking portal. Stay inside and Survive!">);
    BigMessage(
        FilteredArray(AllPlayers(playerTeam), (closestPlayerPortal != ae)),
        <"<0> <1> <2>",
            closestPlayerPortal,
            HeroIconString(HeroOf(closestPlayerPortal)),
            "attacking portal. Cover one!">);
    // Wait closingCount
    Wait(closingCount, WaitBehavior.AbortWhenFalse);
    portalState = PortalState.Closing;
}

rule: "Player/ClosePortal/updatePlayerNumInsidePortal"
Event.OngoingGlobal
if(
    enableClosingProgress
){
    playerNumInsidePortal = CountOf(
        FilteredArray(
            AllPlayers(playerTeam),
            ae.isInSidePortal
        )
    );
    WaitUpdateMediumCycle();
    LoopIfConditionIsTrue();
}

rule: "Player/ClosePortal/cancelClosing //on exit every player"
Event.OngoingGlobal
if(
    !enableClosingProgress
){
    StopChasingVariable(closingProgress);
    // delay hide hud when progress completed
    if(closingProgress == DefaultPercentage()){
        Wait(1.5, WaitBehavior.AbortWhenFalse);
    }
    closingProgress = 0;
    DestroyProgressBarHudText(closingProgressHudEntity);
    closingProgressHudEntity = null;
}

rule: "Player/ClosePortal/finishClose //on count down finished"
Event.OngoingGlobal
if(
    (
        portalState == PortalState.Closing ||
        portalState == PortalState.Closed
    ) &&
    teamLives > 0
){
    WaitConditionConfirmed();
    // When the countdown is complete, clear the portal and give team Lives.
    // Later, we will generate a new portal and start the next round.
    WaitPlayEffect();   //wait portal closing effect
    portalState = PortalState.Closed;
    WaitNextPhase();

    // if lower than max
    if(teamLives < maxTeamLives){
        // play got life sound
        PlayEffect(
            AllPlayers(), PlayEffect.BuffImpactSound,
            Color.White, portalPosition, MaxLength()
        );
        // show got life sound message
        BigMessage(AllPlayers(), "We earned 1 team lives!");
        // add life
        teamLives += 1;
    }
    WaitNextPhase();

    PlayRandomVoiceLine(AllPlayers(playerTeam));
    roundNo += 1;
    BigMessage(AllPlayers(), <"Round <0>", roundNo>);
    WaitBigMessageHide();
    portalState = PortalState.Calculating;  // start next portal create
}

// TAG Player/FairPlay
rule: "Player/FairPlay/disableStealthWhenInside //sombra's stealth for fair play"
Event.OngoingPlayer
if(
    TeamOf() == playerTeam &&
    isInSidePortal &&
    IsStealth(ep)
){
    // Some abilities are disabled inside the portal to make the game fair
    // Sombra stealth is exactly that
    Wait(5.0, WaitBehavior.AbortWhenFalse); // disable ability check cycle
    SetStatus(ep, null, Status.Stunned, 0.1);
    SmallMessage(ep, "Stealth has been interrupted by the portal!");
    LoopIfConditionIsTrue();
}

// TAG Portal Function ----------
define enemyColor: Color.Purple;

globalvar define portalState;
enum PortalState{
    Changing,
    Init,
    Calculating,
    Checking,
    Set,
    Growing,
    UnderAttack,
    Closing,
    Closed,
    End
}

globalvar define portalPosition;
globalvar define portalSize;
globalvar define portalEntitys;
globalvar define isFirstGrowing;

define portalEnable:
    portalState == PortalState.Checking ||
    portalState == PortalState.Set ||
    portalState == PortalState.Growing ||
    portalState == PortalState.UnderAttack;

rule: "Portal/State/Calculating"
Event.OngoingGlobal
if(
    portalState == PortalState.Calculating
){
    // Hide Portal Entity until portal state changed to Show
    // Init param
    StopChasingVariable(portalSize);
    portalPosition = 0;
    portalSize = 0;
    isFirstGrowing = true;
    // Hide portal icon and effect
    DestroyIcon(portalEntitys[0]);
    DestroyEffect(portalEntitys[1]);
    DestroyEffect(portalEntitys[2]);
    DestroyEffect(portalEntitys[3]);
    DestroyEffect(portalEntitys[4]);
}

define playersAny:
    AllPlayers();

define playersConPtlSts(ContactPortalStatus status):
    FilteredArray(AllPlayers(playerTeam), ae.contactPortalState == status);

define playersNConPtlSts(ContactPortalStatus status):
    FilteredArray(AllPlayers(playerTeam), ae.contactPortalState != status);

globalvar define portalColor;

rule: "Portal/State/Set  // waiting for found by players"
Event.OngoingGlobal
if(
    portalState == PortalState.Set
){
    portalColor = enemyColor;

    DestroyIcon(portalEntitys[0]);
    // show Portal Entity by portal state changed to Show
    // Init param
    closingCount = 0;
    // show icon
    portalEntitys = [];
    portalEntitys[0] = CreateIcon(playersConPtlSts(ContactPortalStatus.MaxOutSide), portalPosition, Icon.Spiral,
        IconRev.VisibleToPositionAndColor, portalColor, true);
    // set effect
    // sphere
    portalEntitys[1] = CreateEffect(playersAny, Effect.Sphere, portalColor,
        portalPosition, portalSize, EffectRev.VisibleToPositionRadiusAndColor);
    // cloud
    portalEntitys[2] = CreateEffect(playersNConPtlSts(ContactPortalStatus.HalfInSide), Effect.Cloud, portalColor,
        portalPosition, portalSize * 1.5, EffectRev.VisibleToPositionRadiusAndColor);
    // aura
    portalEntitys[3] = CreateEffect(playersNConPtlSts(ContactPortalStatus.HalfInSide), Effect.BadAura, portalColor,
        portalPosition, portalSize * 1.25, EffectRev.VisibleToPositionRadiusAndColor);
    // sound
    portalEntitys[4] = CreateEffect(playersAny, Effect.EnergySound, portalColor,
        portalPosition, portalSize * 1.25, EffectRev.VisibleToPositionRadiusAndColor);
    // show message
    BigMessage(playersAny, "New portal detected. Find and attack portal!");
}

rule: "Portal/State/Growing"
Event.OngoingGlobal
if(
    portalState == PortalState.Growing
){
    portalColor = enemyColor;

    // Start growing portal with warning message
    UpdateEveryFrame(portalSize);
    ChaseVariableAtRate(
        portalSize, maxPortalSize, 1 + (roundNo / 10),
        RateChaseReevaluation.DestinationAndRate);  // startGrowing
    // If first growing, show message
    if(isFirstGrowing == true){
        isFirstGrowing = false;
        BigMessage(AllPlayers(), "Portal is growing. Hurry up!");
        WaitBigMessageHide();
        BigMessage(AllPlayers(), "Growed portal spawn more enemies and get hard to close.");
    }
}

rule: "Portal/State/UnderAttack"
Event.OngoingGlobal
if(
    portalState == PortalState.UnderAttack
){
    // Stop growing portal
    Wait(1, WaitBehavior.AbortWhenFalse);
    StopChasingVariable(portalSize);
}

rule: "Portal/changePortalColor"
Event.OngoingGlobal
if(
    portalState == PortalState.UnderAttack
){
    portalColor = Color.White;
    Wait(0.05, WaitBehavior.AbortWhenFalse);
    portalColor = enemyColor;
    Wait(0.1 + 1.5 * (1 - (closingProgress / DefaultPercentage())), WaitBehavior.AbortWhenFalse);
    LoopIfConditionIsTrue();
}

rule: "Portal/State/Closing"
Event.OngoingGlobal
if(
    portalState == PortalState.Closing
){
    portalColor = Color.White;

    // apply blast impulse
    ApplyBlastImpulse(AllPlayers(enemyTeam), portalPosition, portalSize);
    // play portal closing effect and kill enemrys
    Kill(AllPlayers(enemyTeam), null);
    // play big blast with sound
    PlayContinuousBlast(Color.Yellow, portalPosition,
        portalSize * 1.5, 10, 3);

    // Hide icon
    DestroyIcon(portalEntitys[0]);
}

rule: "Portal/State/Closed"
Event.OngoingGlobal
if(
    portalState == PortalState.Closed
){
    // init param
    portalPosition = 0;
    portalSize = 0;
    StopChasingVariable(portalSize);
    // Hide portal icon and effect
    DestroyIcon(portalEntitys[0]);
    DestroyEffect(portalEntitys[1]);
    DestroyEffect(portalEntitys[2]);
    DestroyEffect(portalEntitys[3]);
    DestroyEffect(portalEntitys[4]);
    Wait(2, WaitBehavior.AbortWhenFalse);

    // show message
    BigMessage(AllPlayers(), "Portal closed. Nice work!");
}

rule: "Portal/State/End"
Event.OngoingGlobal
if(
    portalState == PortalState.End
){
    // apply blast impulse
    ApplyBlastImpulse(AllPlayers(enemyTeam), portalPosition, portalSize);
    // play portal closing effect and kill enemrys
    Kill(AllPlayers(enemyTeam), null);
    // play big blast with sound
    PlayContinuousBlast(Color.Yellow, portalPosition,
        portalSize * 1.5, 10, 3);

    // init param
    portalPosition = 0;
    portalSize = 0;
    StopChasingVariable(portalSize);
    // Hide portal icon and effect
    DestroyIcon(portalEntitys[0]);
    DestroyEffect(portalEntitys[1]);
    DestroyEffect(portalEntitys[2]);
    DestroyEffect(portalEntitys[3]);
    DestroyEffect(portalEntitys[4]);
}

rule: "Portal/Positioner/createPortal"
Event.OngoingGlobal
if(
    teamLives > 0 &&
    portalState == PortalState.Calculating
){
    WaitConditionConfirmed();
    define candidatePosition;
    for(define retryCount! = 0; retryCount < 30; retryCount++){
        define basePosition! = Midpoint(SpawnPoints(playerTeam)[0], SpawnPoints(enemyTeam)[0]);
        define baseDistance! = DistanceBetween(SpawnPoints(playerTeam)[0], SpawnPoints(enemyTeam)[0]) / 2;
        // select random positon from map
        candidatePosition =
            basePosition +
            RandomPosition(
                baseDistance * 1.2,
                baseDistance * 0.5,
                baseDistance * 1.2
            );

        // convert to walkble position
        candidatePosition = NearestWalkablePosition(candidatePosition);
        // move candidate postion in the direction of player for avoiding map edge
        candidatePosition += DirectionTowards(candidatePosition, basePosition) * RandomReal(1, baseDistance / 4);
        // convert to walkble position
        candidatePosition = NearestWalkablePosition(candidatePosition);

        if(
            // far postion from previous position
            (
                DistanceBetween(prevPortalPosition, candidatePosition) >= 50
            )
        ){
            break;
        }
        Wait(1, WaitBehavior.AbortWhenFalse);
        WaitReleaseServerLoad(ServerLoadType.GameMain);
    }
    // confirm as portal position
    portalPosition = candidatePosition + PositionOffset();
    // create portal, next check position
    portalState = PortalState.Checking;
}

globalvar define prevPortalPosition;

rule: "Portal/Positioner/positionChecking"
Event.OngoingGlobal
if(
    teamLives > 0 &&
    portalState == PortalState.Checking
){
    // wait for portal position check
    Wait(3, WaitBehavior.AbortWhenFalse);
    // confirm portal position
    prevPortalPosition = portalPosition;
    // portal create fin
    portalState = PortalState.Set;
}

// TAG Portal/Positioner/InsideRespawnRoom ----------
rule: "Portal/Positioner/InsideRespawnRoom/resetPortal"
Event.OngoingGlobal
if(
    portalEnable &&
    IsTrueForAny(
        SpawnPoints(playerTeam),
        (
            IsInLineOfSight(ae + Up(), portalPosition)
        )
    )
){
    WaitConditionConfirmed();
    dbgMsg("reset Portal By Inside Respawn Room");
    portalState = PortalState.Calculating;
}

// TAG Portal/Positioner/EnvironmentDeathCount ----------
define environmentDeathLimit: NumberOfPlayers(enemyTeam) + 1;
globalvar define environmentDeathCount!;

rule: "Portal/Positioner/EnvironmentDeathCount/resetCount"
Event.OngoingGlobal
if(
    !portalEnable
){
    environmentDeathCount = 0;
}

rule: "Portal/Positioner/EnvironmentDeathCount/countup"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    portalEnable &&
    (
        Attacker() == ep ||         // killed by res room
        IsInSpawnRoom(Attacker())   // killer in res room
    )
){
    // change room for avoid kill in res room
    ForceSpawnRoom(playerTeam, RandomValueInArray([0, 1, 2]));
    // sucide
    if(Attacker() == ep){
        environmentDeathCount += 1;
    }
    // killer in res room
    else if(IsInSpawnRoom(Attacker())){
        environmentDeathCount += 3;
    }
}

rule: "Portal/Positioner/EnvironmentDeathCount/reduceCount"
Event.OngoingGlobal
if(
    portalEnable &&
    0 < environmentDeathCount
){
    Wait(3, WaitBehavior.AbortWhenFalse);
    environmentDeathCount --;
    LoopIfConditionIsTrue();
}

rule: "Portal/Positioner/EnvironmentDeathCount/resetPortal"
Event.OngoingGlobal
if(
    portalEnable &&
    environmentDeathLimit <= environmentDeathCount
){
    WaitConditionConfirmed();
    dbgMsg("reset Portal By Environment Death Count");
    portalState = PortalState.Calculating;
}

// TAG Portal/Positioner/CantContact ----------
define limitTime: 180;
globalvar define notContactTime!;

rule: "Portal/Positioner/NotContactTime/resetTime"
Event.OngoingGlobal
if(
    !portalEnable
){
    WaitConditionConfirmed();
    notContactTime = 0;
}

rule: "Portal/Positioner/NotContactTime/countup"
Event.OngoingGlobal
if(
    portalEnable &&
    notContactTime != -1  &&
    limitTime > notContactTime
){
    WaitUpdateASecond();
    notContactTime ++;
    LoopIfConditionIsTrue();
}

rule: "Portal/Positioner/NotContactTime/detectContact"
Event.OngoingGlobal
if(
    portalState == PortalState.UnderAttack
){
    notContactTime = -1;
}

rule: "Portal/Positioner/NotContactTime/resetPortal"
Event.OngoingGlobal
if(
    portalEnable &&
    limitTime <= notContactTime
){
    WaitConditionConfirmed();
    dbgMsg("reset Portal By No Contact");
    portalState = PortalState.Calculating;
}

// TAG Portal/Growing ----------
define maxPortalSize: 70;

rule: "Portal/Growing/startGrowingByPlayerFound"
Event.OngoingGlobal
if(
    portalState == PortalState.Set
){
    if(
        IsInLineOfSight(portalPosition,
            ClosestPlayerFromPortal(),
            BarrierLOS.NoBarriersBlock)
    ){
        WaitConditionConfirmed();
        // start portal growing by player found
        portalState = PortalState.Growing;
    }
    else{
        WaitUpdateMediumCycle();
        WaitReleaseServerLoad(ServerLoadType.GameMain);
        LoopIfConditionIsTrue();
    }
}

rule: "Portal/Growing/startGrowingByTimeout"
Event.OngoingGlobal
if(
    portalState == PortalState.Set &&
    portalPosition != 0
){
    // Start portal growing by search time limit out
    define time! = DistanceBetween(portalPosition, ClosestPlayerTo(portalPosition, playerTeam)) * 0.7;
    Wait(RoundToInteger(time), WaitBehavior.AbortWhenFalse);  //wait time to start growing
    portalState = PortalState.Growing;
}

rule: "Portal/Growing/suspendGrowingByPlayerEntered"
Event.OngoingGlobal
if(
    (
        portalState == PortalState.Growing || 
        portalState == PortalState.Set
    )
    &&
    IsTrueForAny(
        AllPlayers(playerTeam), ae.isInSidePortal
    )
){
    // Suspend portal growing by player enter to portal
    WaitConditionConfirmed();
    portalState = PortalState.UnderAttack;
}

rule: "Portal/Growing/resumeGrowingByPlayerExited"
Event.OngoingGlobal
if(
    portalState == PortalState.UnderAttack &&
    !IsTrueForAny(
        AllPlayers(playerTeam), ae.isInSidePortal
    )
){
    // Resume portal growing by player exit from portal
    WaitConditionConfirmed();
    portalState = PortalState.Growing;
}

// TAG EnemyBot ----------
define assetList:
    [
        [
            [EnemyType.SubBoss,     RandomHero,         1],
            [EnemyType.Elite,       RandomHero,         2],
            [EnemyType.Minion,      RandomHero,         3]
        ],
        [
            [EnemyType.SubBoss,     RandomHero,         1],
            [EnemyType.Minion,      RandomHero,         5]
        ],
        [
            [EnemyType.Elite,       RandomHero,         2],
            [EnemyType.Elite,       RandomHero,         2],
            [EnemyType.Minion,      RandomHero,         2]
        ],      
        [       
            [EnemyType.SubBoss,     RandomHero,         1],
            [EnemyType.SubBoss,     RandomHero,         1],
            [EnemyType.Minion,      RandomHero,         4]
        ],
        [       
            [EnemyType.Boss,        RandomHero,         1],
            [EnemyType.Elite,       RandomHero,         2]
        ],
        [
            [EnemyType.SubBoss,     someHero, 		    1],
            [EnemyType.Elite,       someHero, 		    2],
            [EnemyType.Minion,      someHero, 		    3]
        ]
    ];

globalvar define someHero!;

rule: "EnemyBot/reloadBotAsset"
Event.OngoingGlobal
if(
    portalEnable
){
    // change bot asset by random
    if(
        0 >= NumberOfPlayers(enemyTeam) ||
        IsProbabilityTrue(80)
    ){
        someHero = RandomHero;
        // create all bot
        DestroyBots(enemyTeam);
        CreateBotsByAsset(assetList, enemyTeam, 9);
    }
}

// TAG EnemyBot/EnemyType ----------
playervar define eachDealtDamageScale!;
playervar define eachMaxSpawnInterval!;
playervar define eachMinSpawnInterval!;
playervar define eachChargeUltInterval!;
playervar define eachBodyScale!;
define basicSpawnTimeMin: 4;
define minionSpawnTimeMin: basicSpawnTimeMin * 1;
define eliteSpawnTimeMin: basicSpawnTimeMin * 2;
define generalBossSpawnTimeMin: basicSpawnTimeMin * 4;
define spawnTimeScaleMinToMax: 2.0;

rule: "EnemyBot/EnemyType/setEnemyType"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsDummyBot() &&
    HasSpawned() &&
    enemyType != EnemyType.Non
){
    define maxHealthRate! = IsTankHero(HeroOf(ep)) ? (600 / 600) : 1;

    // setEnemyType
    if(enemyType == EnemyType.Minion){
        StartForcingDummyBotName(ep, "Minion");
        watchUpdateRate = 18;
        eachBodyScale = 0.7;
        StartScalingPlayer(ep, eachBodyScale, false);
        StartModifyingHeroVoiceLines(ep, 1.5, false);
        SetMaxHealth(ep, 25 * maxHealthRate);
        SetHealingDealt(ep, 25);
        SetHealingReceived(ep, 25);
        eachDealtDamageScale = 0.5;
        eachChargeUltInterval = 60;
        eachMinSpawnInterval = minionSpawnTimeMin;
        eachMaxSpawnInterval = minionSpawnTimeMin * spawnTimeScaleMinToMax;
        eachPerkDropProbability = 1;
    }
    else if(enemyType == EnemyType.Elite){
        StartForcingDummyBotName(ep, "Elite");
        watchUpdateRate = 6;
        eachBodyScale = 1.0;
        StartScalingPlayer(ep, eachBodyScale, false);
        StartModifyingHeroVoiceLines(ep, 1.0, false);
        SetMaxHealth(ep, 100 * maxHealthRate);
        SetHealingDealt(ep, 100);
        SetHealingReceived(ep, 100);
        eachDealtDamageScale = 1.0;
        eachChargeUltInterval = 30;
        eachMinSpawnInterval = eliteSpawnTimeMin;
        eachMaxSpawnInterval = eliteSpawnTimeMin * spawnTimeScaleMinToMax;
        eachPerkDropProbability = 4;
    }
    else if(enemyType == EnemyType.SubBoss){
        StartForcingDummyBotName(ep, "General");
        watchUpdateRate = 2;
        eachBodyScale = 1.5;
        StartScalingPlayer(ep, eachBodyScale, false);
        StartModifyingHeroVoiceLines(ep, 0.5, false);
        SetMaxHealth(ep, 500 * maxHealthRate);
        SetHealingDealt(ep, 200);
        SetHealingReceived(ep, 200);
        eachDealtDamageScale = 2.0;
        eachChargeUltInterval = 15;
        eachMinSpawnInterval = generalBossSpawnTimeMin;
        eachMaxSpawnInterval = generalBossSpawnTimeMin * spawnTimeScaleMinToMax;
        eachPerkDropProbability = 20;
    }
    else if(enemyType == EnemyType.Boss){
        StartForcingDummyBotName(ep, "Boss");
        watchUpdateRate = 2;
        eachBodyScale = 2.5;
        StartScalingPlayer(ep, eachBodyScale, false);
        StartModifyingHeroVoiceLines(ep, 0.1, false);
        SetMaxHealth(ep, 1000 * maxHealthRate);
        SetHealingDealt(ep, 200);
        SetHealingReceived(ep, 200);
        eachDealtDamageScale = 2.0;
        eachChargeUltInterval = 15;
        eachMinSpawnInterval = generalBossSpawnTimeMin;
        eachMaxSpawnInterval = generalBossSpawnTimeMin * spawnTimeScaleMinToMax;
        eachPerkDropProbability = 40;
        
        // // set addtinal health
        // Wait(0.1, WaitBehavior.AbortWhenFalse);
        // define health! = MaxHealth(ep) * 0.5;
        // AddHealthPoolToPlayer(ep, HealthType.Armor, health, true, false);
        // AddHealthPoolToPlayer(ep, HealthType.Shields, health, true, false);
    }

    // enemy bot can't retreat
    enableRetreat = false;

    // update param
    UpdateEachDealtDamage();
    UpdateEachSpawnInterval();
}

rule: "EnemyBot/Effect/setFullHealth"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.Non &&
    IsAlive()
){
    // heal to max health
    Wait(0.5, WaitBehavior.IgnoreCondition);
    while(Health() < MaxHealth()){
        Heal(ep, null, MaxValue());
        Wait(0.5, WaitBehavior.IgnoreCondition);
    }
}

// TAG EnemyBot/Effect ----------
playervar define botIcon!;

rule: "EnemyBot/Effect/showBotAppearance"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.Non &&
    (
        IsAlive() &&
        !IsInSpawnRoom()
    )
){
    if(
        enemyType == EnemyType.SubBoss ||
        enemyType == EnemyType.Boss
    ){
        // show skull icon
        DestroyIcon(botIcon);
        botIcon = CreateIcon(AllPlayers(playerTeam), ep, Icon.Skull,
            IconRev.VisibleToPositionAndColor, warningIconColor, false);
    }
}

rule: "EnemyBot/Effect/hideBotAppearanceAndReek"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    enemyType != EnemyType.Non &&
    !(
        IsAlive() &&
        !IsInSpawnRoom()
    )
){
    // hide skull icon
    if(
        enemyType == EnemyType.SubBoss ||
        enemyType == EnemyType.Boss
    ){
        DestroyIcon(botIcon);
    }

    // // play dead effect
    // PlayContinuousBlast(enemyColor, BodyPosition(ep),
    //     eachBodyScale * 1.5, eachBodyScale * 1.5, 0);
}

// TAG EnemyBot/Teleport ----------
define teleportAreaSize: 10;
define teleportTooCloseDist: 5;
define ClosestPlayerToTelPos: ClosestPlayerTo(teleportPosition, playerTeam);
define ClosestPlayerToComTelPos: ClosestPlayerTo(commonTeleportPosition, playerTeam);
define ClosestPlayerToMe: ClosestPlayerTo(ep, playerTeam);

Player ClosestPlayerFromPortal()"ClosestPlayerFromPortal"{
    return FirstOf(
        SortedArray(
            FilteredArray(
                AllPlayers(playerTeam),
                (
                    HasSpawned(ae) &&
                    IsAlive(ae) &&
                    !IsInSpawnRoom(ae)
                )
            ),
            DistanceBetween(ae, portalPosition)
        )
    );
}

Player RandomPlayerInPortal()"RandomPlayerInPortal"{
    return RandomValueInArray(
        FilteredArray(
            AllPlayers(playerTeam),
            (
                HasSpawned(ae) &&
                IsAlive(ae) &&
                ae.isInSidePortal
            )
        )
    );
}

playervar define teleportPosition!;
globalvar define commonTeleportPosition!;

Boolean SetTeleportPositionToPlayerFront() playervar "SetTeleportPositionToPlayerFront"{
    define setSuccess! = false;
    define teleportToTarget! = ClosestPlayerFromPortal();

    for(pLoopIndex = 0; pLoopIndex < 10; pLoopIndex++){
        WaitReleaseServerLoad(ServerLoadType.GameMain);

        define currentObjectPosition! = CurrentObjectPosition();
    
        // select teleportPosition from middle of Object and teleportToTarget
        teleportPosition =
            NearestWalkablePosition(
                PositionOf(teleportToTarget)
                    + 
                (
                    DirectionTowards(teleportToTarget, currentObjectPosition)
                        *
                    DistanceBetween(teleportToTarget, currentObjectPosition) * 0.40
                )
                    +
                RandomPosition(
                    (teleportAreaSize),
                    (teleportAreaSize),
                    (teleportAreaSize)
                )
            );

        if(teleportPosition != 0){
            break;
        }

        Wait(0.2, WaitBehavior.AbortWhenFalse);
    }

    if(teleportPosition != 0){
        setSuccess = true;
    }

    return setSuccess;
}

Boolean SetTeleportPositionToPlayerAround() playervar "SetTeleportPositionToPlayerAround"{
    define setSuccess! = false;
    define teleportToTarget! = ClosestPlayerFromPortal();

    for(pLoopIndex = 0; pLoopIndex < 10; pLoopIndex++){
        WaitReleaseServerLoad(ServerLoadType.GameMain);

        // select teleportPosition from current object around
        teleportPosition = 
            NearestWalkablePosition(
                PositionOf(teleportToTarget)
                    +
                RandomPosition(
                    (teleportAreaSize),
                    (teleportAreaSize),
                    (teleportAreaSize)
                )
            );
        
        if(
            teleportPosition != 0 &&
            // Has line to target
            IsInLineOfSight(
                PositionOffsetY1() + PositionOf(ClosestPlayerTo(teleportPosition, playerTeam)),
                PositionOffsetY1() + teleportPosition,
                BarrierLOS.NoBarriersBlock)  
        ){
            break;
        }

        Wait(0.2, WaitBehavior.AbortWhenFalse);    
    }

    if(teleportPosition != 0){
        setSuccess = true;
    }

    return setSuccess;
}

Boolean SetTeleportPositionToCommonPosition() playervar "SetTeleportPositionToCommonPosition"{
    // set telPosNearTarget at closest player from commonTeleportPosition
    if(
        // update commonTeleportPosition conditions
        // invalid commonTeleportPosition
        commonTeleportPosition ==  0 ||
        // force update Probability
        IsProbabilityTrue(3) ||
        // player too close from commonTeleportPosition
        DistanceBetween(commonTeleportPosition, ClosestPlayerTo(commonTeleportPosition, playerTeam)) < 3.0 ||
        // has not line commonTeleportPosition to current object 
        !IsInLineOfSight(
            PositionOffsetY1() + CurrentObjectPosition(),
            PositionOffsetY1() + commonTeleportPosition,
            BarrierLOS.NoBarriersBlock
        )
    ){
        // new select common position
        // set teleport position to player around
        if(SetTeleportPositionToPlayerAround()){
            // save teleport position as common position
            commonTeleportPosition = teleportPosition;
        }
        else{
            // set teleport position from common position
            teleportPosition = commonTeleportPosition;
        }
    }
    else{
        // set teleport position from common position
        teleportPosition = commonTeleportPosition;
    }
    
    return true;
}

define showTeleportBeamTime: 0.5;
void PlayTeleportEffect(define isBefore!) playervar "PlayTeleportEffect"{
    // if before teleport
    if(isBefore){
        // play teleport shadow to own position
        PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, enemyColor, BodyPosition(ep), eachBodyScale * 1.5);
        // play teleport blast to teleport positon
        PlayEffect(AllPlayers(), PlayEffect.BadExplosion, enemyColor, teleportPosition, eachBodyScale * 1.5);

        // show teleport beam to own position
        DestroyEffect(telBeam);
        define fromSky! = IsInSpawnRoom(ep);
        // define fromSky! = true;
        telBeam = CreateBeamEffect(AllPlayers(),
            BeamType.BadBeam,
            fromSky ? 
                teleportPosition + Vector(0, 30, 0) :
                BodyPosition(ep),
            teleportPosition + PositionOffset(),
            enemyColor, EffectRev.VisibleToPositionAndRadius);
        // wait for show teleport shadow of before
        Wait(showTeleportBeamTime, WaitBehavior.IgnoreCondition);
    }
    else{
        // hide teleport beam to teleport positon
        DestroyEffect(telBeam);
        // play teleport shadow to teleport positon
        PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, enemyColor, BodyPosition(ep), eachBodyScale * 1.5);
        // play teleport sound
        PlayEffect(AllPlayers(), PlayEffect.RingExplosionSound, null, BodyPosition(ep), 50);
    }
}

playervar define telBeam!;

void TeleportWithEffect() playervar "TeleportWithEffect"{
    if(teleportPosition == 0){
        return;
    }

    WaitReleaseServerLoad(ServerLoadType.GameMain);
    WaitUntil(IsGameInProgress(), MaxValue());

    define waitTeleportInterval! = 
        IndexOfArrayValue(
            FilteredArray(
                AllPlayers(enemyTeam), IsInSpawnRoom(ae)
            ),
            ep
        ) *
        0.1;
    // reduce over load by bot logic overlap
    Wait(waitTeleportInterval, WaitBehavior.AbortWhenFalse);

    // show pre teleport effect
    PlayTeleportEffect(true);
    // Teleport
    Teleport(ep, teleportPosition);
    // show teleport effect
    PlayTeleportEffect(false);
    // hide teleport beam effect
    DestroyEffect(telBeam);
}

define forceActiveTeleport: 40;
define teleportToCommonPositionProb: 50;

void HybridTeleport()"HybridTeleport"{
    if(
        // during Object attacks
        IsPlayerOnObject ||
        // probability
        IsProbabilityTrue(forceActiveTeleport)
    ){
        if(
            // probability
            IsProbabilityTrue(teleportToCommonPositionProb)
        ){
            if(SetTeleportPositionToCommonPosition()){
                TeleportWithEffect();
            }
        }
        else{
            if(SetTeleportPositionToPlayerAround()){
                TeleportWithEffect();
            }
        }
    }
    else{
        // if(IsTeamOnDefense(TeamOf())){
            if(SetTeleportPositionToPlayerFront()){
                TeleportWithEffect();
            }
        // }
        // else{
        //     if(SetTeleportPositionToPlayerAround()){
        //         TeleportWithEffect();
        //     }
        // }
    }
}

rule: "EnemyBot/Teleport/teleportByPortalDisabled"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    HasSpawned() &&
    !portalEnable
){
    // Teleport Bot to spawn room when portal disable
    // wait show dead effect when portal closing
    Wait(showDeadEffectTime, WaitBehavior.AbortWhenFalse);

    // reset teleport position
    teleportPosition = InvalidPosition();
    // set root
    SetStatus(ep, null, Status.Rooted, MaxValue());
    // show pre teleport effect
    PlayTeleportEffect(true);
    // Teleport to spawn room
    Respawn(AllPlayers(enemyTeam));
    // show teleport effect
    PlayTeleportEffect(false);
}

rule: "EnemyBot/Teleport/teleportByPortalEnabled"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    HasSpawned() &&
    portalEnable
){
    // clear root
    ClearStatus(ep, Status.Rooted);
    HybridTeleport();
}

rule: "EnemyBot/Teleport/teleportByPlayerEntered"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsAlive() &&
    portalEnable &&
    portalState == PortalState.UnderAttack
){
    HybridTeleport();
}

rule: "EnemyBot/Teleport/teleportByRespawn"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    portalEnable &&
    IsInSpawnRoom()
){
    HybridTeleport();
}

define checkTeleportConditionMaxCount: 2;

rule: "EnemyBot/Teleport/teleportForDefencePortal"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    IsAlive() &&
    portalEnable &&
    !IsInSpawnRoom()
){
    for(define checkTeleportConditionCount! = 0; checkTeleportConditionCount < checkTeleportConditionMaxCount; checkTeleportConditionCount ++){
        WaitReleaseServerLoad(ServerLoadType.GameMain);
        Wait(1, WaitBehavior.AbortWhenFalse);
        if(
            actionState != ActionState.Non &&        // in combat
            DistanceBetween(ep, portalPosition) <= ActionRange.Far   // near portal
        ){
            // reset count up
            LoopIfConditionIsTrue();
        }
        // count up
    }
    // when over checkTeleportConditionMaxCount 
    // teleport
    HybridTeleport();

    LoopIfConditionIsTrue();

}


rule: "EnemyBot/Teleport/clearCommonTeleportPosition"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    Attacker() == ep
){
    commonTeleportPosition = 0;
}

// TAG EnemyBot/EnemyAbility ----------
globalvar define spawnRushInterval!;
// globalvar define spawnRushWarningHud!;

rule: "EnemyBot/EnemyAbility/spawnRush"
Event.OngoingGlobal
if(
    IsGameInProgress() &&
    !IsOverTime()
){
    // set default interval
    spawnRushInterval = RandomReal(20, 30);
    spawnRushInterval *= WorkshopSettingReal("Enemy Bot Settings", "Spawn Rush Event Interval Scale", 1.0, 0.1, 100, 3);
    spawnRushInterval = RoundToInteger(spawnRushInterval, Rounding.Up);
    for(;spawnRushInterval > 0; spawnRushInterval--){
        Wait(1, WaitBehavior.AbortWhenFalse);
    }

    // action
    // DestroyHudText(spawnRushWarningHud);
    // spawnRushWarningHud = CreateHudText(AllPlayers(),
    //     "ENEMY SPAWN RUSH INCOMING!", null, null,
    //     Location.Top, 10,
    //     warningIconColor, Color.White, Color.White,
    //     HudTextRev.Color, Spectators.VisibleAlways);

    define rushDurling! = RandomInteger(5, 15);
    for(rushCount; rushDurling > 0; rushDurling--){
        WaitReleaseServerLoad(ServerLoadType.GameMain);
        
        Respawn(AllDeadPlayers(enemyTeam));
        Wait(1, WaitBehavior.IgnoreCondition);
    }

    // Wait(2, WaitBehavior.IgnoreCondition);
    // DestroyHudText(spawnRushWarningHud);

    LoopIfConditionIsTrue();
}

globalvar define shotCallInterval!;
// globalvar define shotCallWarningHud!;

rule: "EnemyBot/EnemyAbility/shotCall"
Event.OngoingGlobal
if(
    IsGameInProgress()
){
    // set default interval
    shotCallInterval = RandomReal(30, 40);
    shotCallInterval *= WorkshopSettingReal("Enemy Bot Settings", "Shot Call Event Interval Scale", 1.0, 0.1, 100, 4);
    shotCallInterval = RoundToInteger(shotCallInterval, Rounding.Up);
    for(;shotCallInterval > 0; shotCallInterval--){
        Wait(1, WaitBehavior.AbortWhenFalse);
    }

    // action
    // DestroyHudText(shotCallWarningHud);
    // shotCallWarningHud = CreateHudText(AllPlayers(),
    //     "ENEMY ALL-OUT ULTIMATE INCOMING!", null, null,
    //     Location.Top, 11,
    //     warningIconColor, Color.White, Color.White,
    //     HudTextRev.Color, Spectators.VisibleAlways);

    define allEnemys! = AllLivingPlayers(enemyTeam);
    define shotCallDelay! = RandomReal(0.1, 1.0);
    for(define scLoopIndex! = 0; scLoopIndex < CountOf(allEnemys); scLoopIndex ++){
        WaitReleaseServerLoad(ServerLoadType.GameMain);

        if(
            IsAlive(allEnemys[scLoopIndex]) &&
            !IsInSpawnRoom(allEnemys[scLoopIndex])
        ){
            SetUltimateCharge(allEnemys[scLoopIndex], DefaultPercentage());
            PressButton(allEnemys[scLoopIndex], Button.Ultimate);
            Wait(shotCallDelay, WaitBehavior.IgnoreCondition);
        }
    }

    // Wait(2, WaitBehavior.IgnoreCondition);
    // DestroyHudText(shotCallWarningHud);

    LoopIfConditionIsTrue();
}

playervar define combatTeleportInterval!;

rule: "EnemyBot/EnemyAbility/combatTeleport"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    (
        enemyType == EnemyType.Boss ||
        enemyType == EnemyType.SubBoss
    ) &&
    IsAlive() &&
    actionState != ActionState.Non &&
    portalState == PortalState.UnderAttack
){
    // is finale
    if(SetTeleportPositionToPlayerAround()){
        // set teleport to player around
        TeleportWithEffect();
    }

    // set default interval
    combatTeleportInterval = RandomReal(10, 20);
    combatTeleportInterval *= WorkshopSettingReal("Enemy Bot Settings", "(General & Boss) Combat Teleport Interval Scale", 1.0, 0.1, 100, 5);
    combatTeleportInterval = RoundToInteger(combatTeleportInterval, Rounding.Up);
    for(;combatTeleportInterval > 0; combatTeleportInterval--){
        Wait(1, WaitBehavior.AbortWhenFalse);
    }
    LoopIfConditionIsTrue();
}

globalvar define multiUltProb!;

rule: "EnemyBot/EnemyAbility/moreUltimate"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    (
        enemyType == EnemyType.Boss ||
        enemyType == EnemyType.SubBoss
    ) &&
    IsAlive() &&
    actionState != ActionState.Non &&
    !IsUsingUltimate()
){
    multiUltProb = 100;
    while(
        IsAlive() &&
        IsProbabilityTrue(multiUltProb)
    ){
        SetUltimateCharge(ep, DefaultPercentage());
        Wait(RandomReal(0, 3), WaitBehavior.IgnoreCondition);
        PressButton(ep, Button.Ultimate);
        WaitUntil(!IsUsingUltimate(), 10);
    }
    multiUltProb = 0;
}

globalvar define decreaseProb = WorkshopSettingInteger("Enemy Bot Settings", "(General & Boss) Multi Ultimate Probability Decrease Rate", 10, 0, 100, 6);

rule: "EnemyBot/EnemyAbility/decreasemultiUltimate"
Event.OngoingGlobal
if(
    multiUltProb > 0
){
    multiUltProb -= multiUltProb < decreaseProb ? multiUltProb : decreaseProb;
    Wait(1.0, WaitBehavior.AbortWhenFalse);
    Loop();
}

// TAG EnemyBot/chargeUltimate ----------
rule: "EnemyBot/chargeUltimate"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    HasSpawned() &&
    enemyType != EnemyType.Non &&
    !IsUsingUltimate()
){
    SetUltimateCharge(ep, UltimateChargePercent() + (DefaultPercentage() / eachChargeUltInterval));
    WaitUpdateASecond();
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/ObstIcon ----------
define IsPlayerOnObject: ([] != AllPlayersOnObjective(playerTeam));
define IsEnemyOnObject: ([] != AllPlayersOnObjective(enemyTeam));

playervar define obstIcon;
define warningIconColor: isBlink ? Color.Red : Color.Yellow;

rule: "EnemyBot/ObstIcon/show"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    (
        IsPlayerOnObject &&
        IsOnObjective(ep)
    )
){
    DestroyIcon(obstIcon);
    obstIcon = CreateIcon(AllPlayers(playerTeam), ep, Icon.ExclamationMark,
        IconRev.PositionAndColor, warningIconColor, true);
}

rule: "EnemyBot/ObstIcon/hide"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    !(
        IsPlayerOnObject &&
        IsOnObjective(ep)
    )
){
    DestroyIcon(obstIcon);
}

globalvar define isBlink = false;

rule: "EnemyBot/ObstIcon/blinkColor"
Event.OngoingGlobal
if(
    initCompleted
){
    while(true){
        isBlink = !isBlink;
        Wait(0.1, WaitBehavior.AbortWhenFalse); 
    }
}

// TAG EnemyBot/SpawnInterval ----------
define showDeadEffectTime: 1.5;
playervar define confirmSpawnInterval!;

void UpdateEachSpawnInterval()"UpdateEachSpawnInterval"{
    confirmSpawnInterval = (eachMaxSpawnInterval - eachMinSpawnInterval);
    confirmSpawnInterval *= (1 - (portalSize / maxPortalSize));
    confirmSpawnInterval -= roundNo / 5;
    confirmSpawnInterval = Max(confirmSpawnInterval, 0);
    confirmSpawnInterval += eachMinSpawnInterval;
    SetRespawnMaxTime(ep, confirmSpawnInterval + showDeadEffectTime); 
}

rule: "EnemyBot/SpawnInterval/update"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    portalEnable &&
    enemyType != EnemyType.Non
){
    UpdateEachSpawnInterval();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

rule: "EnemyBot/SpawnInterval/fastRespawnBySucide"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    Attacker() == ep &&
    portalEnable
){
    Wait(showDeadEffectTime, WaitBehavior.AbortWhenFalse);
    Respawn();
}

// TAG EnemyBot/ReceivedDamage ----------
globalvar define confirmReceiveDamage!;

void UpdateEachReceivedDamage()"UpdateEachReceivedDamage"{
    // set base damage
    confirmReceiveDamage = DefaultPercentage();
    // apply team balance
    confirmReceiveDamage *= ConvertToBalancedValue(0.75, playerTeam);
    SetDamageReceived(AllPlayers(enemyTeam), confirmReceiveDamage);
}

rule: "EnemyBot/ReceivedDamage/update"
Event.OngoingGlobal
if(
    initCompleted
){
    UpdateEachReceivedDamage();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

// TAG EnemyBot/DealtDamage ----------
playervar define confirmDealtDamage!;

void UpdateEachDealtDamage()"UpdateEachDealtDamage"{
    // set base damage
    confirmDealtDamage =
        WorkshopSettingReal("Enemy Bot Settings", "Base Deal Damage", 30.0, 0, 1000, -9);
    // add team lives balance
    confirmDealtDamage += teamLives *
        WorkshopSettingReal("Enemy Bot Settings", "Increase Deal Damage Per Team lives", 1.0, 0, 1000, -6);
    // add round progress
    confirmDealtDamage += roundNo *
        WorkshopSettingReal("Enemy Bot Settings", "Increase Deal Damage Per Round", 1.0, 0, 1000, -7);
    // apply team balance
    confirmDealtDamage /= ConvertToBalancedValue(0.75, playerTeam);
    // apply enemy type scale
    confirmDealtDamage *= eachDealtDamageScale;
    SetDamageDealt(ep, confirmDealtDamage);
}

rule: "EnemyBot/DealtDamage/update"
Event.OngoingPlayer
if(
    TeamOf() == enemyTeam &&
    portalEnable &&
    enemyType != EnemyType.Non
){
    UpdateEachDealtDamage();
    WaitUpdateLongCycle();
    LoopIfConditionIsTrue();
}

// TAG Debug ----------
rule: "Debug/defaultDebugMode"
Event.OngoingGlobal
Team.All
if(
    initCompleted
){
    debugMode = DebugMode.ServerLoad;
    ShowDebugHud(HostPlayer());
}

rule: "Debug/changeDebugMode"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Jump) 
){
    // change debug mode
    WaitLongPressConfirm();
    if(debugMode == DebugMode.Non){
        debugMode = DebugMode.ServerLoad;
    }
    else if(debugMode == DebugMode.ServerLoad){
        debugMode = DebugMode.DebugParam;
    }
    else if(debugMode == DebugMode.DebugParam){
        debugMode = DebugMode.Recording;
    }
    else if(debugMode == DebugMode.Recording){
        debugMode = DebugMode.Non;
    }

    // reload hud
    HideDebugHud();
    ShowDebugHud(HostPlayer());
}

define botOfEnemyType(define enemyType): FirstOf(FilteredArray(AllPlayers(enemyTeam), ae.enemyType == enemyType));
globalvar define debugHuds!;

define Last():
    CountOf(debugHuds);

// show debug icon and hud
void ShowDebugHud(define player!)"ShowDebugHud"{
    if(
        debugMode == DebugMode.Recording
    ){
        EnableInspectorRecording();
        debugHuds[Last()] = CreateDebugHud("Recording", true, Color.Red);
    }
    else{
        DisableInspectorRecording();
    }
    
    if(
        debugMode == DebugMode.ServerLoad ||
        debugMode == DebugMode.DebugParam ||
        debugMode == DebugMode.Recording
    ){
        debugHuds[Last()] = CreateDebugHud("Server Load", ServerLoad(), ServerLoad() < 255 ? Color.Orange : Color.Red);
        debugHuds[Last()] = CreateDebugHud("game Logic Speed", gameLogicSpeed, gameLogicSpeed >= 100 ? Color.Orange : Color.Red);
    }
    if(
        debugMode == DebugMode.DebugParam ||
        debugMode == DebugMode.Recording
    ){  
        // player team
        debugHuds[Last()] = CreateDebugHud("count Wait Random For Distribute Server Load", countGameLogicSpeedDecrease, Color.Orange);
        debugHuds[Last()] = CreateDebugHud("spawn interval", <"scale = <0> / M = <1> / E = <2> / G = <3> / B = <4>",
            1,
            FirstOf(FilteredArray(AllPlayers(enemyTeam), ae.enemyType == EnemyType.Minion)).confirmSpawnInterval,
            FirstOf(FilteredArray(AllPlayers(enemyTeam), ae.enemyType == EnemyType.Elite)).confirmSpawnInterval,
            FirstOf(FilteredArray(AllPlayers(enemyTeam), ae.enemyType == EnemyType.SubBoss)).confirmSpawnInterval,
            FirstOf(FilteredArray(AllPlayers(enemyTeam), ae.enemyType == EnemyType.Boss)).confirmSpawnInterval>, Color.Team2);
        debugHuds[Last()] = CreateDebugHud("damage dealt", <"scale = <0> / M = <1> / E = <2> / G = <3> / B = <4>",
            1,
            FirstOf(FilteredArray(AllPlayers(enemyTeam), ae.enemyType == EnemyType.Minion)).confirmDealtDamage,
            FirstOf(FilteredArray(AllPlayers(enemyTeam), ae.enemyType == EnemyType.Elite)).confirmDealtDamage,
            FirstOf(FilteredArray(AllPlayers(enemyTeam), ae.enemyType == EnemyType.SubBoss)).confirmDealtDamage,
            FirstOf(FilteredArray(AllPlayers(enemyTeam), ae.enemyType == EnemyType.Boss)).confirmDealtDamage>, Color.Team2);
        debugHuds[Last()] = CreateDebugHud("combat teleport interval",
            FirstOf(FilteredArray(AllPlayers(enemyTeam), (ae.enemyType == EnemyType.SubBoss || ae.enemyType == EnemyType.Boss))).combatTeleportInterval,
            FirstOf(FilteredArray(AllPlayers(enemyTeam), (ae.enemyType == EnemyType.SubBoss || ae.enemyType == EnemyType.Boss))).combatTeleportInterval > 5 ? Color.Team2 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("spawn rush interval", spawnRushInterval, spawnRushInterval > 5 ? Color.Team2 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("shot call interval", shotCallInterval, shotCallInterval > 5 ? Color.Team2 : Color.Yellow);
        debugHuds[Last()] = CreateDebugHud("more ult prob", multiUltProb, multiUltProb <= 0 ? Color.Team2 : Color.Yellow);

    }
}

// Hide debug icon and hud
void HideDebugHud()"HideDebugHud"{
    for(gLoopIndex = 0; gLoopIndex < CountOf(debugHuds); gLoopIndex ++){
        DestroyHudText(debugHuds[gLoopIndex]);
    }
}

rule: "Debug/increaseTeamLives"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Ability2)
){
    // Increase TeamLives
    WaitLongPressConfirm();
    teamLives += 1;
    LoopIfConditionIsTrue();
}

rule: "Debug/increaseRoundNo"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Ability1)
){
    // Increase RoundNo
    WaitLongPressConfirm();
    roundNo += 1;
    LoopIfConditionIsTrue();
}

rule: "Debug/resetPortal // reset portal position by random"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    !IsButtonHeld(ep, Button.Reload) &&
    IsButtonHeld(ep, Button.Crouch)
){
    // Recalculate portal
    WaitLongPressConfirm();
    portalState = PortalState.Changing;
    WaitChangeState();  // Wait for the changed status to be processed first
    portalState = PortalState.Calculating;
}

globalvar define debugAimingPosition!;

rule: "Debug/setPortalPositionOnAimCenter // reset portal position by aim center"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Reload) &&
    !IsButtonHeld(ep, Button.Crouch)
){
    // Set portal position to aim center
    WaitLongPressConfirm();
    portalState = PortalState.Changing;
    debugAimingPosition = AimingPosition(MaxLength(), EnemyTeamOf(ep));
    WaitChangeState();  // Wait for the changed status to be processed first
    portalState = PortalState.Calculating;
    WaitUntil(portalState != PortalState.Calculating, 5);
    portalPosition = debugAimingPosition;
}

rule: "Debug/setPortalMaxSize // reset portal position by aim center"
Event.OngoingPlayer
Team.All
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Reload) &&
    IsButtonHeld(ep, Button.Crouch)
){
    // Set portal position to aim center
    WaitLongPressConfirm();
    portalSize = maxPortalSize;
}
