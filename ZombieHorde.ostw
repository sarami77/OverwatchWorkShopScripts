import "ZombieHorde.setting.json";
import "Lib/Debug.del";
import "Lib/Utility.del";
import "Lib/ElapsedTimer.del";

// Builtin -----------------------------------------------
define maxDummyBotNum: 19;
define maxPlayerNum: 5;
define maxEnemyNum: maxDummyBotNum - maxPlayerNum;
define destEnemyKills: 500;
define playerRespawnTime: 15;

globalvar define playerTeam;
globalvar define enemyTeam;
globalvar define initCompleted!;
globalvar define enemyKills!;

rule: "BuiltinGlobal"
Event.OngoingGlobal
if(
    true
){
    DisableInspectorRecording();
    DisableCompletion();
    Wait(5);

    elapsedTimerEnable = true;
    
    // DisableAnnouncer();
    // DisableGameModeHud(AllPlayers());
    // DisableGameModeInworldUI(AllPlayers());

    while(true){
        if(TeamOf(HostPlayer()) == Team.Team1){
            playerTeam = Team.Team1;
            enemyTeam = Team.Team2;
        }
        else if(TeamOf(HostPlayer()) == Team.Team2){
            playerTeam = Team.Team2;
            enemyTeam = Team.Team1;
        }
        else{
            playerTeam = Team.Team2;
            enemyTeam = Team.Team1;    
        }

        SetObjectiveDescription(AllPlayers(playerTeam), <"Survive alone until <0> kills", (destEnemyKills - enemyKills)>);
        SetRespawnMaxTime(AllPlayers(playerTeam), playerRespawnTime);

        initCompleted = true;
        Wait(5, WaitBehavior.IgnoreCondition);
    }
}

// TAG Buddy ----------
import "Lib/Buddy.del";

rule: "Buddy/BuddyContorl"
Event.OngoingGlobal
if(
    initCompleted
){
    define assetE! = [   // assetNo 0
            "asset",
            [EnemyType.None,    Hero.Reinhardt, maxEnemyNum]
        ];
    CreateBotsByAsset(assetE, enemyTeam, 19);

    define assetP! = [   // assetNo 0
            "asset",
            [EnemyType.None,    Hero.Ana,   1],
            [EnemyType.None,    Hero.Mercy, 1],
            [EnemyType.None,    Hero.Reinhardt, 1],
            [EnemyType.None,    Hero.Genji, 1],
            [EnemyType.None,    Hero.Hanzo, 1]
        ];
    CreateBotsByAsset(assetP, playerTeam, 19);
}

// Test Code -----------------------------------------------
// EnemySpawnArround
define makeSpawnPosDistMax: 30;
define changeSpawnPosDist: makeSpawnPosDistMax / 3;
define changeSpawnPosProb: 3;
globalvar define spawnPosRootPlayer;
globalvar define spawnPos = 0;
globalvar define orbPos = 0;
globalvar define calcCount;
globalvar define initalHolDir;
globalvar define changeDir;

define getNewSpawnPosition()"getNewSpawnPosition"{
    define pos! = BlockedPositon(
        spawnPosRootPlayer,
        DirectionFromAngles(
            initalHolDir + (changeDir * calcCount),
            RandomReal(30, -10),
        ),
        makeSpawnPosDistMax
    );
    pos += (DirectionTowards(pos, spawnPosRootPlayer) * 0.5);
    return pos;
}

define maxCalcCount: 100;

void UpdateEnemySpawnPosition()"UpdateEnemySpawnPosition"{
    if(
        !IsInSpawnRoom(spawnPosRootPlayer) &&
        (
            spawnPos == 0 ||
            ProbabilityTrue(changeSpawnPosProb) ||
            !IsInLineOfSight(spawnPosRootPlayer, spawnPos) ||
            DistanceBetween(ClosestPlayerTo(spawnPos, playerTeam), spawnPos) < changeSpawnPosDist
        )
    ){
        calcCount = 0;
        initalHolDir = RandomInteger(0, 360);
        changeDir = RandomValueInArray([10, -10]);

        define posCand = getNewSpawnPosition();
        while(
            calcCount < maxCalcCount &&
            (
                posCand == 0 ||
                DistanceBetween(spawnPosRootPlayer, posCand) < makeSpawnPosDistMax * (1 - (calcCount / maxCalcCount)) ||
                !IsInLineOfSight(spawnPosRootPlayer, BelowPosition(posCand)) ||
                IsBelowAbyss(posCand)
            )
        ){
            Wait(0.01);
            WaitRandomForDistributeServerLoad();
            posCand = getNewSpawnPosition();
            calcCount ++;
        }
        spawnPos = posCand;
        ChaseVariableOverTime(orbPos, spawnPos, 1, TimeChaseReevaluation.DestinationAndDuration);

    }

    // spawn enemy
    if(
        !IsInSpawnRoom(spawnPosRootPlayer)
    ){
        define telepoTarget! = FilteredArray(
                AllPlayers(enemyTeam),
                (
                    !IsInLineOfSight(ae, ClosestPlayerTo(ae, playerTeam)) &&
                    IsAlive(ae)
                )
            );
        
        SetStatus(telepoTarget, null, Status.KnockedDown, 1.5);
        Wait(0.5);
        Teleport(
            telepoTarget,
            // spawnPos
            orbPos
        );
    }
}

rule: "EnemySpawnArround/UpdateSpawnPosRootPlayer"
Event.OngoingGlobal
if(
    NumberOfLivingPlayers(playerTeam) > 0
){
    while(true){
        spawnPosRootPlayer = RandomValueInArray(FilteredArray(AllLivingPlayers(playerTeam), !IsDummyBot(ae)));
        if(spawnPosRootPlayer == null){
            spawnPosRootPlayer = RandomValueInArray(AllPlayers(playerTeam));
        }
        Wait(10, WaitBehavior.IgnoreCondition);
        UpdateEnemySpawnPosition();
    }
}

rule: "EnemySpawnArround/Main"
Event.OngoingGlobal
if(
    HasSpawned(spawnPosRootPlayer)
){
    // CreateBeamEffect(HostPlayer(),
    //     BeamType.GoodBeam, spawnPosRootPlayer, spawnPos,
    //     Color.Yellow, EffectRev.VisibleToPositionAndRadius);

    while(true){
        Wait(1, WaitBehavior.IgnoreCondition);
        UpdateEnemySpawnPosition();
    }
}

rule: "EnemySpawnArround/ChangePosByAbyssDead"
Event.OnDeath
if(
    TeamOf(ep) == enemyTeam &&
    Attacker() == ep
){
    Wait(3, WaitBehavior.IgnoreCondition);
    spawnPos = 0;
}

rule: "EnemySpawnArround/increaseEnemyBuff"
Event.OngoingGlobal
if(
    NumberOfPlayers(enemyTeam) >= maxEnemyNum
){
    enemyKills = 0;
    applyEnemyStatus();

    while(true){
        SetUltimateAbilityEnabled(AllPlayers(enemyTeam), false);
        SetSecondaryFireEnabled(AllPlayers(enemyTeam), false);
        SetAbility1Enabled(AllPlayers(enemyTeam), false);
        SetAbility2Enabled(AllPlayers(enemyTeam), false);
        AllPlayers(enemyTeam).enableHealingMove = false;
        AllPlayers(enemyTeam).enableCheckAbyss = false;
        Wait(5);
    }
}

rule: "EnemySpawnArround/increaseEnemyBuff"
Event.OnDeath
if(
    TeamOf() == enemyTeam &&
    Attacker() != ep
){
    enemyKills += 5;
    applyEnemyStatus();
}

void applyEnemyStatus()"applyEnemyStatus"{
    SetRespawnMaxTime(AllPlayers(enemyTeam),    10 -  (enemyKills * 0.02));
    SetMaxHealth(AllPlayers(enemyTeam),         25 +  (enemyKills * 0.05));
    SetMoveSpeed(AllPlayers(enemyTeam),         25 +  (enemyKills * 0.30));
    SetDamageDealt(AllPlayers(enemyTeam),       25 +  (enemyKills * 0.05));
}

rule: "EnemySpawnArround/knockBack"
Event.OnDamageTaken
if(
    TeamOf() == enemyTeam &&
    Attacker() != ep
){
    ApplyImpulse(ep, 
        VectorTowards(Attacker(), ep + Vector(0, 0.5, 0)),
        EventDamage() * 1.5,
        Relative.ToWorld, ContraryMotion.Cancel);
}

define preDelay: 3;

rule: "EnemySpawnArround/playerRestand"
Event.OnDeath
if(
    TeamOf() == playerTeam &&
    IsDead()
){
    Wait(preDelay, WaitBehavior.AbortWhenFalse);

    BigMessage(ep, <"You will be revived in <0> seconds.", playerRespawnTime>);
    Wait(playerRespawnTime - (preDelay + 0.1), WaitBehavior.AbortWhenFalse);
    define pos = NearestWalkablePosition(ep);
    if(DistanceBetween(ep, pos) >= 5){
        Teleport(ep, pos);
    }
    Resurrect(ep);
    SetStatus(ep, null, Status.PhasedOut, 5);
}

rule: "EnemySpawnArround/playerDefeat"
Event.OnDeath
if(    
    NumberOfLivingPlayers(playerTeam) <= 0
){
    Teleport(AllPlayers(enemyTeam), Vector(0,MaxValue(),0));

    Wait(preDelay, WaitBehavior.IgnoreCondition);
    BigMessage(AllPlayers(playerTeam), "no survivor left...");
    Wait(10, WaitBehavior.IgnoreCondition);
    DeclareTeamVictory(enemyTeam);
}

rule: "EnemySpawnArround/playerVictory"
Event.OngoingGlobal
if(
    destEnemyKills <= enemyKills
){
    Teleport(AllPlayers(enemyTeam), Vector(0,MaxValue(),0));

    Wait(preDelay, WaitBehavior.IgnoreCondition);
    BigMessage(AllPlayers(playerTeam), <"zombie <0> kills completed.", destEnemyKills>);
    Wait(10, WaitBehavior.IgnoreCondition);
    // DeclareTeamVictory(playerTeam);
}



// Debug/Slow -----------------------------------------------
globalvar define slow = DefaultPercentage();

rule: "Debug/Slow/setSlow"
Event.OngoingPlayer
Team.Team1
if(
    HostPlayer() == ep &&
    IsButtonHeld(ep, Button.Interact) &&
    IsButtonHeld(ep, Button.Jump)
){
    // 100 -> 50 -> 25 -> 10
    if(slow == DefaultPercentage())
        slow = 50;
    else if(slow == 50)
        slow = 25;
    else if(slow == 25)
        slow = 10;
    else if(slow == 10)
        slow = DefaultPercentage();
    else
        slow = DefaultPercentage();
    SetSlowMotion(slow);
    dbgMsg(<"setSlow <0>", slow>);
}

// Debug/TuneVal -----------------------------------------------
define changeTimeInterval: 0.1;
define initialTuneUnit : 0.01;
globalvar define tuneVal = 0.1;
globalvar define consecutiveChangeCount = 0;
globalvar define tuneUnit = initialTuneUnit;

rule: "showParam"
Event.OngoingGlobal
{
    // DEBUG
    if(false){
        CreateEffect(
            HostPlayer(), Effect.Orb, Color.Red,
            orbPos, 1, EffectRev.PositionAndRadius);

        CreateBeamEffect(HostPlayer(),
            BeamType.BadBeam, spawnPosRootPlayer, orbPos, Color.Red,
            EffectRev.PositionAndRadius);

        CreateIcon(HostPlayer(), orbPos, Icon.Asterisk,
            IconRev.VisibleToAndPosition, Color.Red, true);
    }


    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "tune Val", tuneVal>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "Server Load", ServerLoad()>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "enemy Kills", enemyKills>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);  

    CreateHudText(HostPlayer(),
        null,
        <"<0> <1>", "calc Count", calcCount>,
        null,
        Location.Left, -1,
        Color.White, Color.Orange, Color.White,
        HudTextRev.VisibleToAndString, Spectators.VisibleNever);  
}

rule: "Debug/TuneVal/startIncreaseParam"
Event.OngoingPlayer
if(
    HostPlayer() &&
    (
        IsButtonHeld(ep, Button.Interact) &&
        IsButtonHeld(ep, Button.Ability2)
    )
){
    tuneVal += tuneUnit;
    Wait(changeTimeInterval, WaitBehavior.AbortWhenFalse);
    changeTuneUnit();
    LoopIfConditionIsTrue();
}

rule: "Debug/TuneVal/stopIncreaseParam"
Event.OngoingPlayer
if(
    HostPlayer() &&
    !(
        IsButtonHeld(ep, Button.Interact) &&
        IsButtonHeld(ep, Button.Ability2)
    )
){
    resetTuneUnit();
}

rule: "Debug/TuneVal/startDecreaseParam"
Event.OngoingPlayer
if(
    HostPlayer() &&
    (
        IsButtonHeld(ep, Button.Interact) &&
        IsButtonHeld(ep, Button.Ability1)
    )
){
    tuneVal -= tuneUnit;
    Wait(changeTimeInterval, WaitBehavior.AbortWhenFalse);
    changeTuneUnit();
    LoopIfConditionIsTrue();
}

rule: "Debug/TuneVal/stopDecreaseParam"
Event.OngoingPlayer
if(
    HostPlayer() &&
    !(
        IsButtonHeld(ep, Button.Interact) &&
        IsButtonHeld(ep, Button.Ability1)
    )
){
    resetTuneUnit();
}

void resetTuneUnit(){
    tuneUnit = initialTuneUnit;
    consecutiveChangeCount= 0;
}

void changeTuneUnit(){
    consecutiveChangeCount ++;
    if(consecutiveChangeCount < 10)
        tuneUnit =  initialTuneUnit * 1;
    else if(consecutiveChangeCount < 20 )
        tuneUnit = initialTuneUnit * 10;
    else if(consecutiveChangeCount < 30 )
        tuneUnit = initialTuneUnit * 100;
    else
        tuneUnit = initialTuneUnit * 1000;
}

rule: "Debug/TuneVal/debugTrigger"
Event.OngoingPlayer
if(
    HostPlayer() &&
    !(
        IsButtonHeld(ep, Button.Interact) &&
        IsButtonHeld(ep, Button.PrimaryFire)
    )
){
    SetUltimateCharge(AllPlayers(enemyTeam), 100);
    PressButton(AllPlayers(enemyTeam), Button.Ultimate);
}